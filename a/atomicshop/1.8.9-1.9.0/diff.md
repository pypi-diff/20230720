# Comparing `tmp/atomicshop-1.8.9-py3-none-any.whl.zip` & `tmp/atomicshop-1.9.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,9 +1,9 @@
-Zip file size: 205977 bytes, number of entries: 139
--rw-rw-rw-  2.0 fat      122 b- defN 23-Jul-19 08:29 atomicshop/__init__.py
+Zip file size: 206736 bytes, number of entries: 139
+-rw-rw-rw-  2.0 fat      122 b- defN 23-Jul-20 10:08 atomicshop/__init__.py
 -rw-rw-rw-  2.0 fat     3699 b- defN 23-Jul-10 11:38 atomicshop/_basics_temp.py
 -rw-rw-rw-  2.0 fat     7257 b- defN 23-Jul-10 11:38 atomicshop/appointment_management.py
 -rw-rw-rw-  2.0 fat     4763 b- defN 23-Jul-10 11:38 atomicshop/archiver.py
 -rw-rw-rw-  2.0 fat      297 b- defN 23-Jul-10 11:38 atomicshop/certificates.py
 -rw-rw-rw-  2.0 fat     1038 b- defN 23-Jul-10 11:38 atomicshop/command_line_processing.py
 -rw-rw-rw-  2.0 fat     1372 b- defN 23-Jul-10 11:38 atomicshop/console_output.py
 -rw-rw-rw-  2.0 fat     3234 b- defN 23-Jul-10 11:38 atomicshop/console_user_response.py
@@ -71,15 +71,15 @@
 -rw-rw-rw-  2.0 fat     2434 b- defN 23-Jul-10 11:38 atomicshop/etw/etw.py
 -rw-rw-rw-  2.0 fat        0 b- defN 23-Jul-10 11:38 atomicshop/file_io/__init__.py
 -rw-rw-rw-  2.0 fat     2029 b- defN 23-Jul-10 11:38 atomicshop/file_io/csvs.py
 -rw-rw-rw-  2.0 fat     5205 b- defN 23-Jul-10 11:38 atomicshop/file_io/file_io.py
 -rw-rw-rw-  2.0 fat     3383 b- defN 23-Jul-10 11:38 atomicshop/file_io/jsons.py
 -rw-rw-rw-  2.0 fat        0 b- defN 23-Jul-10 11:38 atomicshop/mitm/__init__.py
 -rw-rw-rw-  2.0 fat    18954 b- defN 23-Jul-10 11:38 atomicshop/mitm/connection_thread_worker.py
--rw-rw-rw-  2.0 fat     6984 b- defN 23-Jul-18 07:25 atomicshop/mitm/import_config.py
+-rw-rw-rw-  2.0 fat     7473 b- defN 23-Jul-20 09:49 atomicshop/mitm/import_config.py
 -rw-rw-rw-  2.0 fat     7687 b- defN 23-Jul-10 11:38 atomicshop/mitm/initialize_engines.py
 -rw-rw-rw-  2.0 fat    11322 b- defN 23-Jul-18 07:05 atomicshop/mitm/initialize_mitm_server.py
 -rw-rw-rw-  2.0 fat     1732 b- defN 23-Jul-10 11:38 atomicshop/mitm/message.py
 -rw-rw-rw-  2.0 fat     4268 b- defN 23-Jul-10 11:38 atomicshop/mitm/shared_functions.py
 -rw-rw-rw-  2.0 fat        0 b- defN 23-Jul-10 11:38 atomicshop/mitm/engines/__init__.py
 -rw-rw-rw-  2.0 fat     4776 b- defN 23-Jul-10 13:31 atomicshop/mitm/engines/create_module_template.py
 -rw-rw-rw-  2.0 fat      489 b- defN 23-Jul-10 11:38 atomicshop/mitm/engines/create_module_template_example.py
@@ -125,17 +125,17 @@
 -rw-rw-rw-  2.0 fat     1844 b- defN 23-Jul-10 11:38 atomicshop/wrappers/socketw/base.py
 -rw-rw-rw-  2.0 fat     5857 b- defN 23-Jul-10 11:38 atomicshop/wrappers/socketw/creator.py
 -rw-rw-rw-  2.0 fat    39756 b- defN 23-Jul-10 11:38 atomicshop/wrappers/socketw/dns_server.py
 -rw-rw-rw-  2.0 fat     4061 b- defN 23-Jul-10 11:38 atomicshop/wrappers/socketw/get_process.py
 -rw-rw-rw-  2.0 fat     8652 b- defN 23-Jul-10 11:38 atomicshop/wrappers/socketw/receiver.py
 -rw-rw-rw-  2.0 fat     3680 b- defN 23-Jul-10 11:38 atomicshop/wrappers/socketw/sender.py
 -rw-rw-rw-  2.0 fat        0 b- defN 23-Jul-10 11:38 atomicshop/wrappers/socketw/sni.py
--rw-rw-rw-  2.0 fat    18928 b- defN 23-Jul-10 11:38 atomicshop/wrappers/socketw/socket_client.py
+-rw-rw-rw-  2.0 fat    22498 b- defN 23-Jul-20 09:55 atomicshop/wrappers/socketw/socket_client.py
 -rw-rw-rw-  2.0 fat     6314 b- defN 23-Jul-10 11:38 atomicshop/wrappers/socketw/socket_server_tester.py
--rw-rw-rw-  2.0 fat    27741 b- defN 23-Jul-19 07:25 atomicshop/wrappers/socketw/socket_wrapper.py
+-rw-rw-rw-  2.0 fat    26873 b- defN 23-Jul-20 09:51 atomicshop/wrappers/socketw/socket_wrapper.py
 -rw-rw-rw-  2.0 fat      598 b- defN 23-Jul-10 11:38 atomicshop/wrappers/socketw/ssl_base.py
--rw-rw-rw-  2.0 fat     1094 b- defN 23-Jul-19 08:29 atomicshop-1.8.9.dist-info/LICENSE.txt
--rw-rw-rw-  2.0 fat     9057 b- defN 23-Jul-19 08:29 atomicshop-1.8.9.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-Jul-19 08:29 atomicshop-1.8.9.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       11 b- defN 23-Jul-19 08:29 atomicshop-1.8.9.dist-info/top_level.txt
--rw-rw-r--  2.0 fat    12692 b- defN 23-Jul-19 08:29 atomicshop-1.8.9.dist-info/RECORD
-139 files, 659402 bytes uncompressed, 185621 bytes compressed:  71.9%
+-rw-rw-rw-  2.0 fat     1094 b- defN 23-Jul-20 10:09 atomicshop-1.9.0.dist-info/LICENSE.txt
+-rw-rw-rw-  2.0 fat     9057 b- defN 23-Jul-20 10:09 atomicshop-1.9.0.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 23-Jul-20 10:09 atomicshop-1.9.0.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       11 b- defN 23-Jul-20 10:09 atomicshop-1.9.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat    12692 b- defN 23-Jul-20 10:09 atomicshop-1.9.0.dist-info/RECORD
+139 files, 662593 bytes uncompressed, 186380 bytes compressed:  71.9%
```

## zipnote {}

```diff
@@ -396,23 +396,23 @@
 
 Filename: atomicshop/wrappers/socketw/socket_wrapper.py
 Comment: 
 
 Filename: atomicshop/wrappers/socketw/ssl_base.py
 Comment: 
 
-Filename: atomicshop-1.8.9.dist-info/LICENSE.txt
+Filename: atomicshop-1.9.0.dist-info/LICENSE.txt
 Comment: 
 
-Filename: atomicshop-1.8.9.dist-info/METADATA
+Filename: atomicshop-1.9.0.dist-info/METADATA
 Comment: 
 
-Filename: atomicshop-1.8.9.dist-info/WHEEL
+Filename: atomicshop-1.9.0.dist-info/WHEEL
 Comment: 
 
-Filename: atomicshop-1.8.9.dist-info/top_level.txt
+Filename: atomicshop-1.9.0.dist-info/top_level.txt
 Comment: 
 
-Filename: atomicshop-1.8.9.dist-info/RECORD
+Filename: atomicshop-1.9.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## atomicshop/__init__.py

```diff
@@ -1,4 +1,4 @@
 """Atomic Basic functions and classes to make developer life easier"""
 
 __author__ = "Den Kras"
-__version__ = '1.8.9'
+__version__ = '1.9.0'
```

## atomicshop/mitm/import_config.py

```diff
@@ -122,7 +122,17 @@
                 raise FileNotFoundError
 
             # And if 'custom_private_key_path' field was populated in [advanced] section, we'll check its existence.
             if self.config['certificates']['custom_private_key_path']:
                 # Check private key file existence.
                 if not check_file_existence(file_path=self.config['certificates']['custom_private_key_path']):
                     raise FileNotFoundError
+
+        skip_extensions: list = list()
+        if self.config['skip_extensions']['tls_web_client_authentication']:
+            skip_extensions.append('1.3.6.1.5.5.7.3.2')
+        if self.config['skip_extensions']['crl_distribution_points']:
+            skip_extensions.append('2.5.29.31')
+        if self.config['skip_extensions']['authority_information_access']:
+            skip_extensions.append('1.3.6.1.5.5.7.1.1')
+
+        self.config['skip_extensions'] = skip_extensions
```

## atomicshop/wrappers/socketw/socket_client.py

```diff
@@ -1,52 +1,62 @@
 import socket
 import ssl
 import time
 
 from .receiver import Receiver
 from .sender import Sender
-from ...print_api import print_api
+from . import ssl_base
+from .. import cryptographyw
 from ..loggingw import loggingw
+from ...print_api import print_api
+from ...file_io import file_io
+from ... import filesystem
 
 import dns.resolver
 
 
 class SocketClient:
     logger = loggingw.get_logger_with_level("network." + __name__.rpartition('.')[2])
 
     # noinspection GrazieInspection
-    def __init__(self, service_name: str, service_port: int, service_ip=None, dns_servers_list=None):
+    def __init__(self, service_name: str, service_port: int, connection_ip=None, dns_servers_list=None):
         """
         If you have a certificate for domain, but not for the IPv4 address, the SSL Socket context can be created for
         domain and the connection itself (socket.connect()) made for the IP. This way YOU decide to which IPv4 your
         domain will connect.
 
         :param service_name: Should be domain, but can be IPv4 address. In this case SSL Socket will be created to
             IPv4 address.
         :param service_port: Destination server port. Example: 443.
-        :param service_ip: (Optional) If specified, the SSL Socket will be created to 'service_name' and '.connect'
-            will be to specified IPv4 address. If not specified, will be populated from 'socket' resolving and
-            available sources.
+        :param connection_ip: (Optional) If specified, the SSL Socket will be created to 'service_name' and
+            'socket.connect' will be to specified IPv4 address. If not specified, will be populated from 'socket'
+            resolving and available sources. If 'dns_servers_list' specified, will be populated from resolving of the
+            'service_name' by these DNS servers, with the first IPv4 result.
         :param dns_servers_list: (Optional) List object with dns IPv4 addresses that 'service_name' will be resolved
-            with, using 'dnspython' module. 'service_ip' will be populated with first resolved IP.
+            with, using 'dnspython' module. 'connection_ip' will be populated with first resolved IP.
+
+        If both 'connection_ip' and 'dns_servers_list' specified, ValueException with raise.
         """
         self.service_name: str = service_name
         self.service_port: int = service_port
-        self.service_ip = service_ip
+        self.connection_ip = connection_ip
         self.dns_servers_list = dns_servers_list
 
         self.ssl_socket = None
 
-        # If 'service_ip' was specified, but no 'dns_servers_list', then this IP will be used for 'socket.connect()'.
-        # In any way if 'dns_servers_list' the 'service_ip' will be populated from there and in this case
-        # it doesn't matter if you specify the 'service_ip' manually or not.
-        if self.service_ip and not self.dns_servers_list:
+        # If 'connection_ip' was specified, but no 'dns_servers_list', then this IP will be used for 'socket.connect()'.
+        # In any way if 'dns_servers_list' the 'connection_ip' will be populated from there and in this case
+        # it doesn't matter if you specify the 'connection_ip' manually or not.
+        if self.connection_ip and not self.dns_servers_list:
             self.logger.info(
                 f"Manual IPv4 address specified. SSL Socket will be created to domain [{self.service_name}] and "
-                f"connected to IPv4 [{self.service_ip}]")
+                f"connected to IPv4 [{self.connection_ip}]")
+        # If both 'connection_ip' and 'dns_servers_list' specified, raise an exception.
+        elif self.connection_ip and self.dns_servers_list:
+            raise ValueError("Both 'connection_ip' and 'dns_servers_list' were specified.")
 
     # Function to create SSL socket to destination service
     def create_service_ssl_socket(self):
         self.logger.info(f"Creating SSL socket to [{self.service_name}:{self.service_port}]")
 
         # When using with statement, no need to use "socket.close()" method to disconnect when finished
         # AF_INET - Socket family of IPv4
@@ -124,27 +134,27 @@
                 # Building DNS Resolver, it will receive DNS servers from configuration file to contact
                 resolver = dns.resolver.Resolver()
                 # Assigning the dns service address we acquired from configuration file to resolver
                 resolver.nameservers = self.dns_servers_list
                 # Get the DNS
                 function_server_address = resolver.resolve(self.service_name, 'A')
                 # Get only the first entry of the list of IPs [0]
-                self.service_ip = function_server_address[0].to_text()
-                self.logger.info(f"Resolved to [{self.service_ip}]")
+                self.connection_ip = function_server_address[0].to_text()
+                self.logger.info(f"Resolved to [{self.connection_ip}]")
             except dns.resolver.NXDOMAIN:
                 self.logger.error(f"Domain {self.service_name} doesn't exist - Couldn't resolve with "
                                   f"{self.dns_servers_list}.")
                 pass
                 return None
 
         # If DNS was resolved correctly or DNS servers weren't specified - we can try connecting.
-        # If 'service_ip' was manually specified or resolved with 'dnspython' - the connection
+        # If 'connection_ip' was manually specified or resolved with 'dnspython' - the connection
         # will be made to the IP.
-        if self.service_ip:
-            destination = self.service_ip
+        if self.connection_ip:
+            destination = self.connection_ip
         # If not, then the domain name will be used.
         else:
             destination = self.service_name
 
         self.logger.info(f"Connecting to [{destination}]")
         try:
             # "connect()" to the server using address and port
@@ -218,16 +228,16 @@
         else:
             # Getting the IP of the server domain that the socket connected to.
             # We don't need DNS resolving to this IP manually, since if socket connected it means that
             # the socket already got the IP from the DNS server that we passed it from or any other DNS source
             # that was at hand (local DNS cache).
             # Since at this point the connection to the server's domain address was successful - the IP is
             # connectable.
-            self.service_ip = self.ssl_socket.getpeername()[0]
-            self.logger.info(f"[{self.service_name}] resolves to ip: [{self.service_ip}]. Pulled IP from the socket.")
+            self.connection_ip = self.ssl_socket.getpeername()[0]
+            self.logger.info(f"[{self.service_name}] resolves to ip: [{self.connection_ip}]. Pulled IP from the socket.")
 
             # Send the data received from the client to the service over socket
             function_data_sent = Sender(self.ssl_socket, request_bytes).send()
 
             # If the socket disconnected on data send
             if not function_data_sent:
                 error_string = "Service socket closed on data send"
@@ -241,15 +251,15 @@
                 # If data received is empty meaning the socket was closed on the other side
                 if not function_service_data:
                     error_string = "Service server closed the connection on receive"
 
                     # We'll close the socket and nullify the object
                     self.close_socket()
 
-        return function_service_data, error_string, self.service_ip, self.ssl_socket
+        return function_service_data, error_string, self.connection_ip, self.ssl_socket
 
     def send_receive_message_list_with_interval(
             self, requests_bytes_list: list, intervals_list: list, intervals_defaults: int, cycles: int = 1):
         """
         This function will send a list of requests with provided intervals and receive response.
         * If 'intervals_list' is smaller than 'requests_bytes_list', the missing intervals will be filled with
         'interval_defaults'.
@@ -314,15 +324,15 @@
                 # We'll use it when calling the object from outside the class.
 
                 # Sending current client message and receiving a response.
                 # If there was an error it will be passed to "client_message" object class and if not, "None" will
                 # be passed.
                 # If there was connection error or socket close, then "ssl_socket" of the "service_client"
                 # will be empty.
-                response_raw_bytes, error_string, self.service_ip, service_ssl_socket = \
+                response_raw_bytes, error_string, self.connection_ip, service_ssl_socket = \
                     self.send_receive_to_service(request_raw_bytes)
 
                 # Adding the response to responses list. Same for error.
                 responses_list.append(response_raw_bytes)
                 errors_list.append(error_string)
 
                 self.logger.info(f"Response: {response_raw_bytes}")
@@ -333,8 +343,62 @@
                 # if not service_ssl_socket:
                 #     break
 
         # Close the socket when the loop has finished
         if self.ssl_socket:
             self.close_socket()
 
-        return responses_list, errors_list, self.service_ip
+        return responses_list, errors_list, self.connection_ip
+
+    def get_certificate_from_server(
+            self,
+            save_as_file: bool = False,
+            cert_file_path: str = None,
+            cert_output_type: str = 'der',
+            **kwargs
+    ):
+        """
+        This function will get the certificate from the server and return it.
+
+        :param save_as_file: If True, the certificate will be saved to file.
+        :param cert_file_path: The path to the file where the certificate will be saved.
+        :param cert_output_type: The type of the certificate output.
+            'der' - DER bytes format.
+            'cryptography' - cryptography.x509.Certificate object.
+        """
+
+        # If "save_as_file" is True, then "cert_file_path" must be provided, if not, raise an exception.
+        if save_as_file and not cert_file_path:
+            raise ValueError("If 'save_as_file' is True, then 'cert_file_path' must be provided.")
+        # If 'save_as_file' is True and 'cert_file_path' is provided, then check if the file exists.
+        # Since there is no point fetching the certificate from the socket if it already exists.
+        elif save_as_file and cert_file_path:
+            # If certificate from socket exists, then we don't need to get it from the socket and write to file.
+            # and we will return None, since no certificate was fetched.
+            if filesystem.check_file_existence(cert_file_path):
+                return None
+            else:
+                print_api("Certificate from socket doesn't exist, fetching.", logger=self.logger)
+
+        # Connect and get the connected socket.
+        server_socket_for_certificate = self.service_connection()
+        # Get the DER byte certificate from the socket.
+        certificate_from_socket_der_bytes = ssl_base.get_certificate_from_socket(server_socket_for_certificate)
+        print_api('Fetched certificate from socket.', logger=self.logger, **kwargs)
+        # Close the socket.
+        self.close_socket()
+
+        # If "save_as_file" was set to True, and "cert_file_path" was provided, then save the certificate to file.
+        if save_as_file and cert_file_path:
+            # Convert DER certificate from socket to PEM string format.
+            certificate_from_socket_pem_string: str = \
+                ssl_base.convert_der_x509_bytes_to_pem_string(certificate_from_socket_der_bytes)
+
+            # Write PEM certificate to file.
+            file_io.write_file(
+                certificate_from_socket_pem_string, file_path=cert_file_path, logger=self.logger)
+
+        if cert_output_type == 'der':
+            return certificate_from_socket_der_bytes
+        elif cert_output_type == 'cryptography':
+            # Convert DER certificate from socket to X509 cryptography module object.
+            return cryptographyw.convert_der_to_x509_object(certificate_from_socket_der_bytes)
```

## atomicshop/wrappers/socketw/socket_wrapper.py

```diff
@@ -1,22 +1,20 @@
 import os
 import sys
 import ssl
 import threading
 # "select" is used to call for a socket from the list of sockets, when one of the sockets gets connected
 import select
 
-from . import base, ssl_base, socket_client, creator, get_process, accepter
+from . import base, socket_client, creator, get_process, accepter
 from ..certauthw.certauthw import CertAuthWrapper
 from .. import pyopensslw, cryptographyw
-from ...print_api import print_api
 from ...script_as_string_processor import ScriptAsStringProcessor
 from ...domains import get_domain_without_first_subdomain_if_no_subdomain_return_as_is
-from ...file_io import file_io
-from ... import filesystem, queues
+from ... import queues
 
 
 SNI_QUEUE = queues.NonBlockQueue()
 PROCESS_NAME_QUEUE = queues.NonBlockQueue()
 
 
 # === Socket Wrapper ===================================================================================================
@@ -272,71 +270,57 @@
                     f"Couldn't create / overwrite Default Server Certificate: {default_server_certificate_path}")
                 sys.exit()
 
     def create_use_sni_server_certificate_ca_signed(self):
         # === Connect to the domain and get the certificate. ===========================================================
         certificate_from_socket_x509 = None
         if self.config['certificates']['sni_get_server_certificate_from_server_socket']:
-            # Generate PEM certificate file path for downloaded certificates. Signed certificates will go to the
+            # Generate PEM certificate file path string for downloaded certificates. Signed certificates will go to the
             # 'certs' folder.
             certificate_from_socket_file_path: str = \
                 self.config['certificates']['sni_server_certificate_from_server_socket_download_directory'] + \
                 os.sep + self.sni_received_dict['destination_name'] + ".pem"
+            # Get client ip.
+            client_ip = base.get_source_address_from_socket(self.sni_received_dict['ssl_socket'])[0]
 
-            # If certificate from socket doesn't exist, then get it from the socket and write to file.
-            if not filesystem.check_file_existence(certificate_from_socket_file_path):
-                print_api("Certificate from socket doesn't exist, fetching.", logger=self.logger)
-                # Get client ip.
-                client_ip = base.get_source_address_from_socket(self.sni_received_dict['ssl_socket'])[0]
-                # If we're on localhost, then use external services list in order to resolve the domain:
-                # config['tcp']['forwarding_dns_service_ipv4_list___only_for_localhost']
-                if client_ip == "127.0.0.1":
-                    service_client = socket_client.SocketClient(
-                        service_name=self.sni_received_dict['destination_name'],
-                        service_port=base.get_destination_address_from_socket(self.sni_received_dict['ssl_socket'])[1],
-                        dns_servers_list=self.config['tcp']['forwarding_dns_service_ipv4_list___only_for_localhost'])
-                # If we're not on localhost, then connect to domain directly.
-                else:
-                    service_client = socket_client.SocketClient(
-                        service_name=self.sni_received_dict['destination_name'],
-                        service_port=base.get_destination_address_from_socket(self.sni_received_dict['ssl_socket'])[1])
-
-                # Connect and get the connected socket.
-                server_socket_for_certificate = service_client.service_connection()
-                # Get the byte certificate from the socket.
-                certificate_from_socket_bytes = ssl_base.get_certificate_from_socket(server_socket_for_certificate)
-                print_api('Fetched certificate from socket.', logger=self.logger)
-                # Close the socket.
-                service_client.close_socket()
-
-                # Convert DER certificate from socket to PEM string format.
-                certificate_from_socket_pem_string: str = \
-                    ssl_base.convert_der_x509_bytes_to_pem_string(certificate_from_socket_bytes)
-
-                # Write PEM certificate to file.
-                file_io.write_file(
-                    certificate_from_socket_pem_string, file_path=certificate_from_socket_file_path, logger=self.logger)
-
-                # Convert DER certificate from socket to X509 cryptography module object.
-                certificate_from_socket_x509_cryptography_object = cryptographyw.convert_der_to_x509_object(
-                    certificate_from_socket_bytes)
+            # If we're on localhost, then use external services list in order to resolve the domain:
+            if client_ip == "127.0.0.1":
+                service_client = socket_client.SocketClient(
+                    service_name=self.sni_received_dict['destination_name'],
+                    service_port=base.get_destination_address_from_socket(self.sni_received_dict['ssl_socket'])[1],
+                    dns_servers_list=self.config['tcp']['forwarding_dns_service_ipv4_list___only_for_localhost'])
+            # If we're not on localhost, then connect to domain directly.
+            else:
+                service_client = socket_client.SocketClient(
+                    service_name=self.sni_received_dict['destination_name'],
+                    service_port=base.get_destination_address_from_socket(self.sni_received_dict['ssl_socket'])[1])
+
+            # Get certificate from socket and convert to X509 cryptography module object.
+            certificate_from_socket_x509_cryptography_object = service_client.get_certificate_from_server(
+                save_as_file=True, cert_file_path=certificate_from_socket_file_path, cert_output_type='cryptography'
+            )
 
-                skip_extensions = ['1.3.6.1.5.5.7.3.2', '2.5.29.31', '1.3.6.1.5.5.7.1.1']
+            # skip_extensions = ['1.3.6.1.5.5.7.3.2', '2.5.29.31', '1.3.6.1.5.5.7.1.1']
 
+            # If certificate was downloaded successfully, then remove extensions if they were provided.
+            # If certificate was downloaded successfully and no extensions to skip were provided, then use it as is.
+            if certificate_from_socket_x509_cryptography_object and self.config['skip_extensions']:
                 # Copy extensions from old certificate to new certificate, without specified extensions.
-                x509_cryptography_object_without_extensions, _ = \
+                certificate_from_socket_x509_cryptography_object, _ = \
                     cryptographyw.copy_extensions_from_old_cert_to_new_cert(
                         certificate_from_socket_x509_cryptography_object,
-                        skip_extensions=skip_extensions,
+                        skip_extensions=self.config['skip_extensions'],
                         logger=self.logger
                     )
 
-                # # Convert X509 cryptography module object to pyopenssl, since certauth uses pyopenssl.
+            # If certificate was downloaded successfully, then convert it to pyopenssl object.
+            if certificate_from_socket_x509_cryptography_object:
+                # Convert X509 cryptography module object to pyopenssl, since certauth uses pyopenssl.
                 certificate_from_socket_x509 = \
-                    pyopensslw.convert_cryptography_object_to_pyopenssl(x509_cryptography_object_without_extensions)
+                    pyopensslw.convert_cryptography_object_to_pyopenssl(certificate_from_socket_x509_cryptography_object)
 
         # === EOF Get certificate from the domain. =====================================================================
 
         # If CertAuthWrapper wasn't initialized yet, it means that CA wasn't created/loaded yet.
         if not self.certauth_wrapper:
             self.initialize_certauth_create_use_ca_certificate()
         # try:
```

## Comparing `atomicshop-1.8.9.dist-info/LICENSE.txt` & `atomicshop-1.9.0.dist-info/LICENSE.txt`

 * *Files identical despite different names*

## Comparing `atomicshop-1.8.9.dist-info/METADATA` & `atomicshop-1.9.0.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: atomicshop
-Version: 1.8.9
+Version: 1.9.0
 Summary: Atomic functions and classes to make developer life easier
 Author: Denis Kras
 License: MIT License
         
         Copyright (c) 2023 Bugsec, Denis Kras
         
         Permission is hereby granted, free of charge, to any person obtaining a copy
```

## Comparing `atomicshop-1.8.9.dist-info/RECORD` & `atomicshop-1.9.0.dist-info/RECORD`

 * *Files 2% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-atomicshop/__init__.py,sha256=YjiiFokcy3ZYXhSYnvzk1UPOJnG3rSoaW1pgv6UxH20,122
+atomicshop/__init__.py,sha256=1FuyHCsAncnEMcpPlvEGwfmPmIaY3NFjdMrwG4S45Ho,122
 atomicshop/_basics_temp.py,sha256=6cu2dd6r2dLrd1BRNcVDKTHlsHs_26Gpw8QS6v32lQ0,3699
 atomicshop/appointment_management.py,sha256=IsaO1O9Lgso_BPm79QNQkIyunYIr7KuAkTYlityM0nw,7257
 atomicshop/archiver.py,sha256=KKdNI150yiMO_Y1TZdKjXtw4TP5LI5FJzI8VbvFKVwo,4763
 atomicshop/certificates.py,sha256=nxuq6HPBT7RfwRTSipOxoRHBS-nZLsaHR9m6UdHmDn4,297
 atomicshop/command_line_processing.py,sha256=u5yT9Ger_cu7ni5ID0VFlRbVD46ARHeNC9tRM-_YXrQ,1038
 atomicshop/console_output.py,sha256=G-6jxnWooT1nJSaPxcCqIuw8S22R_0lOJcfrdovRhwE,1372
 atomicshop/console_user_response.py,sha256=31HIy9QGXa7f-GVR8MzJauQ79E_ZqAeagF3Ks4GGdDU,3234
@@ -70,15 +70,15 @@
 atomicshop/etw/etw.py,sha256=iCoqX5rx_wqMYQvTA7p04Tdm9qGT7TgaW003RowCejo,2434
 atomicshop/file_io/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 atomicshop/file_io/csvs.py,sha256=hpw-6SyvwuXNl9XPr9kvNT8qpWpk_q86I6cBxBUPfA8,2029
 atomicshop/file_io/file_io.py,sha256=DpN-2TS1XEc9TTHespfjbA6tV12nDjV9Wv0DOBCJ3s8,5205
 atomicshop/file_io/jsons.py,sha256=XgQs--Q6LGqC4ZtcyKvlMY_Fajjjp_l5bi6xYCy2fQQ,3383
 atomicshop/mitm/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 atomicshop/mitm/connection_thread_worker.py,sha256=GWa01_mE98lODEYy3RDQnyPDCoMpwP-VhGmboafzvu4,18954
-atomicshop/mitm/import_config.py,sha256=BI61ktNNQWn2t1iozvVHpGx0qo_coa2qBzVk5iuWFwk,6984
+atomicshop/mitm/import_config.py,sha256=VGMnfEYs-1HjFw12Ar3HlgLPnxvQlFogpHxoBRCPsV0,7473
 atomicshop/mitm/initialize_engines.py,sha256=qCtIjaR-sCbcliKKX_I65O6e4fqc-zDHELGglnL92cw,7687
 atomicshop/mitm/initialize_mitm_server.py,sha256=cU74vgdGDOePNNjohLf9mnRU69q_2nsVPgke4nl5NbY,11322
 atomicshop/mitm/message.py,sha256=u2U2f2SOHdBNU-6r1Ik2W14ai2EOwxUV4wVfGZA098k,1732
 atomicshop/mitm/shared_functions.py,sha256=NeHABBlY-tmQRooWGVl2jZQx1wSTKJtEqG7mMvF2Jqo,4268
 atomicshop/mitm/engines/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 atomicshop/mitm/engines/create_module_template.py,sha256=IKJCW1n1gD-ROONAANMPfu89zCAfnQvY5iBMrRu4hs4,4776
 atomicshop/mitm/engines/create_module_template_example.py,sha256=X5xhvbV6-g9jU_bQVhf_crZmaH50LRWz3bS-faQ18ds,489
@@ -124,16 +124,16 @@
 atomicshop/wrappers/socketw/base.py,sha256=1vvg8EhRGvnxdrRAm1VJSLCXkm2SZDHRjdpTuhkH3Mg,1844
 atomicshop/wrappers/socketw/creator.py,sha256=jeDIg5M1qFNsdL0OgCWuD1_flZZO1L-GwUd4zKZF8U8,5857
 atomicshop/wrappers/socketw/dns_server.py,sha256=XhJdQ1b78y2iSkZfWKsHrAUPSgP5UEcFOQmeTXtRssA,39756
 atomicshop/wrappers/socketw/get_process.py,sha256=NGy8ShYJ400UB7a3SJj9W8d1wyLYyte-EOJK7Og8kU4,4061
 atomicshop/wrappers/socketw/receiver.py,sha256=jkvvzih4H3giIGLsiUygSzXjYPWpTpA76OdgWjhf9wU,8652
 atomicshop/wrappers/socketw/sender.py,sha256=hHpBLc0LCfOIUErq2mc0ATfp0tDDQ5XhcYT4hRAZARU,3680
 atomicshop/wrappers/socketw/sni.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-atomicshop/wrappers/socketw/socket_client.py,sha256=O7PVQF3i4heKptwmck5Y1ELjMQ9tm-R_cdqqFVfIFLc,18928
+atomicshop/wrappers/socketw/socket_client.py,sha256=DoRytFE9Bf3xs7BoFELNrGOfAHEvjYtdeEU3P8av4rA,22498
 atomicshop/wrappers/socketw/socket_server_tester.py,sha256=7-G1t2yyDA-cNQF8zCpQSNlXEqVrMVIsq6IiYIYeKZg,6314
-atomicshop/wrappers/socketw/socket_wrapper.py,sha256=vpIeRlZ-y2Ukd_SmhlW5PQVErFbeyFbLBmhKMeQGHKM,27741
+atomicshop/wrappers/socketw/socket_wrapper.py,sha256=l4t_8fs_5CShlIBiLxA1to79psdfi6KmQggCNSvBBd4,26873
 atomicshop/wrappers/socketw/ssl_base.py,sha256=sD2LBwbrRwMS4k2d4CsDpzgpHaMrE4goNATQN-YtyOI,598
-atomicshop-1.8.9.dist-info/LICENSE.txt,sha256=lLU7EYycfYcK2NR_1gfnhnRC8b8ccOTElACYplgZN88,1094
-atomicshop-1.8.9.dist-info/METADATA,sha256=EkDeVFWhUn_xaQ4telx7sqp9YTuTa4PCgjIyaK9OjII,9057
-atomicshop-1.8.9.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-atomicshop-1.8.9.dist-info/top_level.txt,sha256=EgKJB-7xcrAPeqTRF2laD_Np2gNGYkJkd4OyXqpJphA,11
-atomicshop-1.8.9.dist-info/RECORD,,
+atomicshop-1.9.0.dist-info/LICENSE.txt,sha256=lLU7EYycfYcK2NR_1gfnhnRC8b8ccOTElACYplgZN88,1094
+atomicshop-1.9.0.dist-info/METADATA,sha256=uwfY7DFI7oeQX9OkqBuUuxNHOna1rFucHyfqRgguAPY,9057
+atomicshop-1.9.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+atomicshop-1.9.0.dist-info/top_level.txt,sha256=EgKJB-7xcrAPeqTRF2laD_Np2gNGYkJkd4OyXqpJphA,11
+atomicshop-1.9.0.dist-info/RECORD,,
```

