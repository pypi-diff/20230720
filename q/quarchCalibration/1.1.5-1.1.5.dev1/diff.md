# Comparing `tmp/quarchCalibration-1.1.5-py2.py3-none-any.whl.zip` & `tmp/quarchCalibration-1.1.5.dev1-py2.py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,33 +1,37 @@
-Zip file size: 136843 bytes, number of entries: 31
--rw-rw-rw-  2.0 fat     7185 b- defN 23-May-29 11:51 quarchCalibration/ET2260.py
--rw-rw-rw-  2.0 fat    25831 b- defN 23-May-29 11:51 quarchCalibration/PowerModuleCalibration.py
--rw-rw-rw-  2.0 fat    65172 b- defN 23-Jun-13 09:50 quarchCalibration/QTL1944.py
--rw-rw-rw-  2.0 fat    68014 b- defN 23-Jun-13 09:50 quarchCalibration/QTL1944_06.py
--rw-rw-rw-  2.0 fat    74788 b- defN 23-Jun-13 09:53 quarchCalibration/QTL2347.py
--rw-rw-rw-  2.0 fat    64669 b- defN 23-May-29 11:51 quarchCalibration/QTL2525.py
--rw-rw-rw-  2.0 fat    44492 b- defN 23-May-29 11:51 quarchCalibration/QTL2582.py
--rw-rw-rw-  2.0 fat    54288 b- defN 23-May-29 11:51 quarchCalibration/QTL2621.py
--rw-rw-rw-  2.0 fat    47096 b- defN 23-Jun-13 09:53 quarchCalibration/QTL2673.py
--rw-rw-rw-  2.0 fat    46762 b- defN 23-May-29 11:51 quarchCalibration/QTL2674.py
--rw-rw-rw-  2.0 fat    64687 b- defN 23-Jun-13 09:54 quarchCalibration/QTL2788.py
--rw-rw-rw-  2.0 fat    46445 b- defN 23-May-29 11:51 quarchCalibration/QTL2843.py
--rw-rw-rw-  2.0 fat    46762 b- defN 23-May-29 11:51 quarchCalibration/QTL2887.py
--rw-rw-rw-  2.0 fat    46762 b- defN 23-May-29 11:51 quarchCalibration/QTL2888.py
--rw-rw-rw-  2.0 fat      526 b- defN 23-May-29 11:51 quarchCalibration/__init__.py
--rw-rw-rw-  2.0 fat       82 b- defN 23-May-29 11:51 quarchCalibration/__main__.py
--rw-rw-rw-  2.0 fat       21 b- defN 23-Jun-16 10:33 quarchCalibration/_version.py
--rw-rw-rw-  2.0 fat      713 b- defN 23-May-29 11:51 quarchCalibration/calibrationConfig.py
--rw-rw-rw-  2.0 fat    19316 b- defN 23-Jun-14 17:46 quarchCalibration/calibrationUtil.py
--rw-rw-rw-  2.0 fat     4126 b- defN 23-May-29 11:51 quarchCalibration/deviceHelpers.py
--rw-rw-rw-  2.0 fat     9926 b- defN 23-May-29 11:51 quarchCalibration/elpaSine.py
--rw-rw-rw-  2.0 fat    22184 b- defN 23-May-29 11:51 quarchCalibration/keithley_2460_control.py
--rw-rw-rw-  2.0 fat     9379 b- defN 23-Jun-14 17:46 quarchCalibration/noise_test.py
--rw-rw-rw-  2.0 fat    39461 b- defN 23-May-29 11:51 quarchCalibration/pamCommon.py
--rw-rw-rw-  2.0 fat     7585 b- defN 23-Jun-13 09:54 quarchCalibration/threePhaseSwitchBox.py
--rw-rw-rw-  2.0 fat        0 b- defN 23-May-29 11:51 quarchCalibration/docs/__init__.py
--rw-rw-rw-  2.0 fat     2076 b- defN 23-May-29 11:51 quarchCalibration/docs/conf.py
--rw-rw-rw-  2.0 fat     1562 b- defN 23-Jun-16 10:36 quarchCalibration-1.1.5.dist-info/METADATA
--rw-rw-rw-  2.0 fat      110 b- defN 23-Jun-16 10:36 quarchCalibration-1.1.5.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       18 b- defN 23-Jun-16 10:36 quarchCalibration-1.1.5.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     2725 b- defN 23-Jun-16 10:36 quarchCalibration-1.1.5.dist-info/RECORD
-31 files, 822763 bytes uncompressed, 132449 bytes compressed:  83.9%
+Zip file size: 132774 bytes, number of entries: 35
+-rw-rw-rw-  2.0 fat    25225 b- defN 23-Jul-17 13:56 quarchCalibration/BK9832B.py
+-rw-rw-rw-  2.0 fat     7185 b- defN 23-Jul-17 13:56 quarchCalibration/ET2260.py
+-rw-rw-rw-  2.0 fat    18660 b- defN 23-Jul-17 13:56 quarchCalibration/Keithley_DMM6500_control.py
+-rw-rw-rw-  2.0 fat    19603 b- defN 23-Jul-17 13:56 quarchCalibration/Keysight_AC6804B_control.py
+-rw-rw-rw-  2.0 fat    23554 b- defN 23-Jul-17 13:56 quarchCalibration/PowerModuleCalibration.py
+-rw-rw-rw-  2.0 fat    68014 b- defN 23-Jul-17 13:56 quarchCalibration/QTL1944_06_hd_plus_ppm.py
+-rw-rw-rw-  2.0 fat    65172 b- defN 23-Jul-17 13:56 quarchCalibration/QTL1944_hd_ppm.py
+-rw-rw-rw-  2.0 fat    49330 b- defN 23-Jul-17 13:56 quarchCalibration/QTL2347_pcie.py
+-rw-rw-rw-  2.0 fat    39890 b- defN 23-Jul-17 13:56 quarchCalibration/QTL2525_sff.py
+-rw-rw-rw-  2.0 fat     2966 b- defN 23-Jul-17 13:56 quarchCalibration/QTL2536_6_way_switchbox.py
+-rw-rw-rw-  2.0 fat    40468 b- defN 23-Jul-17 13:56 quarchCalibration/QTL2582_3ph_ac.py
+-rw-rw-rw-  2.0 fat    39414 b- defN 23-Jul-17 13:56 quarchCalibration/QTL2621_2ch_mezz.py
+-rw-rw-rw-  2.0 fat    32603 b- defN 23-Jul-17 13:56 quarchCalibration/QTL2626_4ch_mezz.py
+-rw-rw-rw-  2.0 fat    33360 b- defN 23-Jul-17 13:56 quarchCalibration/QTL2631_ext_mezz.py
+-rw-rw-rw-  2.0 fat    37022 b- defN 23-Jul-17 13:56 quarchCalibration/QTL2673_edsff.py
+-rw-rw-rw-  2.0 fat    40449 b- defN 23-Jul-17 13:56 quarchCalibration/QTL2843_iec_ac.py
+-rw-rw-rw-  2.0 fat      632 b- defN 23-May-10 11:06 quarchCalibration/__init__.py
+-rw-rw-rw-  2.0 fat       82 b- defN 23-Apr-05 12:46 quarchCalibration/__main__.py
+-rw-rw-rw-  2.0 fat       26 b- defN 23-Jul-20 12:57 quarchCalibration/_version.py
+-rw-rw-rw-  2.0 fat     6523 b- defN 23-Jul-17 13:56 quarchCalibration/acHelpers.py
+-rw-rw-rw-  2.0 fat      713 b- defN 23-Apr-05 12:46 quarchCalibration/calibrationConfig.py
+-rw-rw-rw-  2.0 fat    17889 b- defN 23-Jul-17 13:56 quarchCalibration/calibrationUtil.py
+-rw-rw-rw-  2.0 fat     4126 b- defN 23-May-01 15:32 quarchCalibration/deviceHelpers.py
+-rw-rw-rw-  2.0 fat     9958 b- defN 23-Jul-17 13:56 quarchCalibration/elpaSine.py
+-rw-rw-rw-  2.0 fat    22184 b- defN 23-Apr-05 12:46 quarchCalibration/keithley_2460_control.py
+-rw-rw-rw-  2.0 fat     9506 b- defN 23-Jul-17 13:56 quarchCalibration/noise_test.py
+-rw-rw-rw-  2.0 fat    39461 b- defN 23-May-10 11:06 quarchCalibration/pamCommon.py
+-rw-rw-rw-  2.0 fat     1072 b- defN 23-Jul-17 13:56 quarchCalibration/pamHelpers.py
+-rw-rw-rw-  2.0 fat     7585 b- defN 23-Jul-17 13:56 quarchCalibration/threePhaseSwitchBox.py
+-rw-rw-rw-  2.0 fat        0 b- defN 23-Apr-05 12:46 quarchCalibration/docs/__init__.py
+-rw-rw-rw-  2.0 fat     2076 b- defN 23-Apr-05 12:46 quarchCalibration/docs/conf.py
+-rw-rw-rw-  2.0 fat     1567 b- defN 23-Jul-20 12:59 quarchCalibration-1.1.5.dev1.dist-info/METADATA
+-rw-rw-rw-  2.0 fat      110 b- defN 23-Jul-20 12:59 quarchCalibration-1.1.5.dev1.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       18 b- defN 23-Jul-20 12:59 quarchCalibration-1.1.5.dev1.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     3216 b- defN 23-Jul-20 12:59 quarchCalibration-1.1.5.dev1.dist-info/RECORD
+35 files, 669659 bytes uncompressed, 127552 bytes compressed:  81.0%
```

## zipnote {}

```diff
@@ -1,58 +1,67 @@
+Filename: quarchCalibration/BK9832B.py
+Comment: 
+
 Filename: quarchCalibration/ET2260.py
 Comment: 
 
-Filename: quarchCalibration/PowerModuleCalibration.py
+Filename: quarchCalibration/Keithley_DMM6500_control.py
+Comment: 
+
+Filename: quarchCalibration/Keysight_AC6804B_control.py
 Comment: 
 
-Filename: quarchCalibration/QTL1944.py
+Filename: quarchCalibration/PowerModuleCalibration.py
 Comment: 
 
-Filename: quarchCalibration/QTL1944_06.py
+Filename: quarchCalibration/QTL1944_06_hd_plus_ppm.py
 Comment: 
 
-Filename: quarchCalibration/QTL2347.py
+Filename: quarchCalibration/QTL1944_hd_ppm.py
 Comment: 
 
-Filename: quarchCalibration/QTL2525.py
+Filename: quarchCalibration/QTL2347_pcie.py
 Comment: 
 
-Filename: quarchCalibration/QTL2582.py
+Filename: quarchCalibration/QTL2525_sff.py
 Comment: 
 
-Filename: quarchCalibration/QTL2621.py
+Filename: quarchCalibration/QTL2536_6_way_switchbox.py
 Comment: 
 
-Filename: quarchCalibration/QTL2673.py
+Filename: quarchCalibration/QTL2582_3ph_ac.py
 Comment: 
 
-Filename: quarchCalibration/QTL2674.py
+Filename: quarchCalibration/QTL2621_2ch_mezz.py
 Comment: 
 
-Filename: quarchCalibration/QTL2788.py
+Filename: quarchCalibration/QTL2626_4ch_mezz.py
 Comment: 
 
-Filename: quarchCalibration/QTL2843.py
+Filename: quarchCalibration/QTL2631_ext_mezz.py
 Comment: 
 
-Filename: quarchCalibration/QTL2887.py
+Filename: quarchCalibration/QTL2673_edsff.py
 Comment: 
 
-Filename: quarchCalibration/QTL2888.py
+Filename: quarchCalibration/QTL2843_iec_ac.py
 Comment: 
 
 Filename: quarchCalibration/__init__.py
 Comment: 
 
 Filename: quarchCalibration/__main__.py
 Comment: 
 
 Filename: quarchCalibration/_version.py
 Comment: 
 
+Filename: quarchCalibration/acHelpers.py
+Comment: 
+
 Filename: quarchCalibration/calibrationConfig.py
 Comment: 
 
 Filename: quarchCalibration/calibrationUtil.py
 Comment: 
 
 Filename: quarchCalibration/deviceHelpers.py
@@ -66,29 +75,32 @@
 
 Filename: quarchCalibration/noise_test.py
 Comment: 
 
 Filename: quarchCalibration/pamCommon.py
 Comment: 
 
+Filename: quarchCalibration/pamHelpers.py
+Comment: 
+
 Filename: quarchCalibration/threePhaseSwitchBox.py
 Comment: 
 
 Filename: quarchCalibration/docs/__init__.py
 Comment: 
 
 Filename: quarchCalibration/docs/conf.py
 Comment: 
 
-Filename: quarchCalibration-1.1.5.dist-info/METADATA
+Filename: quarchCalibration-1.1.5.dev1.dist-info/METADATA
 Comment: 
 
-Filename: quarchCalibration-1.1.5.dist-info/WHEEL
+Filename: quarchCalibration-1.1.5.dev1.dist-info/WHEEL
 Comment: 
 
-Filename: quarchCalibration-1.1.5.dist-info/top_level.txt
+Filename: quarchCalibration-1.1.5.dev1.dist-info/top_level.txt
 Comment: 
 
-Filename: quarchCalibration-1.1.5.dist-info/RECORD
+Filename: quarchCalibration-1.1.5.dev1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## quarchCalibration/PowerModuleCalibration.py

```diff
@@ -14,51 +14,19 @@
 '''
 
 #Imports QuarchPy library, providing the functions needed to use Quarch modules
 #from quarchpy import quarchDevice #, scanDevices
 
 # Import other libraries used in the examples
 from functools import reduce
-#from quarchCalibration import *
-from .deviceHelpers import returnMeasurement
 from quarchpy.device.device import *
-from quarchpy.qps import isQpsRunning, startLocalQps
-import types
 from time import sleep,time
 from math import ceil
 from quarchpy.user_interface import *
 
-# These functions are dc specific and this is not a good place for them
-# as they are very simple, i'm replacing the call directly in each device file
-
-def load_set_volt(load,value,currentLimit="1e-1"):
-   # set_load_volt uses volts, we convert from mV
-   return load.setReferenceVoltage(value/1000,currentLimit)
-
-def load_get_volt(load):
-
-   # getLoadVoltage returns volts, we convert these to mV and return
-   return load.getLoadVoltage()*1000
-
-def load_meas_volt(load):
-
-   # measaureLoadVoltage returns volts, we convert these to mV and return
-   return load.measureLoadVoltage()*1000
-
-def load_set_cur(load,value):
-
-   #set load current, parameter is uA, the keithley needs amps
-   response = load.setReferenceCurrent(value/1000000)
-   return response
-
-def load_meas_cur(load):
-
-   #get load current, the keithley returns amps, we use uA
-   return load.measureLoadCurrent()*1000000
-
 '''
 Coefficient Class
 
 This class holds a floating point value, and the precision at which it will be stored (in the FPGA)
 
     The constructor will throw an OverFlowError if the integer value overflows the specified integer width
 
@@ -229,29 +197,30 @@
             # negative reg value
             else:
                 return 1 - (round(abs(self.value-1) * 2**23) / 2**23)
 
     '''
     hexString(hex_chars)
 
-    returns a hex string begining 0x with the number of hex characters specified
+    returns a hex string beginning 0x with the number of hex characters specified
     '''
     #def hexString(self,hex_chars):
     #    #shift left by required number of fractional bits, round it (to nearest integer), then and with 1's to truncate it to required length
     #    return "{:#0{hex_chars}x}".format(round(self.value*(2**self.frac_width)) & (2**(hex_chars*4)-1),hex_chars=(hex_chars+2))
 
     def hexString(self,hex_chars):
         # if number has overflowed, don't return a value
         if self.overflow == True:
             return "Overflow Error"
+        # if the number will be positive
+        if self.storedValue() >= 1:
+            return "{:#0{hex_chars}x}".format(round((self.storedValue() - 1) * (2 ** 23)), hex_chars=(hex_chars + 2))
+        # else result is negative
         else:
-            if (self.storedValue()-1) >= 0:
-                return "{:#0{hex_chars}x}".format( round((self.storedValue()-1)*(2**23)) , hex_chars=(hex_chars+2) )
-            else:
-                return "{:#0{hex_chars}x}".format( (2**(hex_chars*4)) - (round(abs(self.storedValue()-1)*(2**23))) , hex_chars=(hex_chars+2) )
+            return "{:#0{hex_chars}x}".format((2**(hex_chars*4)) - (round(abs(self.storedValue() - 1) * (2 ** 23))), hex_chars=(hex_chars + 2))
 
 '''
 AC PAM Calibration Class
 
 This class holds a multiplier and offset coefficient as instances of the Coefficient class
 
     The constructor will generate multiplier and offset from a set of points in the form of a list of coordinates, using the x axis for ADC value and the y axis for reference value
@@ -337,29 +306,17 @@
     dut = None                 # this is a comms device for the module
     calObjectSerial = None     # This is the serial number of the device being calibrated i.e QTL1944 in PPM, the fixture serial number in PAM
     calibrations = {}          # a dictionary of calibrations supported by this module
     verifications = {}         # a dictionary of verifications supported by this module
     voltageMode = None
 
     def specific_requirements(self):
-        # stub method to be overidden
+        # stub method to be overridden
         pass
 
-    def checkWiring(self):
-        self.listOfConnections = []
-        self.listOfConnections.append("Please check that 12v source is connected to switchbox port " + self.hostPort)
-        self.listOfConnections.append("Please check that switchbox port " + self.loadPort + " is connected to Force High and Force Low on the calibration instrument")
-        for k, v in self.hostConnectionPortDict.items():
-            self.listOfConnections.append(
-                "Please check that (red+black) " + k + " on HOST card is connected to switchbox port " + v)
-        for k, v in self.loadConnectionPortDict.items():
-            self.listOfConnections.append(
-                "Please check that (red+black) " + k + " on LOAD card is connected to switchbox port " + v)
-        showDialog(message="\r\n".join(self.listOfConnections))
-
     def wait_for_up_time(self, desired_up_time=600, command="conf:runtimes?"):
 
         returnText=""
         try:
             current_up_time = int(self.dut.sendCommand(command).lower().replace("s", ""))
             success = True
             wait_time = desired_up_time - current_up_time
@@ -383,36 +340,28 @@
             else:
                 printText("Wait for runtime to reach " + str(desired_up_time) + "s skipped")
                 returnText += "Runtime check skipped - Module temperature not guaranteed to be stable.\n"
         return returnText
 
     def open_module(self):
 
-        # Check self test - complicated for HD because of the regulator switching
-        tstResponse = self.dut.sendCommand("*TST?")
-        if tstResponse == "OK" or "not calibrated" in tstResponse.lower():
-            logSimpleResult("Self Test", True)
-        else:
-            logSimpleResult("Self Test", False)
-
-        # set unit into calibration mode
-        self.dut.sendCommand("write " + self.CALIBRATION_MODE_ADDR + " 0xaa55")
-        self.dut.sendCommand("write " + self.CALIBRATION_MODE_ADDR + " 0x55aa")
-
+        # stub method to be overridden
+        pass
+        
     def clear_calibration(self):
-        # stub method to be overidden
+        # stub method to be overridden
         pass
 
     def write_calibration(self):
-        # stub method to be overidden
+        # stub method to be overridden
         pass
 
     def close_module(self):
             
-        # stub method to be overidden
+        # stub method to be overridden
         pass
 
     def close_all(self):
 
         # stub method to be overriden
         pass
 
@@ -539,16 +488,26 @@
         #return all results
         return listOfTestResults
 
     def setupForNoiseTest(self):
         from quarchpy import qpsInterface, isQpsRunning, startLocalQps, GetQpsModuleSelection, quarchDevice, quarchQPS, qps, requiredQuarchpyVersion
         if isQpsRunning() == False:
             startLocalQps() #args="-ccs" # TODO change back to -ccs
-        self.dut.sendCommand("*enclosure?")
-        tempConString =self.dut.ConString[:self.dut.ConString.find(":")]+"::qtl"+self.dut.sendCommand("*enclosure?") # This is needed becuase QPS doesn't support TCP:192.168.1.xxx format connection string.
+        tempIDN=self.dut.sendCommand("*idn?")
+        dictIDN = {}
+        for line in tempIDN.split("\n"):
+            pos = line.find(":")
+            if pos == -1:
+                pass
+            else:
+                key = line[:pos].strip().lower()
+                val = line[pos + 1:].strip()
+                dictIDN[key] = val
+        tempConString= dictIDN["enclosure#"]
+        tempConString =self.dut.ConString[:self.dut.ConString.find(":")]+"::"+tempConString # This is needed because QPS doesn't support TCP:192.168.1.xxx format connection string.
         self.dut.closeConnection()
         time.sleep(0.5)
         myPpmDevice = quarchDevice(tempConString, "QPS")
 
         self.dut = myPpmDevice
         myQpsDevice = quarchQPS(myPpmDevice)
         myQpsDevice.openConnection()
@@ -561,15 +520,15 @@
             return
         oldConString=self.dut.ConString
         oldConType=self.dut.ConType
         myQpsDevice=self.setupForNoiseTest()
         from .noise_test import test_main
         temp=test_main(self ,myQpsDevice)
 
-        #QPS should be closed by now, so DUT connectiong must be reverted back to whatever it was before the Noise Test.
+        #QPS should be closed by now, so DUT connection must be reverted back to whatever it was before the Noise Test.
         myPpmDevice = quarchDevice(oldConString, oldConType)
         self.dut = myPpmDevice
         results=[]
         for row in temp: # Format the returned info
             testPass=None
             if row[1].lower() == "pass":
                 testPass=True
@@ -582,41 +541,39 @@
 
 '''
 bestFit(points)
 
 takes in a list of x and y coordinates of ADC values (x value) and reference values (y value)
 and returns offset and gradient for the best fit straight line approximation of those points
 
-This has been modified to weight the points by 1/x; the term (1/point[0])* in SumXY and SumX2 does the weighting
-This is because we care about % error rather than absolute error and it should weight the values so they all end up with the same % error
-
 '''
 def bestFit(points):
 
     try:
         # calculate the mean value of all x coordinates
         AveX = reduce(lambda sum,point : sum+point[0],points,0)/len(points)
         # calculate the mean value of all y coordinates
         AveY = reduce(lambda sum,point : sum+point[1],points,0)/len(points)
         # calculate the sum of (x-x'mean)*(y-y'mean) for all points
-        SumXY = reduce(lambda sum,point : sum + (1/point[0])*((point[0]-AveX)*(point[1]-AveY)), points, 0)
+        SumXY = reduce(lambda sum,point : sum + ((point[0]-AveX)*(point[1]-AveY)), points, 0)
         # calculate the sum of (x-x'mean)*(x-x'mean) for all points
-        SumX2 = reduce(lambda sum,point : sum + (1/point[0])*((point[0]-AveX)*(point[0]-AveX)), points, 0)
+        SumX2 = reduce(lambda sum,point : sum + ((point[0]-AveX)*(point[0]-AveX)), points, 0)
 
         if SumX2 == 0:
             Slope = AveY/AveX
-            Intercept = 0.0;
+            Intercept = 0.0
         else:
             Slope = SumXY/SumX2
             Intercept = AveY-(Slope*AveX)
 
         return Slope,Intercept
+
     except Exception as e:
-        return 1.0,0.0
         logging.critical(os.path.basename(__file__) + "bestFit algorithm failed to find a solution")
+        return 1.0,0.0
 
 '''
 getError(reference_value,calculated_value,abs_error,rel_error)
 
     takes in a reference value and a calculated value
     returns a tuple with actual error (reference-calculated), absolute error, relative error and result
 
@@ -638,15 +595,15 @@
     #make error positive
     error_value = abs(error_value)
             
     # if error at this point is greater than absolute_error, set abs_error_val to absolute_error
     if error_value >= abs_error_limit:
         abs_error_val = abs_error_limit
 
-        # calculate relative error after deduction of abolute error allowance, and as a percentage of the calculated value (not the reference value)
+        # calculate relative error after deduction of absolute error allowance, and as a percentage of the calculated value (not the reference value)
         # we return a positive percentage because the sign is always the same as abs_error_val so we display +/-(abs + pc)
         # check for divide by zero
         if calculated_value != 0:
             rel_error_val = abs(((error_value - abs_error_val) /  calculated_value) * 100)
         ## if divide by zero return 100%
         else:
             rel_error_val = 100
@@ -654,14 +611,14 @@
     # else round up to the nearest integer 
     else:
         abs_error_val = ceil(error_value)
         rel_error_val = 0
 
     # set pass/fail
     if abs(rel_error_val) <= rel_error_limit:
-        result = True;
+        result = True
     else:
-        result = False;
+        result = False
 
     #  Actual Error, Absolute Error, Relative Error, Pass/Fail
     return([error_value,error_sign,abs_error_val,rel_error_val,result])
```

## quarchCalibration/__init__.py

```diff
@@ -1,8 +1,8 @@
-__all__ = ['deviceHelpers','QTL1944','QTL2347','QTL2525','QTL2788','QTL2621','keithley_2460_control','PowerModuleCalibration','getCalibrationResource']
+__all__ = ['deviceHelpers','pamHelpers','acHelpers','QTL1944','QTL2347','QTL2525','QTL2582_3ph_ac','QTL2788','QTL2621_2ch_mezz','QTL2626_4ch_mezz','QTL2631_ext_mezz','QTL2843_iec_ac','keithley_2460_control','PowerModuleCalibration','getCalibrationResource']
 from quarchCalibration._version import __version__
 
 calCodeVersion = __version__
 from .keithley_2460_control import keithley2460,userSelectCalInstrument
 from .calibrationConfig import *
 from .calibrationUtil import *
 from quarchpy.device.device import *
```

## quarchCalibration/_version.py

```diff
@@ -1 +1 @@
-__version__ = "1.1.5"
+__version__ = "1.1.5.dev1"
```

## quarchCalibration/calibrationUtil.py

```diff
@@ -25,51 +25,45 @@
 
 # Quarch device control
 from quarchpy import *
 from quarchpy.device import *
 
 # Calibration control
 from quarchCalibration import calCodeVersion
-from quarchCalibration.QTL1944 import *
-from quarchCalibration.QTL1944_06 import *
-from quarchCalibration.QTL2347 import *
-from quarchCalibration.QTL2525 import *
-from quarchCalibration.QTL2788 import *
-from quarchCalibration.QTL2887 import *
-from quarchCalibration.QTL2888 import *
-from quarchCalibration.QTL2621 import *
-from quarchCalibration.QTL2673 import *
-from quarchCalibration.QTL2674 import *
-#from quarchCalibration.QTL2582 import *
-#from quarchCalibration.QTL2843 import *
-# from quarchCalibration.QTL2621_2ch_mezz import *
-# from quarchCalibration.QTL2626_4ch_mezz import *
-# from quarchCalibration.QTL2631_ext_mezz import *
-# from quarchCalibration.QTL2582_3ph_ac import *
-# from quarchCalibration.QTL2843_iec_ac import *
+from quarchCalibration.QTL1944_hd_ppm import *
+from quarchCalibration.QTL1944_06_hd_plus_ppm import *
+from quarchCalibration.QTL2347_pcie import *
+from quarchCalibration.QTL2525_sff import *
+from quarchCalibration.QTL2621_2ch_mezz import *
+from quarchCalibration.QTL2626_4ch_mezz import *
+from quarchCalibration.QTL2631_ext_mezz import *
+from quarchCalibration.QTL2673_edsff import *
+from quarchCalibration.QTL2582_3ph_ac import *
+from quarchCalibration.QTL2843_iec_ac import *
 from quarchCalibration.PowerModuleCalibration import*
 from quarchCalibration.calibrationConfig import*
 # UI functions
 from quarchpy.user_interface import *
 # TestCenter functions
 from quarchpy.utilities import TestCenter
 from quarchpy.debug.SystemTest import get_quarchpy_version
 from quarchCalibration.noise_test import test_main as noise_test_main
-from quarchpy.qps import isQpsRunning, startLocalQps
 import time
 # Devices that will show up in the module scan dialog
 scanFilterStr = ["QTL1999", "QTL1995", "QTL1944", "QTL2312", "QTL2098", "QTL2582", "QTL2751", "QTL2789", "QTL2843"]
 my_close_qis = False
 
 # Performs a standard calibration of the PPM
 def runCalibration (loadAddress=None, calPath=None, moduleAddress=None, logLevel="warning", calAction=None, extra_args=None, streamPath=None):
 
     myPpmDevice = None
     listOfFailures = []
     try:
+        # Display the app title to the user
+        print("\n")
         displayTable(["Quarch Technology Calibration System","(C) 2019-2021, All rights reserved", "V" + calCodeVersion], align="c")
 
         # Process parameters
         calPath = get_check_valid_calPath(calPath)
         streamPath = check_path_write_permissions(streamPath)
 
         setup_logging(logLevel)
@@ -105,14 +99,15 @@
                     skippedNoiseTestResult={'title': 'noise test skipped', 'result': False, 'worst case': 'NA', 'report': 'noise test skipped due to module not having one'}
                     listOfFailures.append(skippedNoiseTestResult)
                 calAction=None
             elif (calAction == 'calibrate') or (calAction == 'verify'):
                 # Perform the Calibration or Verification
                 # get CalibrationTime
                 calTime = datetime.datetime.now()
+
                 # open report for writing and write system header
                 fileName = calibrationResources["calPath"] + "\\" + dut.filenameString + "_" + calTime.strftime("%d-%m-%y_%H-%M") + "-" + calAction + ".txt"
                 printText("")
                 printText("Report file: " + fileName)
                 reportFile = open(fileName, "a+", encoding='utf-8')
                 reportFile.write("\n")
                 reportFile.write("Quarch Technology Calibration Report\n" if "cal" in str(calAction).lower() else "Quarch Technology Verification Report\n")
@@ -127,14 +122,15 @@
                     reportFile.write("QuarchPy Version: unknown\n")
                 reportFile.write("Calibration Version: " + str(calCodeVersion) + "\n")
                 reportFile.write("Calibration Time: " + str(calTime.replace(microsecond=0)) + "\n")
                 reportFile.write("\n")
                 reportFile.write("---------------------------------\n")
                 reportFile.write("\n")
                 reportFile.flush()
+
                 # get required instruments etc
                 reportFile.write("Device Specific Information:\n")
                 reportFile.write("\n")
                 reportFile.write(dut.specific_requirements())
                 reportFile.write("\n")
                 reportFile.write("---------------------------------\n")
                 reportFile.write("\n")
@@ -181,20 +177,14 @@
                 dut.close_all()
                 myPpmDevice.closeConnection()
             # Handle case where exception may have been thrown before instrument was set up
             except:
                 logging.error("DUT connection not closed. Exception may have been thrown before instrument was set up.")
                 pass
 
-
-
-
-
-
-
 def create_dut_object():
     # Connect to the module
     while True:
         # If no address specified, the user must select the module to calibrate
         if (calibrationResources["moduleString"] == None):
             deviceString = userSelectDevice(scanFilterStr=scanFilterStr, nice=True, message="Select device for calibration")
             # quit if necessary
@@ -236,72 +226,69 @@
         if ('2347' in fixtureId):
             dut = QTL2347(myPpmDevice)
             success = True
         ## PCIE Gen 4 SFF Fixture
         if ('2525' in fixtureId):
             dut = QTL2525(myPpmDevice)
             success = True
-        ## PCIE Gen 5 SFF Fixture
+        ## PCIE Gen 5 SFF Fixture - same calibration as QTL2525
         if ('2788' in fixtureId):
-            dut = QTL2788(myPpmDevice)
+            dut = QTL2525(myPpmDevice)
             success = True
-        ## EDSFF Fixture (E1)
+		## Gen4 E1 EDSFF Fixture
         if ('2673' in fixtureId):
             dut = QTL2673(myPpmDevice)
-            success = True
-        ## EDSFF Fixture (E3)
+            success = True	
+        ## Gen4 E3 EDSFF Fixture - shares a PCBA with QTL2673
         if ('2674' in fixtureId):
-            dut = QTL2674(myPpmDevice)
-            success = True
-        ## Gen5 EDSFF Fixture (E1)
+            dut = QTL2673(myPpmDevice)
+            success = True	
+        ## Gen5 E1 EDSFF Fixture - shares a PCBA with QTL2673
         if ('2887' in fixtureId):
-            dut = QTL2887(myPpmDevice)
-            success = True
-        ## GEN5 EDSFF Fixture (E3)
+            dut = QTL2673(myPpmDevice)
+            success = True	
+        ## Gen5 E3 EDSFF Fixture - shares a PCBA with QTL2673
         if ('2888' in fixtureId):
-            dut = QTL2888(myPpmDevice)
-            success = True
+            dut = QTL2673(myPpmDevice)
+            success = True	
         # 2-Channel PAM Mezzanine
         if ('2621' in fixtureId):
             dut = QTL2621(myPpmDevice)
             success = True
+        # 4-Channel PAM Mezzanine
+        if ('2626' in fixtureId):
+            dut = QTL2626(myPpmDevice)
+            success = True
+        # External Shunt PAM Mezzanine
+        if ('2631' in fixtureId):
+            dut = QTL2631(myPpmDevice)
+            success = True
     # Else if this is a 3 phase AC PAM
     elif ('2582' in serialNumber) or ('2751' in serialNumber) or ('2789' in serialNumber):
         dut = QTL2582(myPpmDevice)
         success = True
     # Else if this is an IEC PAM
     elif ('2843' in serialNumber):
         dut = QTL2843(myPpmDevice)
         success = True
-        connectionType = deviceString.split(':')
-        connectionName = 'QTL' + serialNumber
-        connStr = connectionType[0] + "::" + connectionName
-        # myPpmDevice = quarchDevice(calibrationResources["moduleString"], ConType='QIS')
-        myPpmDevice = quarchDevice(connStr, ConType='QIS')
-        # version = myPpmDevice.sendCommand("$version")
-        # spversion = version.split('.')
-        # if not (int(spversion[1]) == 26 and int(spversion[2] >= 4) or int(spversion[1] > 26)):
-        #    raise SystemError("QIS version must be > 1.26.04, current version "+version)
-        dut = QTL2582(myPpmDevice)
-        success = True
+                    
     if (success == False):
         if fixtureId:
             raise ValueError("ERROR - Serial number '" + fixtureId + "' not recogised as a valid power module")
         else:
             raise ValueError("ERROR - Serial number '" + serialNumber + "' not recogised as a valid power module")
     # If we're in testcenter setup the test
     if User_interface.instance != None and User_interface.instance.selectedInterface == "testcenter":
         # Store the serial number from the DUT scan for logging and verification
         TestCenter.testPoint("Quarch_Internal.StoreSerial", "Serial=" + dut.calObjectSerial);
         idnStr = str(dut.idnStr).replace("\r\n", "|")
         TestCenter.testPoint("Quarch_Internal.StoreDutActualIdn", "Idn=" + idnStr)
     return dut, myPpmDevice
 
 
-
 def calculateTestPass(list):
     '''Simple fuction uses to determine if the overall test has passed by looking at the list of test failures '''
     if len(list) == 0:
         return True
     else:
         return False
 
@@ -347,40 +334,14 @@
         else:
             stamp = "VERIFICATION FAILED"
 
     for testResults in listOfTestResults:
         overViewList.append([testResults["title"],testResults["result"],testResults["worst case"]])
     reportFile.write("\n\n"+displayTable(overViewList,tableHeaders=["Title", "Passed", "Worst Case"], printToConsole=False, align="r")+"\n\n" + displayTable(stamp, printToConsole=True))
 
-def get_QIS_version():
-	#TODO option var "close_qis_afer_check" to determine if qis is left open or not.
-    global my_close_qis
-    """
-    Returns the version of QIS.  This is the version of QIS currenty running on the local system if one exists.
-    Otherwise the local version within quarchpy will be exectued and its version returned.
-
-    Returns
-    -------
-    version: str
-        String representation of the QIS version number
-    """
-
-    qis_version = ""
-    if isQisRunning() == False:
-        my_close_qis = True
-        startLocalQis(headless=True)
-
-    myQis = qisInterface()
-    qis_version = myQis.sendAndReceiveCmd(cmd="$version")
-    if "No Target Device Specified" in qis_version:
-        qis_version = myQis.sendAndReceiveCmd(cmd="$help").split("\r\n")[0]
-    vmatch = re.search("v([0-9]).([0-9]+)", qis_version)
-    if vmatch:
-        return [int(x) for x in vmatch.groups()]
-
 def main(argstring):
     import argparse
     # Handle expected command line arguments here using a flexible parsing system
     parser = argparse.ArgumentParser(description='Calibration utility parameters')
     parser.add_argument('-a', '--action', help='Calibration action to perform', choices=['calibrate', 'verify', 'noise_test'], type=str.lower)
     parser.add_argument('-m', '--module', help='IP Address or netBIOS name of power module to calibrate', type=str.lower)
     parser.add_argument('-i', '--instr', help='IP Address or netBIOS name of calibration instrument', type=str.lower)
```

## quarchCalibration/elpaSine.py

```diff
@@ -10,18 +10,19 @@
         self.TIMEOUT = 10
         self.BUFFER_SIZE = 4096
         self.connection = None
         self.addr = addr
         self.numeric = re.compile("(\+|-)([0-9\.]+)")
         self.measurementType = "RMS"
         self.measurementTypeList = ["PEAK", "RMS"]
-        self.maxCurrentLimit = 8.0
+        self.maxCurrentLimit = 10.0
         self.isOpen = False
         self.commandDelay = 0.05 # It errors on back to back comms, delay needed.
         self.lastResult = None
+        self.conString = None
 
     def openConnection (self, connectionString = None):
         #print("DEBUG: openConnection")
         if (connectionString is not None):
             self.conString = connectionString
         else:
             self.conString = self.addr
```

## quarchCalibration/noise_test.py

```diff
@@ -14,14 +14,15 @@
 import datetime
 from user_interface.user_interface import get_check_valid_calPath
 from quarchpy.debug.SystemTest import get_quarchpy_version
 import argparse
 # TestCenter functions
 from quarchpy.utilities import TestCenter
 from quarchCalibration.calibrationConfig import *
+from quarchCalibration import _version as quarchCalibrationVersion
 
 current_milli_time = lambda: int(round(time.time() * 1000))
 
 
 def test_main(powerModule, myQpsDevice, close_QPS=False):
     ###HardcoddedVals### TODO Delete these and have all vals passed in.
     # #These now come from dut
@@ -57,30 +58,31 @@
     reportFile.write("System Information:\n")
     reportFile.write("\n")
     try:
         reportFile.write("QuarchPy Version: " + get_quarchpy_version() + "\n")
     except:
 
         reportFile.write("QuarchPy Version: unknown\n")
+    try:
+        reportFile.write("QuarchCalibration Version: " + quarchCalibrationVersion + "\n")
+    except:
+
+        reportFile.write("QuarchCalibration Version: unknown\n")
     reportFile.write("Noise Test Time: " + str(test_time.replace(microsecond=0)) + "\n")
     reportFile.write("\n")
     reportFile.write("---------------------------------\n")
     reportFile.write("\n")
     reportFile.flush()
 
     myQpsDevice.sendCommand("RECord:AVEraging "+powerModule.averaging_value)
     stream_path += "\\tempNoiseTestStream"+time.strftime("%Y-%m-%d-%H-%M-%S", time.gmtime())
     myStream = myQpsDevice.startStream(stream_path)
-
-    start_stream_time = current_milli_time()
-
+    time.sleep(1) #wait 1s before plotting an anno at 1s
     myStream.addAnnotation('Start '+testName, "e"+str(1))
-    time.sleep(powerModule.test_length*1.2+1)#+3
-    #myQpsDevice.sendCommand("Sig:12v:Volt 0") # sb db debug TODO move this HD specific
-    end_test_time = current_milli_time()
+    time.sleep(powerModule.test_length*1.3+1)#+3
     myStream.addAnnotation('End Test'+testName, "e"+str(powerModule.test_length+1))
     time.sleep(1) # lets it stream for 1 seconds
     myStream.stopStream()
     #myStream.hideAllDefaultChannels()
     time.sleep(2) #let the module unload the buffer #TODO change this to poll QPS if stopped streaming
     test_overview = []  # used to write to the report file
     myStats = myStream.get_stats(format="list")
```

## Comparing `quarchCalibration/QTL1944.py` & `quarchCalibration/QTL1944_hd_ppm.py`

 * *Files identical despite different names*

## Comparing `quarchCalibration/QTL1944_06.py` & `quarchCalibration/QTL1944_06_hd_plus_ppm.py`

 * *Files 0% similar despite different names*

```diff
@@ -390,16 +390,16 @@
                 raise ValueError ("Invalid voltage specified")
 
             result = self.powerModule.calInstrument.measureNoLoadVoltage()
 
 
             while (result < lower_limit or result > upper_limit):
                 if voltage.upper() == "12V":
-                    lower_limit = 11
-                    upper_limit = 13
+                    lower_limit = 10
+                    upper_limit = 14
                     self.powerModule.dut.sendAndVerifyCommand("sig:12v:volt 12000")
                 elif voltage.upper() == "5V":
                     lower_limit = 4
                     upper_limit = 6
                     self.powerModule.dut.sendAndVerifyCommand("sig:5v:volt 5000")
                 enclosure = self.powerModule.dut.sendCommand("*enclosure?")
                 if enclosure.__contains__("1995"):
```

## Comparing `quarchCalibration/QTL2525.py` & `quarchCalibration/QTL2347_pcie.py`

 * *Files 22% similar despite different names*

```diff
@@ -3,49 +3,32 @@
 Written for Python 3.6 64 bit
 
 M Dearman April 2019
 '''
 
 '''
 Calibration Flow
-    Connect to PPM
+    Connect to PAM Fixture 
     Connect to Keithley
     step through a set of values and get ADC vs Reference Value
     evaluate results vs defined limits
 
 '''
 
 #Imports QuarchPy library, providing the functions needed to use Quarch modules
-#from quarchpy import quarchDevice #, scanDevices
-
-# Import other libraries used in the examples
-
-
-
-# #unused imports
-# from functools import reduce
-# from quarchpy import *
-# from quarchCalibration.deviceHelpers import returnMeasurement
-# from quarchCalibration.calibrationConfig import *
-# import types
-# from time import sleep,time
-# from math import ceil
-# import threading
-# import datetime
-# from quarchpy.user_interface import storeResult
-
+from .PowerModuleCalibration import *
 from .calibrationConfig import *
 from .keithley_2460_control import *
-from .PowerModuleCalibration import *
-from quarchpy.user_interface import *
-from quarchpy.user_interface import logSimpleResult
+from .QTL2536_6_way_switchbox import *
 from quarchpy.device.device import *
 from quarchpy.device.scanDevices import userSelectDevice
+from quarchpy.user_interface import *
+from quarchpy.user_interface import logSimpleResult
 from quarchpy.utilities.BitManipulation import *
-
+from .pamHelpers import bcdString
 
 
 def parseFixtureData(response,start,length):
 
     # split the multiline response into a list
     response = response.splitlines()
     result = ""
@@ -71,109 +54,208 @@
     device.sendCommand("write 0x0000 " + setBit(response,3))
     #read measurement
     data = device.sendCommand("read 0x1000 to 0x1007")
     #release measurement
     response = device.sendCommand("read 0x0000")
     device.sendCommand("write 0x0000 " + clearBit(response,3))
 
-    if (channel == "5V VOLT"):
+    if (channel == "3V3 V"):
         return parseFixtureData(data,0,16)
-    elif (channel == "5V CUR"):
+    elif (channel == "3V3 A"):
         return parseFixtureData(data,16,25)
-    elif (channel == "12V VOLT"):
+    elif (channel == "12V V"):
         return parseFixtureData(data,41,16)
-    elif (channel == "12V CUR"):
+    elif (channel == "12V A"):
         return parseFixtureData(data,57,25)
-    elif (channel == "3V3_AUX VOLT"):
+    elif (channel == "3V3_AUX V"):
         return parseFixtureData(data,82,16)
-    elif (channel == "3V3_AUX CUR"):
+    elif (channel == "3V3_AUX A"):
         return parseFixtureData(data,98,20)
+    else:
+        raise Exception("Channel " + channel + " not found in fixture data")
 
-def bcdString(bcd,padding):
-    # strip off "0x" if present
-    if bcd[:2] == "0x":
-        bcd = bcd [2:]
-    # strip off leading 0's
-    # loop while we have more the required minimum number of characters left
-    while(len(bcd)>padding):
-        # if the leading character is 0, remove it
-        if bcd[0] == '0':
-            bcd = bcd[1:]
-        # else exit loop
-        else:
-            break
-    return bcd
 
 
-class QTL2525 (PowerModule):
+class QTL2347 (PowerModule):
 
     # Fixture Register Addresses
-    CALIBRATION_MODE_ADDR               = '0xA100'
-    CALIBRATION_CONTROL_ADDR            = '0xA101'      
-    V5_LOW_MULTIPLIER_ADDR            = '0xA105'
-    V5_LOW_OFFSET_ADDR                = '0xA106'
-    V5_HIGH_MULTIPLIER_ADDR           = '0xA107'
-    V5_HIGH_OFFSET_ADDR               = '0xA108'
-    V5_VOLT_MULTIPLIER_ADDR           = '0xA109'
-    V5_VOLT_OFFSET_ADDR               = '0xA10A'
-    V5_LEAKAGE_MULTIPLIER_ADDR        = '0xA10B'
-    V12_LOW_MULTIPLIER_ADDR             = '0xA10C'
-    V12_LOW_OFFSET_ADDR                 = '0xA10D'
-    V12_HIGH_MULTIPLIER_ADDR            = '0xA10E'
-    V12_HIGH_OFFSET_ADDR                = '0xA10F'
-    V12_VOLT_MULTIPLIER_ADDR            = '0xA110'
-    V12_VOLT_OFFSET_ADDR                = '0xA111'
-    V12_LEAKAGE_MULTIPLIER_ADDR         = '0xA112'
-    V3_3_AUX_MULTIPLIER_ADDR            = '0xA113'
-    V3_3_AUX_OFFSET_ADDR                = '0xA114'
-    V3_3_AUX_VOLT_MULTIPLIER_ADDR       = '0xA115'
-    V3_3_AUX_VOLT_OFFSET_ADDR           = '0xA116'
-    V3_3_AUX_LEAKAGE_MULTIPLIER_ADDR    = '0xA117'
-    CALIBRATION_COMPLETE_ADDR	        = '0xA118'
-    LOAD_VOLTAGE                        = 12000
+    CAL_ADDRESSES = {    
+    '3V3_LOW_MULTIPLIER'			: '0xA105',
+    '3V3_LOW_OFFSET'				: '0xA106',
+    '3V3_HIGH_MULTIPLIER'			: '0xA107',
+    '3V3_HIGH_OFFSET'				: '0xA108',
+    '3V3_VOLT_MULTIPLIER'			: '0xA109',
+    '3V3_VOLT_OFFSET'				: '0xA10A',
+    '3V3_LEAKAGE_MULTIPLIER'		: '0xA10B',
+    '12V_LOW_MULTIPLIER'			: '0xA10C',
+    '12V_LOW_OFFSET'				: '0xA10D',
+    '12V_HIGH_MULTIPLIER'			: '0xA10E',
+    '12V_HIGH_OFFSET'				: '0xA10F',
+    '12V_VOLT_MULTIPLIER'			: '0xA110',
+    '12V_VOLT_OFFSET'				: '0xA111',
+    '12V_LEAKAGE_MULTIPLIER'		: '0xA112',
+    '3V3_AUX_LOW_MULTIPLIER'		: '0xA113',
+    '3V3_AUX_LOW_OFFSET'			: '0xA114',
+    '3V3_AUX_VOLT_MULTIPLIER'		: '0xA115',
+    '3V3_AUX_VOLT_OFFSET'			: '0xA116',
+    '3V3_AUX_LEAKAGE_MULTIPLIER'	: '0xA117',
+    'CALIBRATION_COMPLETE'		    : '0xA118'
+	}
+
+    CONTROL_ADDRESSES = {
+    'CALIBRATION_MODE'             	            : '0xA100',
+    'CALIBRATION_CONTROL'          	            : '0xA101', 
+    '12V_LOW_CALIBRATION_CONTROL_SETTING'       : '0x00F4',		# set manual range, full averaging, 12V low current mode,
+    '12V_HIGH_CALIBRATION_CONTROL_SETTING'      : '0x00F8',		# set manual range, full averaging, 12V high current mode,
+    '3V3_LOW_CALIBRATION_CONTROL_SETTING'		: '0x00F1',		# set manual range, full averaging, 5V low current mode,
+    '3V3_HIGH_CALIBRATION_CONTROL_SETTING'		: '0x00F2',		# set manual range, full averaging, 5V low current mode,
+    '3V3_AUX_LOW_CALIBRATION_CONTROL_SETTING'   : '0x00F0',		# no range switching on 3V3_AUX, leave the module in auto mode
+    '3V3_AUX_HIGH_CALIBRATION_CONTROL_SETTING'  : '0x00F0'		# no range switching on 3V3_AUX, leave the module in auto mode
+    }
+
+    LOAD_VOLTAGE                    = 12000
+
+    
+    # Noise Test Vars
+    # Dict of channels and limits
+    has_noise_test = True
+    channel_dict_max_limits = {"current +3.3V Max": "250uA", "current +12V Max": "250uA", "current +3.3Vaux Max": "250uA"}
+    channel_dict_min_limits = {}
+    test_length = 10  # The time measurements are taken over, aka the distandce between the two annotations.
+    averaging_value = "4"  # 4=16us
+
+    host_switchbox_title = "Switchbox"
+    host_switchbox_message = "Select the switch box which connects a 12V supply and Keithley Load to the fixture:"
+    host_switchbox_mapping = {'12V':'A','12V_SUPPLY':'1','3V3_SUPPLY':'2','3V3_AUX_SUPPLY':'3','LOAD':'B','12V_LOAD':'4','3V3_LOAD':'5','3V3_AUX_LOAD':'6'}
 
     # Fixture Information
     PAMSerial = None
     FixtureSerial = None
     calObjectSerial = None     # The serial number of the device that is being calibrated, i.e QTL1944 in HD PPM, Fixture in PAM
     idnStr = None
     Firmware = None
     Fpga = None
     calInstrument = None
     calInstrumentId = None
-    switchbox = None
+    host_switchbox = None
     waitComplete = False
     checkedWiring = False
 
-    # Physical Connection Tracking (what is plugged to what)
-    loadChannel = None
-    hostPowerChannel = None
-    hostPort = "A"
-    loadPort = "B"
-    loadConnectionPortDict = {"12V": "4", "5V": "5", "3V3_AUX": "6"}
-    hostConnectionPortDict = {"12V": "1", "5V": "2", "3V3_AUX": "3"}
+    def __init__(self,dut):
+
+        # set the name of this module
+        self.name = "PCIe x16 Power Measurement Fixture"
+        self.dut = dut
+        
+        # Serial numbers (ensure QTL at start)
+        self.enclosureSerial = self.dut.sendCommand("*ENCLOSURE?")
+        if (self.enclosureSerial.find ("QTL") == -1):
+            self.enclosureSerial = "QTL" + self.enclosureSerial
+        # fetch the enclosure position
+        self.enclosurePosition = self.dut.sendCommand("*POSITION?")
+        self.PAMSerial = self.dut.sendCommand ("*SERIAL?")
+        if (self.PAMSerial.find ("QTL") == -1):
+            self.PAMSerial = "QTL" + self.PAMSerial
+        # Fixture Serial
+        # fixture serial is retrieved as BCD, we need to convert and pad it
+        self.FixtureSerial = "QTL" + bcdString(dut.sendCommand("read 0xA102"),4) + "-" + bcdString(dut.sendCommand("read 0xA103"),2) + "-" + bcdString(dut.sendCommand("read 0xA104"),3) # TODO: this should be replaced with fix:serial? command when implemented
+        # calObjectSerial Serial
+        self.calObjectSerial = self.FixtureSerial
+        # Filename String
+        self.filenameString = self.FixtureSerial
+        # Code version (FPGA)
+        self.idnStr = dut.sendCommand ("*IDN?")
+        pos = self.idnStr.upper().find ("FPGA 1:")
+        if (pos != -1):
+            versionStr = self.idnStr[pos+7:]
+            pos = versionStr.find ("\n")
+            if (pos != -1):
+                versionStr = versionStr[:pos].strip()
+            else:
+                pass
+        else:
+            versionStr = "NOT-FOUND"    
+        self.Fpga = versionStr.strip()
+    
+        # Code version (FW)    
+        pos = self.idnStr.upper().find ("PROCESSOR:")
+        if (pos != -1):
+            versionStr = self.idnStr[pos+10:]
+            pos = versionStr.find ("\n")
+            if (pos != -1):
+                versionStr = versionStr[:pos].strip()            
+            else:
+                pass
+        else:
+            versionStr = "NOT-FOUND"    
+        self.Firmware = versionStr.strip()
+
+        self.calibrations = {}
+        # populate 12V channel with calibrations
+        self.calibrations["12V"] = {
+            "Voltage":self.QTL2347_VoltageCalibration(self,"12V"),
+            "Leakage":self.QTL2347_LeakageCalibration(self,"12V"),
+            "Low Current":self.QTL2347_LowCurrentCalibration(self,"12V"),
+            "High Current":self.QTL2347_HighCurrentCalibration(self,"12V")
+            }
+        # populate 3V3 channel with calibrations
+        self.calibrations["3V3"] = {
+            "Voltage":self.QTL2347_VoltageCalibration(self,"3V3"),
+            "Leakage":self.QTL2347_LeakageCalibration(self,"3V3"),
+            "Low Current":self.QTL2347_LowCurrentCalibration(self,"3V3"),
+            "High Current":self.QTL2347_HighCurrentCalibration(self,"3V3")
+            }
+        # populate 3V3_AUX channel with calibrations
+        self.calibrations["3V3_AUX"] = {
+            "Voltage":self.QTL2347_VoltageCalibration(self,"3V3_AUX"),
+            "Leakage":self.QTL2347_LeakageCalibration(self,"3V3_AUX"),
+            "Current":self.QTL2347_AUX_CurrentCalibration(self,"3V3_AUX")
+            }
+
+        self.verifications = {}
+        # populate 12V channel with verifications
+        self.verifications["12V"] = {
+            "Voltage":self.QTL2347_VoltageVerification(self,"12V"),
+            "Low Current":self.QTL2347_LowCurrentVerification(self,"12V"),
+            "High Current":self.QTL2347_HighCurrentVerification(self,"12V")
+            }
+        # populate 3V3 channel with verifications
+        self.verifications["3V3"] = {
+            "Voltage":self.QTL2347_VoltageVerification(self,"3V3"),
+            "Low Current":self.QTL2347_LowCurrentVerification(self,"3V3"),
+            "High Current":self.QTL2347_HighCurrentVerification(self,"3V3")
+            }
+        # populate 3V3 channel with verifications
+        self.verifications["3V3_AUX"] = {
+            "Voltage":self.QTL2347_VoltageVerification(self,"3V3_AUX"),
+            "Current":self.QTL2347_AUX_CurrentVerification(self,"3V3_AUX")
+            }
+
 
     def specific_requirements(self):
 
         reportText=""
 
-        # select a switchbox to use for calibration
-        if "switchbox" in calibrationResources.keys():
-            self.switchbox = calibrationResources["switchbox"]
-        self.switchbox = self.getSwitchbox()
-        calibrationResources["switchbox"] = self.switchbox
+        # select the host switchbox to use for calibration
+        if "host_switchbox" in calibrationResources.keys():
+            self.host_switchbox = calibrationResources["host_switchbox"]
+        else:
+            self.host_switchbox = self.get_switchbox(self.host_switchbox_message,self.host_switchbox_title,self.host_switchbox_mapping)
+            calibrationResources["host_switchbox"] = self.host_switchbox
+
         if self.checkedWiring != True:
-            self.checkWiring()
+            self.host_switchbox.checkWiring()
+
             self.checkedWiring = True
 
         # Select a Keithley SMU
         # If no calibration instrument is provided, request it
         while (True):
-            loadString = userSelectCalInstrument(scanFilterStr="Keithley 2460", nice=True)
             if (calibrationResources["loadString"] == None):
+                loadString = userSelectCalInstrument(scanFilterStr="Keithley 2460", nice=True)
                 # quit if necessary
                 if loadString == 'quit':
                     printText("no module selected, exiting...")
                     sys.exit(0)
                 else:
                     calibrationResources["loadString"] = loadString
             try:
@@ -198,132 +280,90 @@
         reportText += "FW:" + self.Firmware + ", FPGA: " + self.Fpga + "\n"
         reportText += "\n"
         reportText += "Calibration Instruments#:\n"
         reportText += self.calInstrumentId + "\n"
 
         # perform uptime check and write to file
         if self.waitComplete != True:
-            reportText += self.wait_for_up_time(desired_up_time=600)
+            reportText += self.wait_for_up_time(desired_up_time=600, command="conf:runtime:fix:sec?")
             self.waitComplete = True
 
         return reportText
 
-    def setConnections(self,loadConnection,hostPowerConnection,reset=False):
-    #TODO Fix for using class variable.
-        if reset:
-            self.loadChannel = None
-            self.hostPowerChannel = None
-
-        # If current connections are correct
-        if self.loadChannel == loadConnection and self.hostPowerChannel == hostPowerConnection and reset==False:
-            # do nothing
-            pass
-
-        # else connections need to change
-        else:
-
-            # we can't turn an individual port off (at the moment) so we turn both off first, then set anything that needs setting
-            if loadConnection == None or hostPowerConnection == None:
-                response = self.switchbox.sendCommand("connect off")
-                if response != "OK": raise Exception("switchbox command failed")
-
-            if loadConnection != None:
-                response = self.switchbox.sendCommand("connect " + self.loadPort + " " + self.loadConnectionPortDict[loadConnection])
-                if response != "OK": raise Exception("switchbox command failed")
-
-            if hostPowerConnection != None:
-                response = self.switchbox.sendCommand("connect " + self.hostPort + " " + self.hostConnectionPortDict[hostPowerConnection])
-                if response != "OK": raise Exception("switchbox command failed")
+    def open_module(self):
 
-        self.loadChannel = loadConnection
-        self.hostPowerChannel = hostPowerConnection
+        # set unit into calibration mode
+        self.dut.sendCommand("write " + self.CONTROL_ADDRESSES["CALIBRATION_MODE"] + " 0xaa55")
+        self.dut.sendCommand("write " + self.CONTROL_ADDRESSES["CALIBRATION_MODE"] + " 0x55aa")
 
-    def getSwitchbox(self):
+    def get_switchbox(self,msg,name,portDict):
         # CheckSwitchbox
-        if self.switchbox is None:
-            while (True):
-                switchboxAddress = userSelectDevice(scanFilterStr=["QTL2536"], message="Select a calibration 6 Way Test Lead Switch.", nice=True)
-                if switchboxAddress == "quit":
-                    printText("User Quit Program")
-                    sys.exit(0)
-                try:
-                    self.switchbox = quarchDevice(switchboxAddress)
-                    break
-                except:
-                    printText("Unable to communicate with selected device!")
-                    printText("")
-                    switchboxAddress = None
-                    raise
-        return self.switchbox
+        while (True):
+            switchboxAddress = userSelectDevice(scanFilterStr=["QTL2536"], message=msg, nice=True)
+            if switchboxAddress == "quit":
+                printText("User Quit Program")
+                sys.exit(0)
+            try:
+                switchbox = QTL2536_6_way_switchbox(switchboxAddress,name,portDict)
+                break
+            except:
+                printText("Unable to communicate with selected device!")
+                printText("")
+                switchboxAddress = None
+                raise
+        return switchbox
 
 
     def clear_calibration(self):
 
         # set unit into calibration mode
-        self.dut.sendCommand("write " + QTL2525.CALIBRATION_MODE_ADDR + " 0xaa55")
-        self.dut.sendCommand("write " + QTL2525.CALIBRATION_MODE_ADDR + " 0x55aa")
+        self.dut.sendCommand("write " + self.CONTROL_ADDRESSES["CALIBRATION_MODE"] + " 0xaa55")
+        self.dut.sendCommand("write " + self.CONTROL_ADDRESSES["CALIBRATION_MODE"] + " 0x55aa")
 
         # clear all calibration registers
-        self.dut.sendAndVerifyCommand("write " + QTL2525.V5_VOLT_OFFSET_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2525.V5_VOLT_MULTIPLIER_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2525.V5_LOW_OFFSET_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2525.V5_LOW_MULTIPLIER_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2525.V5_HIGH_OFFSET_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2525.V5_HIGH_MULTIPLIER_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2525.V5_LEAKAGE_MULTIPLIER_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2525.V12_VOLT_OFFSET_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2525.V12_VOLT_MULTIPLIER_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2525.V12_LOW_OFFSET_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2525.V12_LOW_MULTIPLIER_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2525.V12_HIGH_OFFSET_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2525.V12_HIGH_MULTIPLIER_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2525.V12_LEAKAGE_MULTIPLIER_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2525.V3_3_AUX_VOLT_OFFSET_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2525.V3_3_AUX_VOLT_MULTIPLIER_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2525.V3_3_AUX_OFFSET_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2525.V3_3_AUX_MULTIPLIER_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2525.V3_3_AUX_LEAKAGE_MULTIPLIER_ADDR + " 0x0000")
+        for address in self.CAL_ADDRESSES.values():
+            self.dut.sendAndVerifyCommand("write " + address + " 0x0000")
         
         # write 0xaa55 to register to calibration complete register to tell module it is calibrated
-        self.dut.sendAndVerifyCommand("write " + QTL2525.CALIBRATION_COMPLETE_ADDR + " 0xaa55")
+        self.dut.sendAndVerifyCommand("write " + self.CAL_ADDRESSES["CALIBRATION_COMPLETE"] + " 0xaa55")
         
     def write_calibration(self):
 
         # write the calibration registers
         # erase the tag memory
         printText("Erasing TAG memory..")
         self.dut.sendCommand("write 0xa200 0x0020")
         # TODO: should check for completion here...
         # wait for 2 seconds for erase to complete
         # check busy
         while checkBit(self.dut.sendCommand("read 0xa200"),8):
-            sleep(0.1)
+            time.sleep(0.1)
         # write the tag memory
         printText("Programming TAG memory...")
         self.dut.sendCommand("write 0xa200 0x0040")        
         # check busy
         while checkBit(self.dut.sendCommand("read 0xa200"),8):
-            sleep(0.1)
+            time.sleep(0.1)
 
     def close_module(self):
 
         # reset the fixture FPGA
         self.dut.sendCommand("fixture:reset")
 
         #close the connection to the calibration instrument
         self.calInstrument.closeConnection()
 
     def close_all(self):
 
         #close all attached devices
         self.calInstrument.setLoadCurrent(0)
         self.calInstrument.closeConnection()
-        self.powerModule.setConnections(None,None)
+        self.host_switchbox.sendCommand("connect off")
 
-    class QTL2525Calibration (Calibration):
+    class QTL2347Calibration (Calibration):
 
         def __init__(self):
             super().__init__()
 
         def init_cal(self,voltage):
 
             # TODO: No Power control at the moment
@@ -333,72 +373,42 @@
             # set averaging to max
             self.powerModule.dut.sendAndVerifyCommand("rec:ave 32k")
 
             #Turn off compression and power up
             self.powerModule.dut.sendAndVerifyCommand("write 0xA010 0x0011")
 
             # set module into calibration mode (again?)
-            self.powerModule.dut.sendCommand("write " + QTL2525.CALIBRATION_MODE_ADDR + " 0xaa55")   # will not verify
-            self.powerModule.dut.sendCommand("write " + QTL2525.CALIBRATION_MODE_ADDR + " 0x55aa")   # will not verify
+            self.powerModule.dut.sendCommand("write " + self.powerModule.CONTROL_ADDRESSES["CALIBRATION_MODE"] + " 0xaa55")   # will not verify
+            self.powerModule.dut.sendCommand("write " + self.powerModule.CONTROL_ADDRESSES["CALIBRATION_MODE"] + " 0x55aa")   # will not verify
 
             #Reset Keithley
             self.powerModule.calInstrument.reset()
 
-        def meas_12v_volt(self):
-
-            result = getFixtureData(self.powerModule.dut,"12V VOLT")
-            return result
-
-        def meas_12v_cur(self):
-
-            result = getFixtureData(self.powerModule.dut,"12V CUR")
-            return result
-
-        def meas_5V_volt(self):
-
-            result = getFixtureData(self.powerModule.dut,"5V VOLT")
-            return result
-
-        def meas_5V_cur(self):
-
-            result = getFixtureData(self.powerModule.dut,"5V CUR")
-            return result
-
-        def meas_3v3_aux_volt(self):
-
-            result = getFixtureData(self.powerModule.dut,"3V3_AUX VOLT")
-            return result
-
-        def meas_3v3_aux_cur(self):
-
-            result = getFixtureData(self.powerModule.dut,"3V3_AUX CUR")
-            return result
-
         # check connections to host power and load
         def checkLoadVoltage(self,voltage,tolerance):
 
-            #self.powerModule.calInstrument.setReferenceCurrent(0)
-            self.powerModule.calInstrument.setReferenceVoltage(voltage/1000,"1e-6")  # set Keithley to the required voltage but limit current to 1uA
+            self.powerModule.calInstrument.setReferenceCurrent(0)
             result = self.powerModule.calInstrument.measureLoadVoltage()*1000   # *1000 because we use mV but keithley uses volts
             # check result is in required range
             if (result >= voltage-tolerance) and (result <= voltage+tolerance):
                 return True
             else:
                 return False
 
         def finish_cal(self):
 
             #turn off load
             self.powerModule.calInstrument.disable()
 
             #turn off switch
-            self.powerModule.setConnections(None,None)
+            self.powerModule.host_switchbox.setConnections([]) #sendCommand("connect off")
+
 
             # turn dut to autoranging
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.CALIBRATION_CONTROL_ADDR + " 0x00F0")
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CONTROL_ADDRESSES["CALIBRATION_CONTROL"] + " 0x00F0")
 
         def report(self,action,data):
 
             report = []
 
             # send to report file
             report.append("          Pass Level  +/-(" + str(self.absErrorLimit) + str(self.units) +" + " + str(self.relErrorLimit) + "%) \n")
@@ -465,19 +475,20 @@
             report.append("\n\n\n")
             
             #Add to Test Summary? Do this here?
             passfail = lambda x: "Passed" if x else "Failed"
 
             return {"title":self.title,"result":overallResult,"worst case":worstCase,"report":('\n'.join(report))}
 
-    class QTL2525_12V_VoltageCalibration (QTL2525Calibration):
+    class QTL2347_VoltageCalibration (QTL2347Calibration):
 
-        def __init__(self,powerModule):
+        def __init__(self,powerModule,thisChannel):
 
-            self.title = "12V Voltage Calibration"
+            self.thisChannel = thisChannel
+            self.title = thisChannel + " Voltage Calibration"
             self.powerModule = powerModule
             self.absErrorLimit = 2                  # 2mV
             self.relErrorLimit = 1                  # 1%
             self.test_min = 40                      # 40mV
             self.test_max = 14400                   # 14.4V
             self.test_steps = 20
             self.units = "mV"
@@ -487,411 +498,238 @@
             self.multiplier_frac_width = 16
             self.offset_signed = True
             self.offset_int_width = 10
             self.offset_frac_width = 6
 
         def init(self):
 
-            super().init_cal("12v")
+            super().init_cal(self.thisChannel)
 
             # clear the multiplier and offset registers by setting them to zero
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V12_VOLT_MULTIPLIER_ADDR + " 0x0000")
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V12_VOLT_OFFSET_ADDR + " 0x0000")
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_VOLT_MULTIPLIER"] + " 0x0000")
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_VOLT_OFFSET"] + " 0x0000")
+
+            self.powerModule.host_switchbox.setConnections([("12V",None),("LOAD",self.thisChannel + "_LOAD")])
 
-            self.powerModule.setConnections("12V",None)
-            ## Check Host Power is not present        
+            # Check Host Power is present
             #while (super().checkLoadVoltage(500,500) != True):
-            #    input("Unexpected voltage detected at load, please check connections")
             #    self.powerModule.setConnections("12V",None,reset=True)
 
         def setRef(self,value):
 
             self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
 
         def readRef(self):
 
             return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def readVal(self):
 
-            return super().meas_12v_volt()
-
-        def setCoefficients(self):
-
-            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V12_VOLT_MULTIPLIER_ADDR + " " + self.multiplier.hexString(4))
-            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V12_VOLT_OFFSET_ADDR + " " + self.offset.hexString(4))
-            if result1 and result2:
-                result = True
-            else:
-                result = False
-            logSimpleResult("Set 12v voltage", result)
-
-        def finish(self):
-
-            super().finish_cal()
-
-        def report(self,data):
-
-            return super().report("calibrate",data)
-
-        def readCoefficients(self):
-
-            coefficients = {}
-            # get 12v voltage multiplier
-            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + QTL2525.V12_VOLT_MULTIPLIER_ADDR)
-            # get 12v voltage offset
-            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + QTL2525.V12_VOLT_OFFSET_ADDR)
-            return coefficients
-
-        def writeCoefficients(self,coefficients):
-
-            # write 12v voltage multiplier
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V12_VOLT_MULTIPLIER_ADDR + " " + coefficients["multiplier"])
-            # write 12v voltage offset
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V12_VOLT_OFFSET_ADDR + " " + coefficients["offset"])
-
-    class QTL2525_12V_LowCurrentCalibration (QTL2525Calibration):
-
-        def __init__(self,powerModule):
-
-            self.title = "12V Low Current Calibration"
-            self.powerModule = powerModule
-            self.absErrorLimit = 15                 # 15uA
-            self.relErrorLimit = 1                  # 1%
-            self.test_min = 10          # 10uA
-            self.test_max = 85000       # 85mA
-            self.test_steps = 20
-            self.units = "uA"
-            self.scaling = 32
-            self.multiplier_signed = False
-            self.multiplier_int_width = 1
-            self.multiplier_frac_width = 16
-            self.offset_signed = True
-            self.offset_int_width = 10
-            self.offset_frac_width = 6
-
-        def init(self):
-
-            super().init_cal("12v")
-
-            #set manual range, full averaging, 12v low current mode, 5V all off (so we can detect we're connected to the wrong channel
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.CALIBRATION_CONTROL_ADDR + " 0x00F4")
-            # clear the multiplier and offset registers by setting them to zero
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V12_LOW_MULTIPLIER_ADDR + " 0x0000")
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V12_LOW_OFFSET_ADDR + " 0x0000")
-
-            self.powerModule.setConnections("12V","12V")
-            # Check Host Power is present          
-            while (super().checkLoadVoltage(QTL2525.LOAD_VOLTAGE,1000) != True):
-                input("Unexpected voltage detected at load, please check connections")
-                self.powerModule.setConnections("12V","12V",reset=True)
-
-        def setRef(self,value):
-
-            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
-
-        def readRef(self):
-
-            # read device voltage and add leakage current to the reference
-            voltage =  super().meas_12v_volt()
-            #leakage = voltage*self.powerModule.calibrations["12V"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["12V"]["Leakage"].offset.originalValue()
-            return self.powerModule.calInstrument.measureLoadCurrent()*1000000# + leakage
-
-        def readVal(self):
-
-            return super().meas_12v_cur()
+            return getFixtureData(self.powerModule.dut,self.thisChannel + " V")
 
         def setCoefficients(self):
 
-            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V12_LOW_MULTIPLIER_ADDR + " " + self.multiplier.hexString(4))
-            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V12_LOW_OFFSET_ADDR + " " + self.offset.hexString(4))
+            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_VOLT_MULTIPLIER"] + " " + self.multiplier.hexString(4))
+            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_VOLT_OFFSET"] + " " + self.offset.hexString(4))
             if result1 and result2:
                 result = True
             else:
                 result = False
-            logSimpleResult("Set 12v Low Current", result)
+            logSimpleResult("Set " + self.thisChannel + " voltage", result)
 
         def finish(self):
 
             super().finish_cal()
 
         def report(self,data):
 
             return super().report("calibrate",data)
 
         def readCoefficients(self):
 
             coefficients = {}
-            # get 12v low current multiplier
-            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + QTL2525.V12_LOW_MULTIPLIER_ADDR)
-            # get 12v low current offset
-            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + QTL2525.V12_LOW_OFFSET_ADDR)
+            # get voltage multiplier
+            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_VOLT_MULTIPLIER"])
+            # get voltage offset
+            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_VOLT_OFFSET"])
             return coefficients
 
         def writeCoefficients(self,coefficients):
 
-            # write 12v low current multiplier
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V12_LOW_MULTIPLIER_ADDR + " " + coefficients["multiplier"])
-            # write 12v low current offset
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V12_LOW_OFFSET_ADDR + " " + coefficients["offset"])
+            # write voltage multiplier
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_VOLT_MULTIPLIER"] + " " + coefficients["multiplier"])
+            # write voltage offset
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_VOLT_OFFSET"] + " " + coefficients["offset"])
 
-    class QTL2525_12V_HighCurrentCalibration (QTL2525Calibration):
+    class QTL2347_LeakageCalibration (QTL2347Calibration):
 
-        def __init__(self,powerModule):
+        def __init__(self,powerModule,thisChannel):
 
-            self.title = "12V High Current Calibration"
+            self.thisChannel = thisChannel
+            self.title = self.thisChannel + " Leakage Calibration"
             self.powerModule = powerModule
-            self.absErrorLimit = 2000   # 2mA
-            self.relErrorLimit = 1      # 1%
-            self.test_min = 1000        # 1mA
-            self.test_max = 4000000     # 4A
-            self.test_steps = 20
-            self.units = "uA"
-            self.scaling = 2048
-            self.multiplier_signed = False
-            self.multiplier_int_width = 1
-            self.multiplier_frac_width = 16
-            self.offset_signed = True
-            self.offset_int_width = 10
-            self.offset_frac_width = 6
-
-        def init(self):
-
-            super().init_cal("12v")
-
-            #set manual range, full averaging, 12v high current mode, 5V all off (so we can detect we're connected to the wrong channel
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.CALIBRATION_CONTROL_ADDR + " 0x00F8")
-            # clear the multiplier and offset registers by setting them to zero
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V12_HIGH_MULTIPLIER_ADDR + " 0x0000")
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V12_HIGH_OFFSET_ADDR + " 0x0000")
-
-            self.powerModule.setConnections("12V","12V")
-            # Check Host Power is present      
-            while (super().checkLoadVoltage(QTL2525.LOAD_VOLTAGE,1000) != True):
-                input("Unexpected voltage detected at load, please check connections")
-                self.powerModule.setConnections("12V","12V",reset=True)
-
-        def setRef(self,value):
-
-            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
-
-        def readRef(self):
-
-            # read device voltage and add leakage current to the reference
-            voltage =  super().meas_12v_volt()
-            return self.powerModule.calInstrument.measureLoadCurrent()*1000000# + leakage
-
-        def readVal(self):
-
-            return super().meas_12v_cur()
-
-        def setCoefficients(self):
-
-            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V12_HIGH_MULTIPLIER_ADDR + " " + self.multiplier.hexString(4))
-            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V12_HIGH_OFFSET_ADDR + " " + self.offset.hexString(4))
-            if result1 and result2:
-                result = True
-            else:
-                result = False
-            logSimpleResult("Set 12v high current", result)
-
-        def finish(self):
-
-            super().finish_cal()
-
-        def report(self,data):
-
-            return super().report("calibrate",data)
-
-        def readCoefficients(self):
-
-            coefficients = {}
-            # get 12v high current multiplier
-            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + QTL2525.V12_HIGH_MULTIPLIER_ADDR)
-            # get 12v high current offset
-            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + QTL2525.V12_HIGH_OFFSET_ADDR)
-            return coefficients
-
-        def writeCoefficients(self,coefficients):
-
-            # write 12v high current multiplier
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V12_HIGH_MULTIPLIER_ADDR + " " + coefficients["multiplier"])
-            # write 12v high current offset
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V12_HIGH_OFFSET_ADDR + " " + coefficients["offset"])
-
-    class QTL2525_5V_VoltageCalibration (QTL2525Calibration):
-
-        def __init__(self,powerModule):
-
-            self.title = "5V Voltage Calibration"
-            self.powerModule = powerModule
-            self.absErrorLimit = 2                  # 2mV
-            self.relErrorLimit = 1                  # 1%
-            self.test_min = 40                      # 40mV
+            self.absErrorLimit = 50                 # 50uA = 1% of 5000 uA
+            self.relErrorLimit = 0                  # 0%
+            self.test_min = 1000                    # 1000mV
             self.test_max = 14400                   # 14.4V
             self.test_steps = 20
-            self.units = "mV"
-            self.scaling = 4
+            self.units = "uA"
+            self.scaling = 1
             self.multiplier_signed = False
             self.multiplier_int_width = 1
             self.multiplier_frac_width = 16
-            self.offset_signed = True
-            self.offset_int_width = 10
-            self.offset_frac_width = 6
+            self.offset_signed = False               # offset is not stored, don't care
+            self.offset_int_width = 16               # offset is not stored, don't care
+            self.offset_frac_width = 16              # offset is not stored, don't care
 
         def init(self):
 
-            super().init_cal("5V")
+            super().init_cal(self.thisChannel)
 
-            # clear the multiplier and offset registers by setting them to zero
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V5_VOLT_MULTIPLIER_ADDR + " 0x0000")
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V5_VOLT_OFFSET_ADDR + " 0x0000")
+            #set manual range, full averaging, [thisChannel] low current mode, other channels all off (so we can detect we're connected to the wrong channel
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CONTROL_ADDRESSES["CALIBRATION_CONTROL"] + " " + self.powerModule.CONTROL_ADDRESSES[self.thisChannel + "_LOW_CALIBRATION_CONTROL_SETTING"])
+            # clear the multiplier register by setting it to zero
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_LEAKAGE_MULTIPLIER"] + " 0x0000")
+
+            self.powerModule.host_switchbox.setConnections([("12V",None),("LOAD",self.thisChannel + '_LOAD')])
+            ## Check Host Power is present
+            #while (super().checkLoadVoltage(self.powerModule.LOAD_VOLTAGE,1000) != True):
+            #    showDialog(message="Host Power not detected, please check the connections",title="Check Connections")
+            #    self.powerModule.host_switchbox.setConnections([("12V",self.thisChannel + '_SUPPLY'),("LOAD",self.thisChannel + '_LOAD')])
 
-            self.powerModule.setConnections("5V",None)
-            ## Check Host Power is not present            
-            #while (super().checkLoadVoltage(500,500) != True):
-            #    input("Unexpected voltage detected at load, please check connections")
-            #    self.powerModule.setConnections("5V",None,reset=True)
 
         def setRef(self,value):
 
             self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
 
         def readRef(self):
 
-            return self.powerModule.calInstrument.measureLoadVoltage()*1000
+            # negate result because in this case the load is providing the power, not sinking it
+            return -self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
-            return super().meas_5V_volt()
+            return self.powerModule.calInstrument.getLoadVoltage()*1000
 
         def setCoefficients(self):
 
-            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V5_VOLT_MULTIPLIER_ADDR + " " + self.multiplier.hexString(4))
-            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V5_VOLT_OFFSET_ADDR + " " + self.offset.hexString(4))
-            if result1 and result2:
-                result = True
-            else:
-                result = False
-            logSimpleResult("Set 5v voltage", result)
+            # we don't apply the leakage calibration here because it provides uA leakage results and the current calibration uses raw ADC values
+            # instead we will use it to correct the current calibration and apply it later
+            pass
 
         def finish(self):
-
             super().finish_cal()
 
         def report(self,data):
 
             return super().report("calibrate",data)
 
         def readCoefficients(self):
 
             coefficients = {}
-            # get 5V voltage multiplier
-            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + QTL2525.V5_VOLT_MULTIPLIER_ADDR)
-            # get 5V voltage offset
-            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + QTL2525.V5_VOLT_OFFSET_ADDR)
-            return coefficients
+            # get leakage multiplier
+            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_LEAKAGE_MULTIPLIER"])
 
-        def writeCoefficients(self,coefficients):
+        def writeCoefficients(self,coefficents):
 
-            # write 5V voltage multiplier
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V5_VOLT_MULTIPLIER_ADDR + " " + coefficients["multiplier"])
-            # write 5V voltage offset
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V5_VOLT_OFFSET_ADDR + " " + coefficients["offset"])
+            # write leakage multiplier
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_LEAKAGE_MULTIPLIER"] + " " + coefficients["multiplier"])
 
-    class QTL2525_5V_LowCurrentCalibration (QTL2525Calibration):
+    class QTL2347_LowCurrentCalibration (QTL2347Calibration):
 
-        def __init__(self,powerModule):
+        def __init__(self,powerModule,thisChannel):
 
-            self.title = "5V Low Current Calibration"
+            self.thisChannel = thisChannel
+            self.title = thisChannel + " Low Current Calibration"
             self.powerModule = powerModule
-            self.absErrorLimit = 15     # 15uA
-            self.relErrorLimit = 1      # 1%
-            self.test_min = 10          # 10uA
-            self.test_max = 85000       # 85mA
+            self.absErrorLimit = 2      			# 2uA
+            self.relErrorLimit = 2      			# 2%
+            self.test_min = 10                      # 10uA
+            self.test_max = 85000                   # 85mA
             self.test_steps = 20
             self.units = "uA"
             self.scaling = 32
             self.multiplier_signed = False
             self.multiplier_int_width = 1
             self.multiplier_frac_width = 16
             self.offset_signed = True
             self.offset_int_width = 10
             self.offset_frac_width = 6
 
         def init(self):
 
-            super().init_cal("5V")
+            super().init_cal(self.thisChannel)
 
-            #set manual range, full averaging, 5v low current mode, 12v all off (so we can detect we're connected to the wrong channel
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.CALIBRATION_CONTROL_ADDR + " 0x00F1")
+            #set manual range, full averaging, [thisChannel] low current mode, other channels all off (so we can detect we're connected to the wrong channel
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CONTROL_ADDRESSES["CALIBRATION_CONTROL"] + " " + self.powerModule.CONTROL_ADDRESSES[self.thisChannel + "_LOW_CALIBRATION_CONTROL_SETTING"])
             # clear the multiplier and offset registers by setting them to zero
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V5_LOW_MULTIPLIER_ADDR + " 0x0000")
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V5_LOW_OFFSET_ADDR + " 0x0000")
-
-            self.powerModule.setConnections("5V","5V")
-            # Check Host Power is present        
-            while (super().checkLoadVoltage(QTL2525.LOAD_VOLTAGE,1000) != True):
-                input("Unexpected voltage detected at load, please check connections")
-                self.powerModule.setConnections("5V","5V",reset=True)
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_LOW_MULTIPLIER"] + " 0x0000")
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_LOW_OFFSET"] + " 0x0000")
 
+            self.powerModule.host_switchbox.setConnections([("12V",self.thisChannel + '_SUPPLY'),("LOAD",self.thisChannel + '_LOAD')])
+            # Check Host Power is present
+            while (super().checkLoadVoltage(self.powerModule.LOAD_VOLTAGE,1000) != True):
+                showDialog(message="Host Power not detected, please check the connections",title="Check Connections")
+                self.powerModule.host_switchbox.setConnections([("12V",self.thisChannel + '_SUPPLY'),("LOAD",self.thisChannel + '_LOAD')])
 
         def setRef(self,value):
 
             self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
             # read device voltage and add leakage current to the reference
-            voltage =  super().meas_5V_volt()
-            #leakage = voltage*self.powerModule.calibrations["5V"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["5V"]["Leakage"].offset.originalValue()
-            return self.powerModule.calInstrument.measureLoadCurrent()*1000000# + leakage
+            voltage = getFixtureData(self.powerModule.dut,self.thisChannel + " V")
+            leakage = voltage*self.powerModule.calibrations[self.thisChannel]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations[self.thisChannel]["Leakage"].offset.originalValue()
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000 + leakage
 
         def readVal(self):
 
-            return super().meas_5V_cur()
+            return getFixtureData(self.powerModule.dut,self.thisChannel + " A")
 
         def setCoefficients(self):
 
-            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V5_LOW_MULTIPLIER_ADDR + " " + self.multiplier.hexString(4))
-            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V5_LOW_OFFSET_ADDR + " " + self.offset.hexString(4))
+            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_LOW_MULTIPLIER"] + " " + self.multiplier.hexString(4))
+            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_LOW_OFFSET"] + " " + self.offset.hexString(4))
             if result1 and result2:
                 result = True
             else:
                 result = False
-            logSimpleResult("Set 5v low current", result)
+            logSimpleResult("Set " + self.thisChannel + " low current", result)
+
         def finish(self):
 
             super().finish_cal()
 
         def report(self,data):
 
             return super().report("calibrate",data)
 
         def readCoefficients(self):
 
             coefficients = {}
-            # get 5v low current multiplier
-            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + QTL2525.V5_LOW_MULTIPLIER_ADDR)
-            # get 5v low current offset
-            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + QTL2525.V5_LOW_OFFSET_ADDR)
+            # get low current multiplier
+            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_LOW_MULTIPLIER"])
+            # get low current offset
+            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_LOW_OFFSET"])
             return coefficients
 
         def writeCoefficients(self,coefficients):
 
-            # write 5v low current multiplier
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V5_LOW_MULTIPLIER_ADDR + " " + coefficients["multiplier"])
-            # write 5v low current offset
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V5_LOW_OFFSET_ADDR + " " + coefficients["offset"])
+            # write low current multiplier
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_LOW_MULTIPLIER"] + " " + coefficients["multiplier"])
+            # write low current offset
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_LOW_OFFSET"] + " " + coefficients["offset"])
 
-    class QTL2525_5V_HighCurrentCalibration (QTL2525Calibration):
+    class QTL2347_HighCurrentCalibration (QTL2347Calibration):
 
-        def __init__(self,powerModule):
+        def __init__(self,powerModule,thisChannel):
 
-            self.title = "5V High Current Calibration"
+            self.thisChannel = thisChannel
+            self.title = thisChannel + " High Current Calibration"
             self.powerModule = powerModule
             self.absErrorLimit = 2000               # 2mA
             self.relErrorLimit = 1                  # 1%
             self.test_min = 1000                    # 1mA
             self.test_max = 4000000                 # 4A
             self.test_steps = 20
             self.units = "uA"
@@ -901,681 +739,335 @@
             self.multiplier_frac_width = 16
             self.offset_signed = True
             self.offset_int_width = 10
             self.offset_frac_width = 6
 
         def init(self):
 
-            super().init_cal("5V")
+            super().init_cal(self.thisChannel)
 
-            #set manual range, full averaging, 5v high current mode, 12v all off (so we can detect we're connected to the wrong channel
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.CALIBRATION_CONTROL_ADDR + " 0x00F2")
+            #set manual range, full averaging, [thisChannel] high current mode, other channels all off (so we can detect we're connected to the wrong channel
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CONTROL_ADDRESSES["CALIBRATION_CONTROL"] + " " + self.powerModule.CONTROL_ADDRESSES[self.thisChannel + "_HIGH_CALIBRATION_CONTROL_SETTING"])
             # clear the multiplier and offset registers by setting them to zero
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V5_HIGH_MULTIPLIER_ADDR + " 0x0000")
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V5_HIGH_OFFSET_ADDR + " 0x0000")
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_HIGH_MULTIPLIER"] + " 0x0000")
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_HIGH_OFFSET"] + " 0x0000")
 
-            self.powerModule.setConnections("5V","5V")        
+            self.powerModule.host_switchbox.setConnections([("12V",self.thisChannel + '_SUPPLY'),("LOAD",self.thisChannel + '_LOAD')])
             # Check Host Power is present
-            while (super().checkLoadVoltage(QTL2525.LOAD_VOLTAGE,1000) != True):
-            	input("Unexpected voltage detected at load, please check connections")
-            	self.powerModule.setConnections("5V","5V",reset=True)
-
+            while (super().checkLoadVoltage(self.powerModule.LOAD_VOLTAGE,1000) != True):
+                showDialog(message="Host Power not detected, please check the connections",title="Check Connections")
+                self.powerModule.host_switchbox.setConnections([("12V",self.thisChannel + '_SUPPLY'),("LOAD",self.thisChannel + '_LOAD')])
 
         def setRef(self,value):
 
             self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
             # read device voltage and add leakage current to the reference
-            voltage =  super().meas_5V_volt()
-            #leakage = voltage*self.powerModule.calibrations["5V"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["5V"]["Leakage"].offset.originalValue()
-            return self.powerModule.calInstrument.measureLoadCurrent()*1000000# + leakage
+            voltage = getFixtureData(self.powerModule.dut,self.thisChannel + " V")
+            leakage = voltage*self.powerModule.calibrations[self.thisChannel]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations[self.thisChannel]["Leakage"].offset.originalValue()
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000 + leakage
 
         def readVal(self):
 
-            return super().meas_5V_cur()
+            return getFixtureData(self.powerModule.dut,self.thisChannel + " A")
 
         def setCoefficients(self):
 
-            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V5_HIGH_MULTIPLIER_ADDR + " " + self.multiplier.hexString(4))
-            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V5_HIGH_OFFSET_ADDR + " " + self.offset.hexString(4))
+            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_HIGH_MULTIPLIER"] + " " + self.multiplier.hexString(4))
+            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_HIGH_OFFSET"] + " " + self.offset.hexString(4))
             if result1 and result2:
                 result = True
             else:
                 result = False
-            logSimpleResult("Set 5v high current", result)
+            logSimpleResult("Set " + self.thisChannel + " high current", result)
 
             # once we've completed low and high current we can set leakage on the fixture
-            #result = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V5_LEAKAGE_MULTIPLIER_ADDR + " " + self.powerModule.calibrations["5V"]["Leakage"].multiplier.hexString(4))
+            result = self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_LEAKAGE_MULTIPLIER"] + " " + self.powerModule.calibrations[self.thisChannel]["Leakage"].multiplier.hexString(4))
 
         def finish(self):
 
             super().finish_cal()
 
         def report(self,data):
 
             return super().report("calibrate",data)
 
         def readCoefficients(self):
 
             coefficients = {}
-            # get 5V high current multiplier
-            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + QTL2525.V5_HIGH_MULTIPLIER_ADDR)
-            # get 5V high current offset
-            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + QTL2525.V5_HIGH_OFFSET_ADDR)
+            # get high current multiplier
+            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_HIGH_MULTIPLIER"])
+            # get high current offset
+            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_HIGH_OFFSET"])
             return coefficients
 
         def writeCoefficients(self,coefficients):
 
-            # write 5V high current multiplier
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V5_HIGH_MULTIPLIER_ADDR + " " + coefficients["multiplier"])
-            # write 5V high current offset
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V5_HIGH_OFFSET_ADDR + " " + coefficients["offset"])
+            # write high current multiplier
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_HIGH_MULTIPLIER"] + " " + coefficients["multiplier"])
+            # write high current offset
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_HIGH_OFFSET"] + " " + coefficients["offset"])
 
-    class QTL2525_3V3_AUX_VoltageCalibration (QTL2525Calibration):
+    class QTL2347_AUX_CurrentCalibration (QTL2347Calibration):
 
-        def __init__(self,powerModule):
+        def __init__(self,powerModule,thisChannel):
 
-            self.title = "3.3V Aux Voltage Calibration"
+            self.thisChannel = thisChannel
+            self.title = thisChannel + " Aux Current Calibration"
             self.powerModule = powerModule
-            self.absErrorLimit = 2              # 2mV
-            self.relErrorLimit = 1              # 1%
-            self.test_min = 40                  # 40mV
-            self.test_max = 14400               # 14.4V
-            self.test_steps = 20
-            self.units = "mV"
-            self.scaling = 4
-            self.multiplier_signed = False
-            self.multiplier_int_width = 1
-            self.multiplier_frac_width = 16
-            self.offset_signed = True
-            self.offset_int_width = 10
-            self.offset_frac_width = 6
-
-        def init(self):
-
-            super().init_cal("3V3_AUX")
-
-            # clear the multiplier and offset registers by setting them to zero
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V3_3_AUX_VOLT_MULTIPLIER_ADDR + " 0x0000")
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V3_3_AUX_VOLT_OFFSET_ADDR + " 0x0000")
-
-            self.powerModule.setConnections("3V3_AUX",None)
-            ## Check Host Power is not present
-            #while (super().checkLoadVoltage(500,500) != True):
-            #	input("Unexpected voltage detected at load, please check connections")
-            #	self.powerModule.setConnections("3V3_AUX",None,reset=True)
-
-
-        def setRef(self,value):
-
-            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
-
-        def readRef(self):
-
-            return self.powerModule.calInstrument.measureLoadVoltage()*1000
-
-        def readVal(self):
-
-            return super().meas_3v3_aux_volt()
-
-        def setCoefficients(self):
-
-            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V3_3_AUX_VOLT_MULTIPLIER_ADDR + " " + self.multiplier.hexString(4))
-            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V3_3_AUX_VOLT_OFFSET_ADDR + " " + self.offset.hexString(4))
-            if result1 and result2:
-                result = True
-            else:
-                result = False
-            logSimpleResult("Set 3.3v Aux voltage", result)
-
-        def finish(self):
-
-            super().finish_cal()
-
-        def report(self,data):
-
-            return super().report("calibrate",data)
-
-        def readCoefficients(self):
-
-            coefficients = {}
-            # get 3v3 Aux voltage multiplier
-            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + QTL2525.V3_3_AUX_VOLT_MULTIPLIER_ADDR)
-            # get 3v3 Aux voltage offset
-            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + QTL2525.V3_3_AUX_VOLT_OFFSET_ADDR)
-            return coefficients
-
-        def writeCoefficients(self,coefficients):
-
-            # write 3v3 Aux voltage multiplier
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V3_3_AUX_VOLT_MULTIPLIER_ADDR + " " + coefficients["multiplier"])
-            # write 3v3 Aux voltage offset
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V3_3_AUX_VOLT_OFFSET_ADDR + " " + coefficients["offset"])
-
-    class QTL2525_3V3_AUX_CurrentCalibration (QTL2525Calibration):
-
-        def __init__(self,powerModule):
-
-            self.title = "3.3V Aux Current Calibration"
-            self.powerModule = powerModule
-            self.absErrorLimit = 15         # 15uA
-            self.relErrorLimit = 1          # 1%
-            self.test_min = 10              # 10uA
-            self.test_max = 85000           # 85mA
+            self.absErrorLimit = 2          		# 2uA
+            self.relErrorLimit = 2          		# 2%
+            self.test_min = 100             		# 100uA
+            self.test_max = 400000          		# 400mA
             self.test_steps = 20
             self.units = "uA"
-            self.scaling = 32
+            self.scaling = 64
             self.multiplier_signed = False
             self.multiplier_int_width = 1
             self.multiplier_frac_width = 16
             self.offset_signed = True
             self.offset_int_width = 10
             self.offset_frac_width = 6
 
         def init(self):
 
-            super().init_cal("3V3_AUX")
+            super().init_cal(self.thisChannel)
 
+            #set manual range, full averaging, [thisChannel] low current mode, other channels all off (so we can detect we're connected to the wrong channel
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CONTROL_ADDRESSES["CALIBRATION_CONTROL"] + " " + self.powerModule.CONTROL_ADDRESSES[self.thisChannel + "_LOW_CALIBRATION_CONTROL_SETTING"])
             # clear the multiplier and offset registers by setting them to zero
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V3_3_AUX_MULTIPLIER_ADDR + " 0x0000")
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V3_3_AUX_OFFSET_ADDR + " 0x0000")
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_LOW_MULTIPLIER"] + " 0x0000")
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_LOW_OFFSET"] + " 0x0000")
 
-            self.powerModule.setConnections("3V3_AUX","3V3_AUX")
-            # Check Host Power is not present	    
-            while (super().checkLoadVoltage(QTL2525.LOAD_VOLTAGE,1000) != True):
-            	input("Unexpected voltage detected at load, please check connections")
-            	self.powerModule.setConnections("3V3_AUX","3V3_AUX",reset=True)
+            self.powerModule.host_switchbox.setConnections([("12V",self.thisChannel + '_SUPPLY'),("LOAD",self.thisChannel + '_LOAD')])
+            # Check Host Power is present
+            while (super().checkLoadVoltage(self.powerModule.LOAD_VOLTAGE,1000) != True):
+                showDialog(message="Host Power not detected, please check the connections",title="Check Connections")
+                self.powerModule.host_switchbox.setConnections([("12V",self.thisChannel + '_SUPPLY'),("LOAD",self.thisChannel + '_LOAD')])
 
         def setRef(self,value):
 
             self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
             # read device voltage and add leakage current to the reference
-            voltage =  super().meas_3v3_aux_volt()
-            #leakage = voltage*self.powerModule.calibrations["3.3V Aux"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["3.3V Aux"]["Leakage"].offset.originalValue()
-            return self.powerModule.calInstrument.measureLoadCurrent()*1000000# + leakage
+            voltage = getFixtureData(self.powerModule.dut,self.thisChannel + " V")
+            leakage = voltage*self.powerModule.calibrations[self.thisChannel]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations[self.thisChannel]["Leakage"].offset.originalValue()
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000 + leakage
 
         def readVal(self):
 
-            return super().meas_3v3_aux_cur()
+            return getFixtureData(self.powerModule.dut,self.thisChannel + " A")
 
         def setCoefficients(self):
 
-            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V3_3_AUX_MULTIPLIER_ADDR + " " + self.multiplier.hexString(4))
-            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V3_3_AUX_OFFSET_ADDR + " " + self.offset.hexString(4))
+            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_LOW_MULTIPLIER"] + " " + self.multiplier.hexString(4))
+            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_LOW_OFFSET"] + " " + self.offset.hexString(4))
             if result1 and result2:
                 result = True
             else:
                 result = False
-            logSimpleResult("Set 3.3v Aux low current", result)
+            logSimpleResult("Set " + self.thisChannel + " low current", result)
 
             # once we've completed low and high current we can set leakage on the fixture
-            #result = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V3_3_AUX_LEAKAGE_MULTIPLIER_ADDR + " " + self.powerModule.calibrations["3.3V Aux"]["Leakage"].multiplier.hexString(4))
+            result = self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_LEAKAGE_MULTIPLIER"] + " " + self.powerModule.calibrations[self.thisChannel]["Leakage"].multiplier.hexString(4))
 
         def finish(self):
 
             super().finish_cal()
 
         def report(self,data):
 
             return super().report("calibrate",data)
 
         def readCoefficients(self):
 
             coefficients = {}
-            # get 3v3 Aux low current multiplier
-            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + QTL2525.V3_3_AUX_MULTIPLIER_ADDR)
-            # get 3v3 Aux low current offset
-            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + QTL2525.V3_3_AUX_OFFSET_ADDR)
+            # get low current multiplier
+            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_LOW_MULTIPLIER"])
+            # get low current offset
+            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_LOW_OFFSET"])
             return coefficients
 
         def writeCoefficients(self,coefficients):
 
-            # write 3v3 Aux low current multiplier
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V3_3_AUX_MULTIPLIER_ADDR + " " + coefficients["multiplier"])
-            # write 3v3 Aux low current offset
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2525.V3_3_AUX_OFFSET_ADDR + " " + coefficients["offset"])
+            # write low current multiplier
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_LOW_MULTIPLIER"] + " " + coefficients["multiplier"])
+            # write low current offset
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_LOW_OFFSET"] + " " + coefficients["offset"])
 
-    class QTL2525_12V_VoltageVerification (QTL2525Calibration):
+    class QTL2347_VoltageVerification (QTL2347Calibration):
 
-        def __init__(self,powerModule):
+        def __init__(self,powerModule,thisChannel):
 
-            self.title = "12V Voltage Verification"
+            self.thisChannel = thisChannel
+            self.title = thisChannel + " Voltage Verification"
             self.powerModule = powerModule
             self.absErrorLimit = 2      # 2mV
             self.relErrorLimit = 1      # 1%
             self.test_min = 40          # 40mV
             self.test_max = 14400       # 14.4V
             self.test_steps = 20
             self.units = "mV"
 
         def init(self):
 
-            super().init_cal("12V")
+            super().init_cal(self.thisChannel)
 
-            self.powerModule.setConnections("12V",None)
-            # Check Host Power is not present	    
-            while (super().checkLoadVoltage(500,500) != True):
-            	input("Unexpected voltage detected at load, please check connections")
-            	self.powerModule.setConnections("12V",None,reset=True)
+            self.powerModule.host_switchbox.setConnections([("12V",None),("LOAD",self.thisChannel + "_LOAD")])
 
         def setRef(self,value):
 
             self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
 
         def readRef(self):
 
             return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def readVal(self):
 
-            return super().meas_12v_volt()
+            return getFixtureData(self.powerModule.dut,self.thisChannel + " V")
 
         def finish(self):
 
             super().finish_cal()
 
         def report(self,data):
 
             return super().report("verify",data)
 
-    class QTL2525_12V_LowCurrentVerification (QTL2525Calibration):
+    class QTL2347_LowCurrentVerification (QTL2347Calibration):
 
-        def __init__(self,powerModule):
+        def __init__(self,powerModule,thisChannel):
 
-            self.title = "12V Low Current Verification"
+            self.thisChannel = thisChannel
+            self.title = thisChannel + " Low Current Verification"
             self.powerModule = powerModule
-            self.absErrorLimit = 25     # 2uA
-            self.relErrorLimit = 1      # 1% tolerance
+            self.absErrorLimit = 2      # 2uA
+            self.relErrorLimit = 2      # 2% tolerance
             self.test_min = 100         # 100uA
             self.test_max = 1000        # 1mA
             self.test_steps = 20
             self.units = "uA"
 
         def init(self):
 
-            super().init_cal("12V")
+            super().init_cal(self.thisChannel)
 
-            self.powerModule.setConnections("12V","12V")	    
+            self.powerModule.host_switchbox.setConnections([("12V",self.thisChannel + '_SUPPLY'),("LOAD",self.thisChannel + '_LOAD')])
 
             # Check Host Power is present
-            while (super().checkLoadVoltage(QTL2525.LOAD_VOLTAGE,500) != True):
-            	input("Unexpected voltage detected at load, please check connections")
-            	self.powerModule.setConnections("12V","12V",reset=True)
-            	
+            while (super().checkLoadVoltage(self.powerModule.LOAD_VOLTAGE,1000) != True):
+                showDialog(message="Host Power not detected, please check the connections",title="Check Connections")
+                self.powerModule.host_switchbox.setConnections([("12V",self.thisChannel + '_SUPPLY'),("LOAD",self.thisChannel + '_LOAD')])
+
         def setRef(self,value):
 
             self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
             return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
-            return super().meas_12v_cur()
+            return getFixtureData(self.powerModule.dut,self.thisChannel + " A")
 
         def finish(self):
 
             super().finish_cal()
 
         def report(self,data):
 
             return super().report("verify",data)
 
-    class QTL2525_12V_HighCurrentVerification (QTL2525Calibration):
+    class QTL2347_HighCurrentVerification (QTL2347Calibration):
 
-        def __init__(self,powerModule):
+        def __init__(self,powerModule,thisChannel):
 
-            self.title = "12V High Current Verification"
+            self.thisChannel = thisChannel
+            self.title = thisChannel + " High Current Verification"
             self.powerModule = powerModule
             self.absErrorLimit = 2000       # 2mA
             self.relErrorLimit = 1          # 1% tolerance
             self.test_min = 1000            # 1mA
             self.test_max = 4000000         # 4A
             self.test_steps = 20
             self.units = "uA"
 
         def init(self):
 
-            super().init_cal("12v")
+            super().init_cal(self.thisChannel)
 
-            self.powerModule.setConnections("12V","12V")
-            # Check Host Power is present	    	    
-            while (super().checkLoadVoltage(QTL2525.LOAD_VOLTAGE,500) != True):
-            	input("Unexpected voltage detected at load, please check connections")
-            	self.powerModule.setConnections("12V","12V",reset=True)
+            self.powerModule.host_switchbox.setConnections([("12V",self.thisChannel + '_SUPPLY'),("LOAD",self.thisChannel + '_LOAD')])
+            # Check Host Power is present
+            while (super().checkLoadVoltage(self.powerModule.LOAD_VOLTAGE,1000) != True):
+                showDialog(message="Host Power not detected, please check the connections",title="Check Connections")
+                self.powerModule.host_switchbox.setConnections([("12V",self.thisChannel + '_SUPPLY'),("LOAD",self.thisChannel + '_LOAD')])
 
         def setRef(self,value):
 
             self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
             return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
-            return super().meas_12v_cur()
+            return getFixtureData(self.powerModule.dut,self.thisChannel + " A")
 
         def finish(self):
 
             super().finish_cal()
 
         def report(self,data):
 
             return super().report("verify",data)
 
-    class QTL2525_5V_VoltageVerification (QTL2525Calibration):
+    class QTL2347_AUX_CurrentVerification (QTL2347Calibration):
 
-        def __init__(self,powerModule):
+        def __init__(self,powerModule,thisChannel):
 
-            self.title = "5V Voltage Verification"
+            self.thisChannel = thisChannel
+            self.title = thisChannel + " Aux Current Verification"
             self.powerModule = powerModule
-            self.absErrorLimit = 2      # 2mV
-            self.relErrorLimit = 1      # 1%
-            self.test_min = 40          # 40mV
-            self.test_max = 6000        # 6V
-            self.test_steps = 20
-            self.units = "mV"
-
-        def init(self):
-
-            super().init_cal("5V")
-
-            self.powerModule.setConnections("5V",None)
-            
-            # Check Host Power is not present	    
-            while (super().checkLoadVoltage(500,500) != True):
-            	input("Unexpected voltage detected at load, please check connections")
-            	self.powerModule.setConnections("5V",None,reset=True)
-
-        def setRef(self,value):
-
-            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
-
-        def readRef(self):
-
-            return self.powerModule.calInstrument.measureLoadVoltage()*1000
-
-        def readVal(self):
-
-            return super().meas_5V_volt()
-
-        def finish(self):
-
-            super().finish_cal()
-
-        def report(self,data):
-
-            return super().report("verify",data)
-
-    class QTL2525_5V_LowCurrentVerification (QTL2525Calibration):
-
-        def __init__(self,powerModule):
-
-            self.title = "5V Low Current Verification"
-            self.powerModule = powerModule
-            self.absErrorLimit = 25     # 25uA
-            self.relErrorLimit = 1      # 1%
+            self.absErrorLimit = 2      # 2uA
+            self.relErrorLimit = 2      # 2%
             self.test_min = 100         # 100uA
-            self.test_max = 1000        # 1mA
-            self.test_steps = 20
-            self.units = "uA"
-
-        def init(self):
-
-            super().init_cal("5V")
-
-            self.powerModule.setConnections("5V","5V")
-            # Check Host Power is present	    
-            while (super().checkLoadVoltage(QTL2525.LOAD_VOLTAGE,1000) != True):
-            	input("Unexpected voltage detected at load, please check connections")
-            	self.powerModule.setConnections("5V","5V",reset=True)
-  
-        def setRef(self,value):
-
-            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
-
-        def readRef(self):
-
-            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
-
-        def readVal(self):
-
-            return super().meas_5V_cur()
-
-        def finish(self):
-
-            super().finish_cal()
-
-        def report(self,data):
-
-            return super().report("verify",data)
-
-    class QTL2525_5V_HighCurrentVerification (QTL2525Calibration):
-
-        def __init__(self,powerModule):
-
-            self.title = "5V High Current Verification"
-            self.powerModule = powerModule
-            self.absErrorLimit = 2000       # 2mA
-            self.relErrorLimit = 1          # 1% tolerance
-            self.test_min = 1000            # 1mA
-            self.test_max = 4000000         # 4A
+            self.test_max = 400000      # 400mA
             self.test_steps = 20
             self.units = "uA"
 
         def init(self):
 
-            super().init_cal("5V")
+            super().init_cal(self.thisChannel)
 
-            self.powerModule.setConnections("5V","5V")
-            
-            # Check Host Power is present	    
-            while (super().checkLoadVoltage(QTL2525.LOAD_VOLTAGE,1000) != True):
-            	input("Unexpected voltage detected at load, please check connections")
-            	self.powerModule.setConnections("5V","5V",reset=True)
-            	
-
-        def setRef(self,value):
-
-            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
-
-        def readRef(self):
+            self.powerModule.host_switchbox.setConnections([("12V",self.thisChannel + '_SUPPLY'),("LOAD",self.thisChannel + '_LOAD')])
 
-            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
-
-        def readVal(self):
-
-            return super().meas_5V_cur()
-
-        def finish(self):
-
-            super().finish_cal()
-
-        def report(self,data):
-
-            return super().report("verify",data)
-
-    class QTL2525_3V3_AUX_VoltageVerification (QTL2525Calibration):
-
-        def __init__(self,powerModule):
-
-            self.title = "3.3V Aux Voltage Verification"
-            self.powerModule = powerModule
-            self.absErrorLimit = 2      # 2mV
-            self.relErrorLimit = 1      # 1%
-            self.test_min = 40          # 40mV
-            self.test_max = 14400       # 14.4V
-            self.test_steps = 20
-            self.units = "mV"
-
-        def init(self):
-
-            super().init_cal("3V3_AUX")
-
-            self.powerModule.setConnections("3V3_AUX",None)
-            # Check Host Power is not present	    
-            while (super().checkLoadVoltage(500,500) != True):
-            	input("Unexpected voltage detected at load, please check connections")
-            	self.powerModule.setConnections("3V3_AUX",None,reset=True)
-            	
-        def setRef(self,value):
-
-            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
-
-        def readRef(self):
-
-            return self.powerModule.calInstrument.measureLoadVoltage()*1000
-
-        def readVal(self):
-
-            return super().meas_3v3_aux_volt()
-
-        def finish(self):
-
-            super().finish_cal()
-
-        def report(self,data):
-
-            return super().report("verify",data)
-
-    class QTL2525_3V3_AUX_CurrentVerification (QTL2525Calibration):
-
-        def __init__(self,powerModule):
-
-            self.title = "3.3V Aux Current Verification"
-            self.powerModule = powerModule
-            self.absErrorLimit = 25     # 25uA
-            self.relErrorLimit = 1      # 1%
-            self.test_min = 100         # 100uA
-            self.test_max = 85000       # 85mA
-            self.test_steps = 20
-            self.units = "uA"
-
-        def init(self):
-
-            super().init_cal("3V3_AUX")
+            # Check Host Power is present
+            while (super().checkLoadVoltage(self.powerModule.LOAD_VOLTAGE,1000) != True):
+                showDialog(message="Host Power not detected, please check the connections",title="Check Connections")
+                self.powerModule.host_switchbox.setConnections([("12V",self.thisChannel + '_SUPPLY'),("LOAD",self.thisChannel + '_LOAD')])
 
-            self.powerModule.setConnections("3V3_AUX","3V3_AUX")
-            # Check Host Power is present	    
-            while (super().checkLoadVoltage(QTL2525.LOAD_VOLTAGE,1000) != True):
-            	input("Unexpected voltage detected at load, please check connections")
-            	self.powerModule.setConnections("3V3_AUX","3V3_AUX",reset=True)
-    
         def setRef(self,value):
 
             self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
             return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
-            return super().meas_3v3_aux_cur()
+            return getFixtureData(self.powerModule.dut,self.thisChannel + " A")
 
         def finish(self):
 
             super().finish_cal()
 
         def report(self,data):
 
             return super().report("verify",data)
-
-
-
-    def __init__(self,dut):
-
-        # set the name of this module
-        self.name = "PCIe x16 Power Measurement Fixture"
-        self.dut = dut
-        
-        # Serial numbers (ensure QTL at start)
-        self.enclosureSerial = self.dut.sendCommand("*ENCLOSURE?")
-        if (self.enclosureSerial.find ("QTL") == -1):
-            self.enclosureSerial = "QTL" + self.enclosureSerial
-        # fetch the enclosure position
-        self.enclosurePosition = self.dut.sendCommand("*POSITION?")
-        self.PAMSerial = self.dut.sendCommand ("*SERIAL?")
-        if (self.PAMSerial.find ("QTL") == -1):
-            self.PAMSerial = "QTL" + self.PAMSerial
-        # Fixture Serial
-        # fixture serial is retrieved as BCD, we need to convert and pad it
-        self.FixtureSerial = "QTL" + bcdString(dut.sendCommand("read 0xA102"),4) + "-" + bcdString(dut.sendCommand("read 0xA103"),2) + "-" + bcdString(dut.sendCommand("read 0xA104"),3) # TODO: this should be replaced with fix:serial? command when implemented
-        # calObjectSerial Serial
-        self.calObjectSerial = self.FixtureSerial
-        # Filename String
-        self.filenameString = self.FixtureSerial
-        # Code version (FPGA)
-        self.idnStr = dut.sendCommand ("*IDN?")
-        pos = self.idnStr.upper().find ("FPGA 1:")
-        if (pos != -1):
-            versionStr = self.idnStr[pos+7:]
-            pos = versionStr.find ("\n")
-            if (pos != -1):
-                versionStr = versionStr[:pos].strip()
-            else:
-                pass
-        else:
-            versionStr = "NOT-FOUND"    
-        self.Fpga = versionStr.strip()
-    
-        # Code version (FW)    
-        pos = self.idnStr.upper().find ("PROCESSOR:")
-        if (pos != -1):
-            versionStr = self.idnStr[pos+10:]
-            pos = versionStr.find ("\n")
-            if (pos != -1):
-                versionStr = versionStr[:pos].strip()            
-            else:
-                pass
-        else:
-            versionStr = "NOT-FOUND"    
-        self.Firmware = versionStr.strip()
-
-        self.calibrations = {}
-        # populate 12V channel with calibrations
-        self.calibrations["12V"] = {
-            "Voltage":self.QTL2525_12V_VoltageCalibration(self),
-            #"Leakage":self.QTL2525_12V_LeakageCalibration(self),
-            "Low Current":self.QTL2525_12V_LowCurrentCalibration(self),
-            "High Current":self.QTL2525_12V_HighCurrentCalibration(self)
-            }
-        # populate 5V channel with calibrations
-        self.calibrations["5V"] = {
-            "Voltage":self.QTL2525_5V_VoltageCalibration(self),
-            #"Leakage":self.QTL2525_5V_LeakageCalibration(self),
-            "Low Current":self.QTL2525_5V_LowCurrentCalibration(self),
-            "High Current":self.QTL2525_5V_HighCurrentCalibration(self)
-            }
-        # populate 3V3_AUX channel with calibrations
-        self.calibrations["3.3V Aux"] = {
-            "Voltage":self.QTL2525_3V3_AUX_VoltageCalibration(self),
-            #"Leakage":self.QTL2525_3V3_AUX_LeakageCalibration(self),
-            "Current":self.QTL2525_3V3_AUX_CurrentCalibration(self)
-            }
-
-        self.verifications = {}
-        # populate 12V channel with verifications
-        self.verifications["12V"] = {
-            "Voltage":self.QTL2525_12V_VoltageVerification(self),
-            "Low Current":self.QTL2525_12V_LowCurrentVerification(self),
-            "High Current":self.QTL2525_12V_HighCurrentVerification(self)
-            }
-        # populate 5V channel with verifications
-        self.verifications["5V"] = {
-            "Voltage":self.QTL2525_5V_VoltageVerification(self),
-            "Low Current":self.QTL2525_5V_LowCurrentVerification(self),
-            "High Current":self.QTL2525_5V_HighCurrentVerification(self)
-            }
-        # populate 3V3_AUX channel with verifications
-        self.verifications["3.3V Aux"] = {
-            "Voltage":self.QTL2525_3V3_AUX_VoltageVerification(self),
-            "Current":self.QTL2525_3V3_AUX_CurrentVerification(self)
-            }
-
```

## Comparing `quarchCalibration/QTL2582.py` & `quarchCalibration/QTL2582_3ph_ac.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,14 +1,15 @@
 '''
 Quarch Power Module Calibration Functions
 Written for Python 3.6 64 bit
 
 M Dearman April 2019
 Edited k McRobert September 2021
 '''
+from quarchCalibration.Keithley_DMM6500_control import KeithleyDMM6500
 import quarchpy.user_interface
 
 '''
 Calibration Flow
     Connect to AC PAM Fixture 
     Connect to ELPA-SINE
     Connect to AC Power Supply
@@ -36,15 +37,19 @@
 from quarchpy.qis import isQisRunning, startLocalQis
 from quarchpy.connection_specific.connection_QIS import QisInterface as qisInterface
 import csv
 from collections import OrderedDict
 from .threePhaseSwitchBox import ThreePhaseSwitchBox
 from quarchCalibration import Keysight_AC6804B_control
 from quarchCalibration.Keysight_AC6804B_control import KeysightAC6804B
+from .pamHelpers import bcdString
+#from .acHelpers import *
+#import matplotlib.pyplot as plt --debug only
 
+#todo: MIKE - terrible name and strange location
 def get_QIS_version():
 	#TODO option var "close_qis_afer_check" to determine if qis is left open or not.
     global my_close_qis
     """
     Returns the version of QIS.  This is the version of QIS currenty running on the local system if one exists.
     Otherwise the local version within quarchpy will be exectued and its version returned.
 
@@ -64,52 +69,14 @@
     qis_version = myQis.sendAndReceiveCmd(cmd="$version")
     if "No Target Device Specified" in qis_version:
         qis_version = myQis.sendAndReceiveCmd(cmd="$help").split("\r\n")[0]
     vmatch = re.search("v([0-9]).([0-9]+)", qis_version)
     if vmatch:
         return [int(x) for x in vmatch.groups()]
 
-def parseFixtureData(response,start,length):
-
-    # split the multiline response into a list
-    response = response.splitlines()
-    result = ""
-    # for each line
-    for line in response:
-        # remove 0x, swap bytes
-        line = line[4:6] + line[2:4]
-        # convert 4 char Hex to 16 bit binary string
-        line = "{0:016b}".format(int(line,16))
-        # concatenate all the strings
-        result += line
-    # pick out the section we want
-    result = int(result[start:(start+length)],2)
-    # convert two's compliment
-    if (result >= 2**(length-1)):
-        result -= 2**length
-    return result
-
-
-def bcdString(bcd,padding):
-    # strip off "0x" if present
-    if bcd[:2] == "0x":
-        bcd = bcd [2:]
-    # strip off leading 0's
-    # loop while we have more the required minimum number of characters left
-    while(len(bcd)>padding):
-        # if the leading character is 0, remove it
-        if bcd[0] == '0':
-            bcd = bcd[1:]
-        # else exit loop
-        else:
-            break
-    return bcd
-
-currentPhase = None
-
 class QTL2582 (PowerModule):
     phaseList = ['L1', 'L2', 'L3', 'Neutral']
     calTypeList = ['I', 'V', 'V2']
 
     # Fixture Register Addresses
     CALIBRATION_MODE_ADDR               = '0xA100'
     CALIBRATION_CONTROL_ADDR            = '0xA101'
@@ -158,23 +125,128 @@
     calInstrumentId = None
     switchbox = None
 
     # Physical Connection Tracking (what is plugged to what)
     loadChannel = None
     hostPowerChannel = None
 
+    def __init__(self,dut):
+
+        # We need to use QIS to get RMS etc
+        # close the quarchpy connection
+        dut.closeConnection()
+        # and open a QIS connection
+        isQisRunning()
+        version = get_QIS_version()
+        if not ((version[0] == 1 and version[1] >= 27) or version[0] > 1):
+            raise ValueError("ERROR - Detected QIS {0[0]}.{0[1]}, Requires QIS version 1.27 or greater".format(version))
+
+        dut = quarchDevice(dut.ConString, ConType='QIS')
+        dut = quarchPPM(dut)    #mike hack
+
+        sleep(1)
+
+        # set the name of this module
+        self.name = "3 Phase AC PAM"
+        self.dut = dut
+
+        # Serial numbers (ensure QTL at start)
+        self.enclosureSerial = self.dut.sendCommand("*ENCLOSURE?")
+        if (self.enclosureSerial.find ("QTL") == -1):
+            self.enclosureSerial = "QTL" + self.enclosureSerial
+        # fetch the enclosure position
+        self.PAMSerial = self.dut.sendCommand ("*SERIAL?")
+        if (self.PAMSerial.find ("QTL") == -1):
+            self.PAMSerial = "QTL" + self.PAMSerial
+        # Fixture Serial
+        # fixture serial is retrieved as BCD, we need to convert and pad it
+        self.FixtureSerial = "QTL" + bcdString(dut.sendCommand("read 0xA102"),4) + "-" + bcdString(dut.sendCommand("read 0xA103"),2) + "-" + bcdString(dut.sendCommand("read 0xA104"),3) # TODO: this should be replaced with fix:serial? command when implemented
+        # calObjectSerial Serial
+        self.calObjectSerial = self.PAMSerial
+        # Filename String
+        self.filenameString = self.PAMSerial
+        # Code version (FPGA)
+        self.idnStr = dut.sendCommand ("*IDN?")
+        pos = self.idnStr.upper().find ("FPGA 1:")
+        if (pos != -1):
+            versionStr = self.idnStr[pos+7:]
+            pos = versionStr.find ("\n")
+            if (pos != -1):
+                versionStr = versionStr[:pos].strip()
+            else:
+                pass
+        else:
+            versionStr = "NOT-FOUND"    
+        self.Fpga = versionStr.strip()
+    
+        # Code version (FW)    
+        pos = self.idnStr.upper().find ("PROCESSOR:")
+        if (pos != -1):
+            versionStr = self.idnStr[pos+10:]
+            pos = versionStr.find ("\n")
+            if (pos != -1):
+                versionStr = versionStr[:pos].strip()            
+            else:
+                pass
+        else:
+            versionStr = "NOT-FOUND"    
+        self.Firmware = versionStr.strip()
+
+        self.calibrations = {}
+        self.calibrations["L1"] = {
+            "Voltage" : self.QTL2582_Voltage_Calibration(self,"L1"),
+            "Current" : self.QTL2582_Current_Calibration(self,"L1")
+        }
+        self.calibrations["L2"] = {
+            "Voltage" : self.QTL2582_Voltage_Calibration(self,"L2"),
+            "Current" : self.QTL2582_Current_Calibration(self,"L2")
+        }
+        self.calibrations["L3"] = {
+            "Voltage" : self.QTL2582_Voltage_Calibration(self,"L3"),
+            "Current" : self.QTL2582_Current_Calibration(self,"L3")
+        }
+        self.calibrations["Neutral"] = {
+            "Current" : self.QTL2582_Current_Calibration(self,"Neutral")
+        }
+        
+        self.verifications = {}
+        self.verifications["L1"] = {
+            "Voltage" : self.QTL2582_Voltage_Verification(self,"L1"),
+            "Current" : self.QTL2582_Current_Verification(self,"L1")
+        }
+        self.verifications["L2"] = {
+            "Voltage" : self.QTL2582_Voltage_Verification(self,"L2"),
+            "Current" : self.QTL2582_Current_Verification(self,"L2")
+        }
+        self.verifications["L3"] = {
+            "Voltage" : self.QTL2582_Voltage_Verification(self,"L3"),
+            "Current" : self.QTL2582_Current_Verification(self,"L3")
+        }
+        self.verifications["Neutral"] = {
+            "Current" : self.QTL2582_Current_Verification(self,"Neutral")
+        }
     # general
     waitComplete = False
     checkedWiring = False
     currentPhase = None
 
     def specific_requirements(self):
 
         reportText=""
 
+        # select a DMM6500 to use for calibration
+        if "dmm6500" in calibrationResources.keys():
+            self.dmm = calibrationResources["dmm6500"]
+        else:
+            self.dmm = self.getDMM()
+        calibrationResources["dmm6500"] = self.dmm
+
+        # do a read, otherwise the first reading after connection seems to be wrong
+        self.dmm.measureACCurrent("10A") * 1000.0
+
         # select an AC Supply to use for calibration
         if "acSupply" in calibrationResources.keys():
             self.acSupply = calibrationResources["acSupply"]
         else:
             self.acSupply = self.getAcSupply()
         calibrationResources["acSupply"] = self.acSupply
 
@@ -218,14 +290,39 @@
         # perform uptime check and write to file
         if self.waitComplete != True:
             reportText += self.wait_for_up_time(desired_up_time=600, command="conf:runtime:fix:sec?")
             self.waitComplete = True
 
         return reportText
 
+    #todo: MIKE - move to Keithley_DMM6500_control.py?
+    def getDMM(self,alias=""):
+        #if alias is None or alias == "":
+        alias = "DMM6500"
+        # Find an AC Mux
+        while (True):
+            devices = KeithleyDMM6500.discover()
+            selectedDevice = quarchpy.user_interface.listSelection(title="Select an " + alias,message="Please select the correct " + alias,selectionList=devices,additionalOptions = [["rescan","rescan"],["quit","quit"]],nice=True)
+            if str(selectedDevice[1]).lower() == "rescan":
+                pass
+            elif str(selectedDevice[1]).lower() == "quit":
+                printText("User Quit Program")
+                sys.exit(0)
+            else:
+                try:
+                    dmm = KeithleyDMM6500(selectedDevice[2])
+                    break
+                except:
+                    printText("Unable to communicate with selected device!")
+                    printText("")
+                    raise
+
+        return dmm
+
+    #todo: MIKE - move to Keysite_AC6804B_control.py?
     def getAcSupply(self,alias=""):
         #if alias is None or alias == "":
         alias = "AC Supply"
         # Find an AC Mux
         while (True):
             devices = KeysightAC6804B.discover()
             selectedDevice = quarchpy.user_interface.listSelection(title="Select an " + alias,message="Please select the correct " + alias,selectionList=devices,additionalOptions = [["rescan","rescan"],["quit","quit"]],nice=True)
@@ -240,14 +337,15 @@
                     break
                 except:
                     printText("Unable to communicate with selected device!")
                     printText("")
                     raise
         return acSupply
 
+    #todo: MIKE - move to threePhaseSwitchBoxl.py?
     def getAcMux(self,alias=""):
         if alias is None or alias == "":
             alias = "AC Mux"
         # Find an AC Mux
         while (True):
             devices = ThreePhaseSwitchBox.discover()
             selectedDevice = user_interface.listSelection(title="Select an " + alias,message="Please select the correct " + alias,selectionList=devices,additionalOptions = [["rescan","rescan"],["quit","quit"]],nice=True)
@@ -263,14 +361,15 @@
                 except:
                     printText("Unable to communicate with selected device!")
                     printText("")
                     raise
         return acMux
 
 
+    #todo: MIKE - move to elpaSine.py?
     def getAcLoad(self,alias=""):
         if alias is None or alias == "":
             alias = "AC Load"
         # Find an AC Mux
         while (True):
             devices = ElpaSine.discover()
             deviceList = []
@@ -341,90 +440,79 @@
         self.dut.sendCommand("write 0xa200 0x0040")        
         # check busy
         while checkBit(self.dut.sendCommand("read 0xa200"),8):
             sleep(0.1)
 
     def close_module(self):
 
-        #close the connection to the calibration instrument
-        self.acLoad.closeConnection()
+        # try to close the qis connection
+        try:
+            self.powerModule.dut.sendCommand("close")
+        except:
+            pass
 
     def close_all(self):
 
         #close all attached devices
         self.acLoad.setLoadCurrent(0)
         self.acLoad.closeConnection()
         self.acSupplyMux.setMux("off")
         self.acLoadMux.setMux("off")
 
+        # try to close the qis connection
+        try:
+            self.powerModule.dut.sendCommand("close")
+        except:
+            pass
+
     class QTL2582_Calibration (AcPamCalibration):
 
         streamFilename = ''
         iteration = 0
         streamMeasureTime = 2.0
         scaling = 1
 
         def __init__(self):
             super().__init__()
         
         def init_cal(self):
 
+            #Turn on Supply
             self.powerModule.acSupply.setOutputEnable(False)
             self.powerModule.acSupply.setACSupplyRange("AUTO")
             self.powerModule.acSupply.setACSupplyFrequency(50)
-            self.powerModule.acSupply.setSupplyCurrentLimit(10)
+            self.powerModule.acSupply.setSupplyCurrentLimit(15)
+            self.powerModule.acSupply.setACSupplyVoltage(240)
             self.powerModule.acSupply.setOutputEnable(True)
 
         def meas_volt(self,phase):
 
-            return self.getMeasurement(phase, 'V', typ='RMS', streamTime=self.streamMeasureTime)
+            return self.getMeasurement(phase, 'V', typ='RMS')
 
         def meas_current(self,phase):
 
-            return self.getMeasurement(phase, 'I', typ='RMS', streamTime=self.streamMeasureTime)
+            return self.getMeasurement(phase, 'I', typ='RMS')
 
-        def streamData(self,streamMeasureTime=None):
-            if streamMeasureTime is not None:
-                self.streamMeasureTime = streamMeasureTime
+        def startStream(self,device,streamDuration):
+		
             # Sets for a manual record trigger, so we can start the stream from the script
             self.powerModule.dut.sendCommand("record:trigger:mode manual")
             self.powerModule.dut.sendCommand("record:averaging 0")
 
-            # In this example we write to a fixed path
             self.streamFilename = calibrationResources["calPath"] + "\\" + self.phase + '_' + '_' + self.units + '_' + str(self.iteration) + '.csv'
             self.iteration += 1
-            self.powerModule.dut.startStream(self.streamFilename, 2000, 'Example stream to file')
-
-            # Delay for a x seconds while the stream is running.  You can also continue
-            # to run your own commands/scripts here while the stream is recording in the background
-            time.sleep(1)
-
-            # Check the stream status, so we know if anything went wrong during the stream
-            streamStatus = self.powerModule.dut.streamRunningStatus()
-            if ("Stopped" in streamStatus):
-                if ("Overrun" in streamStatus):
-                    print('Stream interrupted due to internal device buffer has filled up')
-                elif ("User" in streamStatus):
-                    print('Stream interrupted due to max file size has being exceeded')
-                else:
-                    print("Stopped for unknown reason")
 
-            # Stop the stream.  This function is blocking and will wait until all remaining data has
-            # been downloaded from the module
-            self.powerModule.dut.stopStream()
-
-            # check to ensure stream is fully stopped before continuing script
-            stopStreamCount = 0
-            while not "stopped" in str(self.powerModule.dut.streamRunningStatus()).lower():
-                stopStreamCount += 1
-                if stopStreamCount > 20:
-                    raise TimeoutError("Failed to stop stream after {} seconds".format(stopStreamCount))
-                time.sleep(1)
+            self.powerModule.dut.startStream(self.streamFilename, 2000, 'Example stream to file', streamDuration)
 
         def readRawValues(self):
+		            
+            # Wait for stream to complete
+            while ("Running" in self.powerModule.dut.streamRunningStatus()):
+                time.sleep(0.1)
+		            
             rawValues = {}
             with open(self.streamFilename, 'r') as fh:
                 csvfile = csv.reader(fh)
                 titles = None
                 for row in csvfile:
                     if not titles:
                         titles = row
@@ -434,22 +522,43 @@
                         for i in range(len(row)):
                             try:
                                 rawValues[titles[i]].append(int(row[i]))
                             except ValueError:
                                 rawValues[titles[i]].append(0)
             return rawValues
 
-        def calcRmsValues(self,samples=800):
+        '''
+        movingAverage(self,values,average)
+
+        values = a dictionary of channels each containing a list of samples
+        average = the number of samples to average with a moving window
+        returns a dictionary of channels each containing a list of samples
+        '''
+        def movingAverage(self,values,average):
+            filteredValues = {}
+            for channel in values.keys():
+                filteredValues[channel] = []
+                for x in range(0,len(values[channel])-(average-1)):
+                    filteredValues[channel].append(sum(values[channel][x:x+average])/average)
+            return filteredValues
+
+        # we calculate rms on every measurement here then return the lot
+        # in calibration we only tend to care about one measurement and should probably replace this with something more specific
+
+        def calcRmsValues(self,average=1):
             rawValues = self.readRawValues()
+            filteredValues = self.movingAverage(rawValues,average)
             rmsValues = {}
-            for k in rawValues.keys():
-                if len(rawValues[k]) >= samples:
-                    items = [float(x**2) for x in rawValues[k][:samples]]
+            for k in filteredValues.keys():
+                items = [float(x**2) for x in rawValues[k]]
+                if len(items) > 0:
                     meanSquares = sum(items) / float(len(items))
-                    rmsValues[k] = meanSquares**0.5
+                else:
+                    meanSquares = 0
+                rmsValues[k] = meanSquares**0.5
             self.lastMeasurement = rmsValues
             return rmsValues
 
         def findPeakValues(self):
             maxvalues = []
             prevValues = []
             peakList = []
@@ -492,28 +601,43 @@
 
                 # Throw away first and last samples, as they may have been clipped
                 peakVector = np.array(peakList[i][1:-1])
                 avgPeak[titles[i]] = peakVector.mean()
 
             return avgPeak
 
-        def getMeasurement(self, phase, parm, typ='PEAK', streamTime=1.0):
-            self.streamData(streamTime)
+        def getMeasurement(self, phase, parm, typ='PEAK', average=1):
             if typ == 'PEAK':
                 vals = self.findPeakValues()
             else:
-                vals = self.calcRmsValues()
+                vals = self.calcRmsValues(average=average)
 
             if parm == 'V':
                 key = "{0:s} mV".format(phase)
             else:
                 key = "{0:s} mA".format(phase)
 
             if key in vals:
+		                
+		        ##TODO: Mike Debug but might be useful if we want to add another package
+		        ##plot value in question
+		        #data = self.readRawValues()[key]
+		        #x = range(0,len(data),1)
+		        #y = self.readRawValues()[key]
+		
+		        #plt.clf()           # clear figure
+		        #plt.title(key)      # set title
+		        #plt.ion()           #interactive on, so it doesnt block
+		        #plt.plot(x, y)      # add the data
+		        #plt.draw()          # draw the data
+		        #plt.pause(0.001)    # allow the GUI to update
+		        #plt.show()          # show the window
+		
                 return vals[key]
+		
             else:
                 raise ValueError("requested measurement not found in data")
         
         def finish_cal(self):
 
             #turn off supply
             self.powerModule.acSupply.setOutputEnable(False)
@@ -585,15 +709,15 @@
 
             report.append("==================================================================================================")
             report.append('\n')
 
             if action == "calibrate":
                 report.append("Calculated Multiplier: " + str(self.multiplier.originalValue()) + ", Calculated Offset: " + str(self.offset.originalValue()))
                 report.append("Stored Multiplier: " + str(self.multiplier.storedValue()) + ", Stored Offset: " + str(self.offset.storedValue()))
-                report.append("Multiplier Register: " + self.multiplier.hexString(4) + ", Offset Register: " + self.offset.hexString(4))
+                report.append("Multiplier Register: " + self.multiplier.hexString(6) + ", Offset Register: " + self.offset.hexString(4))
 
             report.append("" + '{0:<35}'.format(self.title)+ '     '  +'{0:>10}'.format("Passed : ")+ '  '  + '{0:<5}'.format(str(overallResult))+ '     ' + '{0:>11}'.format( "worst case:")+ '  '  +'{0:>11}'.format(worstCase))
             report.append("\n\n\n")
             
             #Add to Test Summary? Do this here?
             passfail = lambda x: "Passed" if x else "Failed"
 
@@ -625,50 +749,56 @@
             super().init_cal()
 
             # clear the multiplier and offset registers by setting them to zero
             caddr = self.powerModule.getCoeffAddr(self.phase, "V")
             self.powerModule.dut.sendAndVerifyCommand("write 0x{0:04x} 0x0000".format(caddr[0]))
             self.powerModule.dut.sendAndVerifyCommand("write 0x{0:04x} 0x0000".format(caddr[1]))
 
+            #Turn on Supply
+            self.powerModule.acSupply.setACSupplyVoltage(240)
+            self.powerModule.acSupply.setOutputEnable(True)
+
             #set switches
             self.powerModule.acSupplyMux.setMux(self.phase)
             self.powerModule.acLoadMux.setMux(self.phase)
             
             #Enable load
             self.powerModule.acLoad.setLoadCurrent(0)
             self.powerModule.acLoad.setOutputEnable(True)
 
             # Check Host Power is present
 #            while (super().checkLoadVoltage(500,500) != True):
 #                input("Unexpected voltage detected at load, please check connections")
 
         def setRef(self,value):
+            self.reference = value
             self.powerModule.acSupply.setACSupplyVoltage(value/1000)
-            sleep(1) # Add settling time
+            sleep(3) # Add settling time
 
         def readRef(self):
+            self.startStream(self.powerModule.dut,0.2)
             return self.powerModule.acLoad.getVoltageMeasurement('RMS') * 1000.0
 
         def readVal(self):
             # Return measurement, normalize all values to Volts and Amps
-            return self.getMeasurement(self.phase, 'V', typ='RMS', streamTime=self.streamMeasureTime)
+            return self.getMeasurement(self.phase, 'V', typ='RMS', average=1)
 
         def setCoefficients(self):
 
             # Get Coefficient Addresses
             addrLow, addrHigh = self.powerModule.getCoeffAddr(self.phase, 'V')
 
             hexString = self.multiplier.hexString(8)
             result1 = self.powerModule.dut.sendAndVerifyCommand("write 0x{0:04x} ".format(addrHigh) + hexString[:6]) 
             result2 = self.powerModule.dut.sendAndVerifyCommand("write 0x{0:04x} ".format(addrLow) + hexString[:2] + hexString[6:])
             if result1 and result2:
                 result = True
             else:
                 result = False
-            logSimpleResult("Set L1 Current Coefficients", result)
+            logSimpleResult("Set " + self.phase + " Voltage Coefficients", result)
 
             # load calibration values to ADE
             self.powerModule.dut.sendCommand("write 0x1800 0x0000")
             self.powerModule.dut.sendCommand("write 0x1800 0x0002")
 
         def finish(self):
 
@@ -681,18 +811,18 @@
     class QTL2582_Current_Calibration (QTL2582_Calibration):
 
         def __init__(self,powerModule,phase):
 
             self.title = phase + " Current Calibration"
             self.phase = phase
             self.powerModule = powerModule
-            self.absErrorLimit = 0                  # 0mA
-            self.relErrorLimit = 1                  # 1%
-            self.test_min = 200                     # 0.2A
-            self.test_max = 5000                    # 5A
+            self.absErrorLimit = 20                 # 20mA
+            self.relErrorLimit = 0.5                # 0.5%
+            self.test_min = 100                     # 100mA
+            self.test_max = 10000                   # 10A
             self.test_steps = 8
             self.units = "mA"
             self.scaling = 1
             self.multiplier_signed = False
             self.multiplier_int_width = 1
             self.multiplier_frac_width = 23
             self.offset_signed = True
@@ -720,19 +850,20 @@
             if value < 0 or value > 10000:
                 raise ValueError("ERROR - ELPA max RMS current must be less than 10A")
             self.powerModule.acLoad.setLoadCurrent(value / 1000.0)
             self.powerModule.acLoad.setOutputEnable(True)
             sleep(1) # Add settling time
 
         def readRef(self):
-            return self.powerModule.acLoad.getCurrentMeasurement('RMS') * 1000.0
+            self.startStream(self.powerModule.dut,3.3)
+            return self.powerModule.dmm.measureACCurrent("10A",readings = 10) * 1000.0
 
         def readVal(self):
             # Return measurement, normalize all values to Volts and Amps
-            return self.getMeasurement(self.phase, 'I', typ='RMS', streamTime=self.streamMeasureTime)
+            return self.getMeasurement(self.phase, 'I', typ='RMS', average=16)
 
         def setCoefficients(self):
 
             # Get Coefficient Addresses
             addrLow, addrHigh = self.powerModule.getCoeffAddr(self.phase, 'I')
 
             hexString = self.multiplier.hexString(8)
@@ -752,97 +883,14 @@
 
             super().finish_cal()
 
         def report(self,data):
 
             return super().report("calibrate",data)
 
-    # Neutral Calibration is the same as L1 Current Calibration, but we measure and calibrate the neutral current instead of L1
-    class QTL2582_Neutral_Current_Calibration (QTL2582_Calibration):
-
-        def __init__(self,powerModule,phase):
-
-            self.title = "Neutral Calibration"
-            self.phase = "Neutral"
-            self.powerModule = powerModule
-            self.absErrorLimit = 0                  # 0mA
-            self.relErrorLimit = 1                  # 1%
-            self.test_min = 200                     # 0.2A
-            self.test_max = 5000                    # 5A
-            self.test_steps = 8
-            self.units = "mA"
-            self.scaling = 1
-            self.multiplier_signed = False
-            self.multiplier_int_width = 1
-            self.multiplier_frac_width = 23
-            self.offset_signed = True
-            self.offset_int_width = 10
-            self.offset_frac_width = 6
-
-        def init(self):
-
-            super().init_cal()
-
-            # clear the multiplier and offset registers by setting them to zero
-            caddr = self.powerModule.getCoeffAddr(self.phase, "I")
-            self.powerModule.dut.sendAndVerifyCommand("write 0x{0:04x} 0x0000".format(caddr[0]))
-            self.powerModule.dut.sendAndVerifyCommand("write 0x{0:04x} 0x0000".format(caddr[1]))
-
-            #turn on AC Supply
-            self.powerModule.acSupply.setACSupplyVoltage(240)
-            self.powerModule.acSupply.setOutputEnable(True)
-
-            #set switches
-            self.powerModule.acSupplyMux.setMux("L1")
-            self.powerModule.acLoadMux.setMux("L1")
-            
-            # Check Host Power is present
-#            while (super().checkLoadVoltage(500,500) != True):
-#                input("Unexpected voltage detected at load, please check connections")
-
-        def setRef(self,value):
-            if value < 0 or value > 10000:
-                raise ValueError("ERROR - ELPA max RMS current must be less than 10A")
-            self.powerModule.acLoad.setLoadCurrent(value / 1000.0)
-            self.powerModule.acLoad.setOutputEnable(True)
-            sleep(1) # Add settling time
-
-        def readRef(self):
-            return self.powerModule.acLoad.getCurrentMeasurement('RMS') * 1000.0
-
-        def readVal(self):
-            # Return measurement, normalize all values to Volts and Amps
-            return self.getMeasurement(self.phase, 'I', typ='RMS', streamTime=self.streamMeasureTime)
-
-        def setCoefficients(self):
-
-            # Get Coefficient Addresses
-            addrLow, addrHigh = self.powerModule.getCoeffAddr(self.phase, 'I')
-
-            hexString = self.multiplier.hexString(8)
-            result1 = self.powerModule.dut.sendAndVerifyCommand("write 0x{0:04x} ".format(addrHigh) + hexString[:6]) 
-            result2 = self.powerModule.dut.sendAndVerifyCommand("write 0x{0:04x} ".format(addrLow) + hexString[:2] + hexString[6:])
-            if result1 and result2:
-                result = True
-            else:
-                result = False
-            logSimpleResult("Set Neutral Current Coefficients", result)
-
-            # load calibration values to ADE
-            self.powerModule.dut.sendCommand("write 0x1800 0x0000")
-            self.powerModule.dut.sendCommand("write 0x1800 0x0002")
-
-        def finish(self):
-
-            super().finish_cal()
-
-        def report(self,data):
-
-            return super().report("calibrate",data)
-
     class QTL2582_Voltage_Verification (QTL2582_Calibration):
 
         def __init__(self,powerModule,phase):
 
             self.title = phase + " Voltage Verification"
             self.phase = phase
             self.powerModule = powerModule
@@ -857,30 +905,29 @@
 
             super().init_cal()
 
             #set switches
             self.powerModule.acSupplyMux.setMux(self.phase)
             self.powerModule.acLoadMux.setMux(self.phase)
 
-            #time.sleep(1) # attempt to sort error in first reading from elpaSine
-            
             # Check Host Power is present
 #            while (super().checkLoadVoltage(500,500) != True):
 #                input("Unexpected voltage detected at load, please check connections")
 
         def setRef(self,value):
             self.powerModule.acSupply.setACSupplyVoltage(value/1000)
             sleep(1) # Add settling time
 
         def readRef(self):
+            self.startStream(self.powerModule.dut,0.2)
             return self.powerModule.acLoad.getVoltageMeasurement('RMS') * 1000.0
 
         def readVal(self):
             # Return measurement, normalize all values to Volts and Amps
-            return self.getMeasurement(self.phase, 'V', typ='RMS', streamTime=self.streamMeasureTime)
+            return self.getMeasurement(self.phase, 'V', typ='RMS', average=1)
 
         def finish(self):
 
             super().finish_cal()
 
         def report(self,data):
 
@@ -889,18 +936,18 @@
     class QTL2582_Current_Verification (QTL2582_Calibration):
 
         def __init__(self,powerModule,phase):
 
             self.title = phase + " Current Verification"
             self.phase = phase
             self.powerModule = powerModule
-            self.absErrorLimit = 0                  # 0mA
-            self.relErrorLimit = 1                  # 1%
-            self.test_min = 200                     # 0.2A
-            self.test_max = 5000                    # 5A
+            self.absErrorLimit = 20                 # 20mA
+            self.relErrorLimit = 0.5                # 0.5%
+            self.test_min = 100                     # 100mA
+            self.test_max = 10000                   # 10A
             self.test_steps = 8
             self.units = "mA"
 
         def init(self):
 
             super().init_cal()
 
@@ -916,165 +963,21 @@
             if value < 0 or value > 10000:
                 raise ValueError("ERROR - ELPA max RMS current must be less than 10A")
             self.powerModule.acLoad.setLoadCurrent(value / 1000.0)
             self.powerModule.acLoad.setOutputEnable(True)
             time.sleep(1) # add settling time
 
         def readRef(self):
-            return self.powerModule.acLoad.getCurrentMeasurement('RMS') * 1000.0
-
-        def readVal(self):
-            # Return measurement, normalize all values to Volts and Amps
-            return self.getMeasurement(self.phase, 'I', typ='RMS', streamTime=self.streamMeasureTime)
-
-        def finish(self):
-
-            super().finish_cal()
-
-        def report(self,data):
-
-            return super().report("verify",data)
-
-    # Neutral Verification is the same as L1 Current Verification, but we measure the neutral current instead of L1
-    class QTL2582_Neutral_Current_Verification (QTL2582_Calibration):
-
-        def __init__(self,powerModule,phase):
-
-            self.title = "Neutral Verification"
-            self.phase = "Neutral"
-            self.powerModule = powerModule
-            self.absErrorLimit = 0                  # 0mA
-            self.relErrorLimit = 1                  # 1%
-            self.test_min = 200                     # 0.2A
-            self.test_max = 5000                    # 5A
-            self.test_steps = 8
-            self.units = "mA"
-
-        def init(self):
-
-            super().init_cal()
-
-            #set switches
-            self.powerModule.acSupplyMux.setMux("L1")
-            self.powerModule.acLoadMux.setMux("L1")
-            
-            # Check Host Power is present
-#            while (super().checkLoadVoltage(500,500) != True):
-#                input("Unexpected voltage detected at load, please check connections")
-
-        def setRef(self,value):
-            if value < 0 or value > 10000:
-                raise ValueError("ERROR - ELPA max RMS current must be less than 10A")
-            self.powerModule.acLoad.setLoadCurrent(value / 1000.0)
-            self.powerModule.acLoad.setOutputEnable(True)
-            sleep(1) # Add settling time
-
-        def readRef(self):
-            return self.powerModule.acLoad.getCurrentMeasurement('RMS') * 1000.0
+            self.startStream(self.powerModule.dut,3.3)
+            return self.powerModule.dmm.measureACCurrent("10A",10) * 1000.0
 
         def readVal(self):
             # Return measurement, normalize all values to Volts and Amps
-            return self.getMeasurement(self.phase, 'I', typ='RMS', streamTime=self.streamMeasureTime)
+            return self.getMeasurement(self.phase, 'I', typ='RMS', average=1)
 
         def finish(self):
 
             super().finish_cal()
 
         def report(self,data):
 
-            return super().report("verify",data)
-
-    def __init__(self,dut):
-
-        # We need to use QIS to get RMS etc
-        # close the quarchpy connection
-        dut.closeConnection()
-        # and open a QIS connection
-        isQisRunning()
-        version = get_QIS_version()
-        if not ((version[0] == 1 and version[1] >= 27) or version[0] > 1):
-            raise ValueError("ERROR - Detected QIS {0[0]}.{0[1]}, Requires QIS version 1.27 or greater".format(version))
-
-        dut = quarchDevice(dut.ConString, ConType='QIS')
-        dut = quarchPPM(dut)    #mike hack
-
-        sleep(1)
-
-        # set the name of this module
-        self.name = "3 Phase AC PAM"
-        self.dut = dut
-
-        # Serial numbers (ensure QTL at start)
-        self.enclosureSerial = self.dut.sendCommand("*ENCLOSURE?")
-        if (self.enclosureSerial.find ("QTL") == -1):
-            self.enclosureSerial = "QTL" + self.enclosureSerial
-        # fetch the enclosure position
-        self.PAMSerial = self.dut.sendCommand ("*SERIAL?")
-        if (self.PAMSerial.find ("QTL") == -1):
-            self.PAMSerial = "QTL" + self.PAMSerial
-        # Fixture Serial
-        # fixture serial is retrieved as BCD, we need to convert and pad it
-        self.FixtureSerial = "QTL" + bcdString(dut.sendCommand("read 0xA102"),4) + "-" + bcdString(dut.sendCommand("read 0xA103"),2) + "-" + bcdString(dut.sendCommand("read 0xA104"),3) # TODO: this should be replaced with fix:serial? command when implemented
-        # calObjectSerial Serial
-        self.calObjectSerial = self.PAMSerial
-        # Filename String
-        self.filenameString = self.PAMSerial
-        # Code version (FPGA)
-        self.idnStr = dut.sendCommand ("*IDN?")
-        pos = self.idnStr.upper().find ("FPGA 1:")
-        if (pos != -1):
-            versionStr = self.idnStr[pos+7:]
-            pos = versionStr.find ("\n")
-            if (pos != -1):
-                versionStr = versionStr[:pos].strip()
-            else:
-                pass
-        else:
-            versionStr = "NOT-FOUND"    
-        self.Fpga = versionStr.strip()
-    
-        # Code version (FW)    
-        pos = self.idnStr.upper().find ("PROCESSOR:")
-        if (pos != -1):
-            versionStr = self.idnStr[pos+10:]
-            pos = versionStr.find ("\n")
-            if (pos != -1):
-                versionStr = versionStr[:pos].strip()            
-            else:
-                pass
-        else:
-            versionStr = "NOT-FOUND"    
-        self.Firmware = versionStr.strip()
-
-        self.calibrations = {}
-        self.calibrations["L1"] = {
-            "Voltage" : self.QTL2582_Voltage_Calibration(self,"L1"),
-            "Current" : self.QTL2582_Current_Calibration(self,"L1")
-        }
-        self.calibrations["L2"] = {
-            "Voltage" : self.QTL2582_Voltage_Calibration(self,"L2"),
-            "Current" : self.QTL2582_Current_Calibration(self,"L2")
-        }
-        self.calibrations["L3"] = {
-            "Voltage" : self.QTL2582_Voltage_Calibration(self,"L3"),
-            "Current" : self.QTL2582_Current_Calibration(self,"L3")
-        }
-        self.calibrations["Neutral"] = {
-            "Current" : self.QTL2582_Neutral_Current_Calibration(self,"Neutral")
-        }
-
-        self.verifications = {}
-        self.verifications["L1"] = {
-            "Voltage" : self.QTL2582_Voltage_Verification(self,"L1"),
-            "Current" : self.QTL2582_Current_Verification(self,"L1")
-        }
-        self.verifications["L2"] = {
-            "Voltage" : self.QTL2582_Voltage_Verification(self,"L2"),
-            "Current" : self.QTL2582_Current_Verification(self,"L2")
-        }
-        self.verifications["L3"] = {
-            "Voltage" : self.QTL2582_Voltage_Verification(self,"L3"),
-            "Current" : self.QTL2582_Current_Verification(self,"L3")
-        }
-        self.verifications["Neutral"] = {
-            "Current" : self.QTL2582_Neutral_Current_Verification(self,"Neutral")
-        }
+            return super().report("verify",data)
```

## Comparing `quarchCalibration/QTL2621.py` & `quarchCalibration/QTL2843_iec_ac.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,394 +1,659 @@
 '''
 Quarch Power Module Calibration Functions
 Written for Python 3.6 64 bit
 
 M Dearman April 2019
+Edited k McRobert September 2021
 '''
+from quarchCalibration.Keithley_DMM6500_control import KeithleyDMM6500
+import quarchpy.user_interface
 
 '''
 Calibration Flow
-    Connect to PPM
-    Connect to Keithley
-    step through a set of values and get ADC vs Reference Value
-    evaluate results vs defined limits
+    Connect to AC PAM Fixture 
+    Connect to ELPA-SINE
+    Connect to AC Power Supply
+    Connect to Switch Boxes
+    step through each AC phase
+      - Read peak voltage value and set voltage multiplier
+      - Step through current values and set current multiplier
+      - Save neutral current readings
+    Calibrate/verify neutral
 
 '''
 
 #Imports QuarchPy library, providing the functions needed to use Quarch modules
+#from quarchpy import quarchDevice #, scanDevices
+
+# Import other libraries used in the examples
+
 from .PowerModuleCalibration import *
 from .calibrationConfig import *
-from .keithley_2460_control import *
+from .elpaSine import *
 from quarchpy.device.device import *
-from quarchpy.device.scanDevices import userSelectDevice
 from quarchpy.user_interface import *
-from quarchpy.user_interface import logSimpleResult
 from quarchpy.utilities.BitManipulation import *
-# Unused Imports...
-#from quarchpy import quarchDevice #, scanDevices
-# from calibrationConfig import *
-# from quarchCalibration.keithley_2460_control import *
-# from PowerModuleCalibration import *
-# # Import other libraries used in the examples
-# from functools import reduce
-# #from quarchpy.calibration import *
-# import quarchpy
-# from quarchpy.calibration.deviceHelpers import returnMeasurement
-# import quarchpy.calibration.calibrationConfig
-# import types
-# from time import sleep,time
-# from math import ceil
-# from quarchpy.calibration.PowerModuleCalibration import *
-#
-# import threading
-# from quarchpy.calibration.calibrationConfig import*
-# from quarchpy.user_interface import *
-# from quarchpy.user_interface import logSimpleResult,storeResult
-# from quarchpy.device.device import *
-# from quarchpy.device.scanDevices import userSelectDevice
-# import datetime
-# from quarchpy.calibration.keithley_2460_control import *
-# from quarchpy.utilities.BitManipulation import *
-
-
-
-
-def parseFixtureData(response,start,length):
-
-    # split the multiline response into a list
-    response = response.splitlines()
-    result = ""
-    # for each line
-    for line in response:
-        # remove 0x, swap bytes
-        line = line[4:6] + line[2:4]
-        # convert 4 char Hex to 16 bit binary string
-        line = "{0:016b}".format(int(line,16))
-        # concatenate all the strings
-        result += line
-    # pick out the section we want
-    result = int(result[start:(start+length)],2)
-    # convert two's compliment
-    if (result >= 2**(length-1)):
-        result -= 2**length
-    return result
-
-
-def getFixtureData(device,channel):
-    #hold measurement
-    response = device.sendCommand("read 0x0000")
-    device.sendCommand("write 0x0000 " + setBit(response,3))
-    #read measurement
-    data = device.sendCommand("read 0x1000 to 0x1007")
-    #release measurement
-    response = device.sendCommand("read 0x0000")
-    device.sendCommand("write 0x0000 " + clearBit(response,3))
-
-    if (channel == "POWER_1 V"):
-        return parseFixtureData(data,0,16)
-    elif (channel == "POWER_1 A"):
-        return parseFixtureData(data,16,25)
-    elif (channel == "POWER_2 V"):
-        return parseFixtureData(data,41,16)
-    elif (channel == "POWER_2 A"):
-        return parseFixtureData(data,57,25)
-
-def bcdString(bcd,padding):
-    # strip off "0x" if present
-    if bcd[:2] == "0x":
-        bcd = bcd [2:]
-    # strip off leading 0's
-    # loop while we have more the required minimum number of characters left
-    while(len(bcd)>padding):
-        # if the leading character is 0, remove it
-        if bcd[0] == '0':
-            bcd = bcd[1:]
-        # else exit loop
-        else:
-            break
-    return bcd
-
-
-class QTL2621 (PowerModule):
+from quarchpy.device import quarchPPM, quarchDevice
+from quarchpy.qis import isQisRunning, startLocalQis
+from quarchpy.connection_specific.connection_QIS import QisInterface as qisInterface
+import csv
+from collections import OrderedDict
+from .threePhaseSwitchBox import ThreePhaseSwitchBox
+from quarchCalibration import Keysight_AC6804B_control
+from quarchCalibration.Keysight_AC6804B_control import KeysightAC6804B
+from .pamHelpers import bcdString
+#from .acHelpers import *
+#import matplotlib.pyplot as plt --debug only
+
+#todo: MIKE - terrible name and strange location
+def get_QIS_version():
+	#TODO option var "close_qis_afer_check" to determine if qis is left open or not.
+    global my_close_qis
+    """
+    Returns the version of QIS.  This is the version of QIS currenty running on the local system if one exists.
+    Otherwise the local version within quarchpy will be exectued and its version returned.
+
+    Returns
+    -------
+    version: str
+        String representation of the QIS version number
+
+    """
+
+    qis_version = ""
+    if isQisRunning() == False:
+        my_close_qis = True
+        startLocalQis(headless=True)
+
+    myQis = qisInterface()
+    qis_version = myQis.sendAndReceiveCmd(cmd="$version")
+    if "No Target Device Specified" in qis_version:
+        qis_version = myQis.sendAndReceiveCmd(cmd="$help").split("\r\n")[0]
+    vmatch = re.search("v([0-9]).([0-9]+)", qis_version)
+    if vmatch:
+        return [int(x) for x in vmatch.groups()]
+
+class QTL2843 (PowerModule):
+    phaseList = ['L1', 'L2', 'L3', 'Neutral']
+    calTypeList = ['I', 'V', 'V2']
 
     # Fixture Register Addresses
     CALIBRATION_MODE_ADDR               = '0xA100'
-    CALIBRATION_CONTROL_ADDR            = '0xA101'      
-    POWER_1_VOLT_MULTIPLIER_ADDR        = '0xA105'
-    POWER_1_VOLT_OFFSET_ADDR            = '0xA106'
-    POWER_1_LOW_MULTIPLIER_ADDR         = '0xA111'
-    POWER_1_LOW_OFFSET_ADDR             = '0xA112'
-    POWER_1_LEAKAGE_MULTIPLIER_ADDR     = '0xA109'
-    POWER_2_VOLT_MULTIPLIER_ADDR        = '0xA10A'
-    POWER_2_VOLT_OFFSET_ADDR            = '0xA10B'
-    POWER_2_LOW_MULTIPLIER_ADDR         = '0xA116'
-    POWER_2_LOW_OFFSET_ADDR             = '0xA117'
-    POWER_2_LEAKAGE_MULTIPLIER_ADDR     = '0xA10E'
-    POWER_1_HIGH_MULTIPLIER_ADDR        = '0xA107'
-    POWER_1_HIGH_OFFSET_ADDR            = '0xA108'
-    POWER_2_HIGH_MULTIPLIER_ADDR        = '0xA10C'
-    POWER_2_HIGH_OFFSET_ADDR            = '0xA10D'
-    CALIBRATION_COMPLETE_ADDR	        = '0xA118'
-    LOAD_VOLTAGE                        = 12000
-
-    # Noise Test Vars
-    # Dict of channels and limits
-    has_noise_test = True
-    channel_dict_max_limits = {"current POWER_1 Max": "400uA", "current POWER_2 Max": "400uA"}
-    channel_dict_min_limits = {}
-    test_length = 10  # The time measurements are taken over, aka the distandce between the two annotations.
-    averaging_value = "4"  # 4=16us
+    CALIBRATION_CONTROL_ADDR            = '0xA101'
+
+    SERIAL_NUMBER_START_ADDR            = '0xA102'
+
+    AIGAIN_LOW_ADDR                     = '0xA105'
+    AIGAIN_HIGH_ADDR                    = '0xA106'
+    AVGAIN_LOW_ADDR                     = '0xA107'
+    AVGAIN_HIGH_ADDR                    = '0xA108'
+    AV2GAIN_LOW_ADDR                    = '0xA109'
+    AV2GAIN_HIGH_ADDR                   = '0xA10A'
+
+    BIGAIN_LOW_ADDR                     = '0xA10B'
+    BIGAIN_HIGH_ADDR                    = '0xA10C'
+    BVGAIN_LOW_ADDR                     = '0xA10D'
+    BVGAIN_HIGH_ADDR                    = '0xA10E'
+    BV2GAIN_LOW_ADDR                    = '0xA10F'
+    BV2GAIN_HIGH_ADDR                   = '0xA110'
+
+    CIGAIN_LOW_ADDR                     = '0xA111'
+    CIGAIN_HIGH_ADDR                    = '0xA112'
+    CVGAIN_LOW_ADDR                     = '0xA113'
+    CVGAIN_HIGH_ADDR                    = '0xA114'
+    CV2GAIN_LOW_ADDR                    = '0xA115'
+    CV2GAIN_HIGH_ADDR                   = '0xA116'
+
+    NIGAIN_LOW_ADDR                     = '0xA117'
+    NIGAIN_HIGH_ADDR                    = '0xA118'
+    NVGAIN_LOW_ADDR                     = '0xA119'
+    NVGAIN_HIGH_ADDR                    = '0xA11A'
+    NV2GAIN_LOW_ADDR                    = '0xA11B'
+    NV2GAIN_HIGH_ADDR                   = '0xA11C'
+
+    CALIBRATION_COMPLETE_ADDR	        = '0xA11D'
+    LOAD_VOLTAGE                        = 240000
 
     # Fixture Information
     PAMSerial = None
     FixtureSerial = None
     calObjectSerial = None     # The serial number of the device that is being calibrated, i.e QTL1944 in HD PPM, Fixture in PAM
     idnStr = None
     Firmware = None
     Fpga = None
     calInstrument = None
     calInstrumentId = None
     switchbox = None
-    waitComplete = False
-    checkedWiring = False
 
     # Physical Connection Tracking (what is plugged to what)
     loadChannel = None
     hostPowerChannel = None
-    hostPort = "A"
-    hostConnectionPortDict = {"POWER_1": "1", "POWER_2": "2"}
-    loadPort = "B"
-    loadConnectionPortDict = {"POWER_1": "4", "POWER_2": "5"}
+
+    def __init__(self,dut):
+
+        # We need to use QIS to get RMS etc
+        # close the quarchpy connection
+        dut.closeConnection()
+        # and open a QIS connection
+        isQisRunning()
+        version = get_QIS_version()
+        if not ((version[0] == 1 and version[1] >= 27) or version[0] > 1):
+            raise ValueError("ERROR - Detected QIS {0[0]}.{0[1]}, Requires QIS version 1.27 or greater".format(version))
+
+        dut = quarchDevice(dut.ConString, ConType='QIS')
+        dut = quarchPPM(dut)    #mike hack
+
+        sleep(1)
+
+        # set the name of this module
+        self.name = "IEC Mains PAM"
+        self.dut = dut
+
+        # Serial numbers (ensure QTL at start)
+        self.enclosureSerial = self.dut.sendCommand("*ENCLOSURE?")
+        if (self.enclosureSerial.find ("QTL") == -1):
+            self.enclosureSerial = "QTL" + self.enclosureSerial
+        # fetch the enclosure position
+        self.PAMSerial = self.dut.sendCommand ("*SERIAL?")
+        if (self.PAMSerial.find ("QTL") == -1):
+            self.PAMSerial = "QTL" + self.PAMSerial
+        # Fixture Serial
+        # fixture serial is retrieved as BCD, we need to convert and pad it
+        self.FixtureSerial = "QTL" + bcdString(dut.sendCommand("read 0xA102"),4) + "-" + bcdString(dut.sendCommand("read 0xA103"),2) + "-" + bcdString(dut.sendCommand("read 0xA104"),3) # TODO: this should be replaced with fix:serial? command when implemented
+        # calObjectSerial Serial
+        self.calObjectSerial = self.PAMSerial
+        # Filename String
+        self.filenameString = self.PAMSerial
+        # Code version (FPGA)
+        self.idnStr = dut.sendCommand ("*IDN?")
+        pos = self.idnStr.upper().find ("FPGA 1:")
+        if (pos != -1):
+            versionStr = self.idnStr[pos+7:]
+            pos = versionStr.find ("\n")
+            if (pos != -1):
+                versionStr = versionStr[:pos].strip()
+            else:
+                pass
+        else:
+            versionStr = "NOT-FOUND"    
+        self.Fpga = versionStr.strip()
+    
+        # Code version (FW)    
+        pos = self.idnStr.upper().find ("PROCESSOR:")
+        if (pos != -1):
+            versionStr = self.idnStr[pos+10:]
+            pos = versionStr.find ("\n")
+            if (pos != -1):
+                versionStr = versionStr[:pos].strip()            
+            else:
+                pass
+        else:
+            versionStr = "NOT-FOUND"    
+        self.Firmware = versionStr.strip()
+
+        self.calibrations = {}
+        self.calibrations["L1"] = {
+            "Voltage" : self.QTL2843_Voltage_Calibration(self,"L1"),
+            "Current" : self.QTL2843_Current_Calibration(self,"L1")
+        }
+        self.calibrations["L2"] = {
+            "Voltage" : self.QTL2843_Voltage_Calibration(self,"L2"),
+            "Current" : self.QTL2843_Current_Calibration(self,"L2")
+        }
+        self.calibrations["L3"] = {
+            "Voltage" : self.QTL2843_Voltage_Calibration(self,"L3"),
+            "Current" : self.QTL2843_Current_Calibration(self,"L3")
+        }
+        self.calibrations["Neutral"] = {
+            "Current" : self.QTL2843_Current_Calibration(self,"Neutral")
+        }
+        
+        self.verifications = {}
+        self.verifications["L1"] = {
+            "Voltage" : self.QTL2843_Voltage_Verification(self,"L1"),
+            "Current" : self.QTL2843_Current_Verification(self,"L1")
+        }
+        self.verifications["L2"] = {
+            "Voltage" : self.QTL2843_Voltage_Verification(self,"L2"),
+            "Current" : self.QTL2843_Current_Verification(self,"L2")
+        }
+        self.verifications["L3"] = {
+            "Voltage" : self.QTL2843_Voltage_Verification(self,"L3"),
+            "Current" : self.QTL2843_Current_Verification(self,"L3")
+        }
+        self.verifications["Neutral"] = {
+            "Current" : self.QTL2843_Current_Verification(self,"Neutral")
+        }
+
+    # general
+    waitComplete = False
+    checkedWiring = False
+    currentPhase = None
 
     def specific_requirements(self):
 
         reportText=""
 
-        # select a switchbox to use for calibration
-        if "switchbox" in calibrationResources.keys():
-            self.switchbox = calibrationResources["switchbox"]
-        self.switchbox = self.getSwitchbox()
-        calibrationResources["switchbox"] = self.switchbox
-        if self.checkedWiring != True:
-            self.checkWiring()
-            self.checkedWiring = True
+        # select a DMM6500 to use for calibration
+        if "dmm6500" in calibrationResources.keys():
+            self.dmm = calibrationResources["dmm6500"]
+        else:
+            self.dmm = self.getDMM()
+        calibrationResources["dmm6500"] = self.dmm
+
+        # do a read, otherwise the first reading after connection seems to be wrong
+        self.dmm.measureACCurrent("10A") * 1000.0
 
-        # Select a Keithley SMU
-        # If no calibration instrument is provided, request it
-        while (True):
-            if (calibrationResources["loadString"] == None):
-                loadString = userSelectCalInstrument(scanFilterStr="Keithley 2460", nice=True)
-                # quit if necessary
-                if loadString == 'quit':
-                    printText("no module selected, exiting...")
-                    sys.exit(0)
-                else:
-                    calibrationResources["loadString"] = loadString
-            try:
-                # Connect to the calibration instrument
-                self.calInstrument = keithley2460(calibrationResources["loadString"])
-                # Open the connection
-                self.calInstrument.openConnection()
-                self.calInstrumentId = self.calInstrument.sendCommandQuery ("*IDN?")
-                break
-            # In fail, allow the user to try again with a new selection
-            except:
-                printText("Unable to communicate with selected instrument!")
-                printText("")
-                calibrationResources["loadString"] = None
+        # select an AC Supply to use for calibration
+        if "acSupply" in calibrationResources.keys():
+            self.acSupply = calibrationResources["acSupply"]
+        else:
+            self.acSupply = self.getAcSupply()
+        calibrationResources["acSupply"] = self.acSupply
+
+        # select an AC Supply Mux to use for calibration
+        if "acSupplyMux" in calibrationResources.keys():
+            self.acSupplyMux = calibrationResources["acSupplyMux"]
+        else:
+            self.acSupplyMux = self.getAcMux("AC Supply Mux")
+        calibrationResources["acSupplyMux"] = self.acSupplyMux
+
+        # select an AC Load Mux to use for calibration
+        if "acLoadMux" in calibrationResources.keys():
+            self.acLoadMux = calibrationResources["acLoadMux"]
+        else:
+            self.acLoadMux = self.getAcMux("AC Load Mux")
+        calibrationResources["acLoadMux"] = self.acLoadMux
+
+        # select an AC Load to use for calibration
+        if "elpasine" in calibrationResources.keys():
+            self.acLoad = calibrationResources["elpasine"]
+        else:
+            self.acLoad = self.getAcLoad()
+        calibrationResources["elpasine"] = self.acLoad
+
+        # Check connectivity to the ELPA-SINE
+        elpaIdentity = self.acLoad.sendCommandQuery("*IDN?")
+        if elpaIdentity.find("ELPA-SINE") == -1:
+            printText("Unable to communicate with ELPA-SINE")
+            raise Exception("Unable to communicate with ELPA-SINE")
+        self.calInstrumentId = elpaIdentity
 
         # Write module specific report header to file
-        reportText += "Quarch Power Analysis Module: "
+        reportText += "Quarch AC Power Analysis Module: "
         reportText += self.PAMSerial + "\n"
-        reportText += "Quarch Fixture: "
-        reportText += self.FixtureSerial + "\n"
         reportText += "Quarch FW Versions: "
         reportText += "FW:" + self.Firmware + ", FPGA: " + self.Fpga + "\n"
         reportText += "\n"
         reportText += "Calibration Instruments#:\n"
         reportText += self.calInstrumentId + "\n"
 
         # perform uptime check and write to file
         if self.waitComplete != True:
-            reportText += self.wait_for_up_time(desired_up_time=600)
+            reportText += self.wait_for_up_time(desired_up_time=600, command="conf:runtime:fix:sec?")
             self.waitComplete = True
 
         return reportText
 
-    def setConnections(self,loadConnection,hostPowerConnection,reset=False):
-    #TODO Fix for using class variable.
-        if reset:
-            self.loadChannel = None
-            self.hostPowerChannel = None
-
-        # If current connections are correct
-        if self.loadChannel == loadConnection and self.hostPowerChannel == hostPowerConnection:
-            # do nothing
-            pass
-
-        # else connections need to change
-        else:
-
-            # we can't turn an individual port off (at the moment) so we turn both off first, then set anything that needs setting
-            if loadConnection == None or hostPowerConnection == None:
-                self.switchbox.sendAndVerifyCommand("connect off")
-
-            if loadConnection != None:
-                self.switchbox.sendAndVerifyCommand("connect " + self.loadPort + " " + self.loadConnectionPortDict[loadConnection])
+    #todo: MIKE - move to Keithley_DMM6500_control.py?
+    def getDMM(self,alias=""):
+        #if alias is None or alias == "":
+        alias = "DMM6500"
+        # Find an AC Mux
+        while (True):
+            devices = KeithleyDMM6500.discover()
+            selectedDevice = quarchpy.user_interface.listSelection(title="Select an " + alias,message="Please select the correct " + alias,selectionList=devices,additionalOptions = [["rescan","rescan"],["quit","quit"]],nice=True)
+            if str(selectedDevice[1]).lower() == "rescan":
+                pass
+            elif str(selectedDevice[1]).lower() == "quit":
+                printText("User Quit Program")
+                sys.exit(0)
+            else:
+                try:
+                    dmm = KeithleyDMM6500(selectedDevice[2])
+                    break
+                except:
+                    printText("Unable to communicate with selected device!")
+                    printText("")
+                    raise
 
-            if hostPowerConnection != None:
-                self.switchbox.sendAndVerifyCommand("connect " + self.hostPort + " " + self.hostConnectionPortDict[hostPowerConnection])
+        return dmm
 
-        self.loadChannel = loadConnection
-        self.hostPowerChannel = hostPowerConnection
+    #todo: MIKE - move to Keysite_AC6804B_control.py?
+    def getAcSupply(self,alias=""):
+        #if alias is None or alias == "":
+        alias = "AC Supply"
+        # Find an AC Mux
+        while (True):
+            devices = KeysightAC6804B.discover()
+            selectedDevice = quarchpy.user_interface.listSelection(title="Select an " + alias,message="Please select the correct " + alias,selectionList=devices,additionalOptions = [["rescan","rescan"],["quit","quit"]],nice=True)
+            if str(selectedDevice[1]).lower() == "rescan":
+                pass
+            elif str(selectedDevice[1]).lower() == "quit":
+                printText("User Quit Program")
+                sys.exit(0)
+            else:
+                try:
+                    acSupply = KeysightAC6804B(selectedDevice[2])
+                    break
+                except:
+                    printText("Unable to communicate with selected device!")
+                    printText("")
+                    raise
+        return acSupply
 
-    def open_module(self):
+    #todo: MIKE - move to threePhaseSwitchBoxl.py?
+    def getAcMux(self,alias=""):
+        if alias is None or alias == "":
+            alias = "AC Mux"
+        # Find an AC Mux
+        while (True):
+            devices = ThreePhaseSwitchBox.discover()
+            selectedDevice = user_interface.listSelection(title="Select an " + alias,message="Please select the correct " + alias,selectionList=devices,additionalOptions = [["rescan","rescan"],["quit","quit"]],nice=True)
+            if str(selectedDevice[1]).lower() == "rescan":
+                pass
+            elif str(selectedDevice[1]).lower() == "quit":
+                printText("User Quit Program")
+                sys.exit(0)
+            else:
+                try:
+                    acMux = ThreePhaseSwitchBox(alias,selectedDevice[2])
+                    break
+                except:
+                    printText("Unable to communicate with selected device!")
+                    printText("")
+                    raise
+        return acMux
 
-        # set unit into calibration mode
-        self.dut.sendCommand("write " + QTL2621.CALIBRATION_MODE_ADDR + " 0xaa55")
-        self.dut.sendCommand("write " + QTL2621.CALIBRATION_MODE_ADDR + " 0x55aa")
 
-    def getSwitchbox(self):
-        # CheckSwitchbox
-        if self.switchbox is None:
-            while (True):
-                switchboxAddress = userSelectDevice(scanFilterStr=["QTL2536"], message="Select a calibration 6 Way Test Lead Switch.", nice=True)
-                if switchboxAddress == "quit":
-                    printText("User Quit Program")
-                    sys.exit(0)
+    #todo: MIKE - move to elpaSine.py?
+    def getAcLoad(self,alias=""):
+        if alias is None or alias == "":
+            alias = "AC Load"
+        # Find an AC Mux
+        while (True):
+            devices = ElpaSine.discover()
+            deviceList = []
+            for device in devices:
+                deviceList.append(device["ip"])
+            selectedDevice = user_interface.listSelection(title="Select an " + alias,message="Please select the correct " + alias,selectionList=deviceList,additionalOptions = [["rescan"],["quit"]],nice=True)
+            if str(selectedDevice).lower() == "rescan":
+                pass
+            elif str(selectedDevice).lower() == "quit":
+                printText("User Quit Program")
+                sys.exit(0)
+            else:
                 try:
-                    self.switchbox = quarchDevice(switchboxAddress)
+                    acLoad = ElpaSine(selectedDevice)
                     break
                 except:
                     printText("Unable to communicate with selected device!")
                     printText("")
-                    switchboxAddress = None
                     raise
-        return self.switchbox
+        return acLoad
+
+    def getCoeffAddr(self, phase, calType):
+        if phase not in self.phaseList:
+            raise ValueError("Unknown phase " + phase)
+        elif calType not in self.calTypeList:
+            raise ValueError("Unknown calibration type " + calType)
+        else:
+            pnumber = self.phaseList.index(phase) * 3 + self.calTypeList.index(calType)
+            addrLow = 0xA105 + pnumber * 2
+            addrHigh = addrLow + 1
+        return (addrLow, addrHigh)
 
     def clear_calibration(self):
 
         # set unit into calibration mode
-        self.dut.sendCommand("write " + QTL2621.CALIBRATION_MODE_ADDR + " 0xaa55")
-        self.dut.sendCommand("write " + QTL2621.CALIBRATION_MODE_ADDR + " 0x55aa")
+        self.dut.sendCommand("write " + QTL2843.CALIBRATION_MODE_ADDR + " 0xaa55")
+        self.dut.sendCommand("write " + QTL2843.CALIBRATION_MODE_ADDR + " 0x55aa")
 
         # clear all calibration registers
-        self.dut.sendAndVerifyCommand("write " + QTL2621.POWER_1_VOLT_OFFSET_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2621.POWER_1_VOLT_MULTIPLIER_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2621.POWER_1_LOW_OFFSET_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2621.POWER_1_LOW_MULTIPLIER_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2621.POWER_1_HIGH_OFFSET_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2621.POWER_1_HIGH_MULTIPLIER_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2621.POWER_1_LEAKAGE_MULTIPLIER_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2621.POWER_2_VOLT_OFFSET_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2621.POWER_2_VOLT_MULTIPLIER_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2621.POWER_2_LOW_OFFSET_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2621.POWER_2_LOW_MULTIPLIER_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2621.POWER_2_HIGH_OFFSET_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2621.POWER_2_HIGH_MULTIPLIER_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2621.POWER_2_LEAKAGE_MULTIPLIER_ADDR + " 0x0000")
-        
+        for phase in self.phaseList:
+            for t in ["V", "I", "V2"]:
+                caddr = self.getCoeffAddr(phase, t)
+                self.dut.sendAndVerifyCommand("write 0x{0:04x} 0x0000".format(caddr[0]))
+                self.dut.sendAndVerifyCommand("write 0x{0:04x} 0x0000".format(caddr[1]))
+
+        # Load calibration values into the ADE7978
+        self.dut.sendCommand("write 0x1800 0x0000")
+        self.dut.sendCommand("write 0x1800 0x0002")
+
+        #self.loadToAde()
+
         # write 0xaa55 to register to calibration complete register to tell module it is calibrated
-        self.dut.sendAndVerifyCommand("write " + QTL2621.CALIBRATION_COMPLETE_ADDR + " 0xaa55")
+        self.dut.sendAndVerifyCommand("write " + QTL2843.CALIBRATION_COMPLETE_ADDR + " 0xaa55")
         
     def write_calibration(self):
 
         # write the calibration registers
         # erase the tag memory
         printText("Erasing TAG memory..")
         self.dut.sendCommand("write 0xa200 0x0020")
         # TODO: should check for completion here...
         # wait for 2 seconds for erase to complete
         # check busy
         while checkBit(self.dut.sendCommand("read 0xa200"),8):
-            time.sleep(0.1)
+            sleep(0.1)
         # write the tag memory
         printText("Programming TAG memory...")
         self.dut.sendCommand("write 0xa200 0x0040")        
         # check busy
         while checkBit(self.dut.sendCommand("read 0xa200"),8):
-            time.sleep(0.1)
+            sleep(0.1)
 
     def close_module(self):
 
-        # reset the fixture FPGA
-        self.dut.sendCommand("fixture:reset")
-
-        #close the connection to the calibration instrument
-        self.calInstrument.closeConnection()
+        # try to close the qis connection
+        try:
+            self.powerModule.dut.sendCommand("close")
+        except:
+            pass
 
     def close_all(self):
 
         #close all attached devices
-        self.calInstrument.setLoadCurrent(0)
-        self.calInstrument.closeConnection()
-        self.switchbox.sendCommand("connect off")
+        self.acLoad.setLoadCurrent(0)
+        self.acLoad.closeConnection()
+        self.acSupplyMux.setMux("off")
+        self.acLoadMux.setMux("off")
+
+        # try to close the qis connection
+        try:
+            self.powerModule.dut.sendCommand("close")
+        except:
+            pass
+
+    class QTL2843_Calibration (AcPamCalibration):
 
-    class QTL2621Calibration (Calibration):
+        streamFilename = ''
+        iteration = 0
+        streamMeasureTime = 2.0
+        scaling = 1
 
         def __init__(self):
             super().__init__()
+        
+        def init_cal(self):
 
-        def init_cal(self,voltage):
-
-            # TODO: No Power control at the moment
-            # power up
-            #self.powerModule.dut.sendAndVerifyCommand("power up")
-
-            # set averaging to max
-            self.powerModule.dut.sendAndVerifyCommand("rec:ave 32k")
-
-            # set module into calibration mode (again?)
-            self.powerModule.dut.sendCommand("write " + QTL2621.CALIBRATION_MODE_ADDR + " 0xaa55")   # will not verify
-            self.powerModule.dut.sendCommand("write " + QTL2621.CALIBRATION_MODE_ADDR + " 0x55aa")   # will not verify
-
-            #Reset Keithley
-            self.powerModule.calInstrument.reset()
-
-        def meas_POWER_1_volt(self):
-
-            result = getFixtureData(self.powerModule.dut,"POWER_1 V")
-            return result
-
-        def meas_POWER_1_cur(self):
-
-            result = getFixtureData(self.powerModule.dut,"POWER_1 A")
-            return result
-
-        def meas_POWER_2_volt(self):
-
-            result = getFixtureData(self.powerModule.dut,"POWER_2 V")
-            return result
-
-        def meas_POWER_2_cur(self):
-
-            result = getFixtureData(self.powerModule.dut,"POWER_2 A")
-            return result
-
-        # check connections to host power and load
-        def checkLoadVoltage(self,voltage,tolerance):
+            #Turn on Supply
+            self.powerModule.acSupply.setOutputEnable(False)
+            self.powerModule.acSupply.setACSupplyRange("AUTO")
+            self.powerModule.acSupply.setACSupplyFrequency(50)
+            self.powerModule.acSupply.setSupplyCurrentLimit(15)
+            self.powerModule.acSupply.setACSupplyVoltage(240)
+            self.powerModule.acSupply.setOutputEnable(True)
+
+        def meas_volt(self,phase):
+
+            return self.getMeasurement(phase, 'V', typ='RMS')
+
+        def meas_current(self,phase):
+
+            return self.getMeasurement(phase, 'I', typ='RMS')
+
+        def startStream(self,device,streamDuration):
+		
+            # Sets for a manual record trigger, so we can start the stream from the script
+            self.powerModule.dut.sendCommand("record:trigger:mode manual")
+            self.powerModule.dut.sendCommand("record:averaging 0")
+
+            self.streamFilename = calibrationResources["calPath"] + "\\" + self.phase + '_' + '_' + self.units + '_' + str(self.iteration) + '.csv'
+            self.iteration += 1
+
+            self.powerModule.dut.startStream(self.streamFilename, 2000, 'Example stream to file', streamDuration)
+
+        def readRawValues(self):
+		            
+            # Wait for stream to complete
+            while ("Running" in self.powerModule.dut.streamRunningStatus()):
+                time.sleep(0.1)
+		            
+            rawValues = {}
+            with open(self.streamFilename, 'r') as fh:
+                csvfile = csv.reader(fh)
+                titles = None
+                for row in csvfile:
+                    if not titles:
+                        titles = row
+                        for i in range(len(row)):
+                            rawValues[titles[i]] = []
+                    else:
+                        for i in range(len(row)):
+                            try:
+                                rawValues[titles[i]].append(int(row[i]))
+                            except ValueError:
+                                rawValues[titles[i]].append(0)
+            return rawValues
+
+        '''
+        movingAverage(self,values,average)
+
+        values = a dictionary of channels each containing a list of samples
+        average = the number of samples to average with a moving window
+        returns a dictionary of channels each containing a list of samples
+        '''
+        def movingAverage(self,values,average):
+            filteredValues = {}
+            for channel in values.keys():
+                filteredValues[channel] = []
+                for x in range(0,len(values[channel])-(average-1)):
+                    filteredValues[channel].append(sum(values[channel][x:x+average])/average)
+            return filteredValues
+
+        # we calculate rms on every measurement here then return the lot
+        # in calibration we only tend to care about one measurement and should probably replace this with something more specific
+
+        def calcRmsValues(self,average=1):
+            rawValues = self.readRawValues()
+            filteredValues = self.movingAverage(rawValues,average)
+            rmsValues = {}
+            for k in filteredValues.keys():
+                items = [float(x**2) for x in rawValues[k]]
+                if len(items) > 0:
+                    meanSquares = sum(items) / float(len(items))
+                else:
+                    meanSquares = 0
+                rmsValues[k] = meanSquares**0.5
+            self.lastMeasurement = rmsValues
+            return rmsValues
+
+        def findPeakValues(self):
+            maxvalues = []
+            prevValues = []
+            peakList = []
+            rising = []
+            with open(self.streamFilename, 'r') as fh:
+                csvfile = csv.reader(fh)
+                titles = None
+                for row in csvfile:
+                    if not titles:
+                        titles = row
+                        for i in range(len(row)):
+                            maxvalues.append(0)
+                            prevValues.append(0)
+                            peakList.append([])
+                            rising.append(False)
+                    else:
+                        for i in range(len(row)):
+                            value = int(row[i])
+                            if value >= maxvalues[i]:
+                                maxvalues[i] = value
+
+                            # If we are in the positive have of the wave, look for the point just when values begin to fall
+                            if value > 0:
+                                if value > prevValues[i]:
+                                    rising[i] = True
+                                    prevValues[i] = value
+                                else:
+                                    if rising[i]:
+                                        peakList[i].append(prevValues[i])
+                                        rising[i] = False
+                            else:
+                                # On the negative half of the wave, reset the values for the next pass
+                                rising[i] = False
+                                prevValues[i] = 0
+
+            mvdict = {}
+            avgPeak = {}
+            for i in range(len(titles)):
+                mvdict[titles[i]] = maxvalues[i]
+
+                # Throw away first and last samples, as they may have been clipped
+                peakVector = np.array(peakList[i][1:-1])
+                avgPeak[titles[i]] = peakVector.mean()
+
+            return avgPeak
+
+        def getMeasurement(self, phase, parm, typ='PEAK', average=1):
+            if typ == 'PEAK':
+                vals = self.findPeakValues()
+            else:
+                vals = self.calcRmsValues(average=average)
 
-            self.powerModule.calInstrument.setReferenceCurrent(0)
-            result = self.powerModule.calInstrument.measureLoadVoltage()*1000    # *1000 because we use mV but keithley uses volts
-            # check result is in required range
-            if (result >= voltage-tolerance) and (result <= voltage+tolerance):
-                return True
+            if parm == 'V':
+                key = "{0:s} mV".format(phase)
             else:
-                return False
+                key = "{0:s} mA".format(phase)
 
+            if key in vals:
+		                
+		        ##TODO: Mike Debug but might be useful if we want to add another package
+		        ##plot value in question
+		        #data = self.readRawValues()[key]
+		        #x = range(0,len(data),1)
+		        #y = self.readRawValues()[key]
+		
+		        #plt.clf()           # clear figure
+		        #plt.title(key)      # set title
+		        #plt.ion()           #interactive on, so it doesnt block
+		        #plt.plot(x, y)      # add the data
+		        #plt.draw()          # draw the data
+		        #plt.pause(0.001)    # allow the GUI to update
+		        #plt.show()          # show the window
+		
+                return vals[key]
+		
+            else:
+                raise ValueError("requested measurement not found in data")
+        
         def finish_cal(self):
 
-            #turn off load
-            self.powerModule.calInstrument.disable()
+            #turn off supply
+            self.powerModule.acSupply.setOutputEnable(False)
 
-            #turn off switch
-            self.powerModule.switchbox.sendCommand("connect off")
+            #turn off switches
+            self.powerModule.acSupplyMux.setMux("off")
+            self.powerModule.acLoadMux.setMux("off")
 
-            # turn dut to autoranging
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.CALIBRATION_CONTROL_ADDR + " 0x00F0")
+            #turn off load
+            self.powerModule.acLoad.setLoadCurrent(0)
+            #self.powerModule.acLoad.setOutputEnable(False)
 
         def report(self,action,data):
 
             report = []
 
             # send to report file
             report.append("          Pass Level  +/-(" + str(self.absErrorLimit) + str(self.units) +" + " + str(self.relErrorLimit) + "%) \n")
@@ -445,863 +710,275 @@
 
             report.append("==================================================================================================")
             report.append('\n')
 
             if action == "calibrate":
                 report.append("Calculated Multiplier: " + str(self.multiplier.originalValue()) + ", Calculated Offset: " + str(self.offset.originalValue()))
                 report.append("Stored Multiplier: " + str(self.multiplier.storedValue()) + ", Stored Offset: " + str(self.offset.storedValue()))
-                report.append("Multiplier Register: " + self.multiplier.hexString(4) + ", Offset Register: " + self.offset.hexString(4))
+                report.append("Multiplier Register: " + self.multiplier.hexString(6) + ", Offset Register: " + self.offset.hexString(4))
 
             report.append("" + '{0:<35}'.format(self.title)+ '     '  +'{0:>10}'.format("Passed : ")+ '  '  + '{0:<5}'.format(str(overallResult))+ '     ' + '{0:>11}'.format( "worst case:")+ '  '  +'{0:>11}'.format(worstCase))
             report.append("\n\n\n")
             
             #Add to Test Summary? Do this here?
             passfail = lambda x: "Passed" if x else "Failed"
 
             return {"title":self.title,"result":overallResult,"worst case":worstCase,"report":('\n'.join(report))}
 
-    class QTL2621_POWER_1_VoltageCalibration (QTL2621Calibration):
+    class QTL2843_Voltage_Calibration (QTL2843_Calibration):
 
-        def __init__(self,powerModule):
+        def __init__(self,powerModule,phase):
 
-            self.title = "POWER_1 Voltage Calibration"
+            self.title = phase + " Voltage Calibration"
+            self.phase = phase
             self.powerModule = powerModule
-            self.absErrorLimit = 2                  # 2mV
-            self.relErrorLimit = 1                  # 1%
-            self.test_min = 40                      # 40mV
-            self.test_max = 14400                   # 14.4V
-            self.test_steps = 20
+            self.absErrorLimit = 0                  # 0mV
+            self.relErrorLimit = 0.5                # 0.5%
+            self.test_min = 50000                   # 50V
+            self.test_max = 270000                  # 270V
+            self.test_steps = 8
             self.units = "mV"
-            self.scaling = 4
+            self.scaling = 1
             self.multiplier_signed = False
             self.multiplier_int_width = 1
-            self.multiplier_frac_width = 16
+            self.multiplier_frac_width = 23
             self.offset_signed = True
             self.offset_int_width = 10
             self.offset_frac_width = 6
 
         def init(self):
 
-            super().init_cal("POWER_1")
+            super().init_cal()
 
             # clear the multiplier and offset registers by setting them to zero
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.POWER_1_VOLT_MULTIPLIER_ADDR + " 0x0000")
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.POWER_1_VOLT_OFFSET_ADDR + " 0x0000")
-
-            self.powerModule.setConnections("POWER_1",None)
-
-            # Check Host Power is present
-            #while (super().checkLoadVoltage(500,500) != True):
-            #    self.powerModule.setConnections("POWER_1",None,reset=True)
-
-        def setRef(self,value):
-
-            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
-
-        def readRef(self):
-
-            return self.powerModule.calInstrument.measureLoadVoltage()*1000
-
-        def readVal(self):
-
-            return super().meas_POWER_1_volt()
-
-        def setCoefficients(self):
-
-            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.POWER_1_VOLT_MULTIPLIER_ADDR + " " + self.multiplier.hexString(4))
-            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.POWER_1_VOLT_OFFSET_ADDR + " " + self.offset.hexString(4))
-            if result1 and result2:
-                result = True
-            else:
-                result = False
-            logSimpleResult("Set POWER_1 voltage", result)
-
-        def finish(self):
-
-            super().finish_cal()
-
-        def report(self,data):
-
-            return super().report("calibrate",data)
-
-        def readCoefficients(self):
-
-            coefficients = {}
-            # get POWER_1 voltage multiplier
-            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + QTL2621.POWER_1_VOLT_MULTIPLIER_ADDR)
-            # get POWER_1 voltage offset
-            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + QTL2621.POWER_1_VOLT_OFFSET_ADDR)
-            return coefficients
-
-        def writeCoefficients(self,coefficients):
-
-            # write POWER_1 voltage multiplier
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.POWER_1_VOLT_MULTIPLIER_ADDR + " " + coefficients["multiplier"])
-            # write POWER_1 voltage offset
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.POWER_1_VOLT_OFFSET_ADDR + " " + coefficients["offset"])
-
-    class QTL2621_POWER_1_LowCurrentCalibration (QTL2621Calibration):
-
-        def __init__(self,powerModule):
-
-            self.title = "POWER_1 Low Current Calibration"
-            self.powerModule = powerModule
-            self.absErrorLimit = 15                 # 15uA
-            self.relErrorLimit = 1                  # 1%
-            self.test_min = 10                      # 10uA
-            self.test_max = 85000                   # 85mA
-            self.test_steps = 20
-            self.units = "uA"
-            self.scaling = 32
-            self.multiplier_signed = False
-            self.multiplier_int_width = 1
-            self.multiplier_frac_width = 16
-            self.offset_signed = True
-            self.offset_int_width = 10
-            self.offset_frac_width = 6
-
-        def init(self):
-
-            super().init_cal("POWER_1")
-
-            #set manual range, full averaging, POWER_1 low current mode, POWER_2 all off (so we can detect we're connected to the wrong channel
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.CALIBRATION_CONTROL_ADDR + " 0x00F1")
-            # clear the multiplier and offset registers by setting them to zero
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.POWER_1_LOW_MULTIPLIER_ADDR + " 0x0000")
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.POWER_1_LOW_OFFSET_ADDR + " 0x0000")
-
-            self.powerModule.setConnections("POWER_1","POWER_1")
+            caddr = self.powerModule.getCoeffAddr(self.phase, "V")
+            self.powerModule.dut.sendAndVerifyCommand("write 0x{0:04x} 0x0000".format(caddr[0]))
+            self.powerModule.dut.sendAndVerifyCommand("write 0x{0:04x} 0x0000".format(caddr[1]))
+
+            #Turn on Supply
+            self.powerModule.acSupply.setACSupplyVoltage(240)
+            self.powerModule.acSupply.setOutputEnable(True)
+
+            #set switches
+            self.powerModule.acSupplyMux.setMux("L1")
+            self.powerModule.acLoadMux.setMux(self.phase)
+            
+            #Enable load
+            self.powerModule.acLoad.setLoadCurrent(0)
+            self.powerModule.acLoad.setOutputEnable(True)
 
             # Check Host Power is present
-            while (super().checkLoadVoltage(QTL2621.LOAD_VOLTAGE,1000) != True):
-                self.powerModule.setConnections("POWER_1","POWER_1",reset=True)
+#            while (super().checkLoadVoltage(500,500) != True):
+#                input("Unexpected voltage detected at load, please check connections")
 
         def setRef(self,value):
-
-            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
+            self.reference = value
+            self.powerModule.acSupply.setACSupplyVoltage(value/1000)
+            sleep(3) # Add settling time
 
         def readRef(self):
-
-            # read device voltage and add leakage current to the reference
-            voltage =  super().meas_POWER_1_volt()
-            #leakage = voltage*self.powerModule.calibrations["POWER_1"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["POWER_1"]["Leakage"].offset.originalValue()
-            return self.powerModule.calInstrument.measureLoadCurrent()*1000000# + leakage
+            self.startStream(self.powerModule.dut,0.2)
+            return self.powerModule.acLoad.getVoltageMeasurement('RMS') * 1000.0
 
         def readVal(self):
-
-            return super().meas_POWER_1_cur()
+            # Return measurement, normalize all values to Volts and Amps
+            return self.getMeasurement(self.phase, 'V', typ='RMS', average=1)
 
         def setCoefficients(self):
 
-            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.POWER_1_LOW_MULTIPLIER_ADDR + " " + self.multiplier.hexString(4))
-            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.POWER_1_LOW_OFFSET_ADDR + " " + self.offset.hexString(4))
-            if result1 and result2:
-                result = True
-            else:
-                result = False
-            logSimpleResult("Set POWER_1 low current", result)
-        def finish(self):
-
-            super().finish_cal()
-
-        def report(self,data):
-
-            return super().report("calibrate",data)
-
-        def readCoefficients(self):
+            # Get Coefficient Addresses
+            addrLow, addrHigh = self.powerModule.getCoeffAddr(self.phase, 'V')
 
-            coefficients = {}
-            # get POWER_1 low current multiplier
-            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + QTL2621.POWER_1_LOW_MULTIPLIER_ADDR)
-            # get POWER_1 low current offset
-            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + QTL2621.POWER_1_LOW_OFFSET_ADDR)
-            return coefficients
-
-        def writeCoefficients(self,coefficients):
-
-            # write POWER_1 low current multiplier
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.POWER_1_LOW_MULTIPLIER_ADDR + " " + coefficients["multiplier"])
-            # write POWER_1 low current offset
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.POWER_1_LOW_OFFSET_ADDR + " " + coefficients["offset"])
-
-    class QTL2621_POWER_1_HighCurrentCalibration (QTL2621Calibration):
-
-        def __init__(self,powerModule):
-
-            self.title = "POWER_1 High Current Calibration"
-            self.powerModule = powerModule
-            self.absErrorLimit = 2000               # 2mA
-            self.relErrorLimit = 1                  # 1%
-            self.test_min = 1000                    # 1mA
-            self.test_max = 4000000                 # 4A
-            self.test_steps = 20
-            self.units = "uA"
-            self.scaling = 2048
-            self.multiplier_signed = False
-            self.multiplier_int_width = 1
-            self.multiplier_frac_width = 16
-            self.offset_signed = True
-            self.offset_int_width = 10
-            self.offset_frac_width = 6
-
-        def init(self):
-
-            super().init_cal("POWER_1")
-
-            #set manual range, full averaging, POWER_1 high current mode, POWER_2 all off (so we can detect we're connected to the wrong channel
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.CALIBRATION_CONTROL_ADDR + " 0x00F2")
-            # clear the multiplier and offset registers by setting them to zero
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.POWER_1_HIGH_MULTIPLIER_ADDR + " 0x0000")
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.POWER_1_HIGH_OFFSET_ADDR + " 0x0000")
-
-            self.powerModule.setConnections("POWER_1","POWER_1")
-
-            # Check Host Power is present
-            while (super().checkLoadVoltage(QTL2621.LOAD_VOLTAGE,1000) != True):
-                self.powerModule.setConnections("POWER_1","POWER_1",reset=True)
-
-        def setRef(self,value):
-
-            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
-
-        def readRef(self):
-
-            # read device voltage and add leakage current to the reference
-            voltage =  super().meas_POWER_1_volt()
-            #leakage = voltage*self.powerModule.calibrations["POWER_1"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["POWER_1"]["Leakage"].offset.originalValue()
-            return self.powerModule.calInstrument.measureLoadCurrent()*1000000# + leakage
-
-        def readVal(self):
-
-            return super().meas_POWER_1_cur()
-
-        def setCoefficients(self):
-
-            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.POWER_1_HIGH_MULTIPLIER_ADDR + " " + self.multiplier.hexString(4))
-            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.POWER_1_HIGH_OFFSET_ADDR + " " + self.offset.hexString(4))
+            hexString = self.multiplier.hexString(8)
+            result1 = self.powerModule.dut.sendAndVerifyCommand("write 0x{0:04x} ".format(addrHigh) + hexString[:6]) 
+            result2 = self.powerModule.dut.sendAndVerifyCommand("write 0x{0:04x} ".format(addrLow) + hexString[:2] + hexString[6:])
             if result1 and result2:
                 result = True
             else:
                 result = False
-            logSimpleResult("Set POWER_1 high current", result)
-
-            # once we've completed low and high current we can set leakage on the fixture
-            #result = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.POWER_1_LEAKAGE_MULTIPLIER_ADDR + " " + self.powerModule.calibrations["POWER_1"]["Leakage"].multiplier.hexString(4))
-
-        def finish(self):
-
-            super().finish_cal()
-
-        def report(self,data):
-
-            return super().report("calibrate",data)
-
-        def readCoefficients(self):
-
-            coefficients = {}
-            # get POWER_1 high current multiplier
-            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + QTL2621.POWER_1_HIGH_MULTIPLIER_ADDR)
-            # get POWER_1 high current offset
-            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + QTL2621.POWER_1_HIGH_OFFSET_ADDR)
-            return coefficients
-
-        def writeCoefficients(self,coefficients):
-
-            # write POWER_1 high current multiplier
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.POWER_1_HIGH_MULTIPLIER_ADDR + " " + coefficients["multiplier"])
-            # write POWER_1 high current offset
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.POWER_1_HIGH_OFFSET_ADDR + " " + coefficients["offset"])
-
-    class QTL2621_POWER_2_VoltageCalibration (QTL2621Calibration):
-
-        def __init__(self,powerModule):
-
-            self.title = "POWER_2 Voltage Calibration"
-            self.powerModule = powerModule
-            self.absErrorLimit = 2                  # 2mV
-            self.relErrorLimit = 1                  # 1%
-            self.test_min = 40                      # 40mV
-            self.test_max = 14400                   # 14.4V
-            self.test_steps = 20
-            self.units = "mV"
-            self.scaling = 4
-            self.multiplier_signed = False
-            self.multiplier_int_width = 1
-            self.multiplier_frac_width = 16
-            self.offset_signed = True
-            self.offset_int_width = 10
-            self.offset_frac_width = 6
-
-        def init(self):
-
-            super().init_cal("POWER_2")
-
-            # set module into calibration mode (again?)
-            self.powerModule.dut.sendCommand("write " + QTL2621.CALIBRATION_MODE_ADDR + " 0xaa55")   # will not verify
-            self.powerModule.dut.sendCommand("write " + QTL2621.CALIBRATION_MODE_ADDR + " 0x55aa")   # will not verify
-            # clear the multiplier and offset registers by setting them to zero
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.POWER_2_VOLT_MULTIPLIER_ADDR + " 0x0000")
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.POWER_2_VOLT_OFFSET_ADDR + " 0x0000")
-
-            self.powerModule.setConnections("POWER_2",None)
-            
-            # Check Host Power is not present
-            #while (super().checkLoadVoltage(500,500) != True):
-            #    self.powerModule.setConnections("POWER_2",None,reset=True)
-
-        def setRef(self,value):
+            logSimpleResult("Set " + self.phase + " Voltage Coefficients", result)
 
-            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
-
-        def readRef(self):
-
-            return self.powerModule.calInstrument.measureLoadVoltage()*1000
-
-        def readVal(self):
-
-            return super().meas_POWER_2_volt()
-
-        def setCoefficients(self):
-
-            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.POWER_2_VOLT_MULTIPLIER_ADDR + " " + self.multiplier.hexString(4))
-            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.POWER_2_VOLT_OFFSET_ADDR + " " + self.offset.hexString(4))
-            if result1 and result2:
-                result = True
-            else:
-                result = False
-            logSimpleResult("Set POWER_2 voltage", result)
+            # load calibration values to ADE
+            self.powerModule.dut.sendCommand("write 0x1800 0x0000")
+            self.powerModule.dut.sendCommand("write 0x1800 0x0002")
 
         def finish(self):
 
             super().finish_cal()
 
         def report(self,data):
 
             return super().report("calibrate",data)
 
-        def readCoefficients(self):
-
-            coefficients = {}
-            # get POWER_2 voltage multiplier
-            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + QTL2621.POWER_2_VOLT_MULTIPLIER_ADDR)
-            # get POWER_2 voltage offset
-            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + QTL2621.POWER_2_VOLT_OFFSET_ADDR)
-            return coefficients
-
-        def writeCoefficients(self,coefficients):
-
-            # write POWER_2 voltage multiplier
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.POWER_2_VOLT_MULTIPLIER_ADDR + " " + coefficients["multiplier"])
-            # write POWER_2 voltage offset
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.POWER_2_VOLT_OFFSET_ADDR + " " + coefficients["offset"])
+    class QTL2843_Current_Calibration (QTL2843_Calibration):
 
-    class QTL2621_POWER_2_LowCurrentCalibration (QTL2621Calibration):
+        def __init__(self,powerModule,phase):
 
-        def __init__(self,powerModule):
-
-            self.title = "POWER_2 Low Current Calibration"
+            self.title = phase + " Current Calibration"
+            self.phase = phase
             self.powerModule = powerModule
-            self.absErrorLimit = 15     # 15uA
-            self.relErrorLimit = 1      # 1%
-            self.test_min = 10          # 10uA
-            self.test_max = 85000       # 85mA
-            self.test_steps = 20
-            self.units = "uA"
-            self.scaling = 32
+            self.absErrorLimit = 10                 # 10mA
+            self.relErrorLimit = 0.5                # 0.5%
+            self.test_min = 100                     # 100mA
+            self.test_max = 10000                   # 10A
+            self.test_steps = 8
+            self.units = "mA"
+            self.scaling = 1
             self.multiplier_signed = False
             self.multiplier_int_width = 1
-            self.multiplier_frac_width = 16
+            self.multiplier_frac_width = 23
             self.offset_signed = True
             self.offset_int_width = 10
             self.offset_frac_width = 6
 
         def init(self):
 
-            super().init_cal("POWER_2")
+            super().init_cal()
 
-            #set manual range, full averaging, POWER_2 low current mode, POWER_1 all off (so we can detect we're connected to the wrong channel
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.CALIBRATION_CONTROL_ADDR + " 0x00F4")
             # clear the multiplier and offset registers by setting them to zero
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.POWER_2_LOW_MULTIPLIER_ADDR + " 0x0000")
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.POWER_2_LOW_OFFSET_ADDR + " 0x0000")
+            caddr = self.powerModule.getCoeffAddr(self.phase, "I")
+            self.powerModule.dut.sendAndVerifyCommand("write 0x{0:04x} 0x0000".format(caddr[0]))
+            self.powerModule.dut.sendAndVerifyCommand("write 0x{0:04x} 0x0000".format(caddr[1]))
 
-            self.powerModule.setConnections("POWER_2","POWER_2")
-            
-            # Check Host Power is present
-            while (super().checkLoadVoltage(QTL2621.LOAD_VOLTAGE,1000) != True):
-                self.powerModule.setConnections("POWER_2","POWER_2",reset=True)
+            #turn on AC Supply
+            self.powerModule.acSupply.setACSupplyVoltage(240)
+            self.powerModule.acSupply.setOutputEnable(True)
 
+            #set switches
+            self.powerModule.acSupplyMux.setMux("L1")
+            self.powerModule.acLoadMux.setMux(self.phase)
 
         def setRef(self,value):
-
-            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
+            if value < 0 or value > 10000:
+                raise ValueError("ERROR - ELPA max RMS current must be less than 10A")
+            self.powerModule.acLoad.setLoadCurrent(value / 1000.0)
+            self.powerModule.acLoad.setOutputEnable(True)
+            sleep(1) # Add settling time
 
         def readRef(self):
-
-            # read device voltage and add leakage current to the reference
-            voltage =  super().meas_POWER_2_volt()
-            #leakage = voltage*self.powerModule.calibrations["POWER_2"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["POWER_2"]["Leakage"].offset.originalValue()
-            return self.powerModule.calInstrument.measureLoadCurrent()*1000000# + leakage
+            self.startStream(self.powerModule.dut,3.3)
+            return self.powerModule.dmm.measureACCurrent("10A",readings = 10) * 1000.0
 
         def readVal(self):
-
-            return super().meas_POWER_2_cur()
+            # Return measurement, normalize all values to Volts and Amps
+            return self.getMeasurement(self.phase, 'I', typ='RMS', average=16)
 
         def setCoefficients(self):
 
-            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.POWER_2_LOW_MULTIPLIER_ADDR + " " + self.multiplier.hexString(4))
-            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.POWER_2_LOW_OFFSET_ADDR + " " + self.offset.hexString(4))
-            if result1 and result2:
-                result = True
-            else:
-                result = False
-            logSimpleResult("Set POWER_2 Low Current", result)
-
-        def finish(self):
-
-            super().finish_cal()
-
-        def report(self,data):
-
-            return super().report("calibrate",data)
-
-        def readCoefficients(self):
-
-            coefficients = {}
-            # get POWER_2 low current multiplier
-            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + QTL2621.POWER_2_LOW_MULTIPLIER_ADDR)
-            # get POWER_2 low current offset
-            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + QTL2621.POWER_2_LOW_OFFSET_ADDR)
-            return coefficients
-
-        def writeCoefficients(self,coefficients):
-
-            # write POWER_2 low current multiplier
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.POWER_2_LOW_MULTIPLIER_ADDR + " " + coefficients["multiplier"])
-            # write POWER_2 low current offset
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.POWER_2_LOW_OFFSET_ADDR + " " + coefficients["offset"])
-
-    class QTL2621_POWER_2_HighCurrentCalibration (QTL2621Calibration):
-
-        def __init__(self,powerModule):
+            # Get Coefficient Addresses
+            addrLow, addrHigh = self.powerModule.getCoeffAddr(self.phase, 'I')
 
-            self.title = "POWER_2 High Current Calibration"
-            self.powerModule = powerModule
-            self.absErrorLimit = 2000   # 2mA
-            self.relErrorLimit = 1      # 1%
-            self.test_min = 1000        # 1mA
-            self.test_max = 4000000     # 4A
-            self.test_steps = 20
-            self.units = "uA"
-            self.scaling = 2048
-            self.multiplier_signed = False
-            self.multiplier_int_width = 1
-            self.multiplier_frac_width = 16
-            self.offset_signed = True
-            self.offset_int_width = 10
-            self.offset_frac_width = 6
-
-        def init(self):
-
-            super().init_cal("POWER_2")
-
-            #set manual range, full averaging, POWER_2 high current mode, POWER_1 all off (so we can detect we're connected to the wrong channel
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.CALIBRATION_CONTROL_ADDR + " 0x00F8")
-            # clear the multiplier and offset registers by setting them to zero
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.POWER_2_HIGH_MULTIPLIER_ADDR + " 0x0000")
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.POWER_2_HIGH_OFFSET_ADDR + " 0x0000")
-
-            self.powerModule.setConnections("POWER_2","POWER_2")
-            # Check Host Power is present
-            while (super().checkLoadVoltage(QTL2621.LOAD_VOLTAGE,1000) != True):
-                self.powerModule.setConnections("POWER_2","POWER_2",reset=True)
-
-        def setRef(self,value):
-
-            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
-
-        def readRef(self):
-
-            # read device voltage and add leakage current to the reference
-            voltage =  super().meas_POWER_2_volt()
-            #leakage = voltage*self.powerModule.calibrations["POWER_2"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["POWER_2"]["Leakage"].offset.originalValue()
-            return self.powerModule.calInstrument.measureLoadCurrent()*1000000# + leakage
-
-        def readVal(self):
-
-            return super().meas_POWER_2_cur()
-
-        def setCoefficients(self):
-
-            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.POWER_2_HIGH_MULTIPLIER_ADDR + " " + self.multiplier.hexString(4))
-            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.POWER_2_HIGH_OFFSET_ADDR + " " + self.offset.hexString(4))
+            hexString = self.multiplier.hexString(8)
+            result1 = self.powerModule.dut.sendAndVerifyCommand("write 0x{0:04x} ".format(addrHigh) + hexString[:6]) 
+            result2 = self.powerModule.dut.sendAndVerifyCommand("write 0x{0:04x} ".format(addrLow) + hexString[:2] + hexString[6:])
             if result1 and result2:
                 result = True
             else:
                 result = False
-            logSimpleResult("Set POWER_2 high current", result)
+            logSimpleResult("Set " + self.phase + " Current Coefficients", result)
 
-            # once we've completed low and high current we can set leakage on the fixture
-            #result = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.POWER_2_LEAKAGE_MULTIPLIER_ADDR + " " + self.powerModule.calibrations["POWER_2"]["Leakage"].multiplier.hexString(4))
+            # load calibration values to ADE
+            self.powerModule.dut.sendCommand("write 0x1800 0x0000")
+            self.powerModule.dut.sendCommand("write 0x1800 0x0002")
 
         def finish(self):
 
             super().finish_cal()
 
         def report(self,data):
 
             return super().report("calibrate",data)
 
-        def readCoefficients(self):
-
-            coefficients = {}
-            # get POWER_2 high current multiplier
-            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + QTL2621.POWER_2_HIGH_MULTIPLIER_ADDR)
-            # get POWER_2 high current offset
-            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + QTL2621.POWER_2_HIGH_OFFSET_ADDR)
-            return coefficients
-
-        def writeCoefficients(self,coefficients):
-
-            # write POWER_2 high current multiplier
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.POWER_2_HIGH_MULTIPLIER_ADDR + " " + coefficients["multiplier"])
-            # write POWER_2 high current offset
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2621.POWER_2_HIGH_OFFSET_ADDR + " " + coefficients["offset"])
+    class QTL2843_Voltage_Verification (QTL2843_Calibration):
 
-    class QTL2621_POWER_2_VoltageVerification (QTL2621Calibration):
+        def __init__(self,powerModule,phase):
 
-        def __init__(self,powerModule):
-
-            self.title = "POWER_2 Voltage Verification"
+            self.title = phase + " Voltage Verification"
+            self.phase = phase
             self.powerModule = powerModule
-            self.absErrorLimit = 2      # 2mV
-            self.relErrorLimit = 1      # 1%
-            self.test_min = 40          # 40mV
-            self.test_max = 14400       # 14.4V
-            self.test_steps = 20
+            self.absErrorLimit = 0                  # 0mV
+            self.relErrorLimit = 0.5                # 0.5%
+            self.test_min = 50000                   # 50V
+            self.test_max = 270000                  # 270V
+            self.test_steps = 8
             self.units = "mV"
 
         def init(self):
 
-            super().init_cal("POWER_2")
+            super().init_cal()
 
-            self.powerModule.setConnections("POWER_2",None)
+            #set switches
+            self.powerModule.acSupplyMux.setMux("L1")
+            self.powerModule.acLoadMux.setMux(self.phase)
 
             # Check Host Power is present
-            #while (super().checkLoadVoltage(500,500) != True):
-                #self.powerModule.setConnections("POWER_2",None,reset=True)
+#            while (super().checkLoadVoltage(500,500) != True):
+#                input("Unexpected voltage detected at load, please check connections")
 
         def setRef(self,value):
-
-            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
+            self.powerModule.acSupply.setACSupplyVoltage(value/1000)
+            sleep(1) # Add settling time
 
         def readRef(self):
-
-            return self.powerModule.calInstrument.measureLoadVoltage()*1000
+            self.startStream(self.powerModule.dut,0.2)
+            return self.powerModule.acLoad.getVoltageMeasurement('RMS') * 1000.0
 
         def readVal(self):
-
-            return super().meas_POWER_2_volt()
+            # Return measurement, normalize all values to Volts and Amps
+            return self.getMeasurement(self.phase, 'V', typ='RMS', average=1)
 
         def finish(self):
 
             super().finish_cal()
 
         def report(self,data):
 
             return super().report("verify",data)
 
-    class QTL2621_POWER_2_LowCurrentVerification (QTL2621Calibration):
+    class QTL2843_Current_Verification (QTL2843_Calibration):
 
-        def __init__(self,powerModule):
+        def __init__(self,powerModule,phase):
 
-            self.title = "POWER_2 Low Current Verification"
+            self.title = phase + " Current Verification"
+            self.phase = phase
             self.powerModule = powerModule
-            self.absErrorLimit = 25     # 25uA  - Deliberately higher than calibration limit
-            self.relErrorLimit = 1      # 1% tolerance
-            self.test_min = 100         # 100uA
-            self.test_max = 1000        # 1mA
-            self.test_steps = 20
-            self.units = "uA"
+            self.absErrorLimit = 10                 # 10mA
+            self.relErrorLimit = 0.5                # 0.5%
+            self.test_min = 100                     # 100mA
+            self.test_max = 10000                   # 10A
+            self.test_steps = 8
+            self.units = "mA"
 
         def init(self):
 
-            super().init_cal("POWER_2")
+            super().init_cal()
 
-            self.powerModule.setConnections("POWER_2","POWER_2")
+            #turn on AC Supply
+            self.powerModule.acSupply.setACSupplyVoltage(240)
+            self.powerModule.acSupply.setOutputEnable(True)
 
-            # Check Host Power is present
-            while (super().checkLoadVoltage(QTL2621.LOAD_VOLTAGE,1000) != True):
-                self.powerModule.setConnections("POWER_2","POWER_2",reset=True)
+            #set switches
+            self.powerModule.acSupplyMux.setMux("L1")
+            self.powerModule.acLoadMux.setMux(self.phase)
 
         def setRef(self,value):
-
-            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
+            if value < 0 or value > 10000:
+                raise ValueError("ERROR - ELPA max RMS current must be less than 10A")
+            self.powerModule.acLoad.setLoadCurrent(value / 1000.0)
+            self.powerModule.acLoad.setOutputEnable(True)
+            time.sleep(1) # add settling time
 
         def readRef(self):
-
-            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
+            self.startStream(self.powerModule.dut,3.3)
+            return self.powerModule.dmm.measureACCurrent("10A",10) * 1000.0
 
         def readVal(self):
-
-            return super().meas_POWER_2_cur()
+            # Return measurement, normalize all values to Volts and Amps
+            return self.getMeasurement(self.phase, 'I', typ='RMS', average=1)
 
         def finish(self):
 
             super().finish_cal()
 
         def report(self,data):
 
-            return super().report("verify",data)
-
-    class QTL2621_POWER_2_HighCurrentVerification (QTL2621Calibration):
-
-        def __init__(self,powerModule):
-
-            self.title = "POWER_2 High Current Verification"
-            self.powerModule = powerModule
-            self.absErrorLimit = 2000       # 2mA
-            self.relErrorLimit = 1          # 1% tolerance
-            self.test_min = 1000            # 1mA
-            self.test_max = 4000000         # 4A
-            self.test_steps = 20
-            self.units = "uA"
-
-        def init(self):
-
-            super().init_cal("POWER_2")
-
-            self.powerModule.setConnections("POWER_2","POWER_2")
-
-            # Check Host Power is present
-            while (super().checkLoadVoltage(QTL2621.LOAD_VOLTAGE,1000) != True):
-                self.powerModule.setConnections("POWER_2","POWER_2",reset=True)
-
-        def setRef(self,value):
-
-            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
-
-        def readRef(self):
-
-            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
-
-        def readVal(self):
-
-            return super().meas_POWER_2_cur()
-
-        def finish(self):
-
-            super().finish_cal()
-
-        def report(self,data):
-
-            return super().report("verify",data)
-
-    class QTL2621_POWER_1_VoltageVerification (QTL2621Calibration):
-
-        def __init__(self,powerModule):
-
-            self.title = "POWER_1 Voltage Verification"
-            self.powerModule = powerModule
-            self.absErrorLimit = 2      # 2mV
-            self.relErrorLimit = 1      # 1%
-            self.test_min = 40          # 40mV
-            self.test_max = 6000        # 6V
-            self.test_steps = 20
-            self.units = "mV"
-
-        def init(self):
-
-            super().init_cal("POWER_1")
-
-            self.powerModule.setConnections("POWER_1",None)
-
-            # Check Host Power is present
-            #while (super().checkLoadVoltage(500,500) != True):
-                #self.powerModule.setConnections("POWER_1",None,reset=True)
-
-        def setRef(self,value):
-
-            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
-
-        def readRef(self):
-
-            return self.powerModule.calInstrument.measureLoadVoltage()*1000
-
-        def readVal(self):
-
-            return super().meas_POWER_1_volt()
-
-        def finish(self):
-
-            super().finish_cal()
-
-        def report(self,data):
-
-            return super().report("verify",data)
-
-    class QTL2621_POWER_1_LowCurrentVerification (QTL2621Calibration):
-
-        def __init__(self,powerModule):
-
-            self.title = "POWER_1 Low Current Verification"
-            self.powerModule = powerModule
-            self.absErrorLimit = 25     # 25uA  - Deliberately higher than calibration limit
-            self.relErrorLimit = 1      # 1%
-            self.test_min = 100         # 100uA
-            self.test_max = 1000        # 1mA
-            self.test_steps = 20
-            self.units = "uA"
-
-        def init(self):
-
-            super().init_cal("POWER_1")
-
-            self.powerModule.setConnections("POWER_1","POWER_1")
-
-            # Check Host Power is present
-            while (super().checkLoadVoltage(QTL2621.LOAD_VOLTAGE,1000) != True):
-                self.powerModule.setConnections("POWER_1","POWER_1",reset=True)
-
-        def setRef(self,value):
-
-            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
-
-        def readRef(self):
-
-            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
-
-        def readVal(self):
-
-            return super().meas_POWER_1_cur()
-
-        def finish(self):
-
-            super().finish_cal()
-
-        def report(self,data):
-
-            return super().report("verify",data)
-
-    class QTL2621_POWER_1_HighCurrentVerification (QTL2621Calibration):
-
-        def __init__(self,powerModule):
-
-            self.title = "POWER_1 High Current Verification"
-            self.powerModule = powerModule
-            self.absErrorLimit = 2000       # 2mA
-            self.relErrorLimit = 1          # 1% tolerance
-            self.test_min = 1000            # 1mA
-            self.test_max = 4000000         # 4A
-            self.test_steps = 20
-            self.units = "uA"
-
-        def init(self):
-
-            super().init_cal("POWER_1")
-
-            self.powerModule.setConnections("POWER_1","POWER_1")
-
-            # Check Host Power is present
-            while (super().checkLoadVoltage(QTL2621.LOAD_VOLTAGE,1000) != True):
-                self.powerModule.setConnections("POWER_1","POWER_1",reset=True)
-
-        def setRef(self,value):
-
-            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
-
-        def readRef(self):
-
-            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
-
-        def readVal(self):
-
-            return super().meas_POWER_1_cur()
-
-        def finish(self):
-
-            super().finish_cal()
-
-        def report(self,data):
-
-            return super().report("verify",data)
-
-
-    def __init__(self,dut):
-
-        # set the name of this module
-        self.name = "PCIe x16 Power Measurement Fixture"
-        self.dut = dut
-        
-        # Serial numbers (ensure QTL at start)
-        self.enclosureSerial = self.dut.sendCommand("*ENCLOSURE?")
-        if (self.enclosureSerial.find ("QTL") == -1):
-            self.enclosureSerial = "QTL" + self.enclosureSerial
-        # fetch the enclosure position
-        self.enclosurePosition = self.dut.sendCommand("*POSITION?")
-        self.PAMSerial = self.dut.sendCommand ("*SERIAL?")
-        if (self.PAMSerial.find ("QTL") == -1):
-            self.PAMSerial = "QTL" + self.PAMSerial
-        # Fixture Serial
-        # fixture serial is retrieved as BCD, we need to convert and pad it
-        self.FixtureSerial = "QTL" + bcdString(dut.sendCommand("read 0xA102"),4) + "-" + bcdString(dut.sendCommand("read 0xA103"),2) + "-" + bcdString(dut.sendCommand("read 0xA104"),3) # TODO: this should be replaced with fix:serial? command when implemented
-        # calObjectSerial Serial
-        self.calObjectSerial = self.FixtureSerial
-        # Filename String
-        self.filenameString = self.FixtureSerial
-        # Code version (FPGA)
-        self.idnStr = dut.sendCommand ("*IDN?")
-        pos = self.idnStr.upper().find ("FPGA 1:")
-        if (pos != -1):
-            versionStr = self.idnStr[pos+7:]
-            pos = versionStr.find ("\n")
-            if (pos != -1):
-                versionStr = versionStr[:pos].strip()
-            else:
-                pass
-        else:
-            versionStr = "NOT-FOUND"    
-        self.Fpga = versionStr.strip()
-    
-        # Code version (FW)    
-        pos = self.idnStr.upper().find ("PROCESSOR:")
-        if (pos != -1):
-            versionStr = self.idnStr[pos+10:]
-            pos = versionStr.find ("\n")
-            if (pos != -1):
-                versionStr = versionStr[:pos].strip()            
-            else:
-                pass
-        else:
-            versionStr = "NOT-FOUND"    
-        self.Firmware = versionStr.strip()
-
-        self.calibrations = {}
-        # populate POWER_1 channel with calibrations
-        self.calibrations["POWER_1"] = {
-            "Voltage":self.QTL2621_POWER_1_VoltageCalibration(self),
-            #"Leakage":self.QTL2621_POWER_1_LeakageCalibration(self),
-            "Low Current":self.QTL2621_POWER_1_LowCurrentCalibration(self),
-            "High Current":self.QTL2621_POWER_1_HighCurrentCalibration(self)
-            }
-        # populate POWER_2 channel with calibrations
-        self.calibrations["POWER_2"] = {
-            "Voltage":self.QTL2621_POWER_2_VoltageCalibration(self),
-            #"Leakage":self.QTL2621_POWER_2_LeakageCalibration(self),
-            "Low Current":self.QTL2621_POWER_2_LowCurrentCalibration(self),
-            "High Current":self.QTL2621_POWER_2_HighCurrentCalibration(self)
-            }
-
-        self.verifications = {}
-        # populate POWER_1 channel with verifications
-        self.verifications["POWER_1"] = {
-            "Voltage":self.QTL2621_POWER_1_VoltageVerification(self),
-            "Low Current":self.QTL2621_POWER_1_LowCurrentVerification(self),
-            "High Current":self.QTL2621_POWER_1_HighCurrentVerification(self)
-            }
-        # populate POWER_2 channel with verifications
-        self.verifications["POWER_2"] = {
-            "Voltage":self.QTL2621_POWER_2_VoltageVerification(self),
-            "Low Current":self.QTL2621_POWER_2_LowCurrentVerification(self),
-            "High Current":self.QTL2621_POWER_2_HighCurrentVerification(self)
-            }
-
+            return super().report("verify",data)
```

## Comparing `quarchCalibration/QTL2673.py` & `quarchCalibration/QTL2673_edsff.py`

 * *Files 19% similar despite different names*

```diff
@@ -12,26 +12,24 @@
     Connect to Keithley
     step through a set of values and get ADC vs Reference Value
     evaluate results vs defined limits
 
 '''
 
 #Imports QuarchPy library, providing the functions needed to use Quarch modules
-#from quarchpy import quarchDevice #, scanDevices
-
-# Import other libraries used in the examples
-
 from .PowerModuleCalibration import *
 from .calibrationConfig import *
 from .keithley_2460_control import *
+from .QTL2536_6_way_switchbox import *
 from quarchpy.device.device import *
 from quarchpy.device.scanDevices import userSelectDevice
 from quarchpy.user_interface import *
 from quarchpy.user_interface import logSimpleResult
 from quarchpy.utilities.BitManipulation import *
+from .pamHelpers import bcdString
 
 def parseFixtureData(response,start,length):
 
     # split the multiline response into a list
     response = response.splitlines()
     result = ""
     # for each line
@@ -56,98 +54,165 @@
     device.sendCommand("write 0x0000 " + setBit(response,3))
     #read measurement
     data = device.sendCommand("read 0x1000 to 0x1007")
     #release measurement
     response = device.sendCommand("read 0x0000")
     device.sendCommand("write 0x0000 " + clearBit(response,3))
 
-    if (channel == "12V VOLT"):
+    if (channel == "12V V"):
         return parseFixtureData(data,0,16)
-    elif (channel == "12V CUR"):
+    elif (channel == "12V A"):
         return parseFixtureData(data,16,25)
-    elif (channel == "3V3_AUX VOLT"):
+    elif (channel == "3V3_AUX V"):
         return parseFixtureData(data,41,16)
-    elif (channel == "3V3_AUX CUR"):
+    elif (channel == "3V3_AUX A"):
         return parseFixtureData(data,57,20)
 
-def bcdString(bcd,padding):
-    # strip off "0x" if present
-    if bcd[:2] == "0x":
-        bcd = bcd [2:]
-    # strip off leading 0's
-    # loop while we have more the required minimum number of characters left
-    while(len(bcd)>padding):
-        # if the leading character is 0, remove it
-        if bcd[0] == '0':
-            bcd = bcd[1:]
-        # else exit loop
-        else:
-            break
-    return bcd
 
 
 class QTL2673 (PowerModule):
 
     # Fixture Register Addresses
-    CALIBRATION_MODE_ADDR               = '0xA100'
-    CALIBRATION_CONTROL_ADDR            = '0xA101'      
-    
-    V12_LOW_MULTIPLIER_ADDR             = '0xA10C'
-    V12_LOW_OFFSET_ADDR                 = '0xA10D'
-    V12_HIGH_MULTIPLIER_ADDR            = '0xA10E'
-    V12_HIGH_OFFSET_ADDR                = '0xA10F'
-    V12_VOLT_MULTIPLIER_ADDR            = '0xA110'
-    V12_VOLT_OFFSET_ADDR                = '0xA111'
-    V12_LEAKAGE_MULTIPLIER_ADDR         = '0xA112'
+    CAL_ADDRESSES = {    
+    '12V_LOW_MULTIPLIER'            : '0xA10C',
+    '12V_LOW_OFFSET'                : '0xA10D',
+    '12V_HIGH_MULTIPLIER'           : '0xA10E',
+    '12V_HIGH_OFFSET'               : '0xA10F',
+    '12V_VOLT_MULTIPLIER'           : '0xA110',
+    '12V_VOLT_OFFSET'               : '0xA111',
+    '12V_LEAKAGE_MULTIPLIER'        : '0xA112',
 	
-    V3_3_AUX_MULTIPLIER_ADDR            = '0xA113'
-    V3_3_AUX_OFFSET_ADDR                = '0xA114'
-    V3_3_AUX_VOLT_MULTIPLIER_ADDR       = '0xA115'
-    V3_3_AUX_VOLT_OFFSET_ADDR           = '0xA116'
-    V3_3_AUX_LEAKAGE_MULTIPLIER_ADDR    = '0xA117'
-    CALIBRATION_COMPLETE_ADDR	        = '0xA118'
-    LOAD_VOLTAGE                        = 12000
+    '3V3_AUX_LOW_MULTIPLIER'        : '0xA113',
+    '3V3_AUX_LOW_OFFSET'            : '0xA114',
+    '3V3_AUX_VOLT_MULTIPLIER'		: '0xA115',
+    '3V3_AUX_VOLT_OFFSET'			: '0xA116',
+    '3V3_AUX_LEAKAGE_MULTIPLIER'    : '0xA117',
+    'CALIBRATION_COMPLETE'          : '0xA118'
+    }
+
+    CONTROL_ADDRESSES = {
+    'CALIBRATION_MODE'             	            : '0xA100',
+    'CALIBRATION_CONTROL'          	            : '0xA101', 
+    '12V_LOW_CALIBRATION_CONTROL_SETTING'       : '0x00F4',      # set manual range, full averaging, 12V low current mode,
+    '12V_HIGH_CALIBRATION_CONTROL_SETTING'      : '0x00F8',      # set manual range, full averaging, 12V high current mode,
+    '3V3_AUX_LOW_CALIBRATION_CONTROL_SETTING'   : '0x00F0',   # no range switching on 3V3_AUX, leave the module in auto mode
+    '3V3_AUX_HIGH_CALIBRATION_CONTROL_SETTING'  : '0x00F0'  # no range switching on 3V3_AUX, leave the module in auto mode
+    }
+
+    LOAD_VOLTAGE                    = 12000
+
+    host_switchbox_title = "Switchbox"
+    host_switchbox_message = "Select the switch box which connects a 12V supply and Keithley Load to the fixture:"
+    host_switchbox_mapping = {'12V':'A','12V_SUPPLY':'1','3V3_AUX_SUPPLY':'3','LOAD':'B','12V_LOAD':'4','3V3_AUX_LOAD':'6'}
 
     # Fixture Information
     PAMSerial = None
     FixtureSerial = None
     calObjectSerial = None     # The serial number of the device that is being calibrated, i.e QTL1944 in HD PPM, Fixture in PAM
     idnStr = None
     Firmware = None
     Fpga = None
     calInstrument = None
     calInstrumentId = None
-    switchbox = None
-
-    # Physical Connection Tracking (what is plugged to what)
-    loadChannel = None
-    hostPowerChannel = None
-
-    # defigning the connection
-    hostPort = "A"
-    loadPort = "B"
-    loadConnectionPortDict = {"12V": "4", "3V3_AUX": "6"}
-    hostConnectionPortDict = {"12V": "1", "3V3_AUX": "3"}
-
-    # general
+    host_switchbox = None
     waitComplete = False
     checkedWiring = False
 
+    def __init__(self,dut):
+
+        # set the name of this module
+        self.name = "EDSFF Power Measurement Fixture"
+        self.dut = dut
+        
+        # Serial numbers (ensure QTL at start)
+        self.enclosureSerial = self.dut.sendCommand("*ENCLOSURE?")
+        if (self.enclosureSerial.find ("QTL") == -1):
+            self.enclosureSerial = "QTL" + self.enclosureSerial
+        # fetch the enclosure position
+        self.enclosurePosition = self.dut.sendCommand("*POSITION?")
+        self.PAMSerial = self.dut.sendCommand ("*SERIAL?")
+        if (self.PAMSerial.find ("QTL") == -1):
+            self.PAMSerial = "QTL" + self.PAMSerial
+        # Fixture Serial
+        # fixture serial is retrieved as BCD, we need to convert and pad it
+        self.FixtureSerial = "QTL" + bcdString(dut.sendCommand("read 0xA102"),4) + "-" + bcdString(dut.sendCommand("read 0xA103"),2) + "-" + bcdString(dut.sendCommand("read 0xA104"),3) # TODO: this should be replaced with fix:serial? command when implemented
+        # calObjectSerial Serial
+        self.calObjectSerial = self.FixtureSerial
+        # Filename String
+        self.filenameString = self.FixtureSerial
+        # Code version (FPGA)
+        self.idnStr = dut.sendCommand ("*IDN?")
+        pos = self.idnStr.upper().find ("FPGA 1:")
+        if (pos != -1):
+            versionStr = self.idnStr[pos+7:]
+            pos = versionStr.find ("\n")
+            if (pos != -1):
+                versionStr = versionStr[:pos].strip()
+            else:
+                pass
+        else:
+            versionStr = "NOT-FOUND"    
+        self.Fpga = versionStr.strip()
+    
+        # Code version (FW)    
+        pos = self.idnStr.upper().find ("PROCESSOR:")
+        if (pos != -1):
+            versionStr = self.idnStr[pos+10:]
+            pos = versionStr.find ("\n")
+            if (pos != -1):
+                versionStr = versionStr[:pos].strip()            
+            else:
+                pass
+        else:
+            versionStr = "NOT-FOUND"    
+        self.Firmware = versionStr.strip()
+
+        self.calibrations = {}
+        # populate 12V channel with calibrations
+        self.calibrations["12V"] = {
+            "Voltage":self.QTL2673_VoltageCalibration(self,"12V"),
+            #"Leakage":self.QTL2673_LeakageCalibration(self,"12V"),
+            "Low Current":self.QTL2673_LowCurrentCalibration(self,"12V"),
+            "High Current":self.QTL2673_HighCurrentCalibration(self,"12V")
+            }
+        # populate 3V3_AUX channel with calibrations
+        self.calibrations["3.3V Aux"] = {
+            "Voltage":self.QTL2673_VoltageCalibration(self,"3V3_AUX"),
+            #"Leakage":self.QTL2673_LeakageCalibration(self,"3V3_AUX"),
+            "Current":self.QTL2673_LowCurrentCalibration(self,"3V3_AUX")
+            }
+
+        self.verifications = {}
+        # populate 12V channel with verifications
+        self.verifications["12V"] = {
+            "Voltage":self.QTL2673_VoltageVerification(self,"12V"),
+            "Low Current":self.QTL2673_LowCurrentVerification(self,"12V"),
+            "High Current":self.QTL2673_HighCurrentVerification(self,"12V")
+            }
+        # populate 3V3_AUX channel with verifications
+        self.verifications["3.3V Aux"] = {
+            "Voltage":self.QTL2673_VoltageVerification(self,"3V3_AUX"),
+            "Current":self.QTL2673_LowCurrentVerification(self,"3V3_AUX")
+            }
+
+
     def specific_requirements(self):
 
         reportText=""
 
-        # select a switchbox to use for calibration
-        if "switchbox" in calibrationResources.keys():
-            self.switchbox = calibrationResources["switchbox"]
-        self.switchbox = self.getSwitchbox()
-        calibrationResources["switchbox"] = self.switchbox
+        # select the host switchbox to use for calibration
+        if "host_switchbox" in calibrationResources.keys():
+            self.host_switchbox = calibrationResources["host_switchbox"]
+        else:
+            self.host_switchbox = self.get_switchbox(self.host_switchbox_message,self.host_switchbox_title,self.host_switchbox_mapping)
+            calibrationResources["host_switchbox"] = self.host_switchbox
 
         if self.checkedWiring != True:
-            self.checkWiring()
+            self.host_switchbox.checkWiring()
+
             self.checkedWiring = True
 
         # Select a Keithley SMU
         # If no calibration instrument is provided, request it
         while (True):
             if (calibrationResources["loadString"] == None):
                 loadString = userSelectCalInstrument(scanFilterStr="Keithley 2460", nice=True)
@@ -184,119 +249,83 @@
         # perform uptime check and write to file
         if self.waitComplete != True:
             reportText += self.wait_for_up_time(desired_up_time=600, command="conf:runtime:fix:sec?")
             self.waitComplete = True
 
         return reportText
 
-    def setConnections(self,loadConnection,hostPowerConnection,reset=False):
-    #TODO Fix for using class variable.
-        if reset:
-            self.loadChannel = None
-            self.hostPowerChannel = None
-
-        # If current connections are correct
-        if self.loadChannel == loadConnection and self.hostPowerChannel == hostPowerConnection:
-            # do nothing
-            pass
-
-        # else connections need to change
-        else:
-
-            # we can't turn an individual port off (at the moment) so we turn both off first, then set anything that needs setting
-            if loadConnection == None or hostPowerConnection == None:
-                response = self.switchbox.sendCommand("connect off")
-                if response != "OK": raise ConnectionError("Switchbox command failed")
-
-            if loadConnection != None:
-                response = self.switchbox.sendCommand("connect " + self.loadPort + " " + self.loadConnectionPortDict[loadConnection])
-                if response != "OK": raise ConnectionError("Switchbox command failed")
-				
-            if hostPowerConnection != None:
-                response = self.switchbox.sendCommand("connect " + self.hostPort + " " + self.hostConnectionPortDict[hostPowerConnection])
-                if response != "OK": raise ConnectionError("Switchbox command failed")
+    def open_module(self):
 
-        self.loadChannel = loadConnection
-        self.hostPowerChannel = hostPowerConnection
+        # set unit into calibration mode
+        self.dut.sendCommand("write " + self.CONTROL_ADDRESSES["CALIBRATION_MODE"] + " 0xaa55")
+        self.dut.sendCommand("write " + self.CONTROL_ADDRESSES["CALIBRATION_MODE"] + " 0x55aa")
 
-    def getSwitchbox(self):
+    def get_switchbox(self,msg,name,portDict):
         # CheckSwitchbox
-        if self.switchbox is None:
-            while (True):
-                switchboxAddress = userSelectDevice(scanFilterStr=["QTL2536"], message="Select a calibration 6 Way Test Lead Switch.", nice=True)
-                if switchboxAddress == "quit":
-                    printText("User Quit Program")
-                    sys.exit(0)
-                try:
-                    self.switchbox = quarchDevice(switchboxAddress)
-                    break
-                except:
-                    printText("Unable to communicate with selected device!")
-                    printText("")
-                    switchboxAddress = None
-                    raise
-        return self.switchbox
+        while (True):
+            switchboxAddress = userSelectDevice(scanFilterStr=["QTL2536"], message=msg, nice=True)
+            if switchboxAddress == "quit":
+                printText("User Quit Program")
+                sys.exit(0)
+            try:
+                switchbox = QTL2536_6_way_switchbox(switchboxAddress,name,portDict)
+                break
+            except:
+                printText("Unable to communicate with selected device!")
+                printText("")
+                switchboxAddress = None
+                raise
+        return switchbox
 
 
     def clear_calibration(self):
 
         # set unit into calibration mode
-        self.dut.sendCommand("write " + QTL2673.CALIBRATION_MODE_ADDR + " 0xaa55")
-        self.dut.sendCommand("write " + QTL2673.CALIBRATION_MODE_ADDR + " 0x55aa")
+        self.dut.sendCommand("write " + self.CONTROL_ADDRESSES["CALIBRATION_MODE"] + " 0xaa55")
+        self.dut.sendCommand("write " + self.CONTROL_ADDRESSES["CALIBRATION_MODE"] + " 0x55aa")
 
         # clear all calibration registers
-      
-        self.dut.sendAndVerifyCommand("write " + QTL2673.V12_VOLT_OFFSET_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2673.V12_VOLT_MULTIPLIER_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2673.V12_LOW_OFFSET_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2673.V12_LOW_MULTIPLIER_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2673.V12_HIGH_OFFSET_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2673.V12_HIGH_MULTIPLIER_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2673.V12_LEAKAGE_MULTIPLIER_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2673.V3_3_AUX_VOLT_OFFSET_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2673.V3_3_AUX_VOLT_MULTIPLIER_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2673.V3_3_AUX_OFFSET_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2673.V3_3_AUX_MULTIPLIER_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2673.V3_3_AUX_LEAKAGE_MULTIPLIER_ADDR + " 0x0000")
+        for address in self.CAL_ADDRESSES.values():
+            self.dut.sendAndVerifyCommand("write " + address + " 0x0000")
         
         # write 0xaa55 to register to calibration complete register to tell module it is calibrated
-        self.dut.sendAndVerifyCommand("write " + QTL2673.CALIBRATION_COMPLETE_ADDR + " 0xaa55")
+        self.dut.sendAndVerifyCommand("write " + self.CAL_ADDRESSES["CALIBRATION_COMPLETE"] + " 0xaa55")
         
     def write_calibration(self):
 
         # write the calibration registers
         # erase the tag memory
         printText("Erasing TAG memory..")
         self.dut.sendCommand("write 0xa200 0x0020")
         # TODO: should check for completion here...
         # wait for 2 seconds for erase to complete
         # check busy
         while checkBit(self.dut.sendCommand("read 0xa200"),8):
-            sleep(0.1)
+            time.sleep(0.1)
         # write the tag memory
         printText("Programming TAG memory...")
         self.dut.sendCommand("write 0xa200 0x0040")        
         # check busy
         while checkBit(self.dut.sendCommand("read 0xa200"),8):
-            sleep(0.1)
+            time.sleep(0.1)
 
     def close_module(self):
 
         # reset the fixture FPGA
         self.dut.sendCommand("fixture:reset")
 
         #close the connection to the calibration instrument
         self.calInstrument.closeConnection()
 
     def close_all(self):
 
         #close all attached devices
         self.calInstrument.setLoadCurrent(0)
         self.calInstrument.closeConnection()
-        self.powerModule.setConnections(None,None)
+        self.host_switchbox.sendCommand("connect off")
 
     class QTL2673Calibration (Calibration):
 
         def __init__(self):
             super().__init__()
 
         def init_cal(self,voltage):
@@ -308,62 +337,42 @@
             # set averaging to max
             self.powerModule.dut.sendAndVerifyCommand("rec:ave 32k")
 
             #Turn off compression and power up
             self.powerModule.dut.sendAndVerifyCommand("write 0xA010 0x0011")
 
             # set module into calibration mode (again?)
-            self.powerModule.dut.sendCommand("write " + QTL2673.CALIBRATION_MODE_ADDR + " 0xaa55")   # will not verify
-            self.powerModule.dut.sendCommand("write " + QTL2673.CALIBRATION_MODE_ADDR + " 0x55aa")   # will not verify
+            self.powerModule.dut.sendCommand("write " + self.powerModule.CONTROL_ADDRESSES["CALIBRATION_MODE"] + " 0xaa55")   # will not verify
+            self.powerModule.dut.sendCommand("write " + self.powerModule.CONTROL_ADDRESSES["CALIBRATION_MODE"] + " 0x55aa")   # will not verify
 
             #Reset Keithley
             self.powerModule.calInstrument.reset()
 
-        def meas_12v_volt(self):
-
-            result = getFixtureData(self.powerModule.dut,"12V VOLT")
-            return result
-
-        def meas_12v_cur(self):
-
-            result = getFixtureData(self.powerModule.dut,"12V CUR")
-            return result
-
-        def meas_3v3_aux_volt(self):
-
-            result = getFixtureData(self.powerModule.dut,"3V3_AUX VOLT")
-            return result
-
-        def meas_3v3_aux_cur(self):
-
-            result = getFixtureData(self.powerModule.dut,"3V3_AUX CUR")
-            return result
-
         # check connections to host power and load
         def checkLoadVoltage(self,voltage,tolerance):
 
-            #self.powerModule.calInstrument.setReferenceCurrent(0)
-            self.powerModule.calInstrument.setReferenceVoltage(voltage/1000,"1e-6")  # set Keithley to the required voltage but limit current to 1uA
+            self.powerModule.calInstrument.setReferenceCurrent(0)
             result = self.powerModule.calInstrument.measureLoadVoltage()*1000   # *1000 because we use mV but keithley uses volts
             # check result is in required range
             if (result >= voltage-tolerance) and (result <= voltage+tolerance):
                 return True
             else:
                 return False
 
         def finish_cal(self):
 
             #turn off load
             self.powerModule.calInstrument.disable()
 
             #turn off switch
-            self.powerModule.setConnections(None,None)
+            self.powerModule.host_switchbox.setConnections([]) #sendCommand("connect off")
+
 
             # turn dut to autoranging
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2673.CALIBRATION_CONTROL_ADDR + " 0x00F0")
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CONTROL_ADDRESSES["CALIBRATION_CONTROL"] + " 0x00F0")
 
         def report(self,action,data):
 
             report = []
 
             # send to report file
             report.append("          Pass Level  +/-(" + str(self.absErrorLimit) + str(self.units) +" + " + str(self.relErrorLimit) + "%) \n")
@@ -430,19 +439,20 @@
             report.append("\n\n\n")
             
             #Add to Test Summary? Do this here?
             passfail = lambda x: "Passed" if x else "Failed"
 
             return {"title":self.title,"result":overallResult,"worst case":worstCase,"report":('\n'.join(report))}
 
-    class QTL2673_12V_VoltageCalibration (QTL2673Calibration):
+    class QTL2673_VoltageCalibration (QTL2673Calibration):
 
-        def __init__(self,powerModule):
+        def __init__(self,powerModule,thisChannel):
 
-            self.title = "12V Voltage Calibration"
+            self.thisChannel = thisChannel
+            self.title = thisChannel + " Voltage Calibration"
             self.powerModule = powerModule
             self.absErrorLimit = 2                  # 2mV
             self.relErrorLimit = 1                  # 1%
             self.test_min = 40                      # 40mV
             self.test_max = 14400                   # 14.4V
             self.test_steps = 20
             self.units = "mV"
@@ -452,698 +462,365 @@
             self.multiplier_frac_width = 16
             self.offset_signed = True
             self.offset_int_width = 10
             self.offset_frac_width = 6
 
         def init(self):
 
-            super().init_cal("12v")
+            super().init_cal(self.thisChannel)
 
             # clear the multiplier and offset registers by setting them to zero
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2673.V12_VOLT_MULTIPLIER_ADDR + " 0x0000")
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2673.V12_VOLT_OFFSET_ADDR + " 0x0000")
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_VOLT_MULTIPLIER"] + " 0x0000")
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_VOLT_OFFSET"] + " 0x0000")
 
-            self.powerModule.setConnections("12V",None)
-            ## Check Host Power is not present        
+            self.powerModule.host_switchbox.setConnections([("12V",None),("LOAD",self.thisChannel + "_LOAD")])
+
+            # Check Host Power is present
             #while (super().checkLoadVoltage(500,500) != True):
-            #    input("Unexpected voltage detected at load, please check connections")
-            #    self.powerModule.setConnections("12V",None,reset=True)
+            #    self.powerModule.setConnections("POWER_1",None,reset=True)
 
         def setRef(self,value):
 
             self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
 
         def readRef(self):
 
             return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def readVal(self):
 
-            return super().meas_12v_volt()
+            return getFixtureData(self.powerModule.dut,self.thisChannel + " V")
 
         def setCoefficients(self):
 
-            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2673.V12_VOLT_MULTIPLIER_ADDR + " " + self.multiplier.hexString(4))
-            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2673.V12_VOLT_OFFSET_ADDR + " " + self.offset.hexString(4))
+            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_VOLT_MULTIPLIER"] + " " + self.multiplier.hexString(4))
+            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_VOLT_OFFSET"] + " " + self.offset.hexString(4))
             if result1 and result2:
                 result = True
             else:
                 result = False
-            logSimpleResult("Set 12v voltage", result)
+            logSimpleResult("Set " + self.thisChannel + " voltage", result)
 
         def finish(self):
 
             super().finish_cal()
 
         def report(self,data):
 
             return super().report("calibrate",data)
 
         def readCoefficients(self):
 
             coefficients = {}
-            # get 12v voltage multiplier
-            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + QTL2673.V12_VOLT_MULTIPLIER_ADDR)
-            # get 12v voltage offset
-            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + QTL2673.V12_VOLT_OFFSET_ADDR)
+            # get voltage multiplier
+            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_VOLT_MULTIPLIER"])
+            # get voltage offset
+            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_VOLT_OFFSET"])
             return coefficients
 
         def writeCoefficients(self,coefficients):
 
-            # write 12v voltage multiplier
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2673.V12_VOLT_MULTIPLIER_ADDR + " " + coefficients["multiplier"])
-            # write 12v voltage offset
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2673.V12_VOLT_OFFSET_ADDR + " " + coefficients["offset"])
+            # write voltage multiplier
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_VOLT_MULTIPLIER"] + " " + coefficients["multiplier"])
+            # write voltage offset
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_VOLT_OFFSET"] + " " + coefficients["offset"])
 
-    class QTL2673_12V_LowCurrentCalibration (QTL2673Calibration):
+    class QTL2673_LowCurrentCalibration (QTL2673Calibration):
 
-        def __init__(self,powerModule):
+        def __init__(self,powerModule,thisChannel):
 
-            self.title = "12V Low Current Calibration"
+            self.thisChannel = thisChannel
+            self.title = thisChannel + " Low Current Calibration"
             self.powerModule = powerModule
             self.absErrorLimit = 15                 # 15uA
             self.relErrorLimit = 1                  # 1%
-            self.test_min = 10          # 10uA
-            self.test_max = 85000       # 85mA
+            self.test_min = 10                      # 10uA
+            self.test_max = 85000                   # 85mA
             self.test_steps = 20
             self.units = "uA"
             self.scaling = 32
             self.multiplier_signed = False
             self.multiplier_int_width = 1
             self.multiplier_frac_width = 16
             self.offset_signed = True
             self.offset_int_width = 10
             self.offset_frac_width = 6
 
         def init(self):
 
-            super().init_cal("12v")
+            super().init_cal(self.thisChannel)
 
-            #set manual range, full averaging, 12v low current mode, 5V all off (so we can detect we're connected to the wrong channel
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2673.CALIBRATION_CONTROL_ADDR + " 0x00F4")
+            #set manual range, full averaging, [thisChannel] low current mode, other channels all off (so we can detect we're connected to the wrong channel
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CONTROL_ADDRESSES["CALIBRATION_CONTROL"] + " " + self.powerModule.CONTROL_ADDRESSES[self.thisChannel + "_LOW_CALIBRATION_CONTROL_SETTING"])
             # clear the multiplier and offset registers by setting them to zero
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2673.V12_LOW_MULTIPLIER_ADDR + " 0x0000")
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2673.V12_LOW_OFFSET_ADDR + " 0x0000")
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_LOW_MULTIPLIER"] + " 0x0000")
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_LOW_OFFSET"] + " 0x0000")
 
-            self.powerModule.setConnections("12V","12V")
-            # Check Host Power is present          
-            while (super().checkLoadVoltage(QTL2673.LOAD_VOLTAGE,1000) != True):
-                input("Unexpected voltage detected at load, please check connections")
-                self.powerModule.setConnections("12V","12V",reset=True)
+            self.powerModule.host_switchbox.setConnections([("12V",self.thisChannel + '_SUPPLY'),("LOAD",self.thisChannel + '_LOAD')])
+            # Check Host Power is present
+            while (super().checkLoadVoltage(self.powerModule.LOAD_VOLTAGE,1000) != True):
+                showDialog(message="Host Power not detected, please check the connections",title="Check Connections")
+                self.powerModule.host_switchbox.setConnections([("12V",self.thisChannel + '_SUPPLY'),("LOAD",self.thisChannel + '_LOAD')])
 
         def setRef(self,value):
 
             self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
             # read device voltage and add leakage current to the reference
-            voltage =  super().meas_12v_volt()
-            #leakage = voltage*self.powerModule.calibrations["12V"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["12V"]["Leakage"].offset.originalValue()
+            #voltage = getFixtureData(self.powerModule.dut,self.thisChannel + " V")
+            #leakage = voltage*self.powerModule.calibrations["POWER_1"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["POWER_1"]["Leakage"].offset.originalValue()
             return self.powerModule.calInstrument.measureLoadCurrent()*1000000# + leakage
 
         def readVal(self):
 
-            return super().meas_12v_cur()
+            return getFixtureData(self.powerModule.dut,self.thisChannel + " A")
 
         def setCoefficients(self):
 
-            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2673.V12_LOW_MULTIPLIER_ADDR + " " + self.multiplier.hexString(4))
-            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2673.V12_LOW_OFFSET_ADDR + " " + self.offset.hexString(4))
+            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_LOW_MULTIPLIER"] + " " + self.multiplier.hexString(4))
+            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_LOW_OFFSET"] + " " + self.offset.hexString(4))
             if result1 and result2:
                 result = True
             else:
                 result = False
-            logSimpleResult("Set 12v Low Current", result)
+            logSimpleResult("Set " + self.thisChannel + " low current", result)
 
         def finish(self):
 
             super().finish_cal()
 
         def report(self,data):
 
             return super().report("calibrate",data)
 
         def readCoefficients(self):
 
             coefficients = {}
-            # get 12v low current multiplier
-            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + QTL2673.V12_LOW_MULTIPLIER_ADDR)
-            # get 12v low current offset
-            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + QTL2673.V12_LOW_OFFSET_ADDR)
+            # get low current multiplier
+            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_LOW_MULTIPLIER"])
+            # get low current offset
+            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_LOW_OFFSET"])
             return coefficients
 
         def writeCoefficients(self,coefficients):
 
-            # write 12v low current multiplier
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2673.V12_LOW_MULTIPLIER_ADDR + " " + coefficients["multiplier"])
-            # write 12v low current offset
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2673.V12_LOW_OFFSET_ADDR + " " + coefficients["offset"])
+            # write low current multiplier
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_LOW_MULTIPLIER"] + " " + coefficients["multiplier"])
+            # write low current offset
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_LOW_OFFSET"] + " " + coefficients["offset"])
 
-    class QTL2673_12V_HighCurrentCalibration (QTL2673Calibration):
+    class QTL2673_HighCurrentCalibration (QTL2673Calibration):
 
-        def __init__(self,powerModule):
+        def __init__(self,powerModule,thisChannel):
 
-            self.title = "12V High Current Calibration"
+            self.thisChannel = thisChannel
+            self.title = thisChannel + " High Current Calibration"
             self.powerModule = powerModule
-            self.absErrorLimit = 2000   # 2mA
-            self.relErrorLimit = 1      # 1%
-            self.test_min = 1000        # 1mA
-            self.test_max = 4000000     # 4A
+            self.absErrorLimit = 2000               # 2mA
+            self.relErrorLimit = 1                  # 1%
+            self.test_min = 1000                    # 1mA
+            self.test_max = 4000000                 # 4A
             self.test_steps = 20
             self.units = "uA"
             self.scaling = 2048
             self.multiplier_signed = False
             self.multiplier_int_width = 1
             self.multiplier_frac_width = 16
             self.offset_signed = True
             self.offset_int_width = 10
             self.offset_frac_width = 6
 
         def init(self):
 
-            super().init_cal("12v")
-
-            #set manual range, full averaging, 12v high current mode, 5V all off (so we can detect we're connected to the wrong channel
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2673.CALIBRATION_CONTROL_ADDR + " 0x00F8")
-            # clear the multiplier and offset registers by setting them to zero
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2673.V12_HIGH_MULTIPLIER_ADDR + " 0x0000")
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2673.V12_HIGH_OFFSET_ADDR + " 0x0000")
-
-            self.powerModule.setConnections("12V","12V")
-            # Check Host Power is present      
-            while (super().checkLoadVoltage(QTL2673.LOAD_VOLTAGE,1000) != True):
-                input("Unexpected voltage detected at load, please check connections")
-                self.powerModule.setConnections("12V","12V",reset=True)
-
-        def setRef(self,value):
-
-            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
-
-        def readRef(self):
-
-            # read device voltage and add leakage current to the reference
-            voltage =  super().meas_12v_volt()
-            return self.powerModule.calInstrument.measureLoadCurrent()*1000000# + leakage
-
-        def readVal(self):
-
-            return super().meas_12v_cur()
-
-        def setCoefficients(self):
-
-            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2673.V12_HIGH_MULTIPLIER_ADDR + " " + self.multiplier.hexString(4))
-            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2673.V12_HIGH_OFFSET_ADDR + " " + self.offset.hexString(4))
-            if result1 and result2:
-                result = True
-            else:
-                result = False
-            logSimpleResult("Set 12v high current", result)
-
-        def finish(self):
-
-            super().finish_cal()
-
-        def report(self,data):
-
-            return super().report("calibrate",data)
-
-        def readCoefficients(self):
-
-            coefficients = {}
-            # get 12v high current multiplier
-            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + QTL2673.V12_HIGH_MULTIPLIER_ADDR)
-            # get 12v high current offset
-            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + QTL2673.V12_HIGH_OFFSET_ADDR)
-            return coefficients
-
-        def writeCoefficients(self,coefficients):
-
-            # write 12v high current multiplier
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2673.V12_HIGH_MULTIPLIER_ADDR + " " + coefficients["multiplier"])
-            # write 12v high current offset
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2673.V12_HIGH_OFFSET_ADDR + " " + coefficients["offset"])
-
-    class QTL2673_3V3_AUX_VoltageCalibration (QTL2673Calibration):
-
-        def __init__(self,powerModule):
-
-            self.title = "3.3V Aux Voltage Calibration"
-            self.powerModule = powerModule
-            self.absErrorLimit = 2              # 2mV
-            self.relErrorLimit = 1              # 1%
-            self.test_min = 40                  # 40mV
-            self.test_max = 14400               # 14.4V
-            self.test_steps = 20
-            self.units = "mV"
-            self.scaling = 4
-            self.multiplier_signed = False
-            self.multiplier_int_width = 1
-            self.multiplier_frac_width = 16
-            self.offset_signed = True
-            self.offset_int_width = 10
-            self.offset_frac_width = 6
-
-        def init(self):
-
-            super().init_cal("3V3_AUX")
+            super().init_cal(self.thisChannel)
 
+            #set manual range, full averaging, [thisChannel] high current mode, other channels all off (so we can detect we're connected to the wrong channel
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CONTROL_ADDRESSES["CALIBRATION_CONTROL"] + " " + self.powerModule.CONTROL_ADDRESSES[self.thisChannel + "_HIGH_CALIBRATION_CONTROL_SETTING"])
             # clear the multiplier and offset registers by setting them to zero
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2673.V3_3_AUX_VOLT_MULTIPLIER_ADDR + " 0x0000")
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2673.V3_3_AUX_VOLT_OFFSET_ADDR + " 0x0000")
-
-            self.powerModule.setConnections("3V3_AUX",None)
-            ## Check Host Power is not present
-            #while (super().checkLoadVoltage(500,500) != True):
-            #	input("Unexpected voltage detected at load, please check connections")
-            #	self.powerModule.setConnections("3V3_AUX",None,reset=True)
-
-
-        def setRef(self,value):
-
-            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
-
-        def readRef(self):
-
-            return self.powerModule.calInstrument.measureLoadVoltage()*1000
-
-        def readVal(self):
-
-            return super().meas_3v3_aux_volt()
-
-        def setCoefficients(self):
-
-            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2673.V3_3_AUX_VOLT_MULTIPLIER_ADDR + " " + self.multiplier.hexString(4))
-            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2673.V3_3_AUX_VOLT_OFFSET_ADDR + " " + self.offset.hexString(4))
-            if result1 and result2:
-                result = True
-            else:
-                result = False
-            logSimpleResult("Set 3.3v Aux voltage", result)
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_HIGH_MULTIPLIER"] + " 0x0000")
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_HIGH_OFFSET"] + " 0x0000")
 
-        def finish(self):
-
-            super().finish_cal()
-
-        def report(self,data):
-
-            return super().report("calibrate",data)
-
-        def readCoefficients(self):
-
-            coefficients = {}
-            # get 3v3 Aux voltage multiplier
-            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + QTL2673.V3_3_AUX_VOLT_MULTIPLIER_ADDR)
-            # get 3v3 Aux voltage offset
-            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + QTL2673.V3_3_AUX_VOLT_OFFSET_ADDR)
-            return coefficients
-
-        def writeCoefficients(self,coefficients):
-
-            # write 3v3 Aux voltage multiplier
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2673.V3_3_AUX_VOLT_MULTIPLIER_ADDR + " " + coefficients["multiplier"])
-            # write 3v3 Aux voltage offset
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2673.V3_3_AUX_VOLT_OFFSET_ADDR + " " + coefficients["offset"])
-
-    class QTL2673_3V3_AUX_CurrentCalibration (QTL2673Calibration):
-
-        def __init__(self,powerModule):
-
-            self.title = "3.3V Aux Current Calibration"
-            self.powerModule = powerModule
-            self.absErrorLimit = 15         # 15uA
-            self.relErrorLimit = 1          # 1%
-            self.test_min = 10              # 10uA
-            self.test_max = 85000           # 85mA
-            self.test_steps = 20
-            self.units = "uA"
-            self.scaling = 32
-            self.multiplier_signed = False
-            self.multiplier_int_width = 1
-            self.multiplier_frac_width = 16
-            self.offset_signed = True
-            self.offset_int_width = 10
-            self.offset_frac_width = 6
-
-        def init(self):
-
-            super().init_cal("3V3_AUX")
-
-            # clear the multiplier and offset registers by setting them to zero
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2673.V3_3_AUX_MULTIPLIER_ADDR + " 0x0000")
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2673.V3_3_AUX_OFFSET_ADDR + " 0x0000")
-
-            self.powerModule.setConnections("3V3_AUX","3V3_AUX")
-            # Check Host Power is not present	    
-            while (super().checkLoadVoltage(QTL2673.LOAD_VOLTAGE,1000) != True):
-                input("Unexpected voltage detected at load, please check connections")
-                self.powerModule.setConnections("3V3_AUX","3V3_AUX",reset=True)
+            self.powerModule.host_switchbox.setConnections([("12V",self.thisChannel + '_SUPPLY'),("LOAD",self.thisChannel + '_LOAD')])
+            # Check Host Power is present
+            while (super().checkLoadVoltage(self.powerModule.LOAD_VOLTAGE,1000) != True):
+                showDialog(message="Host Power not detected, please check the connections",title="Check Connections")
+                self.powerModule.host_switchbox.setConnections([("12V",self.thisChannel + '_SUPPLY'),("LOAD",self.thisChannel + '_LOAD')])
 
         def setRef(self,value):
 
             self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
             # read device voltage and add leakage current to the reference
-            voltage =  super().meas_3v3_aux_volt()
-            #leakage = voltage*self.powerModule.calibrations["3.3V Aux"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["3.3V Aux"]["Leakage"].offset.originalValue()
+            #voltage =  getFixtureData(self.powerModule.dut,self.thisChannel + " V")
+            #leakage = voltage*self.powerModule.calibrations["POWER_1"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["POWER_1"]["Leakage"].offset.originalValue()
             return self.powerModule.calInstrument.measureLoadCurrent()*1000000# + leakage
 
         def readVal(self):
 
-            return super().meas_3v3_aux_cur()
+            return getFixtureData(self.powerModule.dut,self.thisChannel + " A")
 
         def setCoefficients(self):
 
-            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2673.V3_3_AUX_MULTIPLIER_ADDR + " " + self.multiplier.hexString(4))
-            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2673.V3_3_AUX_OFFSET_ADDR + " " + self.offset.hexString(4))
+            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_HIGH_MULTIPLIER"] + " " + self.multiplier.hexString(4))
+            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_HIGH_OFFSET"] + " " + self.offset.hexString(4))
             if result1 and result2:
                 result = True
             else:
                 result = False
-            logSimpleResult("Set 3.3v Aux low current", result)
-
-            # once we've completed low and high current we can set leakage on the fixture
-            #result = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2673.V3_3_AUX_LEAKAGE_MULTIPLIER_ADDR + " " + self.powerModule.calibrations["3.3V Aux"]["Leakage"].multiplier.hexString(4))
+            logSimpleResult("Set " + self.thisChannel + " high current", result)
 
         def finish(self):
 
             super().finish_cal()
 
         def report(self,data):
 
             return super().report("calibrate",data)
 
         def readCoefficients(self):
 
             coefficients = {}
-            # get 3v3 Aux low current multiplier
-            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + QTL2673.V3_3_AUX_MULTIPLIER_ADDR)
-            # get 3v3 Aux low current offset
-            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + QTL2673.V3_3_AUX_OFFSET_ADDR)
+            # get high current multiplier
+            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_HIGH_MULTIPLIER"])
+            # get high current offset
+            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_HIGH_OFFSET"])
             return coefficients
 
         def writeCoefficients(self,coefficients):
 
-            # write 3v3 Aux low current multiplier
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2673.V3_3_AUX_MULTIPLIER_ADDR + " " + coefficients["multiplier"])
-            # write 3v3 Aux low current offset
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2673.V3_3_AUX_OFFSET_ADDR + " " + coefficients["offset"])
+            # write high current multiplier
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_HIGH_MULTIPLIER"] + " " + coefficients["multiplier"])
+            # write high current offset
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_HIGH_OFFSET"] + " " + coefficients["offset"])
 
-    class QTL2673_12V_VoltageVerification (QTL2673Calibration):
+    class QTL2673_VoltageVerification (QTL2673Calibration):
 
-        def __init__(self,powerModule):
+        def __init__(self,powerModule,thisChannel):
 
-            self.title = "12V Voltage Verification"
+            self.thisChannel = thisChannel
+            self.title = thisChannel + " Voltage Verification"
             self.powerModule = powerModule
             self.absErrorLimit = 2      # 2mV
             self.relErrorLimit = 1      # 1%
             self.test_min = 40          # 40mV
             self.test_max = 14400       # 14.4V
             self.test_steps = 20
             self.units = "mV"
 
         def init(self):
 
-            super().init_cal("12V")
+            super().init_cal(self.thisChannel)
 
-            self.powerModule.setConnections("12V",None)
-            # Check Host Power is not present	    
-            while (super().checkLoadVoltage(500,500) != True):
-            	input("Unexpected voltage detected at load, please check connections")
-            	self.powerModule.setConnections("12V",None,reset=True)
+            self.powerModule.host_switchbox.setConnections([("12V",None),("LOAD",self.thisChannel + "_LOAD")])
 
         def setRef(self,value):
 
             self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
 
         def readRef(self):
 
             return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def readVal(self):
 
-            return super().meas_12v_volt()
+            return getFixtureData(self.powerModule.dut,self.thisChannel + " V")
 
         def finish(self):
 
             super().finish_cal()
 
         def report(self,data):
 
             return super().report("verify",data)
 
-    class QTL2673_12V_LowCurrentVerification (QTL2673Calibration):
+    class QTL2673_LowCurrentVerification (QTL2673Calibration):
 
-        def __init__(self,powerModule):
+        def __init__(self,powerModule,thisChannel):
 
-            self.title = "12V Low Current Verification"
+            self.thisChannel = thisChannel
+            self.title = thisChannel + " Low Current Verification"
             self.powerModule = powerModule
-            self.absErrorLimit = 25     # 2uA
-            self.relErrorLimit = 1      # 1% tolerance
+            self.absErrorLimit = 25     # 25uA  - Deliberately higher than calibration limit
+            self.relErrorLimit = 1      # 1%
             self.test_min = 100         # 100uA
             self.test_max = 1000        # 1mA
             self.test_steps = 20
             self.units = "uA"
 
         def init(self):
 
-            super().init_cal("12V")
+            super().init_cal(self.thisChannel)
 
-            self.powerModule.setConnections("12V","12V")	    
+            self.powerModule.host_switchbox.setConnections([("12V",self.thisChannel + '_SUPPLY'),("LOAD",self.thisChannel + '_LOAD')])
 
             # Check Host Power is present
-            while (super().checkLoadVoltage(QTL2673.LOAD_VOLTAGE,500) != True):
-                input("Unexpected voltage detected at load, please check connections")
-                self.powerModule.setConnections("12V","12V",reset=True)
-            	
+            while (super().checkLoadVoltage(self.powerModule.LOAD_VOLTAGE,1000) != True):
+                showDialog(message="Host Power not detected, please check the connections",title="Check Connections")
+                self.powerModule.host_switchbox.setConnections([("12V",self.thisChannel + '_SUPPLY'),("LOAD",self.thisChannel + '_LOAD')])
+
         def setRef(self,value):
 
             self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
             return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
-            return super().meas_12v_cur()
+            return getFixtureData(self.powerModule.dut,self.thisChannel + " A")
 
         def finish(self):
 
             super().finish_cal()
 
         def report(self,data):
 
             return super().report("verify",data)
 
-    class QTL2673_12V_HighCurrentVerification (QTL2673Calibration):
+    class QTL2673_HighCurrentVerification (QTL2673Calibration):
 
-        def __init__(self,powerModule):
+        def __init__(self,powerModule,thisChannel):
 
-            self.title = "12V High Current Verification"
+            self.thisChannel = thisChannel
+            self.title = thisChannel + " High Current Verification"
             self.powerModule = powerModule
             self.absErrorLimit = 2000       # 2mA
             self.relErrorLimit = 1          # 1% tolerance
             self.test_min = 1000            # 1mA
             self.test_max = 4000000         # 4A
             self.test_steps = 20
             self.units = "uA"
 
         def init(self):
 
-            super().init_cal("12v")
-
-            self.powerModule.setConnections("12V","12V")
-            # Check Host Power is present	    	    
-            while (super().checkLoadVoltage(QTL2673.LOAD_VOLTAGE,500) != True):
-                input("Unexpected voltage detected at load, please check connections")
-                self.powerModule.setConnections("12V","12V",reset=True)
-
-        def setRef(self,value):
-
-            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
-
-        def readRef(self):
-
-            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
-
-        def readVal(self):
-
-            return super().meas_12v_cur()
-
-        def finish(self):
-
-            super().finish_cal()
-
-        def report(self,data):
-
-            return super().report("verify",data)
-
-    class QTL2673_3V3_AUX_VoltageVerification (QTL2673Calibration):
-
-        def __init__(self,powerModule):
-
-            self.title = "3.3V Aux Voltage Verification"
-            self.powerModule = powerModule
-            self.absErrorLimit = 2      # 2mV
-            self.relErrorLimit = 1      # 1%
-            self.test_min = 40          # 40mV
-            self.test_max = 14400       # 14.4V
-            self.test_steps = 20
-            self.units = "mV"
-
-        def init(self):
-
-            super().init_cal("3V3_AUX")
-
-            self.powerModule.setConnections("3V3_AUX",None)
-            # Check Host Power is not present	    
-            while (super().checkLoadVoltage(500,500) != True):
-            	input("Unexpected voltage detected at load, please check connections")
-            	self.powerModule.setConnections("3V3_AUX",None,reset=True)
-            	
-        def setRef(self,value):
-
-            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
-
-        def readRef(self):
-
-            return self.powerModule.calInstrument.measureLoadVoltage()*1000
-
-        def readVal(self):
-
-            return super().meas_3v3_aux_volt()
-
-        def finish(self):
-
-            super().finish_cal()
+            super().init_cal(self.thisChannel)
 
-        def report(self,data):
-
-            return super().report("verify",data)
-
-    class QTL2673_3V3_AUX_CurrentVerification (QTL2673Calibration):
-
-        def __init__(self,powerModule):
-
-            self.title = "3.3V Aux Current Verification"
-            self.powerModule = powerModule
-            self.absErrorLimit = 25     # 25uA
-            self.relErrorLimit = 1      # 1%
-            self.test_min = 100         # 100uA
-            self.test_max = 85000       # 85mA
-            self.test_steps = 20
-            self.units = "uA"
-
-        def init(self):
-
-            super().init_cal("3V3_AUX")
+            self.powerModule.host_switchbox.setConnections([("12V",self.thisChannel + '_SUPPLY'),("LOAD",self.thisChannel + '_LOAD')])
+            # Check Host Power is present
+            while (super().checkLoadVoltage(self.powerModule.LOAD_VOLTAGE,1000) != True):
+                showDialog(message="Host Power not detected, please check the connections",title="Check Connections")
+                self.powerModule.host_switchbox.setConnections([("12V",self.thisChannel + '_SUPPLY'),("LOAD",self.thisChannel + '_LOAD')])
 
-            self.powerModule.setConnections("3V3_AUX","3V3_AUX")
-            # Check Host Power is present	    
-            while (super().checkLoadVoltage(QTL2673.LOAD_VOLTAGE,1000) != True):
-                input("Unexpected voltage detected at load, please check connections")
-                self.powerModule.setConnections("3V3_AUX","3V3_AUX",reset=True)
-    
         def setRef(self,value):
 
             self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
             return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
-            return super().meas_3v3_aux_cur()
+            return getFixtureData(self.powerModule.dut,self.thisChannel + " A")
 
         def finish(self):
 
             super().finish_cal()
 
         def report(self,data):
 
-            return super().report("verify",data)
-
-
-
-    def __init__(self,dut):
-
-        # set the name of this module
-        self.name = "PCIe x16 Power Measurement Fixture"
-        self.dut = dut
-        
-        # Serial numbers (ensure QTL at start)
-        self.enclosureSerial = self.dut.sendCommand("*ENCLOSURE?")
-        if (self.enclosureSerial.find ("QTL") == -1):
-            self.enclosureSerial = "QTL" + self.enclosureSerial
-        # fetch the enclosure position
-        self.enclosurePosition = self.dut.sendCommand("*POSITION?")
-        self.PAMSerial = self.dut.sendCommand ("*SERIAL?")
-        if (self.PAMSerial.find ("QTL") == -1):
-            self.PAMSerial = "QTL" + self.PAMSerial
-        # Fixture Serial
-        # fixture serial is retrieved as BCD, we need to convert and pad it
-        self.FixtureSerial = "QTL" + bcdString(dut.sendCommand("read 0xA102"),4) + "-" + bcdString(dut.sendCommand("read 0xA103"),2) + "-" + bcdString(dut.sendCommand("read 0xA104"),3) # TODO: this should be replaced with fix:serial? command when implemented
-        # calObjectSerial Serial
-        self.calObjectSerial = self.FixtureSerial
-        # Filename String
-        self.filenameString = self.FixtureSerial
-        # Code version (FPGA)
-        self.idnStr = dut.sendCommand ("*IDN?")
-        pos = self.idnStr.upper().find ("FPGA 1:")
-        if (pos != -1):
-            versionStr = self.idnStr[pos+7:]
-            pos = versionStr.find ("\n")
-            if (pos != -1):
-                versionStr = versionStr[:pos].strip()
-            else:
-                pass
-        else:
-            versionStr = "NOT-FOUND"    
-        self.Fpga = versionStr.strip()
-    
-        # Code version (FW)    
-        pos = self.idnStr.upper().find ("PROCESSOR:")
-        if (pos != -1):
-            versionStr = self.idnStr[pos+10:]
-            pos = versionStr.find ("\n")
-            if (pos != -1):
-                versionStr = versionStr[:pos].strip()            
-            else:
-                pass
-        else:
-            versionStr = "NOT-FOUND"    
-        self.Firmware = versionStr.strip()
-
-        self.calibrations = {}
-        # populate 12V channel with calibrations
-        self.calibrations["12V"] = {
-            "Voltage":self.QTL2673_12V_VoltageCalibration(self),
-            #"Leakage":self.QTL2673_12V_LeakageCalibration(self),
-            "Low Current":self.QTL2673_12V_LowCurrentCalibration(self),
-            "High Current":self.QTL2673_12V_HighCurrentCalibration(self)
-            }
-			
-        # populate 3V3_AUX channel with calibrations
-        self.calibrations["3.3V Aux"] = {
-            "Voltage":self.QTL2673_3V3_AUX_VoltageCalibration(self),
-            #"Leakage":self.QTL2673_3V3_AUX_LeakageCalibration(self),
-            "Current":self.QTL2673_3V3_AUX_CurrentCalibration(self)
-            }
-
-        self.verifications = {}
-        # populate 12V channel with verifications
-        self.verifications["12V"] = {
-            "Voltage":self.QTL2673_12V_VoltageVerification(self),
-            "Low Current":self.QTL2673_12V_LowCurrentVerification(self),
-            "High Current":self.QTL2673_12V_HighCurrentVerification(self)
-            }
-        
-        # populate 3V3_AUX channel with verifications
-        self.verifications["3.3V Aux"] = {
-            "Voltage":self.QTL2673_3V3_AUX_VoltageVerification(self),
-            "Current":self.QTL2673_3V3_AUX_CurrentVerification(self)
-            }
-
+            return super().report("verify",data)
```

## Comparing `quarchCalibration/QTL2674.py` & `quarchCalibration/QTL2626_4ch_mezz.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,37 +1,34 @@
 '''
 Quarch Power Module Calibration Functions
 Written for Python 3.6 64 bit
 
 M Dearman April 2019
-Edited k McRobert September 2021
 '''
 
 '''
 Calibration Flow
-    Connect to PAM Fixture 
+    Connect to PPM
     Connect to Keithley
     step through a set of values and get ADC vs Reference Value
     evaluate results vs defined limits
 
 '''
 
 #Imports QuarchPy library, providing the functions needed to use Quarch modules
-#from quarchpy import quarchDevice #, scanDevices
-
-# Import other libraries used in the examples
-
 from .PowerModuleCalibration import *
 from .calibrationConfig import *
 from .keithley_2460_control import *
+from .QTL2536_6_way_switchbox import *
 from quarchpy.device.device import *
 from quarchpy.device.scanDevices import userSelectDevice
 from quarchpy.user_interface import *
 from quarchpy.user_interface import logSimpleResult
 from quarchpy.utilities.BitManipulation import *
+from .pamHelpers import bcdString
 
 def parseFixtureData(response,start,length):
 
     # split the multiline response into a list
     response = response.splitlines()
     result = ""
     # for each line
@@ -51,103 +48,199 @@
 
 
 def getFixtureData(device,channel):
     #hold measurement
     response = device.sendCommand("read 0x0000")
     device.sendCommand("write 0x0000 " + setBit(response,3))
     #read measurement
-    data = device.sendCommand("read 0x1000 to 0x1007")
+    data = device.sendCommand("read 0x1000 to 0x1008")
     #release measurement
     response = device.sendCommand("read 0x0000")
     device.sendCommand("write 0x0000 " + clearBit(response,3))
 
-    if (channel == "12V VOLT"):
+    if (channel == "POWER_1 V"):
         return parseFixtureData(data,0,16)
-    elif (channel == "12V CUR"):
-        return parseFixtureData(data,16,25)
-    elif (channel == "3V3_AUX VOLT"):
-        return parseFixtureData(data,41,16)
-    elif (channel == "3V3_AUX CUR"):
-        return parseFixtureData(data,57,20)
-
-def bcdString(bcd,padding):
-    # strip off "0x" if present
-    if bcd[:2] == "0x":
-        bcd = bcd [2:]
-    # strip off leading 0's
-    # loop while we have more the required minimum number of characters left
-    while(len(bcd)>padding):
-        # if the leading character is 0, remove it
-        if bcd[0] == '0':
-            bcd = bcd[1:]
-        # else exit loop
-        else:
-            break
-    return bcd
+    elif (channel == "POWER_1 A"):
+        return parseFixtureData(data,16,16)
+    elif (channel == "POWER_2 V"):
+        return parseFixtureData(data,32,16)
+    elif (channel == "POWER_2 A"):
+        return parseFixtureData(data,48,16)
+    elif (channel == "POWER_3 V"):
+        return parseFixtureData(data,64,16)
+    elif (channel == "POWER_3 A"):
+        return parseFixtureData(data,80,16)
+    elif (channel == "POWER_4 V"):
+        return parseFixtureData(data,96,16)
+    elif (channel == "POWER_4 A"):
+        return parseFixtureData(data,112,16)
 
 
-class QTL2674 (PowerModule):
+class QTL2626 (PowerModule):
 
     # Fixture Register Addresses
-    CALIBRATION_MODE_ADDR               = '0xA100'
-    CALIBRATION_CONTROL_ADDR            = '0xA101'      
-    
-    V12_LOW_MULTIPLIER_ADDR             = '0xA10C'
-    V12_LOW_OFFSET_ADDR                 = '0xA10D'
-    V12_HIGH_MULTIPLIER_ADDR            = '0xA10E'
-    V12_HIGH_OFFSET_ADDR                = '0xA10F'
-    V12_VOLT_MULTIPLIER_ADDR            = '0xA110'
-    V12_VOLT_OFFSET_ADDR                = '0xA111'
-    V12_LEAKAGE_MULTIPLIER_ADDR         = '0xA112'
-	
-    V3_3_AUX_MULTIPLIER_ADDR            = '0xA113'
-    V3_3_AUX_OFFSET_ADDR                = '0xA114'
-    V3_3_AUX_VOLT_MULTIPLIER_ADDR       = '0xA115'
-    V3_3_AUX_VOLT_OFFSET_ADDR           = '0xA116'
-    V3_3_AUX_LEAKAGE_MULTIPLIER_ADDR    = '0xA117'
-    CALIBRATION_COMPLETE_ADDR	        = '0xA118'
+    CAL_ADDRESSES = {
+    'CALIBRATION_MODE'              : '0xA100',
+    'CALIBRATION_CONTROL'           : '0xA101',      
+    'POWER_1_VOLT_MULTIPLIER'       : '0xA105',
+    'POWER_1_VOLT_OFFSET'           : '0xA106',
+    'POWER_1_CURR_MULTIPLIER'       : '0xA107',
+    'POWER_1_CURR_OFFSET'           : '0xA108',
+    #'POWER_1_LEAKAGE_MULTIPLIER'   : '0xA109', -- Not required in Mezzanine
+    'POWER_2_VOLT_MULTIPLIER'       : '0xA10A',
+    'POWER_2_VOLT_OFFSET'           : '0xA10B',
+    'POWER_2_CURR_MULTIPLIER'       : '0xA10C',
+    'POWER_2_CURR_OFFSET'           : '0xA10D',
+    #'POWER_2_LEAKAGE_MULTIPLIER'   : '0xA10E', -- Not required in Mezzanine
+    'POWER_3_VOLT_MULTIPLIER'       : '0xA10F',
+    'POWER_3_VOLT_OFFSET'           : '0xA110',
+    'POWER_3_CURR_MULTIPLIER'       : '0xA111',
+    'POWER_3_CURR_OFFSET'           : '0xA112',
+    #'POWER_3_LEAKAGE_MULTIPLIER'   : '0xA113', -- Not required in Mezzanine
+    'POWER_4_VOLT_MULTIPLIER'       : '0xA114',
+    'POWER_4_VOLT_OFFSET'           : '0xA115',
+    'POWER_4_CURR_MULTIPLIER'       : '0xA116',
+    'POWER_4_CURR_OFFSET'           : '0xA117',
+    'CALIBRATION_COMPLETE'          : '0xA118'
+    }
     LOAD_VOLTAGE                        = 12000
 
+    host_switchbox_title = "12V Switchbox"
+    host_switchbox_message = "Select the switch box which connects a 12V supply to POWER IN:"
+    host_switchbox_mapping = {'12V':'A','POWER_1_IN':'1','POWER_2_IN':'2','POWER_3_IN':'3','POWER_4_IN':'4'}
+
+    load_switchbox_title = "Load Switchbox"
+    load_switchbox_message = "Select the switch box which connects a Keithley 2460 SourceMeter to POWER OUT:"
+    load_switchbox_mapping = {'LOAD':'A','POWER_1_OUT':'1','POWER_2_OUT':'2','POWER_3_OUT':'3','POWER_4_OUT':'4'}
+
     # Fixture Information
     PAMSerial = None
     FixtureSerial = None
     calObjectSerial = None     # The serial number of the device that is being calibrated, i.e QTL1944 in HD PPM, Fixture in PAM
     idnStr = None
     Firmware = None
     Fpga = None
     calInstrument = None
     calInstrumentId = None
-    switchbox = None
-
-    # Physical Connection Tracking (what is plugged to what)
-    loadChannel = None
-    hostPowerChannel = None
-
-    # defigning the connection
-    hostPort = "A"
-    loadPort = "B"
-    loadConnectionPortDict = {"12V": "4", "3V3_AUX": "6"}
-    hostConnectionPortDict = {"12V": "1", "3V3_AUX": "3"}
-
-    # general
+    host_switchbox = None
+    load_switchbox = None
     waitComplete = False
     checkedWiring = False
 
+    def __init__(self,dut):
+
+        # set the name of this module
+        self.name = "4-Channel Power Measurement Fixture"
+        self.dut = dut
+        
+        # Serial numbers (ensure QTL at start)
+        self.enclosureSerial = self.dut.sendCommand("*ENCLOSURE?")
+        if (self.enclosureSerial.find ("QTL") == -1):
+            self.enclosureSerial = "QTL" + self.enclosureSerial
+        # fetch the enclosure position
+        self.enclosurePosition = self.dut.sendCommand("*POSITION?")
+        self.PAMSerial = self.dut.sendCommand ("*SERIAL?")
+        if (self.PAMSerial.find ("QTL") == -1):
+            self.PAMSerial = "QTL" + self.PAMSerial
+        # Fixture Serial
+        # fixture serial is retrieved as BCD, we need to convert and pad it
+        self.FixtureSerial = "QTL" + bcdString(dut.sendCommand("read 0xA102"),4) + "-" + bcdString(dut.sendCommand("read 0xA103"),2) + "-" + bcdString(dut.sendCommand("read 0xA104"),3) # TODO: this should be replaced with fix:serial? command when implemented
+        # calObjectSerial Serial
+        self.calObjectSerial = self.FixtureSerial
+        # Filename String
+        self.filenameString = self.FixtureSerial
+        # Code version (FPGA)
+        self.idnStr = dut.sendCommand ("*IDN?")
+        pos = self.idnStr.upper().find ("FPGA 1:")
+        if (pos != -1):
+            versionStr = self.idnStr[pos+7:]
+            pos = versionStr.find ("\n")
+            if (pos != -1):
+                versionStr = versionStr[:pos].strip()
+            else:
+                pass
+        else:
+            versionStr = "NOT-FOUND"    
+        self.Fpga = versionStr.strip()
+    
+        # Code version (FW)    
+        pos = self.idnStr.upper().find ("PROCESSOR:")
+        if (pos != -1):
+            versionStr = self.idnStr[pos+10:]
+            pos = versionStr.find ("\n")
+            if (pos != -1):
+                versionStr = versionStr[:pos].strip()            
+            else:
+                pass
+        else:
+            versionStr = "NOT-FOUND"    
+        self.Firmware = versionStr.strip()
+
+        self.calibrations = {}
+        # populate POWER_1 channel with calibrations
+        self.calibrations["POWER_1"] = {
+            "Voltage":self.QTL2626_VoltageCalibration(self,"POWER_1"),
+            "Current":self.QTL2626_CurrentCalibration(self,"POWER_1")
+            }
+        # populate POWER_2 channel with calibrations
+        self.calibrations["POWER_2"] = {
+            "Voltage":self.QTL2626_VoltageCalibration(self,"POWER_2"),
+            "Current":self.QTL2626_CurrentCalibration(self,"POWER_2")
+            }
+        # populate POWER_3 channel with calibrations
+        self.calibrations["POWER_3"] = {
+            "Voltage":self.QTL2626_VoltageCalibration(self,"POWER_3"),
+            "Current":self.QTL2626_CurrentCalibration(self,"POWER_3")
+            }
+        # populate POWER_4 channel with calibrations
+        self.calibrations["POWER_4"] = {
+            "Voltage":self.QTL2626_VoltageCalibration(self,"POWER_4"),
+            "Current":self.QTL2626_CurrentCalibration(self,"POWER_4")
+            }
+
+        self.verifications = {}
+        # populate POWER_1 channel with verifications
+        self.verifications["POWER_1"] = {
+            "Voltage":self.QTL2626_VoltageVerification(self,"POWER_1"),
+            "Current":self.QTL2626_CurrentVerification(self,"POWER_1")
+            }
+        self.verifications["POWER_2"] = {
+            "Voltage":self.QTL2626_VoltageVerification(self,"POWER_2"),
+            "Current":self.QTL2626_CurrentVerification(self,"POWER_2")
+            }
+        self.verifications["POWER_3"] = {
+            "Voltage":self.QTL2626_VoltageVerification(self,"POWER_3"),
+            "Current":self.QTL2626_CurrentVerification(self,"POWER_3")
+            }
+        self.verifications["POWER_4"] = {
+            "Voltage":self.QTL2626_VoltageVerification(self,"POWER_4"),
+            "Current":self.QTL2626_CurrentVerification(self,"POWER_4")
+            }
+
     def specific_requirements(self):
 
         reportText=""
 
-        # select a switchbox to use for calibration
-        if "switchbox" in calibrationResources.keys():
-            self.switchbox = calibrationResources["switchbox"]
-        self.switchbox = self.getSwitchbox()
-        calibrationResources["switchbox"] = self.switchbox
+        # select the host switchbox to use for calibration
+        if "host_switchbox" in calibrationResources.keys():
+            self.host_switchbox = calibrationResources["host_switchbox"]
+        else:
+            self.host_switchbox = self.get_switchbox(self.host_switchbox_message,self.host_switchbox_title,self.host_switchbox_mapping)
+            calibrationResources["host_switchbox"] = self.host_switchbox
 
+        # select the load switchbox to use for calibration
+        if "load_switchbox" in calibrationResources.keys():
+            self.load_switchbox = calibrationResources["load_switchbox"]
+        else:
+            self.load_switchbox = self.get_switchbox(self.load_switchbox_message,self.load_switchbox_title,self.load_switchbox_mapping)
+            calibrationResources["load_switchbox"] = self.load_switchbox
+        
         if self.checkedWiring != True:
-            self.checkWiring()
+            self.host_switchbox.checkWiring()
+            self.load_switchbox.checkWiring()
             self.checkedWiring = True
 
         # Select a Keithley SMU
         # If no calibration instrument is provided, request it
         while (True):
             if (calibrationResources["loadString"] == None):
                 loadString = userSelectCalInstrument(scanFilterStr="Keithley 2460", nice=True)
@@ -179,191 +272,133 @@
         reportText += "FW:" + self.Firmware + ", FPGA: " + self.Fpga + "\n"
         reportText += "\n"
         reportText += "Calibration Instruments#:\n"
         reportText += self.calInstrumentId + "\n"
 
         # perform uptime check and write to file
         if self.waitComplete != True:
-            reportText += self.wait_for_up_time(desired_up_time=600, command="conf:runtime:fix:sec?")
+            reportText += self.wait_for_up_time(desired_up_time=600)
             self.waitComplete = True
 
         return reportText
 
-    def setConnections(self,loadConnection,hostPowerConnection,reset=False):
-    #TODO Fix for using class variable.
-        if reset:
-            self.loadChannel = None
-            self.hostPowerChannel = None
-
-        # If current connections are correct
-        if self.loadChannel == loadConnection and self.hostPowerChannel == hostPowerConnection:
-            # do nothing
-            pass
-
-        # else connections need to change
-        else:
-
-            # we can't turn an individual port off (at the moment) so we turn both off first, then set anything that needs setting
-            if loadConnection == None or hostPowerConnection == None:
-                response = self.switchbox.sendCommand("connect off")
-                if response != "OK": raise ConnectionError("Switchbox command failed")
-
-            if loadConnection != None:
-                response = self.switchbox.sendCommand("connect " + self.loadPort + " " + self.loadConnectionPortDict[loadConnection])
-                if response != "OK": raise ConnectionError("Switchbox command failed")
-				
-            if hostPowerConnection != None:
-                response = self.switchbox.sendCommand("connect " + self.hostPort + " " + self.hostConnectionPortDict[hostPowerConnection])
-                if response != "OK": raise ConnectionError("Switchbox command failed")
+    def open_module(self):
 
-        self.loadChannel = loadConnection
-        self.hostPowerChannel = hostPowerConnection
+        # set unit into calibration mode
+        self.dut.sendCommand("write " + self.CAL_ADDRESSES["CALIBRATION_MODE"] + " 0xaa55")
+        self.dut.sendCommand("write " + self.CAL_ADDRESSES["CALIBRATION_MODE"] + " 0x55aa")
 
-    def getSwitchbox(self):
+    def get_switchbox(self,msg,name,portDict):
         # CheckSwitchbox
-        if self.switchbox is None:
-            while (True):
-                switchboxAddress = userSelectDevice(scanFilterStr=["QTL2536"], message="Select a calibration 6 Way Test Lead Switch.", nice=True)
-                if switchboxAddress == "quit":
-                    printText("User Quit Program")
-                    sys.exit(0)
-                try:
-                    self.switchbox = quarchDevice(switchboxAddress)
-                    break
-                except:
-                    printText("Unable to communicate with selected device!")
-                    printText("")
-                    switchboxAddress = None
-                    raise
-        return self.switchbox
+        while (True):
+            switchboxAddress = userSelectDevice(scanFilterStr=["QTL2536"], message=msg, nice=True)
+            if switchboxAddress == "quit":
+                printText("User Quit Program")
+                sys.exit(0)
+            try:
+                switchbox = QTL2536_6_way_switchbox(switchboxAddress,name,portDict)
+                break
+            except:
+                printText("Unable to communicate with selected device!")
+                printText("")
+                switchboxAddress = None
+                raise
+        return switchbox
 
 
     def clear_calibration(self):
 
         # set unit into calibration mode
-        self.dut.sendCommand("write " + QTL2674.CALIBRATION_MODE_ADDR + " 0xaa55")
-        self.dut.sendCommand("write " + QTL2674.CALIBRATION_MODE_ADDR + " 0x55aa")
+        self.dut.sendCommand("write " + self.CAL_ADDRESSES["CALIBRATION_MODE"] + " 0xaa55")
+        self.dut.sendCommand("write " + self.CAL_ADDRESSES["CALIBRATION_MODE"] + " 0x55aa")
 
         # clear all calibration registers
-      
-        self.dut.sendAndVerifyCommand("write " + QTL2674.V12_VOLT_OFFSET_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2674.V12_VOLT_MULTIPLIER_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2674.V12_LOW_OFFSET_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2674.V12_LOW_MULTIPLIER_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2674.V12_HIGH_OFFSET_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2674.V12_HIGH_MULTIPLIER_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2674.V12_LEAKAGE_MULTIPLIER_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2674.V3_3_AUX_VOLT_OFFSET_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2674.V3_3_AUX_VOLT_MULTIPLIER_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2674.V3_3_AUX_OFFSET_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2674.V3_3_AUX_MULTIPLIER_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2674.V3_3_AUX_LEAKAGE_MULTIPLIER_ADDR + " 0x0000")
+        for address in self.CAL_ADDRESSES.values():
+            self.dut.sendAndVerifyCommand("write " + address + " 0x0000")
         
         # write 0xaa55 to register to calibration complete register to tell module it is calibrated
-        self.dut.sendAndVerifyCommand("write " + QTL2674.CALIBRATION_COMPLETE_ADDR + " 0xaa55")
+        self.dut.sendAndVerifyCommand("write " + self.CAL_ADDRESSES["CALIBRATION_COMPLETE"] + " 0xaa55")
         
     def write_calibration(self):
 
         # write the calibration registers
         # erase the tag memory
         printText("Erasing TAG memory..")
         self.dut.sendCommand("write 0xa200 0x0020")
         # TODO: should check for completion here...
         # wait for 2 seconds for erase to complete
         # check busy
         while checkBit(self.dut.sendCommand("read 0xa200"),8):
-            sleep(0.1)
+            time.sleep(0.1)
         # write the tag memory
         printText("Programming TAG memory...")
         self.dut.sendCommand("write 0xa200 0x0040")        
         # check busy
         while checkBit(self.dut.sendCommand("read 0xa200"),8):
-            sleep(0.1)
+            time.sleep(0.1)
 
     def close_module(self):
 
         # reset the fixture FPGA
         self.dut.sendCommand("fixture:reset")
 
         #close the connection to the calibration instrument
         self.calInstrument.closeConnection()
 
     def close_all(self):
 
         #close all attached devices
         self.calInstrument.setLoadCurrent(0)
         self.calInstrument.closeConnection()
-        self.powerModule.setConnections(None,None)
+        self.host_switchbox.sendCommand("connect off")
+        self.load_switchbox.sendCommand("connect off")
 
-    class QTL2674Calibration (Calibration):
+    class QTL2626Calibration (Calibration):
 
         def __init__(self):
             super().__init__()
 
         def init_cal(self,voltage):
 
             # TODO: No Power control at the moment
             # power up
             #self.powerModule.dut.sendAndVerifyCommand("power up")
 
             # set averaging to max
             self.powerModule.dut.sendAndVerifyCommand("rec:ave 32k")
 
-            #Turn off compression and power up
-            self.powerModule.dut.sendAndVerifyCommand("write 0xA010 0x0011")
-
             # set module into calibration mode (again?)
-            self.powerModule.dut.sendCommand("write " + QTL2674.CALIBRATION_MODE_ADDR + " 0xaa55")   # will not verify
-            self.powerModule.dut.sendCommand("write " + QTL2674.CALIBRATION_MODE_ADDR + " 0x55aa")   # will not verify
+            self.powerModule.dut.sendCommand("write " + self.powerModule.CAL_ADDRESSES["CALIBRATION_MODE"] + " 0xaa55")   # will not verify
+            self.powerModule.dut.sendCommand("write " + self.powerModule.CAL_ADDRESSES["CALIBRATION_MODE"] + " 0x55aa")   # will not verify
 
             #Reset Keithley
             self.powerModule.calInstrument.reset()
 
-        def meas_12v_volt(self):
-
-            result = getFixtureData(self.powerModule.dut,"12V VOLT")
-            return result
-
-        def meas_12v_cur(self):
-
-            result = getFixtureData(self.powerModule.dut,"12V CUR")
-            return result
-
-        def meas_3v3_aux_volt(self):
-
-            result = getFixtureData(self.powerModule.dut,"3V3_AUX VOLT")
-            return result
-
-        def meas_3v3_aux_cur(self):
-
-            result = getFixtureData(self.powerModule.dut,"3V3_AUX CUR")
-            return result
-
         # check connections to host power and load
         def checkLoadVoltage(self,voltage,tolerance):
 
-            #self.powerModule.calInstrument.setReferenceCurrent(0)
-            self.powerModule.calInstrument.setReferenceVoltage(voltage/1000,"1e-6")  # set Keithley to the required voltage but limit current to 1uA
-            result = self.powerModule.calInstrument.measureLoadVoltage()*1000   # *1000 because we use mV but keithley uses volts
+            self.powerModule.calInstrument.setReferenceCurrent(0)
+            result = self.powerModule.calInstrument.measureLoadVoltage()*1000    # *1000 because we use mV but keithley uses volts
             # check result is in required range
             if (result >= voltage-tolerance) and (result <= voltage+tolerance):
                 return True
             else:
                 return False
 
         def finish_cal(self):
 
             #turn off load
             self.powerModule.calInstrument.disable()
 
             #turn off switch
-            self.powerModule.setConnections(None,None)
+            self.powerModule.host_switchbox.setConnections([]) #sendCommand("connect off")
+            self.powerModule.load_switchbox.setConnections([]) #sendCommand("connect off")
 
             # turn dut to autoranging
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2674.CALIBRATION_CONTROL_ADDR + " 0x00F0")
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES["CALIBRATION_CONTROL"] + " 0x00F0")
 
         def report(self,action,data):
 
             report = []
 
             # send to report file
             report.append("          Pass Level  +/-(" + str(self.absErrorLimit) + str(self.units) +" + " + str(self.relErrorLimit) + "%) \n")
@@ -430,19 +465,20 @@
             report.append("\n\n\n")
             
             #Add to Test Summary? Do this here?
             passfail = lambda x: "Passed" if x else "Failed"
 
             return {"title":self.title,"result":overallResult,"worst case":worstCase,"report":('\n'.join(report))}
 
-    class QTL2674_12V_VoltageCalibration (QTL2674Calibration):
+    class QTL2626_VoltageCalibration (QTL2626Calibration):
 
-        def __init__(self,powerModule):
+        def __init__(self,powerModule,thisChannel):
 
-            self.title = "12V Voltage Calibration"
+            self.thisChannel = thisChannel
+            self.title = thisChannel + " Voltage Calibration"
             self.powerModule = powerModule
             self.absErrorLimit = 2                  # 2mV
             self.relErrorLimit = 1                  # 1%
             self.test_min = 40                      # 40mV
             self.test_max = 14400                   # 14.4V
             self.test_steps = 20
             self.units = "mV"
@@ -452,698 +488,247 @@
             self.multiplier_frac_width = 16
             self.offset_signed = True
             self.offset_int_width = 10
             self.offset_frac_width = 6
 
         def init(self):
 
-            super().init_cal("12v")
+            super().init_cal(self.thisChannel)
 
             # clear the multiplier and offset registers by setting them to zero
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2674.V12_VOLT_MULTIPLIER_ADDR + " 0x0000")
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2674.V12_VOLT_OFFSET_ADDR + " 0x0000")
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_VOLT_MULTIPLIER"] + " 0x0000")
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_VOLT_OFFSET"] + " 0x0000")
 
-            self.powerModule.setConnections("12V",None)
-            ## Check Host Power is not present        
+            self.powerModule.host_switchbox.setConnections([("12V",None)])
+            self.powerModule.load_switchbox.setConnections([("LOAD",self.thisChannel + '_OUT')])
+
+            # Check Host Power is present
             #while (super().checkLoadVoltage(500,500) != True):
-            #    input("Unexpected voltage detected at load, please check connections")
-            #    self.powerModule.setConnections("12V",None,reset=True)
+            #    self.powerModule.setConnections("POWER_1",None,reset=True)
 
         def setRef(self,value):
 
-            return load_set_volt(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
 
         def readRef(self):
 
-            return load_meas_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def readVal(self):
 
-            return super().meas_12v_volt()
+            return getFixtureData(self.powerModule.dut,self.thisChannel + " V")
 
         def setCoefficients(self):
 
-            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2674.V12_VOLT_MULTIPLIER_ADDR + " " + self.multiplier.hexString(4))
-            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2674.V12_VOLT_OFFSET_ADDR + " " + self.offset.hexString(4))
+            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_VOLT_MULTIPLIER"] + " " + self.multiplier.hexString(4))
+            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_VOLT_OFFSET"] + " " + self.offset.hexString(4))
             if result1 and result2:
                 result = True
             else:
                 result = False
-            logSimpleResult("Set 12v voltage", result)
+            logSimpleResult("Set " + self.thisChannel + " voltage", result)
 
         def finish(self):
 
             super().finish_cal()
 
         def report(self,data):
 
             return super().report("calibrate",data)
 
         def readCoefficients(self):
 
             coefficients = {}
-            # get 12v voltage multiplier
-            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + QTL2674.V12_VOLT_MULTIPLIER_ADDR)
-            # get 12v voltage offset
-            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + QTL2674.V12_VOLT_OFFSET_ADDR)
+            # get POWER_1 voltage multiplier
+            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_VOLT_MULTIPLIER"])
+            # get POWER_1 voltage offset
+            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_VOLT_OFFSET"])
             return coefficients
 
         def writeCoefficients(self,coefficients):
 
-            # write 12v voltage multiplier
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2674.V12_VOLT_MULTIPLIER_ADDR + " " + coefficients["multiplier"])
-            # write 12v voltage offset
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2674.V12_VOLT_OFFSET_ADDR + " " + coefficients["offset"])
+            # write POWER_1 voltage multiplier
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_VOLT_MULTIPLIER"] + " " + coefficients["multiplier"])
+            # write POWER_1 voltage offset
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_VOLT_OFFSET"] + " " + coefficients["offset"])
 
-    class QTL2674_12V_LowCurrentCalibration (QTL2674Calibration):
+    class QTL2626_CurrentCalibration (QTL2626Calibration):
 
-        def __init__(self,powerModule):
+        def __init__(self,powerModule,thisChannel):
 
-            self.title = "12V Low Current Calibration"
+            self.thisChannel = thisChannel
+            self.title = thisChannel + " Current Calibration"
             self.powerModule = powerModule
-            self.absErrorLimit = 15                 # 15uA
+            self.absErrorLimit = 10                 # 10mA
             self.relErrorLimit = 1                  # 1%
-            self.test_min = 10          # 10uA
-            self.test_max = 85000       # 85mA
+            self.test_min = 10                      # 10mA
+            self.test_max = 4000                    # 4000mA
             self.test_steps = 20
-            self.units = "uA"
-            self.scaling = 32
-            self.multiplier_signed = False
-            self.multiplier_int_width = 1
-            self.multiplier_frac_width = 16
-            self.offset_signed = True
-            self.offset_int_width = 10
-            self.offset_frac_width = 6
-
-        def init(self):
-
-            super().init_cal("12v")
-
-            #set manual range, full averaging, 12v low current mode, 5V all off (so we can detect we're connected to the wrong channel
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2674.CALIBRATION_CONTROL_ADDR + " 0x00F4")
-            # clear the multiplier and offset registers by setting them to zero
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2674.V12_LOW_MULTIPLIER_ADDR + " 0x0000")
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2674.V12_LOW_OFFSET_ADDR + " 0x0000")
-
-            self.powerModule.setConnections("12V","12V")
-            # Check Host Power is present          
-            while (super().checkLoadVoltage(QTL2674.LOAD_VOLTAGE,1000) != True):
-                input("Unexpected voltage detected at load, please check connections")
-                self.powerModule.setConnections("12V","12V",reset=True)
-
-        def setRef(self,value):
-
-            load_set_cur(self.powerModule.calInstrument,value)
-
-        def readRef(self):
-
-            # read device voltage and add leakage current to the reference
-            voltage =  super().meas_12v_volt()
-            #leakage = voltage*self.powerModule.calibrations["12V"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["12V"]["Leakage"].offset.originalValue()
-            return load_meas_cur(self.powerModule.calInstrument)# + leakage
-
-        def readVal(self):
-
-            return super().meas_12v_cur()
-
-        def setCoefficients(self):
-
-            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2674.V12_LOW_MULTIPLIER_ADDR + " " + self.multiplier.hexString(4))
-            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2674.V12_LOW_OFFSET_ADDR + " " + self.offset.hexString(4))
-            if result1 and result2:
-                result = True
-            else:
-                result = False
-            logSimpleResult("Set 12v Low Current", result)
-
-        def finish(self):
-
-            super().finish_cal()
-
-        def report(self,data):
-
-            return super().report("calibrate",data)
-
-        def readCoefficients(self):
-
-            coefficients = {}
-            # get 12v low current multiplier
-            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + QTL2674.V12_LOW_MULTIPLIER_ADDR)
-            # get 12v low current offset
-            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + QTL2674.V12_LOW_OFFSET_ADDR)
-            return coefficients
-
-        def writeCoefficients(self,coefficients):
-
-            # write 12v low current multiplier
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2674.V12_LOW_MULTIPLIER_ADDR + " " + coefficients["multiplier"])
-            # write 12v low current offset
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2674.V12_LOW_OFFSET_ADDR + " " + coefficients["offset"])
-
-    class QTL2674_12V_HighCurrentCalibration (QTL2674Calibration):
-
-        def __init__(self,powerModule):
-
-            self.title = "12V High Current Calibration"
-            self.powerModule = powerModule
-            self.absErrorLimit = 2000   # 2mA
-            self.relErrorLimit = 1      # 1%
-            self.test_min = 1000        # 1mA
-            self.test_max = 4000000     # 4A
-            self.test_steps = 20
-            self.units = "uA"
-            self.scaling = 2048
-            self.multiplier_signed = False
-            self.multiplier_int_width = 1
-            self.multiplier_frac_width = 16
-            self.offset_signed = True
-            self.offset_int_width = 10
-            self.offset_frac_width = 6
-
-        def init(self):
-
-            super().init_cal("12v")
-
-            #set manual range, full averaging, 12v high current mode, 5V all off (so we can detect we're connected to the wrong channel
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2674.CALIBRATION_CONTROL_ADDR + " 0x00F8")
-            # clear the multiplier and offset registers by setting them to zero
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2674.V12_HIGH_MULTIPLIER_ADDR + " 0x0000")
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2674.V12_HIGH_OFFSET_ADDR + " 0x0000")
-
-            self.powerModule.setConnections("12V","12V")
-            # Check Host Power is present      
-            while (super().checkLoadVoltage(QTL2674.LOAD_VOLTAGE,1000) != True):
-                input("Unexpected voltage detected at load, please check connections")
-                self.powerModule.setConnections("12V","12V",reset=True)
-
-        def setRef(self,value):
-
-            load_set_cur(self.powerModule.calInstrument,value)
-
-        def readRef(self):
-
-            # read device voltage and add leakage current to the reference
-            voltage =  super().meas_12v_volt()
-            return load_meas_cur(self.powerModule.calInstrument)# + leakage
-
-        def readVal(self):
-
-            return super().meas_12v_cur()
-
-        def setCoefficients(self):
-
-            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2674.V12_HIGH_MULTIPLIER_ADDR + " " + self.multiplier.hexString(4))
-            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2674.V12_HIGH_OFFSET_ADDR + " " + self.offset.hexString(4))
-            if result1 and result2:
-                result = True
-            else:
-                result = False
-            logSimpleResult("Set 12v high current", result)
-
-        def finish(self):
-
-            super().finish_cal()
-
-        def report(self,data):
-
-            return super().report("calibrate",data)
-
-        def readCoefficients(self):
-
-            coefficients = {}
-            # get 12v high current multiplier
-            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + QTL2674.V12_HIGH_MULTIPLIER_ADDR)
-            # get 12v high current offset
-            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + QTL2674.V12_HIGH_OFFSET_ADDR)
-            return coefficients
-
-        def writeCoefficients(self,coefficients):
-
-            # write 12v high current multiplier
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2674.V12_HIGH_MULTIPLIER_ADDR + " " + coefficients["multiplier"])
-            # write 12v high current offset
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2674.V12_HIGH_OFFSET_ADDR + " " + coefficients["offset"])
-
-    class QTL2674_3V3_AUX_VoltageCalibration (QTL2674Calibration):
-
-        def __init__(self,powerModule):
-
-            self.title = "3.3V Aux Voltage Calibration"
-            self.powerModule = powerModule
-            self.absErrorLimit = 2              # 2mV
-            self.relErrorLimit = 1              # 1%
-            self.test_min = 40                  # 40mV
-            self.test_max = 14400               # 14.4V
-            self.test_steps = 20
-            self.units = "mV"
+            self.units = "mA"
             self.scaling = 4
             self.multiplier_signed = False
             self.multiplier_int_width = 1
             self.multiplier_frac_width = 16
             self.offset_signed = True
             self.offset_int_width = 10
             self.offset_frac_width = 6
 
         def init(self):
 
-            super().init_cal("3V3_AUX")
+            super().init_cal(self.thisChannel)
 
+            #set full averaging
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES["CALIBRATION_CONTROL"] + " 0x00F0")
             # clear the multiplier and offset registers by setting them to zero
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2674.V3_3_AUX_VOLT_MULTIPLIER_ADDR + " 0x0000")
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2674.V3_3_AUX_VOLT_OFFSET_ADDR + " 0x0000")
-
-            self.powerModule.setConnections("3V3_AUX",None)
-            ## Check Host Power is not present
-            #while (super().checkLoadVoltage(500,500) != True):
-            #	input("Unexpected voltage detected at load, please check connections")
-            #	self.powerModule.setConnections("3V3_AUX",None,reset=True)
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_CURR_MULTIPLIER"] + " 0x0000")
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_CURR_OFFSET"] + " 0x0000")
 
+            self.powerModule.host_switchbox.setConnections([("12V",self.thisChannel + '_IN')])
+            self.powerModule.load_switchbox.setConnections([("LOAD",self.thisChannel + '_OUT')])
 
-        def setRef(self,value):
-
-            return load_set_volt(self.powerModule.calInstrument,value)
-
-        def readRef(self):
-
-            return load_meas_volt(self.powerModule.calInstrument)
-
-        def readVal(self):
-
-            return super().meas_3v3_aux_volt()
-
-        def setCoefficients(self):
-
-            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2674.V3_3_AUX_VOLT_MULTIPLIER_ADDR + " " + self.multiplier.hexString(4))
-            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2674.V3_3_AUX_VOLT_OFFSET_ADDR + " " + self.offset.hexString(4))
-            if result1 and result2:
-                result = True
-            else:
-                result = False
-            logSimpleResult("Set 3.3v Aux voltage", result)
-
-        def finish(self):
-
-            super().finish_cal()
-
-        def report(self,data):
-
-            return super().report("calibrate",data)
-
-        def readCoefficients(self):
-
-            coefficients = {}
-            # get 3v3 Aux voltage multiplier
-            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + QTL2674.V3_3_AUX_VOLT_MULTIPLIER_ADDR)
-            # get 3v3 Aux voltage offset
-            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + QTL2674.V3_3_AUX_VOLT_OFFSET_ADDR)
-            return coefficients
-
-        def writeCoefficients(self,coefficients):
-
-            # write 3v3 Aux voltage multiplier
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2674.V3_3_AUX_VOLT_MULTIPLIER_ADDR + " " + coefficients["multiplier"])
-            # write 3v3 Aux voltage offset
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2674.V3_3_AUX_VOLT_OFFSET_ADDR + " " + coefficients["offset"])
-
-    class QTL2674_3V3_AUX_CurrentCalibration (QTL2674Calibration):
-
-        def __init__(self,powerModule):
-
-            self.title = "3.3V Aux Current Calibration"
-            self.powerModule = powerModule
-            self.absErrorLimit = 15         # 15uA
-            self.relErrorLimit = 1          # 1%
-            self.test_min = 10              # 10uA
-            self.test_max = 85000           # 85mA
-            self.test_steps = 20
-            self.units = "uA"
-            self.scaling = 32
-            self.multiplier_signed = False
-            self.multiplier_int_width = 1
-            self.multiplier_frac_width = 16
-            self.offset_signed = True
-            self.offset_int_width = 10
-            self.offset_frac_width = 6
-
-        def init(self):
-
-            super().init_cal("3V3_AUX")
-
-            # clear the multiplier and offset registers by setting them to zero
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2674.V3_3_AUX_MULTIPLIER_ADDR + " 0x0000")
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2674.V3_3_AUX_OFFSET_ADDR + " 0x0000")
+            # Check Host Power is present
+            while (super().checkLoadVoltage(self.powerModule.LOAD_VOLTAGE,1000) != True):
+                showDialog(message="Host Power not detected, please check the connections",title="Check Connections")
+                self.powerModule.host_switchbox.setConnections([("12V",self.thisChannel + '_IN')],reset=True)
+                self.powerModule.load_switchbox.setConnections([("LOAD",self.thisChannel + '_OUT')],reset=True)
 
-            self.powerModule.setConnections("3V3_AUX","3V3_AUX")
-            # Check Host Power is not present	    
-            while (super().checkLoadVoltage(QTL2674.LOAD_VOLTAGE,1000) != True):
-            	input("Unexpected voltage detected at load, please check connections")
-            	self.powerModule.setConnections("3V3_AUX","3V3_AUX",reset=True)
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000)
 
         def readRef(self):
 
             # read device voltage and add leakage current to the reference
-            voltage =  super().meas_3v3_aux_volt()
-            #leakage = voltage*self.powerModule.calibrations["3.3V Aux"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["3.3V Aux"]["Leakage"].offset.originalValue()
-            return load_meas_cur(self.powerModule.calInstrument)# + leakage
+            #voltage = getFixtureData(self.powerModule.dut,self.thisChannel + " V")
+            #leakage = voltage*self.powerModule.calibrations["POWER_1"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["POWER_1"]["Leakage"].offset.originalValue()
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000# + leakage
 
         def readVal(self):
 
-            return super().meas_3v3_aux_cur()
+            return getFixtureData(self.powerModule.dut,self.thisChannel + " A")
 
         def setCoefficients(self):
 
-            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2674.V3_3_AUX_MULTIPLIER_ADDR + " " + self.multiplier.hexString(4))
-            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2674.V3_3_AUX_OFFSET_ADDR + " " + self.offset.hexString(4))
+            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_CURR_MULTIPLIER"] + " " + self.multiplier.hexString(4))
+            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_CURR_OFFSET"] + " " + self.offset.hexString(4))
             if result1 and result2:
                 result = True
             else:
                 result = False
-            logSimpleResult("Set 3.3v Aux low current", result)
-
-            # once we've completed low and high current we can set leakage on the fixture
-            #result = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2674.V3_3_AUX_LEAKAGE_MULTIPLIER_ADDR + " " + self.powerModule.calibrations["3.3V Aux"]["Leakage"].multiplier.hexString(4))
+            logSimpleResult("Set " + self.thisChannel + " current", result)
 
         def finish(self):
 
             super().finish_cal()
 
         def report(self,data):
 
             return super().report("calibrate",data)
 
         def readCoefficients(self):
 
             coefficients = {}
-            # get 3v3 Aux low current multiplier
-            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + QTL2674.V3_3_AUX_MULTIPLIER_ADDR)
-            # get 3v3 Aux low current offset
-            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + QTL2674.V3_3_AUX_OFFSET_ADDR)
+            # get POWER_1 low current multiplier
+            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_CURR_MULTIPLIER"])
+            # get POWER_1 low current offset
+            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_CURR_OFFSET"])
             return coefficients
 
         def writeCoefficients(self,coefficients):
 
-            # write 3v3 Aux low current multiplier
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2674.V3_3_AUX_MULTIPLIER_ADDR + " " + coefficients["multiplier"])
-            # write 3v3 Aux low current offset
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2674.V3_3_AUX_OFFSET_ADDR + " " + coefficients["offset"])
+            # write POWER_1 low current multiplier
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_CURR_MULTIPLIER"] + " " + coefficients["multiplier"])
+            # write POWER_1 low current offset
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_CURR_OFFSET"] + " " + coefficients["offset"])
 
-    class QTL2674_12V_VoltageVerification (QTL2674Calibration):
+    class QTL2626_VoltageVerification (QTL2626Calibration):
 
-        def __init__(self,powerModule):
+        def __init__(self,powerModule,thisChannel):
 
-            self.title = "12V Voltage Verification"
+            self.thisChannel = thisChannel
+            self.title = thisChannel + " Voltage Verification"
             self.powerModule = powerModule
             self.absErrorLimit = 2      # 2mV
             self.relErrorLimit = 1      # 1%
             self.test_min = 40          # 40mV
             self.test_max = 14400       # 14.4V
             self.test_steps = 20
             self.units = "mV"
 
         def init(self):
 
-            super().init_cal("12V")
+            super().init_cal(self.thisChannel)
 
-            self.powerModule.setConnections("12V",None)
-            # Check Host Power is not present	    
-            while (super().checkLoadVoltage(500,500) != True):
-            	input("Unexpected voltage detected at load, please check connections")
-            	self.powerModule.setConnections("12V",None,reset=True)
-
-        def setRef(self,value):
-
-            return load_set_volt(self.powerModule.calInstrument,value)
-
-        def readRef(self):
-
-            return load_meas_volt(self.powerModule.calInstrument)
-
-        def readVal(self):
-
-            return super().meas_12v_volt()
-
-        def finish(self):
-
-            super().finish_cal()
-
-        def report(self,data):
-
-            return super().report("verify",data)
-
-    class QTL2674_12V_LowCurrentVerification (QTL2674Calibration):
-
-        def __init__(self,powerModule):
-
-            self.title = "12V Low Current Verification"
-            self.powerModule = powerModule
-            self.absErrorLimit = 25     # 2uA
-            self.relErrorLimit = 1      # 1% tolerance
-            self.test_min = 100         # 100uA
-            self.test_max = 1000        # 1mA
-            self.test_steps = 20
-            self.units = "uA"
-
-        def init(self):
-
-            super().init_cal("12V")
-
-            self.powerModule.setConnections("12V","12V")	    
+            self.powerModule.host_switchbox.setConnections([("12V",None)])
+            self.powerModule.load_switchbox.setConnections([("LOAD",self.thisChannel + '_OUT')])
 
             # Check Host Power is present
-            while (super().checkLoadVoltage(QTL2674.LOAD_VOLTAGE,500) != True):
-            	input("Unexpected voltage detected at load, please check connections")
-            	self.powerModule.setConnections("12V","12V",reset=True)
-            	
-        def setRef(self,value):
-
-            load_set_cur(self.powerModule.calInstrument,value)
-
-        def readRef(self):
-
-            return load_meas_cur(self.powerModule.calInstrument)
-
-        def readVal(self):
-
-            return super().meas_12v_cur()
-
-        def finish(self):
-
-            super().finish_cal()
-
-        def report(self,data):
-
-            return super().report("verify",data)
-
-    class QTL2674_12V_HighCurrentVerification (QTL2674Calibration):
-
-        def __init__(self,powerModule):
-
-            self.title = "12V High Current Verification"
-            self.powerModule = powerModule
-            self.absErrorLimit = 2000       # 2mA
-            self.relErrorLimit = 1          # 1% tolerance
-            self.test_min = 1000            # 1mA
-            self.test_max = 4000000         # 4A
-            self.test_steps = 20
-            self.units = "uA"
-
-        def init(self):
-
-            super().init_cal("12v")
-
-            self.powerModule.setConnections("12V","12V")
-            # Check Host Power is present	    	    
-            while (super().checkLoadVoltage(QTL2674.LOAD_VOLTAGE,500) != True):
-            	input("Unexpected voltage detected at load, please check connections")
-            	self.powerModule.setConnections("12V","12V",reset=True)
+            #while (super().checkLoadVoltage(500,500) != True):
+                #self.powerModule.setConnections(self.thisChannel,None,reset=True)
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
 
         def readRef(self):
 
-            return load_meas_cur(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def readVal(self):
 
-            return super().meas_12v_cur()
+            return getFixtureData(self.powerModule.dut,self.thisChannel + " V")
 
         def finish(self):
 
             super().finish_cal()
 
         def report(self,data):
 
             return super().report("verify",data)
 
-    class QTL2674_3V3_AUX_VoltageVerification (QTL2674Calibration):
+    class QTL2626_CurrentVerification (QTL2626Calibration):
 
-        def __init__(self,powerModule):
+        def __init__(self,powerModule,thisChannel):
 
-            self.title = "3.3V Aux Voltage Verification"
+            self.thisChannel = thisChannel
+            self.title = thisChannel + " Current Verification"
             self.powerModule = powerModule
-            self.absErrorLimit = 2      # 2mV
-            self.relErrorLimit = 1      # 1%
-            self.test_min = 40          # 40mV
-            self.test_max = 14400       # 14.4V
+            self.absErrorLimit = 10     # 25mA  - Deliberately higher than calibration limit
+            self.relErrorLimit = 1      # 1% tolerance
+            self.test_min = 10          # 10mA
+            self.test_max = 4000        # 4000mA
             self.test_steps = 20
-            self.units = "mV"
+            self.units = "mA"
 
         def init(self):
 
-            super().init_cal("3V3_AUX")
+            super().init_cal(self.thisChannel)
 
-            self.powerModule.setConnections("3V3_AUX",None)
-            # Check Host Power is not present	    
-            while (super().checkLoadVoltage(500,500) != True):
-            	input("Unexpected voltage detected at load, please check connections")
-            	self.powerModule.setConnections("3V3_AUX",None,reset=True)
-            	
-        def setRef(self,value):
-
-            return load_set_volt(self.powerModule.calInstrument,value)
+            self.powerModule.host_switchbox.setConnections([("12V",self.thisChannel + '_IN')])
+            self.powerModule.load_switchbox.setConnections([("LOAD",self.thisChannel + '_OUT')])
 
-        def readRef(self):
-
-            return load_meas_volt(self.powerModule.calInstrument)
-
-        def readVal(self):
-
-            return super().meas_3v3_aux_volt()
-
-        def finish(self):
-
-            super().finish_cal()
-
-        def report(self,data):
-
-            return super().report("verify",data)
-
-    class QTL2674_3V3_AUX_CurrentVerification (QTL2674Calibration):
-
-        def __init__(self,powerModule):
-
-            self.title = "3.3V Aux Current Verification"
-            self.powerModule = powerModule
-            self.absErrorLimit = 25     # 25uA
-            self.relErrorLimit = 1      # 1%
-            self.test_min = 100         # 100uA
-            self.test_max = 85000       # 85mA
-            self.test_steps = 20
-            self.units = "uA"
-
-        def init(self):
-
-            super().init_cal("3V3_AUX")
+            # Check Host Power is present
+            while (super().checkLoadVoltage(self.powerModule.LOAD_VOLTAGE,1000) != True):
+                showDialog(message="Host Power not detected, please check the connections",title="Check Connections")
+                self.powerModule.host_switchbox.setConnections([("12V",self.thisChannel + '_IN')],reset=True)
+                self.powerModule.load_switchbox.setConnections([("LOAD",self.thisChannel + '_OUT')],reset=True)
 
-            self.powerModule.setConnections("3V3_AUX","3V3_AUX")
-            # Check Host Power is present	    
-            while (super().checkLoadVoltage(QTL2674.LOAD_VOLTAGE,1000) != True):
-            	input("Unexpected voltage detected at load, please check connections")
-            	self.powerModule.setConnections("3V3_AUX","3V3_AUX",reset=True)
-    
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000)
 
         def readRef(self):
 
-            return load_meas_cur(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000
 
         def readVal(self):
 
-            return super().meas_3v3_aux_cur()
+            return getFixtureData(self.powerModule.dut,self.thisChannel + " A")
 
         def finish(self):
 
             super().finish_cal()
 
         def report(self,data):
 
-            return super().report("verify",data)
-
-
-
-    def __init__(self,dut):
-
-        # set the name of this module
-        self.name = "PCIe x16 Power Measurement Fixture"
-        self.dut = dut
-        
-        # Serial numbers (ensure QTL at start)
-        self.enclosureSerial = self.dut.sendCommand("*ENCLOSURE?")
-        if (self.enclosureSerial.find ("QTL") == -1):
-            self.enclosureSerial = "QTL" + self.enclosureSerial
-        # fetch the enclosure position
-        self.enclosurePosition = self.dut.sendCommand("*POSITION?")
-        self.PAMSerial = self.dut.sendCommand ("*SERIAL?")
-        if (self.PAMSerial.find ("QTL") == -1):
-            self.PAMSerial = "QTL" + self.PAMSerial
-        # Fixture Serial
-        # fixture serial is retrieved as BCD, we need to convert and pad it
-        self.FixtureSerial = "QTL" + bcdString(dut.sendCommand("read 0xA102"),4) + "-" + bcdString(dut.sendCommand("read 0xA103"),2) + "-" + bcdString(dut.sendCommand("read 0xA104"),3) # TODO: this should be replaced with fix:serial? command when implemented
-        # calObjectSerial Serial
-        self.calObjectSerial = self.FixtureSerial
-        # Filename String
-        self.filenameString = self.FixtureSerial
-        # Code version (FPGA)
-        self.idnStr = dut.sendCommand ("*IDN?")
-        pos = self.idnStr.upper().find ("FPGA 1:")
-        if (pos != -1):
-            versionStr = self.idnStr[pos+7:]
-            pos = versionStr.find ("\n")
-            if (pos != -1):
-                versionStr = versionStr[:pos].strip()
-            else:
-                pass
-        else:
-            versionStr = "NOT-FOUND"    
-        self.Fpga = versionStr.strip()
-    
-        # Code version (FW)    
-        pos = self.idnStr.upper().find ("PROCESSOR:")
-        if (pos != -1):
-            versionStr = self.idnStr[pos+10:]
-            pos = versionStr.find ("\n")
-            if (pos != -1):
-                versionStr = versionStr[:pos].strip()            
-            else:
-                pass
-        else:
-            versionStr = "NOT-FOUND"    
-        self.Firmware = versionStr.strip()
-
-        self.calibrations = {}
-        # populate 12V channel with calibrations
-        self.calibrations["12V"] = {
-            "Voltage":self.QTL2674_12V_VoltageCalibration(self),
-            #"Leakage":self.QTL2674_12V_LeakageCalibration(self),
-            "Low Current":self.QTL2674_12V_LowCurrentCalibration(self),
-            "High Current":self.QTL2674_12V_HighCurrentCalibration(self)
-            }
-			
-        # populate 3V3_AUX channel with calibrations
-        self.calibrations["3.3V Aux"] = {
-            "Voltage":self.QTL2674_3V3_AUX_VoltageCalibration(self),
-            #"Leakage":self.QTL2674_3V3_AUX_LeakageCalibration(self),
-            "Current":self.QTL2674_3V3_AUX_CurrentCalibration(self)
-            }
-
-        self.verifications = {}
-        # populate 12V channel with verifications
-        self.verifications["12V"] = {
-            "Voltage":self.QTL2674_12V_VoltageVerification(self),
-            "Low Current":self.QTL2674_12V_LowCurrentVerification(self),
-            "High Current":self.QTL2674_12V_HighCurrentVerification(self)
-            }
-        
-        # populate 3V3_AUX channel with verifications
-        self.verifications["3.3V Aux"] = {
-            "Voltage":self.QTL2674_3V3_AUX_VoltageVerification(self),
-            "Current":self.QTL2674_3V3_AUX_CurrentVerification(self)
-            }
-
+            return super().report("verify",data)
```

## Comparing `quarchCalibration/QTL2887.py` & `quarchCalibration/QTL2525_sff.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,37 +1,35 @@
 '''
 Quarch Power Module Calibration Functions
 Written for Python 3.6 64 bit
 
 M Dearman April 2019
-Edited k McRobert September 2021
 '''
 
 '''
 Calibration Flow
     Connect to PAM Fixture 
     Connect to Keithley
     step through a set of values and get ADC vs Reference Value
     evaluate results vs defined limits
 
 '''
 
 #Imports QuarchPy library, providing the functions needed to use Quarch modules
-#from quarchpy import quarchDevice #, scanDevices
-
-# Import other libraries used in the examples
-
 from .PowerModuleCalibration import *
 from .calibrationConfig import *
 from .keithley_2460_control import *
+from .QTL2536_6_way_switchbox import *
 from quarchpy.device.device import *
 from quarchpy.device.scanDevices import userSelectDevice
 from quarchpy.user_interface import *
 from quarchpy.user_interface import logSimpleResult
 from quarchpy.utilities.BitManipulation import *
+from .pamHelpers import bcdString
+
 
 def parseFixtureData(response,start,length):
 
     # split the multiline response into a list
     response = response.splitlines()
     result = ""
     # for each line
@@ -56,98 +54,190 @@
     device.sendCommand("write 0x0000 " + setBit(response,3))
     #read measurement
     data = device.sendCommand("read 0x1000 to 0x1007")
     #release measurement
     response = device.sendCommand("read 0x0000")
     device.sendCommand("write 0x0000 " + clearBit(response,3))
 
-    if (channel == "12V VOLT"):
+    if (channel == "5V V"):
         return parseFixtureData(data,0,16)
-    elif (channel == "12V CUR"):
+    elif (channel == "5V A"):
         return parseFixtureData(data,16,25)
-    elif (channel == "3V3_AUX VOLT"):
+    elif (channel == "12V V"):
         return parseFixtureData(data,41,16)
-    elif (channel == "3V3_AUX CUR"):
-        return parseFixtureData(data,57,20)
+    elif (channel == "12V A"):
+        return parseFixtureData(data,57,25)
+    elif (channel == "3V3_AUX V"):
+        return parseFixtureData(data,82,16)
+    elif (channel == "3V3_AUX A"):
+        return parseFixtureData(data,98,20)
 
-def bcdString(bcd,padding):
-    # strip off "0x" if present
-    if bcd[:2] == "0x":
-        bcd = bcd [2:]
-    # strip off leading 0's
-    # loop while we have more the required minimum number of characters left
-    while(len(bcd)>padding):
-        # if the leading character is 0, remove it
-        if bcd[0] == '0':
-            bcd = bcd[1:]
-        # else exit loop
-        else:
-            break
-    return bcd
 
 
-class QTL2887 (PowerModule):
+class QTL2525 (PowerModule):
 
     # Fixture Register Addresses
-    CALIBRATION_MODE_ADDR               = '0xA100'
-    CALIBRATION_CONTROL_ADDR            = '0xA101'      
-    
-    V12_LOW_MULTIPLIER_ADDR             = '0xA10C'
-    V12_LOW_OFFSET_ADDR                 = '0xA10D'
-    V12_HIGH_MULTIPLIER_ADDR            = '0xA10E'
-    V12_HIGH_OFFSET_ADDR                = '0xA10F'
-    V12_VOLT_MULTIPLIER_ADDR            = '0xA110'
-    V12_VOLT_OFFSET_ADDR                = '0xA111'
-    V12_LEAKAGE_MULTIPLIER_ADDR         = '0xA112'
-	
-    V3_3_AUX_MULTIPLIER_ADDR            = '0xA113'
-    V3_3_AUX_OFFSET_ADDR                = '0xA114'
-    V3_3_AUX_VOLT_MULTIPLIER_ADDR       = '0xA115'
-    V3_3_AUX_VOLT_OFFSET_ADDR           = '0xA116'
-    V3_3_AUX_LEAKAGE_MULTIPLIER_ADDR    = '0xA117'
-    CALIBRATION_COMPLETE_ADDR	        = '0xA118'
-    LOAD_VOLTAGE                        = 12000
+    CAL_ADDRESSES = {    
+    '5V_LOW_MULTIPLIER'			    : '0xA105',
+    '5V_LOW_OFFSET'				    : '0xA106',
+    '5V_HIGH_MULTIPLIER'			: '0xA107',
+    '5V_HIGH_OFFSET'				: '0xA108',
+    '5V_VOLT_MULTIPLIER'			: '0xA109',
+    '5V_VOLT_OFFSET'				: '0xA10A',
+    '5V_LEAKAGE_MULTIPLIER'		    : '0xA10B',
+    '12V_LOW_MULTIPLIER'			: '0xA10C',
+    '12V_LOW_OFFSET'				: '0xA10D',
+    '12V_HIGH_MULTIPLIER'			: '0xA10E',
+    '12V_HIGH_OFFSET'				: '0xA10F',
+    '12V_VOLT_MULTIPLIER'			: '0xA110',
+    '12V_VOLT_OFFSET'				: '0xA111',
+    '12V_LEAKAGE_MULTIPLIER'		: '0xA112',
+    '3V3_AUX_LOW_MULTIPLIER'		: '0xA113',
+    '3V3_AUX_LOW_OFFSET'			: '0xA114',
+    '3V3_AUX_VOLT_MULTIPLIER'		: '0xA115',
+    '3V3_AUX_VOLT_OFFSET'			: '0xA116',
+    '3V3_AUX_LEAKAGE_MULTIPLIER'	: '0xA117',
+    'CALIBRATION_COMPLETE'		    : '0xA118'
+	}
+
+    CONTROL_ADDRESSES = {
+    'CALIBRATION_MODE'             	            : '0xA100',
+    'CALIBRATION_CONTROL'          	            : '0xA101', 
+    '12V_LOW_CALIBRATION_CONTROL_SETTING'       : '0x00F4',		# set manual range, full averaging, 12V low current mode,
+    '12V_HIGH_CALIBRATION_CONTROL_SETTING'      : '0x00F8',		# set manual range, full averaging, 12V high current mode,
+    '5V_LOW_CALIBRATION_CONTROL_SETTING'		: '0x00F1',		# set manual range, full averaging, 5V low current mode,
+    '5V_HIGH_CALIBRATION_CONTROL_SETTING'		: '0x00F2',		# set manual range, full averaging, 5V low current mode,
+    '3V3_AUX_LOW_CALIBRATION_CONTROL_SETTING'   : '0x00F0',		# no range switching on 3V3_AUX, leave the module in auto mode
+    '3V3_AUX_HIGH_CALIBRATION_CONTROL_SETTING'  : '0x00F0'		# no range switching on 3V3_AUX, leave the module in auto mode
+    }
+
+    LOAD_VOLTAGE                    = 12000
+
+    host_switchbox_title = "Switchbox"
+    host_switchbox_message = "Select the switch box which connects a 12V supply and Keithley Load to the fixture:"
+    host_switchbox_mapping = {'12V':'A','12V_SUPPLY':'1','5V_SUPPLY':'2','3V3_AUX_SUPPLY':'3','LOAD':'B','12V_LOAD':'4','5V_LOAD':'5','3V3_AUX_LOAD':'6'}
 
     # Fixture Information
     PAMSerial = None
     FixtureSerial = None
     calObjectSerial = None     # The serial number of the device that is being calibrated, i.e QTL1944 in HD PPM, Fixture in PAM
     idnStr = None
     Firmware = None
     Fpga = None
     calInstrument = None
     calInstrumentId = None
-    switchbox = None
-
-    # Physical Connection Tracking (what is plugged to what)
-    loadChannel = None
-    hostPowerChannel = None
-
-    # defigning the connection
-    hostPort = "A"
-    loadPort = "B"
-    loadConnectionPortDict = {"12V": "4", "3V3_AUX": "6"}
-    hostConnectionPortDict = {"12V": "1", "3V3_AUX": "3"}
-
-    # general
+    host_switchbox = None
     waitComplete = False
     checkedWiring = False
 
+    def __init__(self,dut):
+
+        # set the name of this module
+        self.name = "SFF8639 Power Measurement Fixture"
+        self.dut = dut
+        
+        # Serial numbers (ensure QTL at start)
+        self.enclosureSerial = self.dut.sendCommand("*ENCLOSURE?")
+        if (self.enclosureSerial.find ("QTL") == -1):
+            self.enclosureSerial = "QTL" + self.enclosureSerial
+        # fetch the enclosure position
+        self.enclosurePosition = self.dut.sendCommand("*POSITION?")
+        self.PAMSerial = self.dut.sendCommand ("*SERIAL?")
+        if (self.PAMSerial.find ("QTL") == -1):
+            self.PAMSerial = "QTL" + self.PAMSerial
+        # Fixture Serial
+        # fixture serial is retrieved as BCD, we need to convert and pad it
+        self.FixtureSerial = "QTL" + bcdString(dut.sendCommand("read 0xA102"),4) + "-" + bcdString(dut.sendCommand("read 0xA103"),2) + "-" + bcdString(dut.sendCommand("read 0xA104"),3) # TODO: this should be replaced with fix:serial? command when implemented
+        # calObjectSerial Serial
+        self.calObjectSerial = self.FixtureSerial
+        # Filename String
+        self.filenameString = self.FixtureSerial
+        # Code version (FPGA)
+        self.idnStr = dut.sendCommand ("*IDN?")
+        pos = self.idnStr.upper().find ("FPGA 1:")
+        if (pos != -1):
+            versionStr = self.idnStr[pos+7:]
+            pos = versionStr.find ("\n")
+            if (pos != -1):
+                versionStr = versionStr[:pos].strip()
+            else:
+                pass
+        else:
+            versionStr = "NOT-FOUND"    
+        self.Fpga = versionStr.strip()
+    
+        # Code version (FW)    
+        pos = self.idnStr.upper().find ("PROCESSOR:")
+        if (pos != -1):
+            versionStr = self.idnStr[pos+10:]
+            pos = versionStr.find ("\n")
+            if (pos != -1):
+                versionStr = versionStr[:pos].strip()            
+            else:
+                pass
+        else:
+            versionStr = "NOT-FOUND"    
+        self.Firmware = versionStr.strip()
+
+        self.calibrations = {}
+        # populate 12V channel with calibrations
+        self.calibrations["12V"] = {
+            "Voltage":self.QTL2525_VoltageCalibration(self,"12V"),
+            #"Leakage":self.QTL2525_LeakageCalibration(self,"12V"),
+            "Low Current":self.QTL2525_LowCurrentCalibration(self,"12V"),
+            "High Current":self.QTL2525_HighCurrentCalibration(self,"12V")
+            }
+        # populate 5V channel with calibrations
+        self.calibrations["5V"] = {
+            "Voltage":self.QTL2525_VoltageCalibration(self,"5V"),
+            #"Leakage":self.QTL2525_LeakageCalibration(self,"5V"),
+            "Low Current":self.QTL2525_LowCurrentCalibration(self,"5V"),
+            "High Current":self.QTL2525_HighCurrentCalibration(self,"5V")
+            }
+        # populate 3V3_AUX channel with calibrations
+        self.calibrations["3V3_AUX"] = {
+            "Voltage":self.QTL2525_VoltageCalibration(self,"3V3_AUX"),
+            #"Leakage":self.QTL2525__LeakageCalibration(self,"3V3_AUX"),
+            "Current":self.QTL2525_LowCurrentCalibration(self,"3V3_AUX")
+            }
+
+        self.verifications = {}
+        # populate 12V channel with verifications
+        self.verifications["12V"] = {
+            "Voltage":self.QTL2525_VoltageVerification(self,"12V"),
+            "Low Current":self.QTL2525_LowCurrentVerification(self,"12V"),
+            "High Current":self.QTL2525_HighCurrentVerification(self,"12V")
+            }
+        # populate 5V channel with verifications
+        self.verifications["5V"] = {
+            "Voltage":self.QTL2525_VoltageVerification(self,"5V"),
+            "Low Current":self.QTL2525_LowCurrentVerification(self,"5V"),
+            "High Current":self.QTL2525_HighCurrentVerification(self,"5V")
+            }
+        # populate 3V3_AUX channel with verifications
+        self.verifications["3V3_AUX"] = {
+            "Voltage":self.QTL2525_VoltageVerification(self,"3V3_AUX"),
+            "Current":self.QTL2525_AuxCurrentVerification(self,"3V3_AUX")
+            }
+
+
     def specific_requirements(self):
 
         reportText=""
 
-        # select a switchbox to use for calibration
-        if "switchbox" in calibrationResources.keys():
-            self.switchbox = calibrationResources["switchbox"]
-        self.switchbox = self.getSwitchbox()
-        calibrationResources["switchbox"] = self.switchbox
+        # select the host switchbox to use for calibration
+        if "host_switchbox" in calibrationResources.keys():
+            self.host_switchbox = calibrationResources["host_switchbox"]
+        else:
+            self.host_switchbox = self.get_switchbox(self.host_switchbox_message,self.host_switchbox_title,self.host_switchbox_mapping)
+            calibrationResources["host_switchbox"] = self.host_switchbox
 
         if self.checkedWiring != True:
-            self.checkWiring()
+            self.host_switchbox.checkWiring()
+
             self.checkedWiring = True
 
         # Select a Keithley SMU
         # If no calibration instrument is provided, request it
         while (True):
             if (calibrationResources["loadString"] == None):
                 loadString = userSelectCalInstrument(scanFilterStr="Keithley 2460", nice=True)
@@ -179,126 +269,90 @@
         reportText += "FW:" + self.Firmware + ", FPGA: " + self.Fpga + "\n"
         reportText += "\n"
         reportText += "Calibration Instruments#:\n"
         reportText += self.calInstrumentId + "\n"
 
         # perform uptime check and write to file
         if self.waitComplete != True:
-            reportText += self.wait_for_up_time(desired_up_time=600, command="conf:runtime:fix:sec?")
+            reportText += self.wait_for_up_time(desired_up_time=600)
             self.waitComplete = True
 
         return reportText
 
-    def setConnections(self,loadConnection,hostPowerConnection,reset=False):
-    #TODO Fix for using class variable.
-        if reset:
-            self.loadChannel = None
-            self.hostPowerChannel = None
-
-        # If current connections are correct
-        if self.loadChannel == loadConnection and self.hostPowerChannel == hostPowerConnection:
-            # do nothing
-            pass
+    def open_module(self):
 
-        # else connections need to change
-        else:
-
-            # we can't turn an individual port off (at the moment) so we turn both off first, then set anything that needs setting
-            if loadConnection == None or hostPowerConnection == None:
-                response = self.switchbox.sendCommand("connect off")
-                if response != "OK": raise ConnectionError("Switchbox command failed")
-
-            if loadConnection != None:
-                response = self.switchbox.sendCommand("connect " + self.loadPort + " " + self.loadConnectionPortDict[loadConnection])
-                if response != "OK": raise ConnectionError("Switchbox command failed")
-				
-            if hostPowerConnection != None:
-                response = self.switchbox.sendCommand("connect " + self.hostPort + " " + self.hostConnectionPortDict[hostPowerConnection])
-                if response != "OK": raise ConnectionError("Switchbox command failed")
-
-        self.loadChannel = loadConnection
-        self.hostPowerChannel = hostPowerConnection
+        # set unit into calibration mode
+        self.dut.sendCommand("write " + self.CONTROL_ADDRESSES["CALIBRATION_MODE"] + " 0xaa55")
+        self.dut.sendCommand("write " + self.CONTROL_ADDRESSES["CALIBRATION_MODE"] + " 0x55aa")
 
-    def getSwitchbox(self):
+    def get_switchbox(self,msg,name,portDict):
         # CheckSwitchbox
-        if self.switchbox is None:
-            while (True):
-                switchboxAddress = userSelectDevice(scanFilterStr=["QTL2536"], message="Select a calibration 6 Way Test Lead Switch.", nice=True)
-                if switchboxAddress == "quit":
-                    printText("User Quit Program")
-                    sys.exit(0)
-                try:
-                    self.switchbox = quarchDevice(switchboxAddress)
-                    break
-                except:
-                    printText("Unable to communicate with selected device!")
-                    printText("")
-                    switchboxAddress = None
-                    raise
-        return self.switchbox
+        while (True):
+            switchboxAddress = userSelectDevice(scanFilterStr=["QTL2536"], message=msg, nice=True)
+            if switchboxAddress == "quit":
+                printText("User Quit Program")
+                sys.exit(0)
+            try:
+                switchbox = QTL2536_6_way_switchbox(switchboxAddress,name,portDict)
+                break
+            except:
+                printText("Unable to communicate with selected device!")
+                printText("")
+                switchboxAddress = None
+                raise
+        return switchbox
 
 
     def clear_calibration(self):
 
         # set unit into calibration mode
-        self.dut.sendCommand("write " + QTL2887.CALIBRATION_MODE_ADDR + " 0xaa55")
-        self.dut.sendCommand("write " + QTL2887.CALIBRATION_MODE_ADDR + " 0x55aa")
+        self.dut.sendCommand("write " + self.CONTROL_ADDRESSES["CALIBRATION_MODE"] + " 0xaa55")
+        self.dut.sendCommand("write " + self.CONTROL_ADDRESSES["CALIBRATION_MODE"] + " 0x55aa")
 
         # clear all calibration registers
-      
-        self.dut.sendAndVerifyCommand("write " + QTL2887.V12_VOLT_OFFSET_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2887.V12_VOLT_MULTIPLIER_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2887.V12_LOW_OFFSET_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2887.V12_LOW_MULTIPLIER_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2887.V12_HIGH_OFFSET_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2887.V12_HIGH_MULTIPLIER_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2887.V12_LEAKAGE_MULTIPLIER_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2887.V3_3_AUX_VOLT_OFFSET_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2887.V3_3_AUX_VOLT_MULTIPLIER_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2887.V3_3_AUX_OFFSET_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2887.V3_3_AUX_MULTIPLIER_ADDR + " 0x0000")
-        self.dut.sendAndVerifyCommand("write " + QTL2887.V3_3_AUX_LEAKAGE_MULTIPLIER_ADDR + " 0x0000")
+        for address in self.CAL_ADDRESSES.values():
+            self.dut.sendAndVerifyCommand("write " + address + " 0x0000")
         
         # write 0xaa55 to register to calibration complete register to tell module it is calibrated
-        self.dut.sendAndVerifyCommand("write " + QTL2887.CALIBRATION_COMPLETE_ADDR + " 0xaa55")
+        self.dut.sendAndVerifyCommand("write " + self.CAL_ADDRESSES["CALIBRATION_COMPLETE"] + " 0xaa55")
         
     def write_calibration(self):
 
         # write the calibration registers
         # erase the tag memory
         printText("Erasing TAG memory..")
         self.dut.sendCommand("write 0xa200 0x0020")
         # TODO: should check for completion here...
         # wait for 2 seconds for erase to complete
         # check busy
         while checkBit(self.dut.sendCommand("read 0xa200"),8):
-            sleep(0.1)
+            time.sleep(0.1)
         # write the tag memory
         printText("Programming TAG memory...")
         self.dut.sendCommand("write 0xa200 0x0040")        
         # check busy
         while checkBit(self.dut.sendCommand("read 0xa200"),8):
-            sleep(0.1)
+            time.sleep(0.1)
 
     def close_module(self):
 
         # reset the fixture FPGA
         self.dut.sendCommand("fixture:reset")
 
         #close the connection to the calibration instrument
         self.calInstrument.closeConnection()
 
     def close_all(self):
 
         #close all attached devices
         self.calInstrument.setLoadCurrent(0)
         self.calInstrument.closeConnection()
-        self.powerModule.setConnections(None,None)
+        self.host_switchbox.sendCommand("connect off")
 
-    class QTL2887Calibration (Calibration):
+    class QTL2525Calibration (Calibration):
 
         def __init__(self):
             super().__init__()
 
         def init_cal(self,voltage):
 
             # TODO: No Power control at the moment
@@ -308,62 +362,42 @@
             # set averaging to max
             self.powerModule.dut.sendAndVerifyCommand("rec:ave 32k")
 
             #Turn off compression and power up
             self.powerModule.dut.sendAndVerifyCommand("write 0xA010 0x0011")
 
             # set module into calibration mode (again?)
-            self.powerModule.dut.sendCommand("write " + QTL2887.CALIBRATION_MODE_ADDR + " 0xaa55")   # will not verify
-            self.powerModule.dut.sendCommand("write " + QTL2887.CALIBRATION_MODE_ADDR + " 0x55aa")   # will not verify
+            self.powerModule.dut.sendCommand("write " + self.powerModule.CONTROL_ADDRESSES["CALIBRATION_MODE"] + " 0xaa55")   # will not verify
+            self.powerModule.dut.sendCommand("write " + self.powerModule.CONTROL_ADDRESSES["CALIBRATION_MODE"] + " 0x55aa")   # will not verify
 
             #Reset Keithley
             self.powerModule.calInstrument.reset()
 
-        def meas_12v_volt(self):
-
-            result = getFixtureData(self.powerModule.dut,"12V VOLT")
-            return result
-
-        def meas_12v_cur(self):
-
-            result = getFixtureData(self.powerModule.dut,"12V CUR")
-            return result
-
-        def meas_3v3_aux_volt(self):
-
-            result = getFixtureData(self.powerModule.dut,"3V3_AUX VOLT")
-            return result
-
-        def meas_3v3_aux_cur(self):
-
-            result = getFixtureData(self.powerModule.dut,"3V3_AUX CUR")
-            return result
-
         # check connections to host power and load
         def checkLoadVoltage(self,voltage,tolerance):
 
-            #self.powerModule.calInstrument.setReferenceCurrent(0)
-            self.powerModule.calInstrument.setReferenceVoltage(voltage/1000,"1e-6")  # set Keithley to the required voltage but limit current to 1uA
+            self.powerModule.calInstrument.setReferenceCurrent(0)
             result = self.powerModule.calInstrument.measureLoadVoltage()*1000   # *1000 because we use mV but keithley uses volts
             # check result is in required range
             if (result >= voltage-tolerance) and (result <= voltage+tolerance):
                 return True
             else:
                 return False
 
         def finish_cal(self):
 
             #turn off load
             self.powerModule.calInstrument.disable()
 
             #turn off switch
-            self.powerModule.setConnections(None,None)
+            self.powerModule.host_switchbox.setConnections([]) #sendCommand("connect off")
+
 
             # turn dut to autoranging
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2887.CALIBRATION_CONTROL_ADDR + " 0x00F0")
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CONTROL_ADDRESSES["CALIBRATION_CONTROL"] + " 0x00F0")
 
         def report(self,action,data):
 
             report = []
 
             # send to report file
             report.append("          Pass Level  +/-(" + str(self.absErrorLimit) + str(self.units) +" + " + str(self.relErrorLimit) + "%) \n")
@@ -430,19 +464,20 @@
             report.append("\n\n\n")
             
             #Add to Test Summary? Do this here?
             passfail = lambda x: "Passed" if x else "Failed"
 
             return {"title":self.title,"result":overallResult,"worst case":worstCase,"report":('\n'.join(report))}
 
-    class QTL2887_12V_VoltageCalibration (QTL2887Calibration):
+    class QTL2525_VoltageCalibration (QTL2525Calibration):
 
-        def __init__(self,powerModule):
+        def __init__(self,powerModule,thisChannel):
 
-            self.title = "12V Voltage Calibration"
+            self.thisChannel = thisChannel
+            self.title = thisChannel + " Voltage Calibration"
             self.powerModule = powerModule
             self.absErrorLimit = 2                  # 2mV
             self.relErrorLimit = 1                  # 1%
             self.test_min = 40                      # 40mV
             self.test_max = 14400                   # 14.4V
             self.test_steps = 20
             self.units = "mV"
@@ -452,698 +487,410 @@
             self.multiplier_frac_width = 16
             self.offset_signed = True
             self.offset_int_width = 10
             self.offset_frac_width = 6
 
         def init(self):
 
-            super().init_cal("12v")
+            super().init_cal(self.thisChannel)
 
             # clear the multiplier and offset registers by setting them to zero
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2887.V12_VOLT_MULTIPLIER_ADDR + " 0x0000")
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2887.V12_VOLT_OFFSET_ADDR + " 0x0000")
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_VOLT_MULTIPLIER"] + " 0x0000")
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_VOLT_OFFSET"] + " 0x0000")
 
-            self.powerModule.setConnections("12V",None)
-            ## Check Host Power is not present        
+            self.powerModule.host_switchbox.setConnections([("12V",None),("LOAD",self.thisChannel + "_LOAD")])
+
+            # Check Host Power is present
             #while (super().checkLoadVoltage(500,500) != True):
-            #    input("Unexpected voltage detected at load, please check connections")
             #    self.powerModule.setConnections("12V",None,reset=True)
 
         def setRef(self,value):
 
-            return load_set_volt(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
 
         def readRef(self):
 
-            return load_meas_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def readVal(self):
 
-            return super().meas_12v_volt()
+            return getFixtureData(self.powerModule.dut,self.thisChannel + " V")
 
         def setCoefficients(self):
 
-            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2887.V12_VOLT_MULTIPLIER_ADDR + " " + self.multiplier.hexString(4))
-            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2887.V12_VOLT_OFFSET_ADDR + " " + self.offset.hexString(4))
+            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_VOLT_MULTIPLIER"] + " " + self.multiplier.hexString(4))
+            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_VOLT_OFFSET"] + " " + self.offset.hexString(4))
             if result1 and result2:
                 result = True
             else:
                 result = False
-            logSimpleResult("Set 12v voltage", result)
+            logSimpleResult("Set " + self.thisChannel + " voltage", result)
 
         def finish(self):
 
             super().finish_cal()
 
         def report(self,data):
 
             return super().report("calibrate",data)
 
         def readCoefficients(self):
 
             coefficients = {}
-            # get 12v voltage multiplier
-            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + QTL2887.V12_VOLT_MULTIPLIER_ADDR)
-            # get 12v voltage offset
-            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + QTL2887.V12_VOLT_OFFSET_ADDR)
+            # get voltage multiplier
+            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_VOLT_MULTIPLIER"])
+            # get voltage offset
+            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_VOLT_OFFSET"])
             return coefficients
 
         def writeCoefficients(self,coefficients):
 
-            # write 12v voltage multiplier
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2887.V12_VOLT_MULTIPLIER_ADDR + " " + coefficients["multiplier"])
-            # write 12v voltage offset
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2887.V12_VOLT_OFFSET_ADDR + " " + coefficients["offset"])
+            # write voltage multiplier
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_VOLT_MULTIPLIER"] + " " + coefficients["multiplier"])
+            # write voltage offset
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_VOLT_OFFSET"] + " " + coefficients["offset"])
 
-    class QTL2887_12V_LowCurrentCalibration (QTL2887Calibration):
+    class QTL2525_LowCurrentCalibration (QTL2525Calibration):
 
-        def __init__(self,powerModule):
+        def __init__(self,powerModule,thisChannel):
 
-            self.title = "12V Low Current Calibration"
+            self.thisChannel = thisChannel
+            self.title = thisChannel + " Low Current Calibration"
             self.powerModule = powerModule
             self.absErrorLimit = 15                 # 15uA
             self.relErrorLimit = 1                  # 1%
-            self.test_min = 10          # 10uA
-            self.test_max = 85000       # 85mA
+            self.test_min = 10                      # 10uA
+            self.test_max = 85000                   # 85mA
             self.test_steps = 20
             self.units = "uA"
             self.scaling = 32
             self.multiplier_signed = False
             self.multiplier_int_width = 1
             self.multiplier_frac_width = 16
             self.offset_signed = True
             self.offset_int_width = 10
             self.offset_frac_width = 6
 
         def init(self):
 
-            super().init_cal("12v")
+            super().init_cal(self.thisChannel)
 
-            #set manual range, full averaging, 12v low current mode, 5V all off (so we can detect we're connected to the wrong channel
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2887.CALIBRATION_CONTROL_ADDR + " 0x00F4")
+            #set manual range, full averaging, [thisChannel] low current mode, other channels all off (so we can detect we're connected to the wrong channel
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CONTROL_ADDRESSES["CALIBRATION_CONTROL"] + " " + self.powerModule.CONTROL_ADDRESSES[self.thisChannel + "_LOW_CALIBRATION_CONTROL_SETTING"])
             # clear the multiplier and offset registers by setting them to zero
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2887.V12_LOW_MULTIPLIER_ADDR + " 0x0000")
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2887.V12_LOW_OFFSET_ADDR + " 0x0000")
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_LOW_MULTIPLIER"] + " 0x0000")
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_LOW_OFFSET"] + " 0x0000")
 
-            self.powerModule.setConnections("12V","12V")
-            # Check Host Power is present          
-            while (super().checkLoadVoltage(QTL2887.LOAD_VOLTAGE,1000) != True):
-                input("Unexpected voltage detected at load, please check connections")
-                self.powerModule.setConnections("12V","12V",reset=True)
+            self.powerModule.host_switchbox.setConnections([("12V",self.thisChannel + '_SUPPLY'),("LOAD",self.thisChannel + '_LOAD')])
+            # Check Host Power is present
+            while (super().checkLoadVoltage(self.powerModule.LOAD_VOLTAGE,1000) != True):
+                showDialog(message="Host Power not detected, please check the connections",title="Check Connections")
+                self.powerModule.host_switchbox.setConnections([("12V",self.thisChannel + '_SUPPLY'),("LOAD",self.thisChannel + '_LOAD')])
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
             # read device voltage and add leakage current to the reference
-            voltage =  super().meas_12v_volt()
-            #leakage = voltage*self.powerModule.calibrations["12V"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["12V"]["Leakage"].offset.originalValue()
-            return load_meas_cur(self.powerModule.calInstrument)# + leakage
+            #voltage = getFixtureData(self.powerModule.dut,self.thisChannel + " V")
+            #leakage = voltage*self.powerModule.calibrations["POWER_1"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["POWER_1"]["Leakage"].offset.originalValue()
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000# + leakage
 
         def readVal(self):
 
-            return super().meas_12v_cur()
+            return getFixtureData(self.powerModule.dut,self.thisChannel + " A")
 
         def setCoefficients(self):
 
-            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2887.V12_LOW_MULTIPLIER_ADDR + " " + self.multiplier.hexString(4))
-            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2887.V12_LOW_OFFSET_ADDR + " " + self.offset.hexString(4))
+            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_LOW_MULTIPLIER"] + " " + self.multiplier.hexString(4))
+            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_LOW_OFFSET"] + " " + self.offset.hexString(4))
             if result1 and result2:
                 result = True
             else:
                 result = False
-            logSimpleResult("Set 12v Low Current", result)
+            logSimpleResult("Set " + self.thisChannel + " low current", result)
 
         def finish(self):
 
             super().finish_cal()
 
         def report(self,data):
 
             return super().report("calibrate",data)
 
         def readCoefficients(self):
 
             coefficients = {}
-            # get 12v low current multiplier
-            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + QTL2887.V12_LOW_MULTIPLIER_ADDR)
-            # get 12v low current offset
-            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + QTL2887.V12_LOW_OFFSET_ADDR)
+            # get low current multiplier
+            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_LOW_MULTIPLIER"])
+            # get low current offset
+            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_LOW_OFFSET"])
             return coefficients
 
         def writeCoefficients(self,coefficients):
 
-            # write 12v low current multiplier
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2887.V12_LOW_MULTIPLIER_ADDR + " " + coefficients["multiplier"])
-            # write 12v low current offset
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2887.V12_LOW_OFFSET_ADDR + " " + coefficients["offset"])
+            # write low current multiplier
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_LOW_MULTIPLIER"] + " " + coefficients["multiplier"])
+            # write low current offset
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_LOW_OFFSET"] + " " + coefficients["offset"])
 
-    class QTL2887_12V_HighCurrentCalibration (QTL2887Calibration):
+    class QTL2525_HighCurrentCalibration (QTL2525Calibration):
 
-        def __init__(self,powerModule):
+        def __init__(self,powerModule,thisChannel):
 
-            self.title = "12V High Current Calibration"
+            self.thisChannel = thisChannel
+            self.title = thisChannel + " High Current Calibration"
             self.powerModule = powerModule
-            self.absErrorLimit = 2000   # 2mA
-            self.relErrorLimit = 1      # 1%
-            self.test_min = 1000        # 1mA
-            self.test_max = 4000000     # 4A
+            self.absErrorLimit = 2000               # 2mA
+            self.relErrorLimit = 1                  # 1%
+            self.test_min = 1000                    # 1mA
+            self.test_max = 4000000                 # 4A
             self.test_steps = 20
             self.units = "uA"
             self.scaling = 2048
             self.multiplier_signed = False
             self.multiplier_int_width = 1
             self.multiplier_frac_width = 16
             self.offset_signed = True
             self.offset_int_width = 10
             self.offset_frac_width = 6
 
         def init(self):
 
-            super().init_cal("12v")
+            super().init_cal(self.thisChannel)
 
-            #set manual range, full averaging, 12v high current mode, 5V all off (so we can detect we're connected to the wrong channel
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2887.CALIBRATION_CONTROL_ADDR + " 0x00F8")
+            #set manual range, full averaging, [thisChannel] high current mode, other channels all off (so we can detect we're connected to the wrong channel
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CONTROL_ADDRESSES["CALIBRATION_CONTROL"] + " " + self.powerModule.CONTROL_ADDRESSES[self.thisChannel + "_HIGH_CALIBRATION_CONTROL_SETTING"])
             # clear the multiplier and offset registers by setting them to zero
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2887.V12_HIGH_MULTIPLIER_ADDR + " 0x0000")
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2887.V12_HIGH_OFFSET_ADDR + " 0x0000")
-
-            self.powerModule.setConnections("12V","12V")
-            # Check Host Power is present      
-            while (super().checkLoadVoltage(QTL2887.LOAD_VOLTAGE,1000) != True):
-                input("Unexpected voltage detected at load, please check connections")
-                self.powerModule.setConnections("12V","12V",reset=True)
-
-        def setRef(self,value):
-
-            load_set_cur(self.powerModule.calInstrument,value)
-
-        def readRef(self):
-
-            # read device voltage and add leakage current to the reference
-            voltage =  super().meas_12v_volt()
-            return load_meas_cur(self.powerModule.calInstrument)# + leakage
-
-        def readVal(self):
-
-            return super().meas_12v_cur()
-
-        def setCoefficients(self):
-
-            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2887.V12_HIGH_MULTIPLIER_ADDR + " " + self.multiplier.hexString(4))
-            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2887.V12_HIGH_OFFSET_ADDR + " " + self.offset.hexString(4))
-            if result1 and result2:
-                result = True
-            else:
-                result = False
-            logSimpleResult("Set 12v high current", result)
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_HIGH_MULTIPLIER"] + " 0x0000")
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_HIGH_OFFSET"] + " 0x0000")
 
-        def finish(self):
-
-            super().finish_cal()
-
-        def report(self,data):
-
-            return super().report("calibrate",data)
-
-        def readCoefficients(self):
-
-            coefficients = {}
-            # get 12v high current multiplier
-            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + QTL2887.V12_HIGH_MULTIPLIER_ADDR)
-            # get 12v high current offset
-            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + QTL2887.V12_HIGH_OFFSET_ADDR)
-            return coefficients
-
-        def writeCoefficients(self,coefficients):
-
-            # write 12v high current multiplier
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2887.V12_HIGH_MULTIPLIER_ADDR + " " + coefficients["multiplier"])
-            # write 12v high current offset
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2887.V12_HIGH_OFFSET_ADDR + " " + coefficients["offset"])
-
-    class QTL2887_3V3_AUX_VoltageCalibration (QTL2887Calibration):
-
-        def __init__(self,powerModule):
-
-            self.title = "3.3V Aux Voltage Calibration"
-            self.powerModule = powerModule
-            self.absErrorLimit = 2              # 2mV
-            self.relErrorLimit = 1              # 1%
-            self.test_min = 40                  # 40mV
-            self.test_max = 14400               # 14.4V
-            self.test_steps = 20
-            self.units = "mV"
-            self.scaling = 4
-            self.multiplier_signed = False
-            self.multiplier_int_width = 1
-            self.multiplier_frac_width = 16
-            self.offset_signed = True
-            self.offset_int_width = 10
-            self.offset_frac_width = 6
-
-        def init(self):
-
-            super().init_cal("3V3_AUX")
-
-            # clear the multiplier and offset registers by setting them to zero
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2887.V3_3_AUX_VOLT_MULTIPLIER_ADDR + " 0x0000")
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2887.V3_3_AUX_VOLT_OFFSET_ADDR + " 0x0000")
-
-            self.powerModule.setConnections("3V3_AUX",None)
-            ## Check Host Power is not present
-            #while (super().checkLoadVoltage(500,500) != True):
-            #	input("Unexpected voltage detected at load, please check connections")
-            #	self.powerModule.setConnections("3V3_AUX",None,reset=True)
-
-
-        def setRef(self,value):
-
-            return load_set_volt(self.powerModule.calInstrument,value)
-
-        def readRef(self):
-
-            return load_meas_volt(self.powerModule.calInstrument)
-
-        def readVal(self):
-
-            return super().meas_3v3_aux_volt()
-
-        def setCoefficients(self):
-
-            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2887.V3_3_AUX_VOLT_MULTIPLIER_ADDR + " " + self.multiplier.hexString(4))
-            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2887.V3_3_AUX_VOLT_OFFSET_ADDR + " " + self.offset.hexString(4))
-            if result1 and result2:
-                result = True
-            else:
-                result = False
-            logSimpleResult("Set 3.3v Aux voltage", result)
-
-        def finish(self):
-
-            super().finish_cal()
-
-        def report(self,data):
-
-            return super().report("calibrate",data)
-
-        def readCoefficients(self):
-
-            coefficients = {}
-            # get 3v3 Aux voltage multiplier
-            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + QTL2887.V3_3_AUX_VOLT_MULTIPLIER_ADDR)
-            # get 3v3 Aux voltage offset
-            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + QTL2887.V3_3_AUX_VOLT_OFFSET_ADDR)
-            return coefficients
-
-        def writeCoefficients(self,coefficients):
-
-            # write 3v3 Aux voltage multiplier
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2887.V3_3_AUX_VOLT_MULTIPLIER_ADDR + " " + coefficients["multiplier"])
-            # write 3v3 Aux voltage offset
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2887.V3_3_AUX_VOLT_OFFSET_ADDR + " " + coefficients["offset"])
-
-    class QTL2887_3V3_AUX_CurrentCalibration (QTL2887Calibration):
-
-        def __init__(self,powerModule):
-
-            self.title = "3.3V Aux Current Calibration"
-            self.powerModule = powerModule
-            self.absErrorLimit = 15         # 15uA
-            self.relErrorLimit = 1          # 1%
-            self.test_min = 10              # 10uA
-            self.test_max = 85000           # 85mA
-            self.test_steps = 20
-            self.units = "uA"
-            self.scaling = 32
-            self.multiplier_signed = False
-            self.multiplier_int_width = 1
-            self.multiplier_frac_width = 16
-            self.offset_signed = True
-            self.offset_int_width = 10
-            self.offset_frac_width = 6
-
-        def init(self):
-
-            super().init_cal("3V3_AUX")
-
-            # clear the multiplier and offset registers by setting them to zero
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2887.V3_3_AUX_MULTIPLIER_ADDR + " 0x0000")
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2887.V3_3_AUX_OFFSET_ADDR + " 0x0000")
-
-            self.powerModule.setConnections("3V3_AUX","3V3_AUX")
-            # Check Host Power is not present	    
-            while (super().checkLoadVoltage(QTL2887.LOAD_VOLTAGE,1000) != True):
-            	input("Unexpected voltage detected at load, please check connections")
-            	self.powerModule.setConnections("3V3_AUX","3V3_AUX",reset=True)
+            self.powerModule.host_switchbox.setConnections([("12V",self.thisChannel + '_SUPPLY'),("LOAD",self.thisChannel + '_LOAD')])
+            # Check Host Power is present
+            while (super().checkLoadVoltage(self.powerModule.LOAD_VOLTAGE,1000) != True):
+                showDialog(message="Host Power not detected, please check the connections",title="Check Connections")
+                self.powerModule.host_switchbox.setConnections([("12V",self.thisChannel + '_SUPPLY'),("LOAD",self.thisChannel + '_LOAD')])
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
             # read device voltage and add leakage current to the reference
-            voltage =  super().meas_3v3_aux_volt()
-            #leakage = voltage*self.powerModule.calibrations["3.3V Aux"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["3.3V Aux"]["Leakage"].offset.originalValue()
-            return load_meas_cur(self.powerModule.calInstrument)# + leakage
+            #voltage =  getFixtureData(self.powerModule.dut,self.thisChannel + " V")
+            #leakage = voltage*self.powerModule.calibrations["POWER_1"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["POWER_1"]["Leakage"].offset.originalValue()
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000# + leakage
 
         def readVal(self):
 
-            return super().meas_3v3_aux_cur()
+            return getFixtureData(self.powerModule.dut,self.thisChannel + " A")
 
         def setCoefficients(self):
 
-            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2887.V3_3_AUX_MULTIPLIER_ADDR + " " + self.multiplier.hexString(4))
-            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2887.V3_3_AUX_OFFSET_ADDR + " " + self.offset.hexString(4))
+            result1 = self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_HIGH_MULTIPLIER"] + " " + self.multiplier.hexString(4))
+            result2 = self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_HIGH_OFFSET"] + " " + self.offset.hexString(4))
             if result1 and result2:
                 result = True
             else:
                 result = False
-            logSimpleResult("Set 3.3v Aux low current", result)
-
-            # once we've completed low and high current we can set leakage on the fixture
-            #result = self.powerModule.dut.sendAndVerifyCommand("write " + QTL2887.V3_3_AUX_LEAKAGE_MULTIPLIER_ADDR + " " + self.powerModule.calibrations["3.3V Aux"]["Leakage"].multiplier.hexString(4))
+            logSimpleResult("Set " + self.thisChannel + " high current", result)
 
         def finish(self):
 
             super().finish_cal()
 
         def report(self,data):
 
             return super().report("calibrate",data)
 
         def readCoefficients(self):
 
             coefficients = {}
-            # get 3v3 Aux low current multiplier
-            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + QTL2887.V3_3_AUX_MULTIPLIER_ADDR)
-            # get 3v3 Aux low current offset
-            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + QTL2887.V3_3_AUX_OFFSET_ADDR)
+            # get high current multiplier
+            coefficients["multiplier"] = self.powerModule.dut.sendCommand("read " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_HIGH_MULTIPLIER"])
+            # get high current offset
+            coefficients["offset"] = self.powerModule.dut.sendCommand("read " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_HIGH_OFFSET"])
             return coefficients
 
         def writeCoefficients(self,coefficients):
 
-            # write 3v3 Aux low current multiplier
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2887.V3_3_AUX_MULTIPLIER_ADDR + " " + coefficients["multiplier"])
-            # write 3v3 Aux low current offset
-            self.powerModule.dut.sendAndVerifyCommand("write " + QTL2887.V3_3_AUX_OFFSET_ADDR + " " + coefficients["offset"])
+            # write high current multiplier
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_HIGH_MULTIPLIER"] + " " + coefficients["multiplier"])
+            # write high current offset
+            self.powerModule.dut.sendAndVerifyCommand("write " + self.powerModule.CAL_ADDRESSES[self.thisChannel + "_HIGH_OFFSET"] + " " + coefficients["offset"])
 
-    class QTL2887_12V_VoltageVerification (QTL2887Calibration):
+    class QTL2525_VoltageVerification (QTL2525Calibration):
 
-        def __init__(self,powerModule):
+        def __init__(self,powerModule,thisChannel):
 
-            self.title = "12V Voltage Verification"
+            self.thisChannel = thisChannel
+            self.title = thisChannel + " Voltage Verification"
             self.powerModule = powerModule
             self.absErrorLimit = 2      # 2mV
             self.relErrorLimit = 1      # 1%
             self.test_min = 40          # 40mV
             self.test_max = 14400       # 14.4V
             self.test_steps = 20
             self.units = "mV"
 
         def init(self):
 
-            super().init_cal("12V")
+            super().init_cal(self.thisChannel)
 
-            self.powerModule.setConnections("12V",None)
-            # Check Host Power is not present	    
-            while (super().checkLoadVoltage(500,500) != True):
-            	input("Unexpected voltage detected at load, please check connections")
-            	self.powerModule.setConnections("12V",None,reset=True)
+            self.powerModule.host_switchbox.setConnections([("12V",None),("LOAD",self.thisChannel + "_LOAD")])
 
         def setRef(self,value):
 
-            return load_set_volt(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
 
         def readRef(self):
 
-            return load_meas_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def readVal(self):
 
-            return super().meas_12v_volt()
+            return getFixtureData(self.powerModule.dut,self.thisChannel + " V")
 
         def finish(self):
 
             super().finish_cal()
 
         def report(self,data):
 
             return super().report("verify",data)
 
-    class QTL2887_12V_LowCurrentVerification (QTL2887Calibration):
+    class QTL2525_LowCurrentVerification (QTL2525Calibration):
 
-        def __init__(self,powerModule):
+        def __init__(self,powerModule,thisChannel):
 
-            self.title = "12V Low Current Verification"
+            self.thisChannel = thisChannel
+            self.title = thisChannel + " Low Current Verification"
             self.powerModule = powerModule
-            self.absErrorLimit = 25     # 2uA
-            self.relErrorLimit = 1      # 1% tolerance
+            self.absErrorLimit = 25     # 25uA  - Deliberately higher than calibration limit
+            self.relErrorLimit = 1      # 1%
             self.test_min = 100         # 100uA
             self.test_max = 1000        # 1mA
             self.test_steps = 20
             self.units = "uA"
 
         def init(self):
 
-            super().init_cal("12V")
+            super().init_cal(self.thisChannel)
 
-            self.powerModule.setConnections("12V","12V")	    
+            self.powerModule.host_switchbox.setConnections([("12V",self.thisChannel + '_SUPPLY'),("LOAD",self.thisChannel + '_LOAD')])
 
             # Check Host Power is present
-            while (super().checkLoadVoltage(QTL2887.LOAD_VOLTAGE,500) != True):
-            	input("Unexpected voltage detected at load, please check connections")
-            	self.powerModule.setConnections("12V","12V",reset=True)
-            	
+            while (super().checkLoadVoltage(self.powerModule.LOAD_VOLTAGE,1000) != True):
+                showDialog(message="Host Power not detected, please check the connections",title="Check Connections")
+                self.powerModule.host_switchbox.setConnections([("12V",self.thisChannel + '_SUPPLY'),("LOAD",self.thisChannel + '_LOAD')])
+
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
-            return load_meas_cur(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
-            return super().meas_12v_cur()
+            return getFixtureData(self.powerModule.dut,self.thisChannel + " A")
 
         def finish(self):
 
             super().finish_cal()
 
         def report(self,data):
 
             return super().report("verify",data)
 
-    class QTL2887_12V_HighCurrentVerification (QTL2887Calibration):
+    class QTL2525_HighCurrentVerification (QTL2525Calibration):
 
-        def __init__(self,powerModule):
+        def __init__(self,powerModule,thisChannel):
 
-            self.title = "12V High Current Verification"
+            self.thisChannel = thisChannel
+            self.title = thisChannel + " High Current Verification"
             self.powerModule = powerModule
             self.absErrorLimit = 2000       # 2mA
             self.relErrorLimit = 1          # 1% tolerance
             self.test_min = 1000            # 1mA
             self.test_max = 4000000         # 4A
             self.test_steps = 20
             self.units = "uA"
 
         def init(self):
 
-            super().init_cal("12v")
-
-            self.powerModule.setConnections("12V","12V")
-            # Check Host Power is present	    	    
-            while (super().checkLoadVoltage(QTL2887.LOAD_VOLTAGE,500) != True):
-            	input("Unexpected voltage detected at load, please check connections")
-            	self.powerModule.setConnections("12V","12V",reset=True)
-
-        def setRef(self,value):
-
-            load_set_cur(self.powerModule.calInstrument,value)
-
-        def readRef(self):
-
-            return load_meas_cur(self.powerModule.calInstrument)
-
-        def readVal(self):
-
-            return super().meas_12v_cur()
-
-        def finish(self):
-
-            super().finish_cal()
-
-        def report(self,data):
-
-            return super().report("verify",data)
-
-    class QTL2887_3V3_AUX_VoltageVerification (QTL2887Calibration):
-
-        def __init__(self,powerModule):
-
-            self.title = "3.3V Aux Voltage Verification"
-            self.powerModule = powerModule
-            self.absErrorLimit = 2      # 2mV
-            self.relErrorLimit = 1      # 1%
-            self.test_min = 40          # 40mV
-            self.test_max = 14400       # 14.4V
-            self.test_steps = 20
-            self.units = "mV"
-
-        def init(self):
+            super().init_cal(self.thisChannel)
 
-            super().init_cal("3V3_AUX")
+            self.powerModule.host_switchbox.setConnections([("12V",self.thisChannel + '_SUPPLY'),("LOAD",self.thisChannel + '_LOAD')])
+            # Check Host Power is present
+            while (super().checkLoadVoltage(self.powerModule.LOAD_VOLTAGE,1000) != True):
+                showDialog(message="Host Power not detected, please check the connections",title="Check Connections")
+                self.powerModule.host_switchbox.setConnections([("12V",self.thisChannel + '_SUPPLY'),("LOAD",self.thisChannel + '_LOAD')])
 
-            self.powerModule.setConnections("3V3_AUX",None)
-            # Check Host Power is not present	    
-            while (super().checkLoadVoltage(500,500) != True):
-            	input("Unexpected voltage detected at load, please check connections")
-            	self.powerModule.setConnections("3V3_AUX",None,reset=True)
-            	
         def setRef(self,value):
 
-            return load_set_volt(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
-            return load_meas_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
-            return super().meas_3v3_aux_volt()
+            return getFixtureData(self.powerModule.dut,self.thisChannel + " A")
 
         def finish(self):
 
             super().finish_cal()
 
         def report(self,data):
 
             return super().report("verify",data)
 
-    class QTL2887_3V3_AUX_CurrentVerification (QTL2887Calibration):
+    class QTL2525_AuxCurrentVerification (QTL2525Calibration):
 
-        def __init__(self,powerModule):
+        def __init__(self,powerModule,thisChannel):
 
-            self.title = "3.3V Aux Current Verification"
+            self.thisChannel = thisChannel
+            self.title = thisChannel + " Aux Current Verification"
             self.powerModule = powerModule
             self.absErrorLimit = 25     # 25uA
             self.relErrorLimit = 1      # 1%
             self.test_min = 100         # 100uA
             self.test_max = 85000       # 85mA
             self.test_steps = 20
             self.units = "uA"
 
         def init(self):
 
-            super().init_cal("3V3_AUX")
+            super().init_cal(self.thisChannel)
+
+            self.powerModule.host_switchbox.setConnections([("12V",self.thisChannel + '_SUPPLY'),("LOAD",self.thisChannel + '_LOAD')])
+
+            # Check Host Power is present
+            while (super().checkLoadVoltage(self.powerModule.LOAD_VOLTAGE,1000) != True):
+                showDialog(message="Host Power not detected, please check the connections",title="Check Connections")
+                self.powerModule.host_switchbox.setConnections([("12V",self.thisChannel + '_SUPPLY'),("LOAD",self.thisChannel + '_LOAD')])
 
-            self.powerModule.setConnections("3V3_AUX","3V3_AUX")
-            # Check Host Power is present	    
-            while (super().checkLoadVoltage(QTL2887.LOAD_VOLTAGE,1000) != True):
-            	input("Unexpected voltage detected at load, please check connections")
-            	self.powerModule.setConnections("3V3_AUX","3V3_AUX",reset=True)
-    
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
-            return load_meas_cur(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
-            return super().meas_3v3_aux_cur()
+            return getFixtureData(self.powerModule.dut,self.thisChannel + " A")
 
         def finish(self):
 
             super().finish_cal()
 
         def report(self,data):
 
             return super().report("verify",data)
-
-
-
-    def __init__(self,dut):
-
-        # set the name of this module
-        self.name = "PCIe x16 Power Measurement Fixture"
-        self.dut = dut
-        
-        # Serial numbers (ensure QTL at start)
-        self.enclosureSerial = self.dut.sendCommand("*ENCLOSURE?")
-        if (self.enclosureSerial.find ("QTL") == -1):
-            self.enclosureSerial = "QTL" + self.enclosureSerial
-        # fetch the enclosure position
-        self.enclosurePosition = self.dut.sendCommand("*POSITION?")
-        self.PAMSerial = self.dut.sendCommand ("*SERIAL?")
-        if (self.PAMSerial.find ("QTL") == -1):
-            self.PAMSerial = "QTL" + self.PAMSerial
-        # Fixture Serial
-        # fixture serial is retrieved as BCD, we need to convert and pad it
-        self.FixtureSerial = "QTL" + bcdString(dut.sendCommand("read 0xA102"),4) + "-" + bcdString(dut.sendCommand("read 0xA103"),2) + "-" + bcdString(dut.sendCommand("read 0xA104"),3) # TODO: this should be replaced with fix:serial? command when implemented
-        # calObjectSerial Serial
-        self.calObjectSerial = self.FixtureSerial
-        # Filename String
-        self.filenameString = self.FixtureSerial
-        # Code version (FPGA)
-        self.idnStr = dut.sendCommand ("*IDN?")
-        pos = self.idnStr.upper().find ("FPGA 1:")
-        if (pos != -1):
-            versionStr = self.idnStr[pos+7:]
-            pos = versionStr.find ("\n")
-            if (pos != -1):
-                versionStr = versionStr[:pos].strip()
-            else:
-                pass
-        else:
-            versionStr = "NOT-FOUND"    
-        self.Fpga = versionStr.strip()
-    
-        # Code version (FW)    
-        pos = self.idnStr.upper().find ("PROCESSOR:")
-        if (pos != -1):
-            versionStr = self.idnStr[pos+10:]
-            pos = versionStr.find ("\n")
-            if (pos != -1):
-                versionStr = versionStr[:pos].strip()            
-            else:
-                pass
-        else:
-            versionStr = "NOT-FOUND"    
-        self.Firmware = versionStr.strip()
-
-        self.calibrations = {}
-        # populate 12V channel with calibrations
-        self.calibrations["12V"] = {
-            "Voltage":self.QTL2887_12V_VoltageCalibration(self),
-            #"Leakage":self.QTL2887_12V_LeakageCalibration(self),
-            "Low Current":self.QTL2887_12V_LowCurrentCalibration(self),
-            "High Current":self.QTL2887_12V_HighCurrentCalibration(self)
-            }
-			
-        # populate 3V3_AUX channel with calibrations
-        self.calibrations["3.3V Aux"] = {
-            "Voltage":self.QTL2887_3V3_AUX_VoltageCalibration(self),
-            #"Leakage":self.QTL2887_3V3_AUX_LeakageCalibration(self),
-            "Current":self.QTL2887_3V3_AUX_CurrentCalibration(self)
-            }
-
-        self.verifications = {}
-        # populate 12V channel with verifications
-        self.verifications["12V"] = {
-            "Voltage":self.QTL2887_12V_VoltageVerification(self),
-            "Low Current":self.QTL2887_12V_LowCurrentVerification(self),
-            "High Current":self.QTL2887_12V_HighCurrentVerification(self)
-            }
-        
-        # populate 3V3_AUX channel with verifications
-        self.verifications["3.3V Aux"] = {
-            "Voltage":self.QTL2887_3V3_AUX_VoltageVerification(self),
-            "Current":self.QTL2887_3V3_AUX_CurrentVerification(self)
-            }
-
```

## Comparing `quarchCalibration-1.1.5.dist-info/METADATA` & `quarchCalibration-1.1.5.dev1.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: quarchCalibration
-Version: 1.1.5
+Version: 1.1.5.dev1
 Summary: This packpage offers calibration for Quarch Technology modules.
 Author: Quarch Technology ltd
 Author-email: support@quarch.com
 License: Quarch Technology ltd
 Keywords: quarch quarchpy calibration torridon
 Classifier: Intended Audience :: Information Technology
 Classifier: Intended Audience :: Developers
```

## Comparing `quarchCalibration-1.1.5.dist-info/RECORD` & `quarchCalibration-1.1.5.dev1.dist-info/RECORD`

 * *Files 20% similar despite different names*

```diff
@@ -1,31 +1,35 @@
+quarchCalibration/BK9832B.py,sha256=lDCAIAvkw4WFyCfyxw0LtxVTV9fFkGAFJPGdXAHvFFU,25225
 quarchCalibration/ET2260.py,sha256=9nt9CfIbqz8kcGSBQnLsyScxPU3e7oNBlGg3TvWfkKQ,7185
-quarchCalibration/PowerModuleCalibration.py,sha256=BOHF-p_SHJYAI9uqn5Jh4RHaYAyhCODAzX-_AssWRG4,25831
-quarchCalibration/QTL1944.py,sha256=ovRvQHnMtjNKAlIG8-_r78gqxvh1PjoNYZveG-z8rYM,65172
-quarchCalibration/QTL1944_06.py,sha256=2rUkaiFahHNGea9L00-FZTU70GDA7-NMuRd3ve4NYh4,68014
-quarchCalibration/QTL2347.py,sha256=UMCYz6Nm3xxIqksO6xATkSwTwpS_JymMzLLD8B6y7rA,74788
-quarchCalibration/QTL2525.py,sha256=byyxnxllbLmCUhNqKZljbOwh6TOJvnq2mGs3Ri85XZc,64669
-quarchCalibration/QTL2582.py,sha256=-zAmaP_Wcem71VhuNleCQoT4UvZ6aPz9hgdFVpLP5DY,44492
-quarchCalibration/QTL2621.py,sha256=xE0bH2lxLAgUVCEekDyWxGj0nvipwmZrqjiNSz0ijy8,54288
-quarchCalibration/QTL2673.py,sha256=DnMP8cKcVV24zULtKdb-d_vnT_Qvh7dz_7iIXWav0UY,47096
-quarchCalibration/QTL2674.py,sha256=5Qxr9vOx-A6spwox6VqFnc6EEJM1m-ejf9lvyajS41U,46762
-quarchCalibration/QTL2788.py,sha256=v1kh3dUu6MfrKBrwyxGn6a7fJ2alZHqCgYxgRFI1WKA,64687
-quarchCalibration/QTL2843.py,sha256=1S6mR0HXyLsiOc_giooM4t2ZG2ckN9HnamsF9glbuWg,46445
-quarchCalibration/QTL2887.py,sha256=zJi_jjis4S7P3wbQHY40doKExYoVAGC1UrtVBGB2I0Y,46762
-quarchCalibration/QTL2888.py,sha256=AKlSBO3-U75J78URiLqVsXmtv1PMSOQUpdJFPCpXd-Q,46762
-quarchCalibration/__init__.py,sha256=mbzK24iscOr7nwFCEupkdLEp-M2Vs2W7mCR76GZz20Q,526
+quarchCalibration/Keithley_DMM6500_control.py,sha256=dMBK1xoohrCJ0PiVGpfpZmbi9vX97Dsf3EyzVLGVxiI,18660
+quarchCalibration/Keysight_AC6804B_control.py,sha256=gDxKi1SAOxUl7DdmaYp2vQsd_bIo58X4XCKgLXNk5yI,19603
+quarchCalibration/PowerModuleCalibration.py,sha256=x4rsb27cksOeG3zubfiB93ixhoAO8aklpoW8qV8PwDs,23554
+quarchCalibration/QTL1944_06_hd_plus_ppm.py,sha256=ww60xV8kxgUbSNk_jN11ixQBFoVgDcUovjZYZPqQJ8g,68014
+quarchCalibration/QTL1944_hd_ppm.py,sha256=ovRvQHnMtjNKAlIG8-_r78gqxvh1PjoNYZveG-z8rYM,65172
+quarchCalibration/QTL2347_pcie.py,sha256=nWS8MWMo_1L6exG7DcNe7Y9D3hIDKaIoP-NM_fboVTQ,49330
+quarchCalibration/QTL2525_sff.py,sha256=L_uMhk47KVs81EUFVYGPuaLALhpPvkOGEYvnLQcgENg,39890
+quarchCalibration/QTL2536_6_way_switchbox.py,sha256=2_gODxuIsheQyRYC1EuuRRznQ8E1uTl34Ue4X0YuY-I,2966
+quarchCalibration/QTL2582_3ph_ac.py,sha256=uxkTiZsoJgOOIhCqUB0giVQAmagrKmLcyQ1752UTY4c,40468
+quarchCalibration/QTL2621_2ch_mezz.py,sha256=dRybUnoKgPqetEk_68yENEtSPySYxE7Gja3fd0B_tzI,39414
+quarchCalibration/QTL2626_4ch_mezz.py,sha256=Cr_U4jc0-VBwHHSApb6jL7TL4CrPytpO71GReHJmPek,32603
+quarchCalibration/QTL2631_ext_mezz.py,sha256=IjeQkIW3bVKcviXX5MARViEsvjRhaZK5u_8icrzw1x8,33360
+quarchCalibration/QTL2673_edsff.py,sha256=Q65K1MNTRMxIrdgHPvgjNzZITCAUpaAWM6LdTS6Bq7w,37022
+quarchCalibration/QTL2843_iec_ac.py,sha256=6dZ2oPrDFLwtz5MvEJCYNiC9wPyoDyO5tjofMmz-dAM,40449
+quarchCalibration/__init__.py,sha256=P9qGw04tWqlg9S_Kq24Lr6TQiWwc-6aCs48mWEt8aRc,632
 quarchCalibration/__main__.py,sha256=gZxkbC5-1lzb_PZnjMW68hExuCWkFevjP5ED39w1KSo,82
-quarchCalibration/_version.py,sha256=KLQb3GCeXw4r8Bf9qIvjUMx5wCHESIM8ynu8zSnf8cI,21
+quarchCalibration/_version.py,sha256=6b4mCOKQWJFN-xC4f6vzBIm50T3MkvMn73_XREqb5bk,26
+quarchCalibration/acHelpers.py,sha256=rnq9q5BDCOatki9qan3gmZ7GsVYJXqAVZrbmXzGQqkg,6523
 quarchCalibration/calibrationConfig.py,sha256=kfyTEUJFHFh9WHiudgXIA2gmW53IB1cc76523YWsOQM,713
-quarchCalibration/calibrationUtil.py,sha256=mukALOGc6Al6BC5Bb3X2eN397cfPSJuFpBlOqTke_tk,19316
+quarchCalibration/calibrationUtil.py,sha256=sogYOO6x5yJRIBao1ZCiVSIC_gefV-9HNGhdgQRInmI,17889
 quarchCalibration/deviceHelpers.py,sha256=O4K3JnldZjFoCPcrBqhDgrdSeDEiA-eR5_wM5IHzKPw,4126
-quarchCalibration/elpaSine.py,sha256=zxpEgHTJI3tm6P2V5gUsi4th6KzOb7ORjYrHVnL6Ev4,9926
+quarchCalibration/elpaSine.py,sha256=3iUaEGQ2VPh06YU4NerdKp2FQsKNO1Y7oQ0ZUUxfv-c,9958
 quarchCalibration/keithley_2460_control.py,sha256=8BjRY7R1mViFcqOOIUUyqcIltUDnz1DkZwUSm44heZU,22184
-quarchCalibration/noise_test.py,sha256=tpgNPyyLnkkdK655CD68Coij99tPICjYbbSDto0DvBY,9379
+quarchCalibration/noise_test.py,sha256=p9D3yLouscf3ske4xEH8e096hamrfkFxHYZNhq4D7Ss,9506
 quarchCalibration/pamCommon.py,sha256=Miji_Ewuiyq-92EGb1YzWttWM_zNwxag4KpCXrR895E,39461
+quarchCalibration/pamHelpers.py,sha256=p0GCe0X-2Z_rbqkdLFyAaHraFabmhkbGxrjug0UJyRo,1072
 quarchCalibration/threePhaseSwitchBox.py,sha256=8LpjGFEMmznKWc2mwoYI9pUgHexr_DA5HMrYTv0hsOU,7585
 quarchCalibration/docs/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 quarchCalibration/docs/conf.py,sha256=QQjLji6g2mzCksnfluxXWHGgxpV5mrtGiTkH5kMCRWo,2076
-quarchCalibration-1.1.5.dist-info/METADATA,sha256=CU16Hv7mkFVfEeFhbIJg9K143l19Vv2QPYfwok2lcRg,1562
-quarchCalibration-1.1.5.dist-info/WHEEL,sha256=a-zpFRIJzOq5QfuhBzbhiA1eHTzNCJn8OdRvhdNX0Rk,110
-quarchCalibration-1.1.5.dist-info/top_level.txt,sha256=4sTt-nDiODeU-FUOWSdIZfUEK8olrtX1wbjExcJ-_3M,18
-quarchCalibration-1.1.5.dist-info/RECORD,,
+quarchCalibration-1.1.5.dev1.dist-info/METADATA,sha256=muAHQEDjVyPJ4wqV-UOn5VYysWcS2-nS8_tdgUhr_YA,1567
+quarchCalibration-1.1.5.dev1.dist-info/WHEEL,sha256=a-zpFRIJzOq5QfuhBzbhiA1eHTzNCJn8OdRvhdNX0Rk,110
+quarchCalibration-1.1.5.dev1.dist-info/top_level.txt,sha256=4sTt-nDiODeU-FUOWSdIZfUEK8olrtX1wbjExcJ-_3M,18
+quarchCalibration-1.1.5.dev1.dist-info/RECORD,,
```

