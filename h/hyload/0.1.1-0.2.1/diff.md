# Comparing `tmp/hyload-0.1.1-py3-none-any.whl.zip` & `tmp/hyload-0.2.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,19 +1,19 @@
-Zip file size: 25526 bytes, number of entries: 17
--rw-rw-rw-  2.0 fat      178 b- defN 23-Jul-05 09:45 hyload/__init__.py
--rw-rw-rw-  2.0 fat       17 b- defN 23-Jul-13 02:57 hyload/cfg.py
--rw-rw-rw-  2.0 fat    14049 b- defN 23-Jul-05 09:33 hyload/httpclient.py
--rw-rw-rw-  2.0 fat     2439 b- defN 21-Nov-12 07:11 hyload/logger.py
--rw-rw-rw-  2.0 fat    10289 b- defN 23-Jul-08 23:01 hyload/stats.py
--rw-rw-rw-  2.0 fat      979 b- defN 23-Jul-08 13:02 hyload/util.py
--rw-rw-rw-  2.0 fat        0 b- defN 21-Jun-03 08:31 hyload/tools/__init__.py
--rw-rw-rw-  2.0 fat     3667 b- defN 21-Dec-05 01:27 hyload/tools/plotperf.py
--rw-rw-rw-  2.0 fat     2802 b- defN 21-Dec-05 01:27 hyload/tools/plotresource.py
--rw-rw-rw-  2.0 fat    39521 b- defN 22-Mar-06 03:33 hyload/tools/puttyagents.py
--rw-rw-rw-  2.0 fat     3937 b- defN 23-Jul-08 23:53 hyload/tools/remoteop.py
--rw-rw-rw-  2.0 fat     7203 b- defN 23-Jul-12 02:03 hyload/tools/statshub.py
--rw-rw-rw-  2.0 fat     1100 b- defN 23-Jul-13 03:03 hyload-0.1.1.dist-info/LICENSE.txt
--rw-rw-rw-  2.0 fat     1482 b- defN 23-Jul-13 03:03 hyload-0.1.1.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-Jul-13 03:03 hyload-0.1.1.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        7 b- defN 23-Jul-13 03:03 hyload-0.1.1.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     1311 b- defN 23-Jul-13 03:03 hyload-0.1.1.dist-info/RECORD
-17 files, 89073 bytes uncompressed, 23402 bytes compressed:  73.7%
+Zip file size: 26033 bytes, number of entries: 17
+-rw-rw-rw-  2.0 fat      171 b- defN 23-Jul-19 05:41 hyload/__init__.py
+-rw-rw-rw-  2.0 fat       17 b- defN 23-Jul-17 05:11 hyload/cfg.py
+-rw-rw-rw-  2.0 fat    15612 b- defN 23-Jul-20 02:58 hyload/httpclient.py
+-rw-rw-rw-  2.0 fat     2439 b- defN 23-Jul-08 14:54 hyload/logger.py
+-rw-rw-rw-  2.0 fat    10770 b- defN 23-Jul-20 03:23 hyload/stats.py
+-rw-rw-rw-  2.0 fat      979 b- defN 23-Jul-08 14:54 hyload/util.py
+-rw-rw-rw-  2.0 fat        0 b- defN 23-Jul-08 14:54 hyload/tools/__init__.py
+-rw-rw-rw-  2.0 fat     3667 b- defN 23-Jul-08 14:54 hyload/tools/plotperf.py
+-rw-rw-rw-  2.0 fat     2802 b- defN 23-Jul-08 14:54 hyload/tools/plotresource.py
+-rw-rw-rw-  2.0 fat    39521 b- defN 23-Jul-08 14:54 hyload/tools/puttyagents.py
+-rw-rw-rw-  2.0 fat     3940 b- defN 23-Jul-20 08:38 hyload/tools/remoteop.py
+-rw-rw-rw-  2.0 fat     7493 b- defN 23-Jul-14 12:12 hyload/tools/statshub.py
+-rw-rw-rw-  2.0 fat     1100 b- defN 23-Jul-20 11:21 hyload-0.2.1.dist-info/LICENSE.txt
+-rw-rw-rw-  2.0 fat     1482 b- defN 23-Jul-20 11:21 hyload-0.2.1.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 23-Jul-20 11:21 hyload-0.2.1.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        7 b- defN 23-Jul-20 11:21 hyload-0.2.1.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     1311 b- defN 23-Jul-20 11:21 hyload-0.2.1.dist-info/RECORD
+17 files, 91403 bytes uncompressed, 23909 bytes compressed:  73.8%
```

## zipnote {}

```diff
@@ -30,23 +30,23 @@
 
 Filename: hyload/tools/remoteop.py
 Comment: 
 
 Filename: hyload/tools/statshub.py
 Comment: 
 
-Filename: hyload-0.1.1.dist-info/LICENSE.txt
+Filename: hyload-0.2.1.dist-info/LICENSE.txt
 Comment: 
 
-Filename: hyload-0.1.1.dist-info/METADATA
+Filename: hyload-0.2.1.dist-info/METADATA
 Comment: 
 
-Filename: hyload-0.1.1.dist-info/WHEEL
+Filename: hyload-0.2.1.dist-info/WHEEL
 Comment: 
 
-Filename: hyload-0.1.1.dist-info/top_level.txt
+Filename: hyload-0.2.1.dist-info/top_level.txt
 Comment: 
 
-Filename: hyload-0.1.1.dist-info/RECORD
+Filename: hyload-0.2.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## hyload/__init__.py

```diff
@@ -1,5 +1,5 @@
-from gevent import monkey,spawn,sleep
-monkey.patch_all()
-from hyload.stats import Stats
-from hyload.logger import TestLogger
-from hyload.httpclient import HttpsClient,HttpClient
+from gevent import monkey,spawn,sleep
+monkey.patch_all()
+from hyload.stats import Stats
+from hyload.logger import TestLogger
+from hyload.httpclient import HttpClient
```

## hyload/cfg.py

```diff
@@ -1 +1 @@
-Version = '0.1.1'
+Version = '0.2.1'
```

## hyload/httpclient.py

```diff
@@ -1,30 +1,33 @@
 # byhy performance testing lib: ByClient
 # Author : byhy
 
 import time,http.client,traceback,socket
 from urllib.parse import urlparse,urlencode
-from hyload.stats import Stats
+from hyload.stats import Stats,bcolors
 from hyload.util import getCurTime
 from hyload.logger import TestLogger
 import json as jsonlib
 from http.cookies import SimpleCookie
 
 
 CommonHeaders = {
     # 'User-Agent' : "hyload tester"
 }
 
+_sending_http_msg = ''
 
 _ori_http_send = http.client.HTTPConnection.send
 def _patch_httplib_funcs(encoding='utf8'):
     def new_send(self, data):
+        global _sending_http_msg
         if hasattr(data, "read"):
             return
-        print(data.decode(encoding),end='')
+        _sending_http_msg += data.decode(encoding)
+        # print(bcolors.OKGREEN + data.decode(encoding) + bcolors.ENDC, end='')
         return _ori_http_send(self, data)
     http.client.HTTPConnection.send = new_send
 
 
 def _unpatch_httplib_funcs():
     http.client.HTTPConnection.send = _ori_http_send
 
@@ -35,15 +38,15 @@
     def __init__(self,errortype):        
         self.errortype = errortype 
 
 
 # HTTPResponse Wraper obj
 # refer to  
 # https://docs.python.org/3/library/http.client.html#httpresponse-objects
-class HyHttpResponse():
+class HttpResponse():
     def __init__(self,
                  httpResponse:http.client.HTTPResponse,
                  rawBody,
                  responseTime,
                  url): # 响应时长毫秒为单位
         self.httpResponse = httpResponse
         self.raw = rawBody
@@ -104,299 +107,355 @@
         cookieDict = self.getAllCookies()
         return cookieDict.get(cookieName)
 
 
 
 # refer to https://docs.python.org/3/library/http.client.html#http.client.HTTPConnection
 class HttpClient:
-    MAX_KEEPALIVE_REQ_NUM = 90
     
-    def __init__(self,*args,**kargs): 
+    def __init__(self,timeout=10, proxy=None): 
         """
-        An HttpClient instance represents one transaction with an HTTP server.
+        An HyHTTPConnection instance represents one transaction with an HTTP server.
         """        
-        self.args  = args
-        self.kargs = kargs
-        self.cookie = SimpleCookie()
-        self.createConnection(*self.args,**self.kargs)
-        self.autoSendCookie = True
-        self._showRawMsg = False
+        self.timeout     = timeout
+        self.proxy       = proxy    # in form of 127.0.0.1:8888
+        self._conn       = None     # default HTTPConnection or  HTTPSConnection
+        self._conn_table = {}
+
+        self._showAllRawMsg = False
         self._msgEncodeing = 'utf-8'
+        self._httplibPathced = False
+
+    def createConnection(self, protocol, host, port):
+        
+        if protocol == 'http':
+            connection_class = http.client.HTTPConnection
+        elif protocol == 'https':
+            connection_class = http.client.HTTPSConnection
+        else:
+            raise Exception(f'unsupported protocol: {protocol}')
+        
+        # set default connection
+        if self.proxy is None:
+            self._conn = connection_class(host, port, timeout=self.timeout)
+        else:
+            self._conn = connection_class(self.proxy, timeout=self.timeout)
+            self._conn.set_tunnel(host, port)
+            
+        self._conn.protocol = protocol
+        self._conn.cookie = SimpleCookie()
+
+
+        self._conn_table[(protocol, host, port)] = self._conn
+        
+        self.host, self.port = self._conn.host, self._conn.port
 
-    def createConnection(self,*args,**kargs):
-        self.conn = http.client.HTTPConnection(
-                                *args,
-                                **kargs)
         try:
-            self.conn.connect()
+            self._conn.connect()
         except ConnectionRefusedError:
-            errInfo = '服务端拒绝连接，可能是服务没有启动'
+            errInfo = 'connection refused, maybe server not started'
             print('!!! ConnectionRefusedError\n' + errInfo)
             TestLogger.write(f'80|{errInfo}')
             
             raise
 
-        # 连接数量统计+1
         Stats.connectionNumIncreace()
-        self.ka_req_num = 0 # keep alive connect requests have been sent
-
-    # 可以设定代理
-    def proxy(self,proxyurl='127.0.0.1:8888'):
-        targeturl = self.args[0]
-        self.args = list(self.args)
-        self.args[0] = proxyurl
-
-        self.conn = http.client.HTTPConnection(
-            *self.args,
-            **self.kargs)
 
 
-        self.conn.set_tunnel(targeturl)
-
-    def showRawMsg(self, isShow:bool=False, encoding='utf8'):
+    def showRawMsg(self, isShow:bool=True, encoding='utf8'):
         """
         show or hide raw http messages
 
         Parameters
         ----------
         isShow : bool, optional
             True: show 
             False: not show
             
         encoding : string, optional
             Message Encoding, default is 'utf8'
             
         """
-        self._showRawMsg = isShow
+        self._showAllRawMsg = isShow
         self._msgEncodeing = encoding
         if isShow:
             _patch_httplib_funcs(encoding)
+            self._httplibPathced = True
         else:
             _unpatch_httplib_funcs()
     
-    # 设定是否自动发送保存的cookies
-    def autoSendCookie(self,isAuto):
-        self.autoSendCookie = isAuto
+
+    @staticmethod
+    def _urlAnalyze(url):
+        protocol, host, port, path = None, None, None, None
+
+        def handleUrlAfterHttpPrefix(url, urlPart, isSecure):
+            if len(urlPart) == 0:
+                raise Exception(f'url error:{url}')
+            
+            parts = urlPart.split('/',1)
+            host = parts[0]
+            path = '/' if len(parts)==1 else '/' + parts[1]
+
+            if ':' not in host:
+                port = 443 if isSecure else 80
+            else:
+                host, port = host.split(':')
+                port = int(port)
+
+            return host, port, path
+
+
+        if url.startswith('http://'):
+            protocol = 'http'
+            host, port, path = handleUrlAfterHttpPrefix(url, url[7:], False)
+
+        elif url.startswith('https://'):
+            protocol = 'https'
+            host, port, path = handleUrlAfterHttpPrefix(url, url[8:], True)
+
+        else: # url only contain path
+            path = url
+
+        return protocol, host, port, path
+
+
 
     # send request, https://docs.python.org/3/library/http.client.html#http.client.HTTPConnection.request
     # return HyResponse which is a HTTPResponse Wraper obj
     # args are method, url, body=None, headers=None, 
     def send(self,
             method:str,
             url:str,
             params=None,
             data=None, 
             json=None,
             encoding='utf8',
             headers=None, 
-            duration=None):
+            duration=None,
+            showRawMsg=False):
         
-        if url.startswith('http'):
-            try:
-                parts = url.split('//',1)[1].split('/',1)
-                if len(parts) == 1: # 只有主机名
-                    url = ''
+        global _sending_http_msg
+
+        if showRawMsg:
+            if not self._httplibPathced:
+                _patch_httplib_funcs(encoding)
+                self._httplibPathced = True
+
+        
+        protocol, host, port, path = self._urlAnalyze(url)
+
+        if not self._conn_table:  # no existing connections
+            if protocol is None:
+                raise Exception(f'url error:{url}, should have "http" or "https" as prefix')
+            
+            self.createConnection(protocol, host, port)
+            # print('no existing connections, create new connection')
+
+        else:                     # there are existing connections
+
+            if protocol is not None:
+                # print('protocol/host/port specified')
+                self._conn = self._conn_table.get((protocol, host, port))
+                if not self._conn:
+                    # print('protocol/host/port not used before, create new connection')
+                    self.createConnection(protocol, host, port)
                 else:
-                    url = '/' + parts[1]
-                    
-                
-            except:
-                raise Exception(f'url格式错误:{url}')
-                
+                    # print('protocol/host/port used before , use old connection')
+                    pass
+
+            else:
+                # print('protocol/host/port not specified, use default connection self._conn')
+                pass   
+             
             
         beforeSendTime = getCurTime()
 
         
         if headers is None: 
             headers = {}
         for k,v in CommonHeaders.items():
             if k not in headers:
                 headers[k] = v
 
         # add cookies
-        if self.autoSendCookie and len(self.cookie) > 0:
-            headers.update({'Cookie':self.cookie.output(header="",attrs=[],sep=';')})
+        if len(self._conn.cookie) > 0:
+            headers.update({'Cookie':self._conn.cookie.output(header="",attrs=[],sep=';')})
 
         # url params handle
         if params is not None:
             queryStr = urlencode(params)
-            if '?' in url:
-                url += '&' + queryStr
+            if '?' in path:
+                path += '&' + queryStr
             else:
-                url += '?' + queryStr
+                path += '?' + queryStr
 
 
 
         body = None
-        # json 格式消息体
+        # msg body is in format of JSON
         if json is not None:
             headers['Content-Type'] = 'application/json'
             body = jsonlib.dumps(json,ensure_ascii=False).encode(encoding)
 
         
+        # msg body is in format of urlencoded
         elif data is not None:
-            # urlencode 格式消息体
             if type(data) == dict:
                 headers['Content-Type'] = 'application/x-www-form-urlencoded'
                 body = urlencode(data).encode(encoding)
             # str类型，编码后放入消息体
             elif type(data) == str:
                 body = data.encode(encoding)
             # bytes类型，直接放入消息体
             elif type(data) == bytes:
                 body = data
 
         try:
-            if self._showRawMsg:
-                print('---------------------------')
-            self.conn.request(method, url, body, headers)
-            if self._showRawMsg:
-                print('\n---------------------------')
+            self._conn.request(method, path, body, headers)
+            if self._showAllRawMsg or showRawMsg:
+                print('\n---------------------------')       
+                print(bcolors.OKGREEN + _sending_http_msg + bcolors.ENDC, end='')
+                _sending_http_msg = ''
+                print('\n---------------------------')    
+
         except ConnectionRefusedError:
-            errInfo = '服务端拒绝连接，可能是服务没有启动'
+            errInfo = 'connection refused, maybe server not started'
             print('!!! ConnectionRefusedError\n' + errInfo)
             TestLogger.write(f'80|{errInfo}')
             
-            self.conn.close()
+            self._conn.close()
             
             raise
         
         except socket.timeout as e:
-            print('!!! socket.timeout 连接服务器超时')
+            print('!!! socket timeout', e)
             Stats.oneTimeout()
 
-            # 一旦超时，该connnection就不能再发送后续消息了。
-            # 必须重新创建 HttpClient 对象
-            self.conn.close()
+            self._conn.close()
             Stats.connectionNumDecreace()
-            self.createConnection(*self.args, **self.kargs)
+            # self.createConnection(*self.args, **self.kargs)
+
+            TestLogger.write(f'100|time out|{url}')
 
-            # 需要自动记录到日志中
-            TestLogger.write(f'100|连接超时|{url}')
             return ErrReponse(100)
+        
         except ConnectionAbortedError as e:
-            print('!!! ConnectionAbortedError\n发送请求过程中，连接突然中断')
+            print('!!! Connection Aborted during sending',e)
             Stats.oneError()
 
-            self.conn.close()
+            self._conn.close()
             Stats.connectionNumDecreace()
-            self.createConnection(*self.args, **self.kargs)
+            # self.createConnection(*self.args, **self.kargs)
             
-            # 需要自动记录到日志中
-            TestLogger.write(f'101|发送请求过程中，连接突然中断|{url}')
+            TestLogger.write(f'101|Connection Aborted during sending|{url}')
+
             return ErrReponse(101)
 
         afterSendTime = Stats.oneSent()
 
 
         # recv response
         try:
-            httpResponse = self.conn.getresponse()
+            httpResponse = self._conn.getresponse()
             
-            if self._showRawMsg:
-                print(f"HTTP/{'1.1' if httpResponse.version==11 else '1.0'}", httpResponse.status, httpResponse.reason)
-                print(httpResponse.msg.as_string(),end='')
+            if self._showAllRawMsg or showRawMsg:
+                print(bcolors.OKBLUE + f"HTTP/{'1.1' if httpResponse.version==11 else '1.0'} {httpResponse.status} {httpResponse.reason}" + bcolors.ENDC)
+                print(bcolors.OKBLUE + httpResponse.msg.as_string() + bcolors.ENDC,end='')
         except socket.timeout as e:
-            print('!!! 响应超时')
+            print('!!! response timeout')
 
             Stats.oneTimeout()
 
-            # 一旦超时，该connnection就不能再发送后续消息了。
-            # 必须重新创建 HttpClient 对象
-            self.conn.close()
+            self._conn.close()
             Stats.connectionNumDecreace()
-            self.createConnection(*self.args, **self.kargs)
+
+            # self.createConnection(*self.args, **self.kargs)
             
-            # 需要自动记录到日志中
-            TestLogger.write(f'110|响应超时|{url}')
+            TestLogger.write(f'110|response time out|{url}')
             return ErrReponse(110)
             
         except ConnectionAbortedError as e:
-            print('!!! ConnectionAbortedError\n接收响应过程中，连接突然中断')
+            print('!!! Connection Aborted during receiving response',e)
             Stats.oneError()
 
-            self.conn.close()
+            self._conn.close()
             Stats.connectionNumDecreace()
-            self.createConnection(*self.args, **self.kargs)
+            # self.createConnection(*self.args, **self.kargs)
             
-            # 需要自动记录到日志中
-            TestLogger.write(f'120|接收响应过程中连接突然中断|{url}')
+            TestLogger.write(f'120|Connection Aborted during receiving response|{url}')
             return ErrReponse(120)
 
         except http.client.RemoteDisconnected as e:
             # 这种情况很可能是 http连接闲置时间过长，服务端断开了连接，尝试重发            
-            self.conn.close()
+            self._conn.close()
             Stats.connectionNumDecreace()
-            self.createConnection(*self.args, **self.kargs)
+
+            # self.createConnection(*self.args, **self.kargs)
 
             try:
-                self.conn.request(method, url, body,headers)
+                self._conn.request(method, path, body, headers)
                 afterSendTime = Stats.oneSent()
-                httpResponse = self.conn.getresponse()
+                httpResponse = self._conn.getresponse()
 
-                info = f'*请求发出后，服务端断开连接，重连重发成功|{url}'
+                info = f'* after sending, server closed connection, reconnect and resending succeed|{url}'
                 print(info)
                 TestLogger.write(info)
             except:
                 Stats.oneError()
-                self.conn.close()
+                self._conn.close()
                 Stats.connectionNumDecreace()
-                self.createConnection(*self.args, **self.kargs)
+                # self.createConnection(*self.args, **self.kargs)
                             
-                err = f'130|请求发出后，服务端断开连接，重连重发失败!! |{url}'
+                err = f'130|after sending, server closed connection, reconnect and resending failed|{url}'
                 print(err)
                 TestLogger.write(err)
                 return ErrReponse(130)
                 
 
         # 下面是 可以正常接收响应 情况下 的代码
 
         recvTime = Stats.oneRecv(afterSendTime)
 
-        # 检查是否有cookie
+        # check cookie
         cookieHdrs = httpResponse.getheader('set-cookie')
         if cookieHdrs:
             # print (cookieHdrs)
-            self.cookie.load(cookieHdrs)
+            self._conn.cookie.load(cookieHdrs)
 
         # 如果 有 duration，需要接收完消息后sleep一点时间，确保整体时间为duration
         if duration:
             
             # print(f'send {beforeSendTime} -- recv {recvTime}')
             extraWait = duration-(recvTime-beforeSendTime)
             if extraWait >0:  # 因为小于1ms的sleep通常就是不准确的
                 # print(f'sleep {extraWait}')
                 time.sleep(extraWait)
 
-
-
+        
         rawBody = httpResponse.read()
         
-        if self._showRawMsg:
-            print(rawBody.decode(self._msgEncodeing))
-            print('---------------------------\n')
+        if self._showAllRawMsg or showRawMsg:
+            outputStr = rawBody.decode(self._msgEncodeing)
+            if len(outputStr) > 2048:
+                outputStr = outputStr[:2000] + '\n.................'
+            print(bcolors.OKBLUE + outputStr+ bcolors.ENDC)
+            print('\n')
 
 
-        self.response = HyHttpResponse(httpResponse,
+        self.response = HttpResponse(httpResponse,
                                    rawBody,
                                    int((recvTime-afterSendTime)*1000),
-                                   url)
+                                   path)
         
-        # 发出一定数量请求后主动关闭连接
-        self.ka_req_num += 1
-        # if self.ka_req_num >= self.MAX_KEEPALIVE_REQ_NUM
-        #     self.conn.close()
-        #     self.createConnection(*self.args, **self.kargs)
-        #     # print('Keep Alive reconnect')
+     
             
             
         return self.response
-
-    #  发送请求，也可以使用 sendAndRecv 方法
-    sendAndRecv = send
+    
 
     def  get(self,*args,**kargs):
         return self.send('GET',*args,**kargs)
         
     def  post(self,*args,**kargs):
         return self.send('POST',*args,**kargs)
         
@@ -408,18 +467,8 @@
         
     def  patch(self,*args,**kargs):
         return self.send('PATCH',*args,**kargs)
 
     def  head(self,*args,**kargs):
         return self.send('HEAD',*args,**kargs)
 
-class HttpsClient(HttpClient):
-    def __init__(self,*args,**kargs):
-        super().__init__(*args,**kargs)
-
-    def createConnection(self,*args,**kargs):
-        self.conn = http.client.HTTPSConnection(
-                                *args,
-                                **kargs)
-        self.ka_req_num = 0 # keep alive connect requests have been sent
-
```

## hyload/stats.py

```diff
@@ -1,14 +1,24 @@
 from hyload.util import getCurTime
 import time,sys,json,socket,os,gevent
 import http.client
 from urllib.parse import quote_plus
 
 
-
+class bcolors:
+    HEADER = '\033[95m'
+    OKBLUE = '\033[94m'
+    OKCYAN = '\033[96m'
+    OKGREEN = '\033[92m'
+    YELLOW = '\033[33m'
+    WARNING = '\033[93m'
+    FAIL = '\033[91m'
+    ENDC = '\033[0m'
+    BOLD = '\033[1m'
+    UNDERLINE = '\033[4m'
 
 def getCommandArg(argName):
     for arg in sys.argv[1:]:
         if f'{argName}=' in arg:
             value = arg.replace(f'{argName}=','')
             return value
     
@@ -125,32 +135,35 @@
 
         except Exception as e:
             print(f'send stats to console failed! {e}')
 
 
     @classmethod
     def _statsOneTable(cls,
+                       strLastSecond,
                       lastSecond,
                       table,
                       tableName,
                       action,
                       statsOneSecond):
 
         # 如果前1秒 有记录， 打印出记录，并且加入发送给console的信息里
         if lastSecond in table:
-            print(f'{lastSecond} s: {action} {table[lastSecond]:6}')
+            if not cls.runFlag:
+                print(f'{strLastSecond}> {action} {table[lastSecond]:6}')
             statsOneSecond[tableName] = table[lastSecond]
             table.pop(lastSecond)
         else:
             statsOneSecond[tableName] = 0
 
 
     # 一秒结束后的统计处理
     @classmethod
     def oneSecondDataDoneStats(cls,lastSecond):
+        strLastSecond = time.strftime('%H:%M:%S',time.localtime(lastSecond))
          
         # 如果上一秒没有什么有效信息
         # 表示 要么是上1秒没有收发数据也没有超时错误，要么是 上1秒的统计已经发送出去 
         # 这次都不需要发送统计
         if (lastSecond not in cls.rpsTable) and \
             (lastSecond not in cls.tpsTable) and \
             (lastSecond not in cls.timeoutTable) and \
@@ -160,27 +173,28 @@
             
         # 如果上1秒统计数据存在，表示上1秒的数据还没有发送出去   
         
         # 创建统计数据对象
         statsOneSecond = {'t':lastSecond}
 
         # rps
-        cls._statsOneTable(lastSecond,cls.rpsTable,'rps','send',statsOneSecond)
+        cls._statsOneTable(strLastSecond,lastSecond,cls.rpsTable,'rps','send',statsOneSecond)
 
         # tops
-        cls._statsOneTable(lastSecond,cls.timeoutTable,'tops','timeout',statsOneSecond)
+        cls._statsOneTable(strLastSecond,lastSecond,cls.timeoutTable,'tops','timeout',statsOneSecond)
 
         # eps
-        cls._statsOneTable(lastSecond,cls.errorTable, 'eps','error',statsOneSecond)
+        cls._statsOneTable(strLastSecond,lastSecond,cls.errorTable, 'eps','error',statsOneSecond)
 
         # tps、respTimeSum 、 avgRespTime
         if lastSecond in cls.tpsTable:
             count = cls.tpsTable[lastSecond]
             avgRespTime = cls.responseTimeTable[lastSecond]/count  
-            print(f'{lastSecond} s: recv {count:6} | avg lantency {avgRespTime:.4f}')
+            if not cls.runFlag:
+                print(f'{strLastSecond}> recv {count:6} | avg lantency {avgRespTime:.4f}')
 
             statsOneSecond['tps'] = count
             statsOneSecond['respTimeSum'] = round(cls.responseTimeTable[lastSecond],4)
             statsOneSecond['avgRespTime'] = round(avgRespTime,4)
 
             cls.tpsTable.pop(lastSecond)
             cls.responseTimeTable.pop(lastSecond)
@@ -302,15 +316,14 @@
     def connectionNumDecreace(cls):
         cls.connectionNumber -=1
 
 
         
     @classmethod
     def oneRecv(cls,sentTime):
-        
                 
         recvTime = cls.measurePerSecond(cls.tpsTable,1)
         cls.totalRecv +=1
 
         duration = recvTime - sentTime
         cls.measurePerSecond(cls.responseTimeTable,duration,recvTime)
 
@@ -327,24 +340,22 @@
             cls.resptimeRange['>=3000ms'] += 1
 
         return recvTime
 
     @classmethod
     def oneTimeout(cls):
 
-
         cls.measurePerSecond(cls.timeoutTable, 1)
         cls.totalTimeout += 1
 
         return
 
 
     @classmethod
     def oneError(cls):
 
-
         cls.measurePerSecond(cls.errorTable, 1)
         cls.totalError += 1
 
         return
 
 Stats.clear()
```

## hyload/tools/remoteop.py

```diff
@@ -2,15 +2,15 @@
 import sys,os
 
 
 class RemoteOp:
 
     def __init__(self,HOST,PORT,USER, PASSWD, SSHKEY):
 
-        print(f'connect {HOST}:{PORT} ...',end='')
+        print(f'connect to {HOST}:{PORT} ...',end='')
 
         self.ssh = paramiko.SSHClient()
 
         self.ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
 
         self.ssh.load_system_host_keys()
```

## hyload/tools/statshub.py

```diff
@@ -1,220 +1,221 @@
-#! /usr/bin/env python3
-#
-# forked from https://github.com/zkmkarlsruhe/baton
-
-
-# check websockets installation
-import os,sys
-try:
-    import websockets
-except:
-    print('\nwebsockets not installed, install it\n')
-    cmd = f'"{sys.executable}" -m pip install websockets'
-    print(cmd,'\n')
-    ret = os.system(cmd)
-    if ret != 0:
-        print('install websockets faild !\n')
-        exit(2)
-    else:
-        print('install websockets succeed.\n\n')
-
-import asyncio
-import websockets
-import signal
-import argparse
-
-##### parser
-
-parser = argparse.ArgumentParser(description="udp <-> websocket relay server")
-parser.add_argument(
-    "--wshost", action="store", dest="wshost",
-    default="0.0.0.0", help="websocket host ie. ws://####:8081 default: 0.0.0.0")
-parser.add_argument(
-    "--wsport", action="store", dest="wsport",
-    default=8081, type=int, help="websocket port ie. ws://0.0.0.0:####, default: 8081")
-parser.add_argument(
-    "--recvaddr", action="store", dest="recvaddr",
-    default="0.0.0.0", help="udp receive addr, default: 0.0.0.0")
-parser.add_argument(
-    "--recvport", action="store", dest="recvport",
-    default=9999, type=int, help="udp receive port, default: 9999")
-# parser.add_argument(
-#     "--sendaddr", action="store", dest="sendaddr",
-#     default="0.0.0.0", help="udp send addr, default: 0.0.0.0")
-# parser.add_argument(
-#     "--sendport", action="store", dest="sendport",
-#     default=8888, type=int, help="udp send port, default: 8888")
-parser.add_argument("-v", "--verbose", action="store_true", dest="verbose",
-    help="enable verbose printing")
-
-##### UDP
-
-# simple UDP sender asyncio protocol
-class UDPSender:
-
-    @staticmethod
-    def create(loop, remote_addr, verbose):
-        coro = loop.create_datagram_endpoint(
-            lambda: UDPSender(verbose=verbose),
-            remote_addr=remote_addr, allow_broadcast=True)
-            
-        task = asyncio.Task(coro,loop=loop)
-        _, udpsender = loop.run_until_complete(task)
-        return udpsender
-
-    def __init__(self, verbose=True):
-        self.transport = None
-        self.verbose = verbose # verbosity
-
-    def close(self):
-        self.transport.close()
-
-    def send(self, data):
-        self.transport.sendto(data)
-        if self.verbose:
-            print(f"udp sender: sent {data}")
-
-    def connection_made(self, transport):
-        self.transport = transport
-        if self.verbose:
-            print(f"udp sender: connected")
-
-    def connection_lost(self, exc):
-        if self.verbose:
-            print("udp sender: disconnected, error:", exc)
-
-# simple UDP receiver asyncio protocol
-class UDPReceiver:
-
-    @staticmethod
-    def create(loop, local_addr, server, verbose):
-        coro = loop.create_datagram_endpoint(
-            lambda: UDPReceiver(server=server, verbose=verbose),
-            local_addr=local_addr, allow_broadcast=True)
-            
-        task = loop.create_task(coro)
-        #task = asyncio.Task(coro,loop=loop)
-        
-        
-        #_, udpreceiver = loop.run_until_complete(task)
-        #print(2)
-        #return udpreceiver
-
-    def __init__(self, loop=None, server=None, verbose=True):
-        self.transport = None
-        self.server = server   # websocket server
-        self.verbose = verbose # verbosity
-
-    def close(self):
-        self.transport.close()
-
-    def connection_made(self, transport):
-        self.transport = transport
-        if self.verbose:
-            sockname = transport.get_extra_info("sockname")
-            print(f"udp receiver: connected {sockname}")
-
-    # relay raw datagrams to websocket clients
-    def datagram_received(self, data, addr):
-        #print('.', end = ' ')
-        if self.verbose:
-            print(f"udp receiver: received {data} from {addr}")
-        
-        for websocket in WebSocketRelayServer.clients:
-            asyncio.create_task(websocket.send(data))  
-
-    def connection_lost(self, exc):
-        if self.verbose:
-            print(f"udp receiver: disconnected, error: {exc}")
-
-##### websocket
-
-# lazy static class wrapper as websockets.serve only takes a function for ws_handler,
-# quicker than figuring out how to implement a custom WebSocketServerProtocol
-class WebSocketRelayServer:
-
-    clients = set() # connected clients
-    sender = None   # udp sender
-    verbose = False # verbosity
-
-    @staticmethod
-    def create(loop, addr, sender, verbose=False):
-        host, port = addr
-        task = websockets.serve(ws_handler=WebSocketRelayServer.relay, host=host, port=port)
-        
-        server = loop.run_until_complete(task)
-        WebSocketRelayServer.sender = sender
-        WebSocketRelayServer.verbose = verbose
-        if verbose:
-            print(f"websocket: connected {addr}")
-        return server
-
-    @staticmethod
-    async def register(websocket):
-        WebSocketRelayServer.clients.add(websocket)
-        if WebSocketRelayServer.verbose:
-            print("websocket: client connected", websocket)
-
-    @staticmethod
-    async def unregister(websocket):
-        WebSocketRelayServer.clients.remove(websocket)
-        if WebSocketRelayServer.verbose:
-            print("websocket: client disconnected", websocket)
-                 
-               
-
-    # relay raw websocket messages to UDP sender
-    @staticmethod
-    async def relay(websocket, path):
-        await WebSocketRelayServer.register(websocket)
-        try:
-            async for data in websocket:
-                if WebSocketRelayServer.verbose:
-                    print(f"websocket: received {data}")
-                if WebSocketRelayServer.sender is not None:
-                    WebSocketRelayServer.sender.send(data)
-        except Exception as exc:
-            # ignore "normal" disconnects, from websockets/exceptions.py:
-            # 1000 "OK"
-            # 1006 "connection closed abnormally [internal]"
-            if exc.code != 1000 and exc.code != 1006:
-                print(f"websocket: read error: {exc.code} {exc}")
-        finally:
-            await WebSocketRelayServer.unregister(websocket)
-
-##### signal
-
-# signal handler for nice exit
-def sigint_handler():
-    asyncio.get_running_loop().stop()
-
-##### GO
-
-# parse
-args = parser.parse_args()
-print(f"data -> udp {args.recvaddr}:{args.recvport} -> ws://{args.wshost}:{args.wsport} -> all ws clients")
-#print(f"recv <- udp {args.sendaddr}:{args.sendport} <- ws://{args.wshost}:{args.wsport}")
-
-# set up event loop
-# loop = asyncio.get_event_loop()
-loop = asyncio.new_event_loop()
-asyncio.set_event_loop(loop)
-loop.add_signal_handler(signal.SIGINT, sigint_handler)
-
-# udp sender
-# udpsender = UDPSender.create(loop, remote_addr=(args.sendaddr, args.sendport), verbose=args.verbose)
-
-# websocket server
-#relayserver = WebSocketRelayServer.create(loop, addr=(args.wshost, args.wsport), sender=udpsender, verbose=args.verbose)
-relayserver = WebSocketRelayServer.create(loop, addr=(args.wshost, args.wsport), sender=None, verbose=args.verbose)
-
-# udp receiver
-udpreceiver = UDPReceiver.create(loop, local_addr=(args.recvaddr, args.recvport), server=relayserver, verbose=args.verbose)
-
-# run forever
-try:
-    loop.run_forever()
-finally:...
-    #udpsender.close()
-    #udpreceiver.close()
+#! /usr/bin/env python3
+#
+# forked from https://github.com/zkmkarlsruhe/baton
+
+
+# check websockets installation
+import os,sys
+try:
+    import websockets
+except:
+    print('\nwebsockets not installed, install it\n')
+    cmd = f'"{sys.executable}" -m pip install websockets'
+    print(cmd,'\n')
+    ret = os.system(cmd)
+    if ret != 0:
+        print('install websockets faild !\n')
+        exit(2)
+    else:
+        print('install websockets succeed.\n\n')
+
+import asyncio
+import websockets
+import signal
+import argparse
+
+##### parser
+
+parser = argparse.ArgumentParser(description="udp <-> websocket relay server")
+parser.add_argument(
+    "--wshost", action="store", dest="wshost",
+    default="0.0.0.0", help="websocket host ie. ws://####:8081 default: 0.0.0.0")
+parser.add_argument(
+    "--wsport", action="store", dest="wsport",
+    default=8081, type=int, help="websocket port ie. ws://0.0.0.0:####, default: 8081")
+parser.add_argument(
+    "--recvaddr", action="store", dest="recvaddr",
+    default="0.0.0.0", help="udp receive addr, default: 0.0.0.0")
+parser.add_argument(
+    "--recvport", action="store", dest="recvport",
+    default=9999, type=int, help="udp receive port, default: 9999")
+# parser.add_argument(
+#     "--sendaddr", action="store", dest="sendaddr",
+#     default="0.0.0.0", help="udp send addr, default: 0.0.0.0")
+# parser.add_argument(
+#     "--sendport", action="store", dest="sendport",
+#     default=8888, type=int, help="udp send port, default: 8888")
+parser.add_argument("-v", "--verbose", action="store_true", dest="verbose",
+    help="enable verbose printing")
+
+##### UDP
+
+# simple UDP sender asyncio protocol
+class UDPSender:
+
+    @staticmethod
+    def create(loop, remote_addr, verbose):
+        coro = loop.create_datagram_endpoint(
+            lambda: UDPSender(verbose=verbose),
+            remote_addr=remote_addr, allow_broadcast=True)
+            
+        task = asyncio.Task(coro,loop=loop)
+        _, udpsender = loop.run_until_complete(task)
+        return udpsender
+
+    def __init__(self, verbose=True):
+        self.transport = None
+        self.verbose = verbose # verbosity
+
+    def close(self):
+        self.transport.close()
+
+    def send(self, data):
+        self.transport.sendto(data)
+        if self.verbose:
+            print(f"udp sender: sent {data}")
+
+    def connection_made(self, transport):
+        self.transport = transport
+        if self.verbose:
+            print(f"udp sender: connected")
+
+    def connection_lost(self, exc):
+        if self.verbose:
+            print("udp sender: disconnected, error:", exc)
+
+# simple UDP receiver asyncio protocol
+class UDPReceiver:
+
+    @staticmethod
+    def create(loop, local_addr, server, verbose):
+        coro = loop.create_datagram_endpoint(
+            lambda: UDPReceiver(server=server, verbose=verbose),
+            local_addr=local_addr, allow_broadcast=True)
+            
+        task = loop.create_task(coro)
+        #task = asyncio.Task(coro,loop=loop)
+        
+        
+        #_, udpreceiver = loop.run_until_complete(task)
+        #print(2)
+        #return udpreceiver
+
+    def __init__(self, loop=None, server=None, verbose=True):
+        self.transport = None
+        self.server = server   # websocket server
+        self.verbose = verbose # verbosity
+
+    def close(self):
+        self.transport.close()
+
+    def connection_made(self, transport):
+        self.transport = transport
+        if self.verbose:
+            sockname = transport.get_extra_info("sockname")
+            print(f"udp receiver: connected {sockname}")
+
+    # relay raw datagrams to websocket clients
+    def datagram_received(self, data, addr):
+        #print('.', end = ' ')
+        if self.verbose:
+            print(f"udp receiver: received {data} from {addr}")
+        
+        msgBytes = f'{addr[0]}:{addr[1]}|'.encode('ascii') + data
+        for websocket in WebSocketRelayServer.clients:
+            asyncio.create_task(websocket.send(msgBytes))  
+
+    def connection_lost(self, exc):
+        if self.verbose:
+            print(f"udp receiver: disconnected, error: {exc}")
+
+##### websocket
+
+# lazy static class wrapper as websockets.serve only takes a function for ws_handler,
+# quicker than figuring out how to implement a custom WebSocketServerProtocol
+class WebSocketRelayServer:
+
+    clients = set() # connected clients
+    sender = None   # udp sender
+    verbose = False # verbosity
+
+    @staticmethod
+    def create(loop, addr, sender, verbose=False):
+        host, port = addr
+        task = websockets.serve(ws_handler=WebSocketRelayServer.relay, host=host, port=port)
+        
+        server = loop.run_until_complete(task)
+        WebSocketRelayServer.sender = sender
+        WebSocketRelayServer.verbose = verbose
+        if verbose:
+            print(f"websocket: connected {addr}")
+        return server
+
+    @staticmethod
+    async def register(websocket):
+        WebSocketRelayServer.clients.add(websocket)
+        if WebSocketRelayServer.verbose:
+            print("websocket: client connected", websocket)
+
+    @staticmethod
+    async def unregister(websocket):
+        WebSocketRelayServer.clients.remove(websocket)
+        if WebSocketRelayServer.verbose:
+            print("websocket: client disconnected", websocket)
+                 
+               
+
+    # relay raw websocket messages to UDP sender
+    @staticmethod
+    async def relay(websocket, path):
+        await WebSocketRelayServer.register(websocket)
+        try:
+            async for data in websocket:
+                if WebSocketRelayServer.verbose:
+                    print(f"websocket: received {data}")
+                if WebSocketRelayServer.sender is not None:
+                    WebSocketRelayServer.sender.send(data)
+        except Exception as exc:
+            # ignore "normal" disconnects, from websockets/exceptions.py:
+            # 1000 "OK"
+            # 1006 "connection closed abnormally [internal]"
+            if exc.code != 1000 and exc.code != 1006:
+                print(f"websocket: read error: {exc.code} {exc}")
+        finally:
+            await WebSocketRelayServer.unregister(websocket)
+
+##### signal
+
+# signal handler for nice exit
+def sigint_handler():
+    asyncio.get_running_loop().stop()
+
+##### GO
+
+# parse
+args = parser.parse_args()
+print(f"data -> udp {args.recvaddr}:{args.recvport} -> ws://{args.wshost}:{args.wsport} -> all ws clients")
+#print(f"recv <- udp {args.sendaddr}:{args.sendport} <- ws://{args.wshost}:{args.wsport}")
+
+# set up event loop
+# loop = asyncio.get_event_loop()
+loop = asyncio.new_event_loop()
+asyncio.set_event_loop(loop)
+loop.add_signal_handler(signal.SIGINT, sigint_handler)
+
+# udp sender
+# udpsender = UDPSender.create(loop, remote_addr=(args.sendaddr, args.sendport), verbose=args.verbose)
+
+# websocket server
+#relayserver = WebSocketRelayServer.create(loop, addr=(args.wshost, args.wsport), sender=udpsender, verbose=args.verbose)
+relayserver = WebSocketRelayServer.create(loop, addr=(args.wshost, args.wsport), sender=None, verbose=args.verbose)
+
+# udp receiver
+udpreceiver = UDPReceiver.create(loop, local_addr=(args.recvaddr, args.recvport), server=relayserver, verbose=args.verbose)
+
+# run forever
+try:
+    loop.run_forever()
+finally:...
+    #udpsender.close()
+    #udpreceiver.close()
     #relayserver.close()
```

## Comparing `hyload-0.1.1.dist-info/LICENSE.txt` & `hyload-0.2.1.dist-info/LICENSE.txt`

 * *Files identical despite different names*

## Comparing `hyload-0.1.1.dist-info/METADATA` & `hyload-0.2.1.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: hyload
-Version: 0.1.1
+Version: 0.2.1
 Summary: Framework for load testing
 Home-page: http://www.byhy.net
 Download-URL: https://pypi.python.org/pypi/hyload
 Author: baiyueheiyu 白月黑羽
 Author-email: jcyrss@gmail.com
 License: Apache License 2.0
 Keywords: hyload loadtesting
```

## Comparing `hyload-0.1.1.dist-info/RECORD` & `hyload-0.2.1.dist-info/RECORD`

 * *Files 18% similar despite different names*

```diff
@@ -1,17 +1,17 @@
-hyload/__init__.py,sha256=vMdWFxLLjPb7pbPRAGtShm1DxyqM6uiNuCIF_tgiQo8,178
-hyload/cfg.py,sha256=RAul3wiC5UsslSRPlihJ_wCVPGcbWqs-cEMfOoC6Mbg,17
-hyload/httpclient.py,sha256=fHUlGcPsomkTgt9oqk5Y2uoiFKn9UiRpsmu0XE1fImk,14049
+hyload/__init__.py,sha256=wXjdLCvcOlQV8a7Mku2cQbyWRXheGf7dGkHfjvBqKu8,171
+hyload/cfg.py,sha256=uisuY7nIEXhRqibyun63mFNRLab56cOQt7UjyfyPwrs,17
+hyload/httpclient.py,sha256=xsbuhB5Pg1to47J-lMcxSh3N2-bFqezK8KsfInoRYOk,15612
 hyload/logger.py,sha256=JR8uUXypCp9eaWvKZRT_pqtUYRbATkC2XCKIB9R_ptM,2439
-hyload/stats.py,sha256=yzJ80lDPv8p7How-KTPMmMqwNnLpDqFYqLFhKkO35Mc,10289
+hyload/stats.py,sha256=x3JS7ZjYw3_1ecnaQc5pIMvnrNZN4lG5YlIffd3BecQ,10770
 hyload/util.py,sha256=lNKVVW4vYFueXcvOC4HoIMIiXFUz6skR9shSA7iPsWU,979
 hyload/tools/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 hyload/tools/plotperf.py,sha256=H1OszxmfgAYAxX4YEp-_aX66w6slynz9tjDGdpraMMo,3667
 hyload/tools/plotresource.py,sha256=9ydos2xFSA__ANhQ4b_fr5ORJPwWVLCgXoYnYdO5cA4,2802
 hyload/tools/puttyagents.py,sha256=NvL3VhYYka69kh7QTdRzjm7dLN3dB5MuU__K1GmGsW8,39521
-hyload/tools/remoteop.py,sha256=wwvZVSPu_cHYVy5jA14Nd9AHVWc8ZosfP9e3t9ETdNg,3937
-hyload/tools/statshub.py,sha256=rqzfjcLYna9rw4VZUCJLuETjj8oZQuPx82M-tea-9QA,7203
-hyload-0.1.1.dist-info/LICENSE.txt,sha256=OGhxEO0MAMle3LEQV8Us5uo4C8pk-jWmCBKyQ7U_gCE,1100
-hyload-0.1.1.dist-info/METADATA,sha256=aKmUlwQ2P602CGfhFirSMznlD4JEHP8ZZghJ7Qj-MKI,1482
-hyload-0.1.1.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
-hyload-0.1.1.dist-info/top_level.txt,sha256=ivEyc-v2p5WU0itBl-u9QARFubEqBlHfczIhYbuD_U8,7
-hyload-0.1.1.dist-info/RECORD,,
+hyload/tools/remoteop.py,sha256=yyySauc3rSc03jsJ1n_6dKuIv-Vlo6W-TSC5EOI-VEQ,3940
+hyload/tools/statshub.py,sha256=bPyj9h6eewxRJSJmQpqtkx3DFbvoYbQsWpcFvATFang,7493
+hyload-0.2.1.dist-info/LICENSE.txt,sha256=OGhxEO0MAMle3LEQV8Us5uo4C8pk-jWmCBKyQ7U_gCE,1100
+hyload-0.2.1.dist-info/METADATA,sha256=lFbcQoVIvxFCmzzUQKRg4ewnzlzYINYc4Ac3SPCxr5Y,1482
+hyload-0.2.1.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+hyload-0.2.1.dist-info/top_level.txt,sha256=ivEyc-v2p5WU0itBl-u9QARFubEqBlHfczIhYbuD_U8,7
+hyload-0.2.1.dist-info/RECORD,,
```

