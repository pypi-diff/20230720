# Comparing `tmp/pyalgotrading-2023.6.2-py3-none-any.whl.zip` & `tmp/pyalgotrading-2023.7.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,13 +1,13 @@
-Zip file size: 34663 bytes, number of entries: 30
+Zip file size: 37051 bytes, number of entries: 30
 -rw-rw-r--  2.0 unx      181 b- defN 23-May-09 09:57 pyalgotrading/__init__.py
--rw-rw-r--  2.0 unx     6355 b- defN 23-Jun-16 17:42 pyalgotrading/constants.py
+-rw-rw-r--  2.0 unx     6544 b- defN 23-Jul-20 11:02 pyalgotrading/constants.py
 -rw-rw-r--  2.0 unx      133 b- defN 22-Jul-16 11:17 pyalgotrading/algobulls/__init__.py
--rw-rw-r--  2.0 unx    19010 b- defN 23-Jun-16 17:42 pyalgotrading/algobulls/api.py
--rw-rw-r--  2.0 unx    40055 b- defN 23-Jun-16 17:42 pyalgotrading/algobulls/connection.py
+-rw-rw-r--  2.0 unx    19585 b- defN 23-Jul-20 11:02 pyalgotrading/algobulls/api.py
+-rw-rw-r--  2.0 unx    51042 b- defN 23-Jul-20 11:42 pyalgotrading/algobulls/connection.py
 -rw-rw-r--  2.0 unx     2187 b- defN 23-Jun-10 13:22 pyalgotrading/algobulls/exceptions.py
 -rw-rw-r--  2.0 unx       66 b- defN 22-Jan-11 13:11 pyalgotrading/broker/__init__.py
 -rw-rw-r--  2.0 unx     7594 b- defN 23-May-09 09:57 pyalgotrading/broker/broker_connection_base.py
 -rw-rw-r--  2.0 unx    13703 b- defN 22-Jan-11 13:11 pyalgotrading/broker/broker_connection_zerodha.py
 -rw-rw-r--  2.0 unx     1204 b- defN 22-Jan-11 13:11 pyalgotrading/broker/utils.py
 -rw-rw-r--  2.0 unx        0 b- defN 22-Jan-11 13:11 pyalgotrading/instrument/__init__.py
 -rw-rw-r--  2.0 unx     1688 b- defN 22-Jan-11 13:11 pyalgotrading/instrument/instrument.py
@@ -20,13 +20,13 @@
 -rw-rw-r--  2.0 unx      482 b- defN 22-Jan-11 13:11 pyalgotrading/strategy/validate_strategy.py
 -rw-rw-r--  2.0 unx        0 b- defN 22-Jan-11 13:11 pyalgotrading/utils/__init__.py
 -rw-rw-r--  2.0 unx     8656 b- defN 23-Jun-10 13:22 pyalgotrading/utils/func.py
 -rw-rw-r--  2.0 unx       83 b- defN 23-May-09 09:57 pyalgotrading/utils/candlesticks/__init__.py
 -rw-rw-r--  2.0 unx     2003 b- defN 22-Jan-11 13:11 pyalgotrading/utils/candlesticks/heikinashi.py
 -rw-rw-r--  2.0 unx     1434 b- defN 22-Jan-11 13:11 pyalgotrading/utils/candlesticks/linebreak.py
 -rw-rw-r--  2.0 unx     2089 b- defN 22-Jan-11 13:11 pyalgotrading/utils/candlesticks/renko.py
--rw-rw-r--  2.0 unx     1066 b- defN 23-Jun-16 17:44 pyalgotrading-2023.6.2.dist-info/LICENSE
--rw-rw-r--  2.0 unx     5123 b- defN 23-Jun-16 17:44 pyalgotrading-2023.6.2.dist-info/METADATA
--rw-rw-r--  2.0 unx       92 b- defN 23-Jun-16 17:44 pyalgotrading-2023.6.2.dist-info/WHEEL
--rw-rw-r--  2.0 unx       14 b- defN 23-Jun-16 17:44 pyalgotrading-2023.6.2.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     2757 b- defN 23-Jun-16 17:44 pyalgotrading-2023.6.2.dist-info/RECORD
-30 files, 128363 bytes uncompressed, 30121 bytes compressed:  76.5%
+-rw-rw-r--  2.0 unx     1066 b- defN 23-Jul-20 11:42 pyalgotrading-2023.7.1.dist-info/LICENSE
+-rw-rw-r--  2.0 unx     5123 b- defN 23-Jul-20 11:42 pyalgotrading-2023.7.1.dist-info/METADATA
+-rw-rw-r--  2.0 unx       92 b- defN 23-Jul-20 11:42 pyalgotrading-2023.7.1.dist-info/WHEEL
+-rw-rw-r--  2.0 unx       14 b- defN 23-Jul-20 11:42 pyalgotrading-2023.7.1.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     2757 b- defN 23-Jul-20 11:42 pyalgotrading-2023.7.1.dist-info/RECORD
+30 files, 140114 bytes uncompressed, 32509 bytes compressed:  76.8%
```

## zipnote {}

```diff
@@ -69,23 +69,23 @@
 
 Filename: pyalgotrading/utils/candlesticks/linebreak.py
 Comment: 
 
 Filename: pyalgotrading/utils/candlesticks/renko.py
 Comment: 
 
-Filename: pyalgotrading-2023.6.2.dist-info/LICENSE
+Filename: pyalgotrading-2023.7.1.dist-info/LICENSE
 Comment: 
 
-Filename: pyalgotrading-2023.6.2.dist-info/METADATA
+Filename: pyalgotrading-2023.7.1.dist-info/METADATA
 Comment: 
 
-Filename: pyalgotrading-2023.6.2.dist-info/WHEEL
+Filename: pyalgotrading-2023.7.1.dist-info/WHEEL
 Comment: 
 
-Filename: pyalgotrading-2023.6.2.dist-info/top_level.txt
+Filename: pyalgotrading-2023.7.1.dist-info/top_level.txt
 Comment: 
 
-Filename: pyalgotrading-2023.6.2.dist-info/RECORD
+Filename: pyalgotrading-2023.7.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## pyalgotrading/constants.py

```diff
@@ -251,14 +251,24 @@
     A class of locale
     """
     DEFAULT = 'en-US'
     INDIA = 'en-IN'
     USA = 'en-US'
 
 
+class ExecutionStatus(Enum):
+    """
+    A class of status values of execution
+    """
+    STARTING = 'STARTING'
+    STARTED = 'STARTED'
+    STOPPING = 'STOPPING'
+    STOPPED = 'STOPPED'
+
+
 KEY_DT_FORMAT_WITH_TIMEZONE = 0
 KEY_DT_FORMAT_WITHOUT_TIMEZONE = 1
 
 TRADING_TYPE_DT_FORMAT_MAP = {
     TradingType.BACKTESTING: {KEY_DT_FORMAT_WITH_TIMEZONE: '%Y-%m-%d %H:%M %z', KEY_DT_FORMAT_WITHOUT_TIMEZONE: '%Y-%m-%d %H:%M'},
     TradingType.PAPERTRADING: {KEY_DT_FORMAT_WITH_TIMEZONE: '%H:%M %z', KEY_DT_FORMAT_WITHOUT_TIMEZONE: '%H:%M'},
     TradingType.REALTRADING: {KEY_DT_FORMAT_WITH_TIMEZONE: '%H:%M %z', KEY_DT_FORMAT_WITHOUT_TIMEZONE: '%H:%M'},
```

## pyalgotrading/algobulls/api.py

```diff
@@ -320,37 +320,38 @@
             trading_type: Trading type
             lots: Lots
             location: Location of the exchange
             initial_funds_virtual: Virtual funds before starting the strategy
             broker_details: Client's broking details
 
         Info: ENDPOINT
-            `PATCH` v4/portfolio/strategies?isPythonBuild=true
+            `PATCH` v5/portfolio/strategies?isPythonBuild=true
         """
 
         try:
             key = self.__get_key(strategy_code=strategy_code, trading_type=trading_type)
             map_trading_type_to_date_key = {
                 TradingType.REALTRADING: 'liveDataTime',
                 TradingType.PAPERTRADING: 'backDataTime',
                 TradingType.BACKTESTING: 'backDataDate'
             }
             execute_config = {
                 map_trading_type_to_date_key[trading_type]: [start_timestamp.astimezone(timezone.utc).isoformat(), end_timestamp.astimezone(timezone.utc).isoformat()],
                 'isLiveDataTestMode': trading_type in [TradingType.PAPERTRADING, TradingType.REALTRADING],
                 'customizationsQuantity': lots,
-                'brokingDetails': broker_details
+                'brokingDetails': broker_details,
+                'mode': trading_type.name
             }
 
             params = None
             if trading_type in [TradingType.PAPERTRADING, TradingType.BACKTESTING]:
-                endpoint = f'v4/portfolio/strategies?isPythonBuild=true&isLive=false&location={location}'
+                endpoint = f'v5/portfolio/strategies?isPythonBuild=true&isLive=false&location={location}'
                 execute_config['initialFundsVirtual'] = initial_funds_virtual
             elif trading_type is TradingType.REALTRADING:
-                endpoint = f'v4/portfolio/strategies?isPythonBuild=true&isLive=true&location={location}'
+                endpoint = f'v5/portfolio/strategies?isPythonBuild=true&isLive=true&location={location}'
             else:
                 raise NotImplementedError
             json_data = {'method': 'update', 'newVal': 1, 'key': key, 'record': {'status': 0, 'lots': lots, 'executeConfig': execute_config}, 'dataIndex': 'executeConfig'}
             print(f'Submitting {trading_type.name} job...', end=' ')
 
             response = self._send_request(method='patch', endpoint=endpoint, json_data=json_data, params=params)
             print('Success.')
@@ -365,18 +366,18 @@
         Stop Backtesting / Paper Trading / Real Trading job for strategy with code strategy_code & return the job ID.
         
         Args:
             strategy_code: Strategy code
             trading_type: Trading type
         
         Info: ENDPOINT
-            `POST` v4/portfolio/strategies
+            `POST` v5/portfolio/strategies
         """
 
-        endpoint = 'v4/portfolio/strategies'
+        endpoint = 'v5/portfolio/strategies'
         try:
             key = self.__get_key(strategy_code=strategy_code, trading_type=trading_type)
             json_data = {'method': 'update', 'newVal': 0, 'key': key, 'record': {'status': 2}, 'dataIndex': 'executeConfig'}
             print(f'Stopping {trading_type.name} job...', end=' ')
             response = self._send_request(method='patch', endpoint=endpoint, json_data=json_data)
             print('Success.')
 
@@ -403,33 +404,43 @@
         key = self.__get_key(strategy_code=strategy_code, trading_type=trading_type)
         params = {'key': key}
         endpoint = f'v2/user/strategy/status'
         response = self._send_request(endpoint=endpoint, params=params)
 
         return response
 
-    def get_logs(self, strategy_code: str, trading_type: TradingType) -> dict:
+    def get_logs(self, strategy_code: str, trading_type: TradingType, log_type: str, initial_next_token: str = None) -> dict:
         """
         Fetch logs for a strategy
-        
+
         Args:
             strategy_code: Strategy code
             trading_type: Trading type
-        
+            log_type: type of logs, 'partial' or 'full' requests
+            initial_next_token: Token of next logs for v4 logs
+
         Returns:
             Execution logs
-            
+
         Info: ENDPOINT
             `POST`: v2/user/strategy/logs
         """
-
-        endpoint = 'v2/user/strategy/logs'
         key = self.__get_key(strategy_code=strategy_code, trading_type=trading_type)
-        json_data = {'key': key}
-        response = self._send_request(method='post', endpoint=endpoint, json_data=json_data)
+        params = None
+
+        if log_type == 'partial':
+            endpoint = 'v4/user/strategy/logs'
+            json_data = {'key': key, 'nextToken': initial_next_token, 'limit': 1000, 'direction': 'forward', 'reverse': False, 'type': 'userLogs'}
+            params = {'isPythonBuild': True, 'isLive': trading_type == TradingType.REALTRADING}
+
+        else:
+            endpoint = 'v2/user/strategy/logs'
+            json_data = {'key': key}
+
+        response = self._send_request(method='post', endpoint=endpoint, json_data=json_data, params=params)
 
         return response
 
     def get_reports(self, strategy_code: str, trading_type: TradingType, report_type: TradingReportType, location: str) -> dict:
         """
         Fetch report for a strategy
```

## pyalgotrading/algobulls/connection.py

```diff
@@ -1,45 +1,55 @@
 """
 Module for AlgoBulls connection
 """
 import inspect
+import pprint
+import re
 import time
 from collections import OrderedDict
 from datetime import datetime as dt
 
 import pandas as pd
 import quantstats as qs
+from tabulate import tabulate
+from tqdm.auto import tqdm
 
 from .api import AlgoBullsAPI
 from .exceptions import AlgoBullsAPIBadRequestException, AlgoBullsAPIGatewayTimeoutErrorException
-from ..constants import StrategyMode, TradingType, TradingReportType, CandleInterval, AlgoBullsEngineVersion, EXCHANGE_LOCALE_MAP, Locale
+from ..constants import StrategyMode, TradingType, TradingReportType, CandleInterval, AlgoBullsEngineVersion, EXCHANGE_LOCALE_MAP, Locale, ExecutionStatus
 from ..strategy.strategy_base import StrategyBase
 from ..utils.func import get_valid_enum_names, get_datetime_with_tz
 
 
 class AlgoBullsConnection:
     """
     Class for AlgoBulls connection
     """
 
     def __init__(self):
         """
         Init method that is used while creating an object of this class
         """
         self.api = AlgoBullsAPI(self)
-        self.backtesting_pnl_data = None
-        self.papertrade_pnl_data = None
-        self.realtrade_pnl_data = None
+
+        self.saved_parameters = {
+            'start_timestamp_map': {},
+            'end_timestamp_map': {}
+        }
 
         self.strategy_locale_map = {
             TradingType.BACKTESTING: {},
             TradingType.PAPERTRADING: {},
             TradingType.REALTRADING: {},
         }
 
+        self.backtesting_pnl_data = None
+        self.papertrade_pnl_data = None
+        self.realtrade_pnl_data = None
+
     @staticmethod
     def get_authorization_url():
         """
         Fetch the authorization URL
 
         Returns:
             Authorization URL
@@ -147,14 +157,34 @@
         response = self.api.get_all_strategies()
         if isinstance(response['data'], list):
             _ = response['data']
             return pd.DataFrame(_) if return_as_dataframe else _
         else:
             return response
 
+    def get_strategy_name(self, strategy_code):
+        """
+        Fetch the name of the strategy using strategy-code
+
+        Args:
+            strategy_code: strategy code
+
+        Returns:
+            name of the strategy
+        """
+        strategy_name = None
+        try:
+            # TODO: Currently fetching strategy name over API everytime. Will be optimized in future to avoid repeated API calls.
+            all_strategies_df = self.get_all_strategies()
+            strategy_name = all_strategies_df.loc[all_strategies_df['strategyCode'] == strategy_code].iloc[0]['strategyName']
+
+        except Exception as ex:
+            print(f'Error while fetching strategy name of strategy code {strategy_code}. Error: {ex}')
+        return strategy_name
+
     def get_strategy_details(self, strategy_code):
         """
         Fetch the strategy details of a particular strategy
 
         Args:
             strategy_code: strategy code
 
@@ -238,30 +268,117 @@
         """
 
         assert isinstance(strategy_code, str), f'Argument "strategy_code" should be a string'
         assert isinstance(trading_type, TradingType), f'Argument "trading_type" should be an enum of type {TradingType.__name__}'
 
         response = self.api.stop_strategy_algotrading(strategy_code=strategy_code, trading_type=trading_type)
 
-    def get_logs(self, strategy_code, trading_type):
+    def get_logs(self, strategy_code, trading_type, auto_update=True, display_logs_in_auto_update_mode=False):
         """
         Fetch logs for a strategy
 
         Args:
             strategy_code: strategy code
             trading_type: trading type
+            auto_update: If True, logs will be continuously fetched until strategy execution is complete. A progress bar will show the live status of strategy execution
+            display_logs_in_auto_update_mode: Applicable only if auto_update is True; display the logs as they are fetched
 
         Returns:
             Execution logs
         """
 
         assert isinstance(strategy_code, str), f'Argument "strategy_code" should be a string'
         assert isinstance(trading_type, TradingType), f'Argument "trading_type" should be an enum of type {TradingType.__name__}'
+        assert isinstance(auto_update, bool), f'Argument "show_progress_bar" should be a boolean'
+
+        # TODO: to extract timestamp from a different source which will be independent of whether save parameters are present in the object
+        start_timestamp_map = self.saved_parameters.get('start_timestamp_map')
+        end_timestamp_map = self.saved_parameters.get('end_timestamp_map')
+        all_logs = ''
+
+        # logging with progress bar
+        if auto_update and start_timestamp_map.get(trading_type) and end_timestamp_map.get(trading_type):
+            tqdm_progress_bar = None
+            initial_next_token = None
+            error_counter = 0
+            status = None
+
+            start_timestamp = start_timestamp_map.get(trading_type).replace(tzinfo=None)
+            end_timestamp = end_timestamp_map.get(trading_type).replace(tzinfo=None)
+            total_seconds = (end_timestamp - start_timestamp).total_seconds()
+
+            count_starting_status = 0
+            while True:
+
+                # if logs are in starting phase, we wait until it changes
+                if status is None or status == ExecutionStatus.STARTING.value:
+                    status = self.get_job_status(strategy_code, trading_type)["message"]
+                    time.sleep(5)
+                    if status == ExecutionStatus.STARTING.value:
+                        count_starting_status += 1
+                        print('\r', end=f'Looking for a dedicated virtual server to execute your strategy... ({count_starting_status})')
+                    continue
+
+                # if logs get in started phase, we initialize the tqdm object for progress tracking
+                if tqdm_progress_bar is None and status == ExecutionStatus.STARTED.value:
+                    tqdm_progress_bar = tqdm(desc='Execution Progress', total=total_seconds, position=0, leave=True, bar_format='{l_bar}{bar}| {n_fmt}/{total_fmt} [{elapsed}<{remaining}]')
+
+                response = self.api.get_logs(strategy_code=strategy_code, trading_type=trading_type, log_type='partial', initial_next_token=initial_next_token)
+                logs = response.get('data')
+                if type(logs) is list:
+                    all_logs += '\n'.join(logs) + '\n'
+
+                # if logs are empty we wait
+                if not logs:
+                    status = self.get_job_status(strategy_code, trading_type)["message"]
+
+                    # if status is stopped we break the while loop
+                    if status in [ExecutionStatus.STOPPED.value, ExecutionStatus.STOPPING.value]:
+                        # tqdm.write(f'INFO: Got status as {status}, strategy execution completed.')    # for debug
+                        if tqdm_progress_bar is not None:
+                            tqdm_progress_bar.close()
+                        break
+
+                    # continue if logs are not fetched
+                    else:
+                        # tqdm.write(f'WARNING: got no data, current status is {status}...')      # for debug
+                        time.sleep(5)
+                        continue
+
+                else:
+                    # print the logs below progressbar
+                    if display_logs_in_auto_update_mode:
+                        tqdm.write('\n'.join(logs))
+
+                    # iterate in reverse order
+                    for log in logs[::-1]:
+                        try:
+
+                            # extract log terms inside square brackets
+                            _ = re.findall(r'\[(.*?)\]', log)
+
+                            # extract datetime from logs
+                            if tqdm_progress_bar is not None and _[0] in ['BT', 'PT', 'RT']:
+                                current_timestamp = dt.strptime(_[1].split(',')[0], '%Y-%m-%d %H:%M:%S')
+                                total_completion = (current_timestamp - start_timestamp).total_seconds()
+                                tqdm_progress_bar.update(total_completion - tqdm_progress_bar.n)
+                                break
+
+                        except Exception as ex:
+                            tqdm.write(f'WARNING: faced an error while updating logs process. Error: {ex}')
+                            error_counter += 1
+
+                        # avoid infinite loop in case of error
+                        if error_counter > 5:
+                            break
 
-        return self.api.get_logs(strategy_code=strategy_code, trading_type=trading_type).get('data')
+                    initial_next_token = response.get('initialNextToken')
+        else:
+            all_logs = self.api.get_logs(strategy_code=strategy_code, trading_type=trading_type, log_type='full').get('data')
+        return all_logs
 
     def get_report(self, strategy_code, trading_type, report_type, render_as_dataframe=False, show_all_rows=False, location=None):
         """
         Fetch report for a strategy
 
         Args:
             strategy_code: Strategy code
@@ -358,15 +475,15 @@
                 Report details
         """
 
         order_report = None
 
         # get pnl data and cleanup as per quantstats format
         _returns_df = pnl_df[['entry_timestamp', 'pnl_absolute']]
-        _returns_df['entry_timestamp'] = _returns_df['entry_timestamp'].dt.tz_localize(None)            # Note: Quantstats has a bug. It doesn't accept the df index, which is set below, with timezone. Hence we have to drop the timezone info
+        _returns_df['entry_timestamp'] = _returns_df['entry_timestamp'].dt.tz_localize(None)  # Note: Quantstats has a bug. It doesn't accept the df index, which is set below, with timezone. Hence, we have to drop the timezone info
         _returns_df = _returns_df.set_index('entry_timestamp')
         _returns_df["total_funds"] = _returns_df.pnl_absolute.cumsum() + initial_funds
         _returns_df = _returns_df.dropna()
 
         # Note: Quantstats has a potential bug. It cannot work with multiple entries having the same timestamp. For now, we are dropping multiple entries with the same entry_timestamp (else the quantstats code below would throw an error)
         # Suggestion for workaround: For entries with same entry timestamps, we can slightly modify the entry timestamps by adding single-digit microseconds to make them unique
         _returns_df = _returns_df[~_returns_df.index.duplicated(keep='first')]
@@ -384,28 +501,56 @@
         if html_dump:
             all_strategies = self.get_all_strategies()
             strategy_name = all_strategies.loc[all_strategies['strategyCode'] == strategy_code]['strategyName'].iloc[0]
             qs.reports.html(total_funds_series, title=strategy_name, output='', download_filename=f'report_{strategy_name}_{time.time():.0f}.html')
 
         return order_report
 
-    def start_job(self, strategy=None, start=None, end=None, instruments=None, lots=1, parameters=None, candle=None, mode=StrategyMode.INTRADAY, initial_funds_virtual=1e9, delete_previous_trades=True, trading_type=None, broking_details=None,
-                  **kwargs):
+    def print_strategy_config(self, trading_type):
+        _ = self.saved_parameters
+        strategy_name = self.get_strategy_name(_['strategy_code'])
+
+        data = [
+            ['Strategy Name', strategy_name],
+            # ['Strategy Code', _['strategy_code']],    # not required as of now
+            ['Trading Type', trading_type.name],
+            ['Instrument(s)', pprint.pformat(_['instruments'])],
+            ['Quantity/Lots', _['lots']],
+            ['Start Timestamp', _['start_timestamp_map'][trading_type]],
+            ['End Timestamp', _['end_timestamp_map'][trading_type]],
+            ['Parameters', pprint.pformat(_['strategy_parameters'])],
+            ['Candle', _['candle_interval'].value],
+            ['Mode', _['strategy_mode'].name],
+        ]
+
+        if trading_type in [TradingType.BACKTESTING, TradingType.PAPERTRADING]:
+            data.append(['Initial Funds (Virtual)', _['initial_funds_virtual']])
+        elif trading_type in [TradingType.REALTRADING]:
+            data.insert(0, ["Broker Name", _['vendor_details']['brokerName']])  # Note, key is still 'vendor_details' even for broking purpose
+
+        if _.get('vendor_details') is not None:
+            data.insert(0, ["Vendor Name", _['vendor_details']['brokerName']])
+
+        _msg = tabulate(data, headers=['Config', 'Value'], tablefmt="fancy_grid")
+        print(f"\nStarting the strategy '{strategy_name}' in {trading_type.name} mode...\n{_msg}\n")
+
+    def start_job(self, strategy_code=None, start_timestamp=None, end_timestamp=None, instruments=None, lots=None, strategy_parameters=None, candle_interval=None, strategy_mode=None, initial_funds_virtual=None, delete_previous_trades=True,
+                  trading_type=None, broking_details=None, **kwargs):
         """
         Submit a BT/PT/RT job for a strategy on the AlgoBulls Platform
 
         Args:
-            strategy: Strategy code
-            start: Start date-time/time
-            end: End date-time/time
+            strategy_code: Strategy code
+            start_timestamp: Start date-time/time
+            end_timestamp: End date-time/time
             instruments: Instrument key
             lots: Number of lots of the passed instrument to trade on
-            parameters: Parameters
-            candle: Candle interval
-            mode: Intraday or delivery
+            strategy_parameters: Parameters
+            candle_interval: Candle interval
+            strategy_mode: Intraday or delivery
             delete_previous_trades: Delete data for previous trades
             initial_funds_virtual: virtual funds allotted before the backtesting starts
             trading_type: type of trading : PT/BT/RT
             broking_details: details of client's broker
 
         Legacy args (will be deprecated in future release):
             'strategy_code' behaves same as 'strategy'
@@ -417,118 +562,149 @@
             'strategy_mode' behaves same as 'mode'
 
         Returns:
             job submission status
             location of the instruments
         """
 
-        # check if values received by new parameter names, else extract from old parameter names
-        strategy = strategy if strategy is not None else kwargs.get('strategy_code')
-        start = start if start is not None else kwargs.get('start_timestamp')
-        end = end if end is not None else kwargs.get('end_timestamp')
-        parameters = parameters if parameters is not None else kwargs.get('strategy_parameters')
-        candle = candle if candle is not None else kwargs.get('candle_interval')
-        instruments = instruments if instruments is not None else kwargs.get('instrument')
-        mode = mode if 'strategy_mode' not in kwargs else kwargs.get('strategy_mode')
+        # check if values received by new parameter names, else extract from old parameter names, else extract from saved parameters
+        saved_params = self.saved_parameters
+        start_timestamp_map = saved_params.get('start_timestamp_map')
+        end_timestamp_map = saved_params.get('end_timestamp_map')
+        strategy_code = strategy_code or kwargs.get('strategy_code') or saved_params.get('strategy_code')
+        start_timestamp = start_timestamp or kwargs.get('start_timestamp') or start_timestamp_map.get(trading_type)
+        end_timestamp = end_timestamp or kwargs.get('end_timestamp') or end_timestamp_map.get(trading_type)
+        strategy_parameters = strategy_parameters or kwargs.get('strategy_parameters') or saved_params.get('strategy_parameters')
+        candle_interval = candle_interval or kwargs.get('candle_interval') or saved_params.get('candle_interval')
+        instruments = instruments or kwargs.get('instrument') or saved_params.get('instruments')
+        strategy_mode = strategy_mode or kwargs.get('strategy_mode') or saved_params.get('strategy_mode') or StrategyMode.INTRADAY
+        lots = lots or saved_params.get('lots')
+        initial_funds_virtual = initial_funds_virtual or saved_params.get('initial_funds_virtual') or 1e9
+        broking_details = broking_details or saved_params.get('vendor_details')
 
         # Sanity checks - Convert config parameters
         _error_msg_candle = f'Argument "candle" should be a valid string or an enum of type CandleInterval. Possible string values can be: {get_valid_enum_names(CandleInterval)}'
         _error_msg_timestamps = f'\nString Format (YYYY-MM-DD HH:MM z) or an instance of type datetime.datetime for Back Testing \nString Format (HH:MM z) or an instance of type datetime.time for Real trading or Paper Trading'
         _error_msg_instruments = f'Argument "instruments" should be a valid instrument string or a list of valid instruments strings. You can use the \'get_instrument()\' method of AlgoBullsConnection class to search for instruments'
         _error_msg_mode = f'Argument "mode" should be a valid string or an enum of type StrategyMode. Possible string values can be: {get_valid_enum_names(StrategyMode)}'
         _error_msg_broking_details = 'Argument "broking_details" should be a valid dict with valid keys. Expected keys "brokerName" and "credentialParameters" '
 
         initial_funds_virtual = float(initial_funds_virtual)
-        if isinstance(start, str):
-            start = get_datetime_with_tz(start, trading_type)
-        if isinstance(end, str):
-            end = get_datetime_with_tz(end, trading_type)
-        if isinstance(mode, str):
-            _ = mode.upper()
+        if isinstance(start_timestamp, str):
+            start_timestamp = get_datetime_with_tz(start_timestamp, trading_type)
+        if isinstance(end_timestamp, str):
+            end_timestamp = get_datetime_with_tz(end_timestamp, trading_type)
+        if isinstance(strategy_mode, str):
+            _ = strategy_mode.upper()
             assert _ in StrategyMode.__members__, _error_msg_candle
-            mode = StrategyMode[_]
-        if isinstance(candle, str):
-            _ = f"{'_' if candle[0].isdigit() else ''}{candle.strip().upper().replace(' ', '_')}"
+            strategy_mode = StrategyMode[_]
+        if isinstance(candle_interval, str):
+            _ = f"{'_' if candle_interval[0].isdigit() else ''}{candle_interval.strip().upper().replace(' ', '_')}"
             assert _ in CandleInterval.__members__, _error_msg_candle
-            candle = CandleInterval[_]
+            candle_interval = CandleInterval[_]
         if isinstance(instruments, str):
             instruments = [instruments]
 
         # Sanity checks - Validate config parameters
-        assert isinstance(strategy, str), f'Argument "strategy" should be a valid string'
-        assert isinstance(start, dt), 'Argument "start" should be a valid timestamp string\n' + _error_msg_timestamps
-        assert isinstance(end, dt), 'Argument "end" should be a valid timestamp string\n' + _error_msg_timestamps
+        assert isinstance(strategy_code, str), f'Argument "strategy" should be a valid string'
+        assert isinstance(start_timestamp, dt), 'Argument "start" should be a valid timestamp string\n' + _error_msg_timestamps
+        assert isinstance(end_timestamp, dt), 'Argument "end" should be a valid timestamp string\n' + _error_msg_timestamps
         assert isinstance(instruments, list), _error_msg_instruments
         assert len(instruments) > 0, _error_msg_instruments
         assert (isinstance(lots, int) and lots > 0), f'Argument "lots" should be a positive integer.'
-        assert isinstance(parameters, dict), f'Argument "parameters" should be a dict'
-        assert isinstance(mode, StrategyMode), _error_msg_mode
-        assert isinstance(candle, CandleInterval), _error_msg_candle
+        assert isinstance(strategy_parameters, dict), f'Argument "parameters" should be a dict'
+        assert isinstance(strategy_mode, StrategyMode), _error_msg_mode
+        assert isinstance(candle_interval, CandleInterval), _error_msg_candle
         assert isinstance(initial_funds_virtual, float), 'Argument "initial_funds_virtual" should be a float'
         assert isinstance(delete_previous_trades, bool), 'Argument "delete_previous_trades" should be a boolean'
 
         if broking_details is not None:
             assert isinstance(broking_details, dict), f'Argument "broking_details" should be a dict'
             assert 'brokerName' in broking_details, f'Argument "broking_details" should be a dict with "brokerName" key'
             assert 'credentialParameters' in broking_details, f'Argument "broking_details" should be a dict with "credentialParameters" key'
 
         if trading_type is not TradingType.BACKTESTING:
-            start = dt.combine(dt.now().astimezone(start.tzinfo).date(), start.time(), tzinfo=start.tzinfo)
-            end = dt.combine(dt.now().astimezone(end.tzinfo).date(), end.time(), tzinfo=end.tzinfo)
+            start_timestamp = dt.combine(dt.now().astimezone(start_timestamp.tzinfo).date(), start_timestamp.time(), tzinfo=start_timestamp.tzinfo)
+            end_timestamp = dt.combine(dt.now().astimezone(end_timestamp.tzinfo).date(), end_timestamp.time(), tzinfo=end_timestamp.tzinfo)
+
+            start_timestamp_map[TradingType.REALTRADING] = start_timestamp
+            start_timestamp_map[TradingType.PAPERTRADING] = start_timestamp
+            end_timestamp_map[TradingType.REALTRADING] = end_timestamp
+            end_timestamp_map[TradingType.PAPERTRADING] = end_timestamp
+
+        else:
+            start_timestamp_map[TradingType.BACKTESTING] = start_timestamp
+            end_timestamp_map[TradingType.BACKTESTING] = end_timestamp
 
         # Restructuring strategy params
         restructured_strategy_parameters = []
-        for parameter_name in parameters:
+        for parameter_name in strategy_parameters:
             restructured_strategy_parameters.append({
                 'paramName': parameter_name,
-                'paramValue': parameters[parameter_name]
+                'paramValue': strategy_parameters[parameter_name]
             })
 
         # get exchange location
         _ = instruments[0].split(':')
         if len(_) == 2 and EXCHANGE_LOCALE_MAP.get(_[0]) is not None:
             location = EXCHANGE_LOCALE_MAP[_[0]]
         else:
             print('Warning: Valid exchange not given, assuming exchange as "NSE_EQ".\n Expected format for giving an instrument "<EXCHANGE>:<TRADING_SYMBOL>"\nPossible exchange values include: {EXCHANGE_LOCALE_MAP.keys()}')
             location = EXCHANGE_LOCALE_MAP[Locale.DEFAULT.value]
-            
+
         # generate instruments' id list
         instrument_list = []
         for _instrument in instruments:
             exchange, tradingsymbol = _instrument.split(':')
             instrument_results = self.search_instrument(instrument=tradingsymbol, exchange=exchange)
             for _ in instrument_results:
                 if _["value"] == _instrument:
                     instrument_list.append({'id': _["id"]})
                     break
 
+        # save BT/PT/RT parameters
+        self.saved_parameters = {
+            'strategy_code': strategy_code,
+            'start_timestamp_map': start_timestamp_map,
+            'end_timestamp_map': end_timestamp_map,
+            'strategy_parameters': strategy_parameters,
+            'candle_interval': candle_interval,
+            'instruments': instruments,
+            'strategy_mode': strategy_mode,
+            'lots': lots,
+            'initial_funds_virtual': initial_funds_virtual,
+            'vendor_details': broking_details  # Note: key name is saved as vendor_details for logging purpose
+        }
+
+        self.print_strategy_config(trading_type)
+
         # delete previous trades
         if delete_previous_trades and trading_type in [TradingType.BACKTESTING, TradingType.PAPERTRADING]:
-            self.delete_previous_trades(strategy)
+            self.delete_previous_trades(strategy_code)
 
         # Setup config for starting the job
         strategy_config = {
             'instruments': {
                 'instruments': instrument_list
             },
             'lots': lots,
             'userParams': restructured_strategy_parameters,
-            'candleDuration': candle.value,
-            'strategyMode': mode.value
+            'candleDuration': candle_interval.value,
+            'strategyMode': strategy_mode.value
         }
-        self.api.set_strategy_config(strategy_code=strategy, strategy_config=strategy_config, trading_type=trading_type)
+        self.api.set_strategy_config(strategy_code=strategy_code, strategy_config=strategy_config, trading_type=trading_type)
 
         # Submit trading job
-        response = self.api.start_strategy_algotrading(strategy_code=strategy, start_timestamp=start, end_timestamp=end, trading_type=trading_type,
+        response = self.api.start_strategy_algotrading(strategy_code=strategy_code, start_timestamp=start_timestamp, end_timestamp=end_timestamp, trading_type=trading_type,
                                                        lots=lots, initial_funds_virtual=initial_funds_virtual, broker_details=broking_details, location=location)
 
-        self.strategy_locale_map[trading_type][strategy] = location
+        self.strategy_locale_map[trading_type][strategy_code] = location
         return response
 
-    def backtest(self, strategy=None, start=None, end=None, instruments=None, lots=1, parameters=None, candle=None, mode=StrategyMode.INTRADAY, delete_previous_trades=True, initial_funds_virtual=1e9, vendor_details=None, **kwargs):
+    def backtest(self, strategy=None, start=None, end=None, instruments=None, lots=None, parameters=None, candle=None, mode=None, delete_previous_trades=True, initial_funds_virtual=None, vendor_details=None, **kwargs):
         """
         Submit a backtesting job for a strategy on the AlgoBulls Platform
 
         Args:
             strategy: Strategy code
             start: Start date-time/time
             end: End date-time/time
@@ -552,15 +728,15 @@
 
         Returns:
             backtest job submission status
         """
 
         # start backtesting job
         response = self.start_job(
-            strategy=strategy, start=start, end=end, instruments=instruments, lots=lots, parameters=parameters, candle=candle, mode=mode,
+            strategy_code=strategy, start_timestamp=start, end_timestamp=end, instruments=instruments, lots=lots, strategy_parameters=parameters, candle_interval=candle, strategy_mode=mode,
             initial_funds_virtual=initial_funds_virtual, delete_previous_trades=delete_previous_trades, trading_type=TradingType.BACKTESTING, broking_details=vendor_details, **kwargs
         )
 
         # Update previously saved pnl data and exchange location
         self.backtesting_pnl_data = None
 
     def get_backtesting_job_status(self, strategy_code):
@@ -589,28 +765,30 @@
             stop job status
         """
 
         assert isinstance(strategy_code, str), f'Argument "strategy_code" should be a string'
 
         return self.stop_job(strategy_code=strategy_code, trading_type=TradingType.BACKTESTING)
 
-    def get_backtesting_logs(self, strategy_code):
+    def get_backtesting_logs(self, strategy_code, auto_update=True, display_logs_in_auto_update_mode=False):
         """
         Fetch Back Testing logs
 
         Args:
             strategy_code: Strategy code
+            auto_update: If True, logs will be continuously fetched until strategy execution is complete. A progress bar will show the live status of strategy execution
+            display_logs_in_auto_update_mode: Applicable only if auto_update is True; display the logs as they are fetched
 
         Returns:
             Report details
         """
 
         assert isinstance(strategy_code, str), f'Argument "strategy_code" should be a string'
 
-        return self.get_logs(strategy_code, trading_type=TradingType.BACKTESTING)
+        return self.get_logs(strategy_code, trading_type=TradingType.BACKTESTING, auto_update=auto_update, display_logs_in_auto_update_mode=display_logs_in_auto_update_mode)
 
     def get_backtesting_report_pnl_table(self, strategy_code, location=None, show_all_rows=False, force_fetch=False):
         """
         Fetch Back Testing Profit & Loss details
 
         Args:
             strategy_code: strategy code
@@ -664,15 +842,15 @@
             Report details
         """
 
         assert isinstance(strategy_code, str), f'Argument "strategy_code" should be a string'
 
         return self.get_report(strategy_code=strategy_code, trading_type=TradingType.BACKTESTING, report_type=TradingReportType.ORDER_HISTORY)
 
-    def papertrade(self, strategy=None, start=None, end=None, instruments=None, lots=None, parameters=None, candle=None, mode=StrategyMode.INTRADAY, delete_previous_trades=True, initial_funds_virtual=1e9, vendor_details=None, **kwargs):
+    def papertrade(self, strategy=None, start=None, end=None, instruments=None, lots=None, parameters=None, candle=None, mode=None, delete_previous_trades=True, initial_funds_virtual=None, vendor_details=None, **kwargs):
         """
         Submit a papertrade job for a strategy on the AlgoBulls Platform
 
         Args:
             strategy: Strategy code
             start: Start date-time/time
             end: End date-time/time
@@ -696,15 +874,15 @@
 
         Returns:
             papertrade job submission status
         """
 
         # start papertrading job
         response = self.start_job(
-            strategy=strategy, start=start, end=end, instruments=instruments, lots=lots, parameters=parameters, candle=candle, mode=mode,
+            strategy_code=strategy, start_timestamp=start, end_timestamp=end, instruments=instruments, lots=lots, strategy_parameters=parameters, candle_interval=candle, strategy_mode=mode,
             initial_funds_virtual=initial_funds_virtual, delete_previous_trades=delete_previous_trades, trading_type=TradingType.PAPERTRADING, broking_details=vendor_details, **kwargs
         )
 
         # Update previously saved pnl data and exchange location
         self.papertrade_pnl_data = None
 
     def get_papertrading_job_status(self, strategy_code):
@@ -733,28 +911,30 @@
             stop job status
         """
 
         assert isinstance(strategy_code, str), f'Argument "strategy_code" should be a string'
 
         return self.stop_job(strategy_code=strategy_code, trading_type=TradingType.PAPERTRADING)
 
-    def get_papertrading_logs(self, strategy_code):
+    def get_papertrading_logs(self, strategy_code, auto_update=False, display_logs_in_auto_update_mode=False):
         """
         Fetch Paper Trading logs
 
         Args:
             strategy_code: Strategy code
+            auto_update: If True, logs will be continuously fetched until strategy execution is complete. A progress bar will show the live status of strategy execution
+            display_logs_in_auto_update_mode: Applicable only if auto_update is True; display the logs as they are fetched
 
         Returns:
             Report details
         """
 
         assert isinstance(strategy_code, str), f'Argument "strategy_code" should be a string'
 
-        return self.get_logs(strategy_code=strategy_code, trading_type=TradingType.PAPERTRADING)
+        return self.get_logs(strategy_code=strategy_code, trading_type=TradingType.PAPERTRADING, auto_update=auto_update, display_logs_in_auto_update_mode=display_logs_in_auto_update_mode)
 
     def get_papertrading_report_pnl_table(self, strategy_code, location=None, show_all_rows=False, force_fetch=False):
         """
         Fetch Paper Trading Profit & Loss details
 
         Args:
             strategy_code: strategy code
@@ -808,15 +988,15 @@
             Report details
         """
 
         assert isinstance(strategy_code, str), f'Argument "strategy_code" should be a string'
 
         return self.get_report(strategy_code=strategy_code, trading_type=TradingType.PAPERTRADING, report_type=TradingReportType.ORDER_HISTORY)
 
-    def realtrade(self, strategy=None, start=None, end=None, instruments=None, lots=None, parameters=None, candle=None, mode=StrategyMode.INTRADAY, broking_details=None, **kwargs):
+    def realtrade(self, strategy=None, start=None, end=None, instruments=None, lots=None, parameters=None, candle=None, mode=None, broking_details=None, **kwargs):
         """
         Start a Real Trading session.
         Update: This requires an approval process which is currently on request basis.
 
         Start a realtrading job for a strategy on the AlgoBulls Platform
 
         Args:
@@ -840,15 +1020,17 @@
             'strategy_mode' behaves same as 'mode'
 
         Returns:
             realtrade job submission status
         """
 
         # start realtrading job
-        response = self.start_job(strategy=strategy, start=start, end=end, instruments=instruments, lots=lots, parameters=parameters, candle=candle, mode=mode, trading_type=TradingType.REALTRADING, broking_details=broking_details, **kwargs)
+        response = self.start_job(strategy_code=strategy, start_timestamp=start, end_timestamp=end, instruments=instruments, lots=lots, strategy_parameters=parameters, candle_interval=candle, strategy_mode=mode, trading_type=TradingType.REALTRADING,
+                                  broking_details=broking_details,
+                                  **kwargs)
 
         # Update previously saved pnl data and exchange location
         self.realtrade_pnl_data = None
 
     def livetrade(self, *args, **kwargs):
         self.realtrade(*args, **kwargs)
 
@@ -878,28 +1060,30 @@
             stop job status
         """
 
         assert isinstance(strategy_code, str), f'Argument "strategy_code" should be a string'
 
         return self.stop_job(strategy_code=strategy_code, trading_type=TradingType.REALTRADING)
 
-    def get_realtrading_logs(self, strategy_code):
+    def get_realtrading_logs(self, strategy_code, auto_update=False, display_logs_in_auto_update_mode=False):
         """
         Fetch Real Trading logs
 
         Args:
             strategy_code: Strategy code
+            auto_update: If True, logs will be continuously fetched until strategy execution is complete. A progress bar will show the live status of strategy execution
+            display_logs_in_auto_update_mode: Applicable only if auto_update is True; display the logs as they are fetched
 
         Returns:
             Report details
         """
 
         assert isinstance(strategy_code, str), f'Argument "strategy_code" should be a string'
 
-        return self.get_logs(strategy_code=strategy_code, trading_type=TradingType.REALTRADING)
+        return self.get_logs(strategy_code=strategy_code, trading_type=TradingType.REALTRADING, auto_update=auto_update, display_logs_in_auto_update_mode=display_logs_in_auto_update_mode)
 
     def get_realtrading_report_pnl_table(self, strategy_code, location=None, show_all_rows=False, force_fetch=False):
         """
         Fetch Real Trading Profit & Loss details
 
         Args:
             strategy_code: strategy code
```

## Comparing `pyalgotrading-2023.6.2.dist-info/LICENSE` & `pyalgotrading-2023.7.1.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `pyalgotrading-2023.6.2.dist-info/METADATA` & `pyalgotrading-2023.7.1.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: pyalgotrading
-Version: 2023.6.2
+Version: 2023.7.1
 Summary: Official Python Package for Algorithmic Trading APIs powered by AlgoBulls
 Home-page: https://github.com/algobulls/pyalgotrading
 Author: Pushpak Dagade
 Author-email: pushpak@algobulls.com
 License: UNKNOWN
 Project-URL: Source, https://github.com/algobulls/pyalgotrading
 Project-URL: Documentation, https://algobulls.github.io/pyalgotrading/
```

## Comparing `pyalgotrading-2023.6.2.dist-info/RECORD` & `pyalgotrading-2023.7.1.dist-info/RECORD`

 * *Files 18% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 pyalgotrading/__init__.py,sha256=e0lmS8IOW1JBf_jfyDAO-9cCEyNsNoSCjwetSCWPeIg,181
-pyalgotrading/constants.py,sha256=ijnA0FWPSBZ2KkY4ITuCUM9-bTz4WFc_qP-pctDFkWI,6355
+pyalgotrading/constants.py,sha256=tXclfw_CW5A9arWh2ZmHBRBqWRmOHGAji_AAVIhUl-E,6544
 pyalgotrading/algobulls/__init__.py,sha256=IRkbWtJfgQnPH7gikjqpa6QsYnmk_NQ1lwtx7LPIC6c,133
-pyalgotrading/algobulls/api.py,sha256=C2tGAQapTUTnjcZYZ5PKW5uBhO1q-MqhHtjakrtI3l4,19010
-pyalgotrading/algobulls/connection.py,sha256=KWd7JESjNRYyrlZpWj0A1dLRuZfYhR3AUw3ldFzN_xY,40055
+pyalgotrading/algobulls/api.py,sha256=EIh0PUFyWzVXin_jWvd9MpF45gs9EWvdUPkQ05aOfYE,19585
+pyalgotrading/algobulls/connection.py,sha256=oNlGOWjrPF0exKjJBSaQ9HUFZ5iQ7sR-_z5oDf4y3EI,51042
 pyalgotrading/algobulls/exceptions.py,sha256=B96On8cN8tgtX7i4shKOlYfvjSjvspIRPbOpyF-jn0I,2187
 pyalgotrading/broker/__init__.py,sha256=jXVWBVRlqzevKxNDqrPANJz9WubROBes8gaKcxcYz58,66
 pyalgotrading/broker/broker_connection_base.py,sha256=vAJN5EAQuVfL8Ngf03wsaI5TTGdziCHKCb0bczGgSJ0,7594
 pyalgotrading/broker/broker_connection_zerodha.py,sha256=bw9Eu40YhSbRLhvVniY255uYeziX_EOVBPkfUUg4tFs,13703
 pyalgotrading/broker/utils.py,sha256=ojL1oebAjNrY_sS2z9JKHy1qo-Pif0ED2uNKLwdnQxo,1204
 pyalgotrading/instrument/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 pyalgotrading/instrument/instrument.py,sha256=PKqq784MYmpvBL2MIde1n44U9kwuRdSNIot1KKQ5J-o,1688
@@ -19,12 +19,12 @@
 pyalgotrading/strategy/validate_strategy.py,sha256=Ot2kvROtG-tpcbK_Fv-OdapG8oNdgvSNV2hTWtfTCQI,482
 pyalgotrading/utils/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 pyalgotrading/utils/func.py,sha256=V1ktGhQqr1Hdyw30B6TMQ5wntnrW7NVwQZd1enyjyFc,8656
 pyalgotrading/utils/candlesticks/__init__.py,sha256=maIn__tvTvJDjldPhU9agBcNNuROt_lpNTV4CZ1Yl6I,83
 pyalgotrading/utils/candlesticks/heikinashi.py,sha256=SpcuK7AYV0sgzcw-DMfLNtTDn2RfWqGvWBt4no7yKD4,2003
 pyalgotrading/utils/candlesticks/linebreak.py,sha256=cYwoETMrenWOa06d03xASZoiou-qRz7n2mZYCi5ilEs,1434
 pyalgotrading/utils/candlesticks/renko.py,sha256=zovQ6D658pBLas86FuTu9fU3-Kkv2hM-4h7OQJjdxng,2089
-pyalgotrading-2023.6.2.dist-info/LICENSE,sha256=-LLEprvixKS-LwHef99YQSOFon_tWeTwJRAWuUwwr1g,1066
-pyalgotrading-2023.6.2.dist-info/METADATA,sha256=ATxdU1PzDuahWmIrcjF_EwPfW5i0AcSWMyipEUc0zRo,5123
-pyalgotrading-2023.6.2.dist-info/WHEEL,sha256=g4nMs7d-Xl9-xC9XovUrsDHGXt-FT0E17Yqo92DEfvY,92
-pyalgotrading-2023.6.2.dist-info/top_level.txt,sha256=A12PTnbXqO3gsZ0D0Gkyzf_OYRQxjJvtg3MqN-Ur2zY,14
-pyalgotrading-2023.6.2.dist-info/RECORD,,
+pyalgotrading-2023.7.1.dist-info/LICENSE,sha256=-LLEprvixKS-LwHef99YQSOFon_tWeTwJRAWuUwwr1g,1066
+pyalgotrading-2023.7.1.dist-info/METADATA,sha256=8JVGrO4p_ZvHy1WAvX4P4iA6UapgYhLGRVjCxJc0dW8,5123
+pyalgotrading-2023.7.1.dist-info/WHEEL,sha256=g4nMs7d-Xl9-xC9XovUrsDHGXt-FT0E17Yqo92DEfvY,92
+pyalgotrading-2023.7.1.dist-info/top_level.txt,sha256=A12PTnbXqO3gsZ0D0Gkyzf_OYRQxjJvtg3MqN-Ur2zY,14
+pyalgotrading-2023.7.1.dist-info/RECORD,,
```

