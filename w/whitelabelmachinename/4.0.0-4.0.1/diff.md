# Comparing `tmp/whitelabelmachinename-4.0.0.tar.gz` & `tmp/whitelabelmachinename-4.0.1.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "whitelabelmachinename-4.0.0.tar", last modified: Thu Jul 20 14:43:32 2023, max compression
+gzip compressed data, was "whitelabelmachinename-4.0.1.tar", last modified: Mon May 16 11:25:17 2022, max compression
```

## Comparing `whitelabelmachinename-4.0.0.tar` & `whitelabelmachinename-4.0.1.tar`

### file list

```diff
@@ -1,564 +1,542 @@
-drwxr-xr-x   0 runner    (1001) docker     (122)        0 2023-07-20 14:43:32.488497 whitelabelmachinename-4.0.0/
--rw-r--r--   0 runner    (1001) docker     (122)    11338 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/LICENSE
--rw-r--r--   0 runner    (1001) docker     (122)     4682 2023-07-20 14:43:32.488497 whitelabelmachinename-4.0.0/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (122)     3753 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/README.md
--rw-r--r--   0 runner    (1001) docker     (122)       38 2023-07-20 14:43:32.488497 whitelabelmachinename-4.0.0/setup.cfg
--rw-r--r--   0 runner    (1001) docker     (122)     1367 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/setup.py
-drwxr-xr-x   0 runner    (1001) docker     (122)        0 2023-07-20 14:43:32.412496 whitelabelmachinename-4.0.0/whitelabelmachinename/
--rw-r--r--   0 runner    (1001) docker     (122)    50024 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (122)        0 2023-07-20 14:43:32.428496 whitelabelmachinename-4.0.0/whitelabelmachinename/api/
--rw-r--r--   0 runner    (1001) docker     (122)     8185 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/__init__.py
--rw-r--r--   0 runner    (1001) docker     (122)    22361 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/account_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    23808 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/analytics_query_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    22667 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/application_user_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    12616 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/bank_account_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    12672 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/bank_transaction_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    12735 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/card_processing_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    12644 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/charge_attempt_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    12763 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/charge_bank_transaction_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    12847 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/charge_flow_level_payment_link_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    16966 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/charge_flow_level_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    30999 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/charge_flow_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)     7023 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/condition_type_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)     3343 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/country_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)     7197 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/country_state_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    12735 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/currency_bank_account_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)     3350 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/currency_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    29541 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/customer_address_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    33470 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/customer_comment_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    25191 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/customer_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    52481 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/debt_collection_case_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    12831 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/debt_collector_configuration_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)     7013 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/debt_collector_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    21653 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/delivery_indication_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    12686 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/document_template_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)     7104 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/document_template_type_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    12910 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/external_transfer_bank_transaction_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    26252 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/human_user_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    18591 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/installment_payment_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    13127 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/installment_payment_slice_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)     4782 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/installment_plan_calculation_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    13207 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/installment_plan_configuration_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    13296 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/installment_plan_slice_configuration_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    12910 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/internal_transfer_bank_transaction_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    22996 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/invoice_reconciliation_record_invoice_link_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    25161 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/invoice_reconciliation_record_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    22202 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/invoice_reimbursement_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)     7123 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/label_description_group_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)     7064 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/label_description_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)     3348 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/language_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    11002 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/legal_organization_form_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    12602 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/manual_task_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)     5209 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/mertic_usage_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    12873 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/payment_connector_configuration_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)     7040 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/payment_connector_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    25418 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/payment_link_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)     7082 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/payment_method_brand_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    12831 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/payment_method_configuration_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)     7023 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/payment_method_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    12873 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/payment_processor_configuration_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)     7040 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/payment_processor_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    29441 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/payment_terminal_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    12397 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/payment_terminal_till_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    17329 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/payment_terminal_transaction_summary_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    41593 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/payment_web_app_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)     6986 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/permission_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    12763 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/refund_bank_transaction_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    28777 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/refund_comment_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    12882 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/refund_recovery_bank_transaction_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    34768 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/refund_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    17038 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/shopify_recurring_order_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    17336 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/shopify_subscriber_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    21925 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/shopify_subscription_product_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    31273 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/shopify_subscription_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    21510 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/shopify_subscription_suspension_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    12833 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/shopify_subscription_version_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    12714 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/shopify_transaction_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    22299 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/space_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)     7017 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/static_value_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    25365 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/subscriber_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    25690 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/subscription_affiliate_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    20912 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/subscription_charge_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    16964 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/subscription_ledger_entry_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    25647 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/subscription_metric_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    17165 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/subscription_metric_usage_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    12777 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/subscription_period_bill_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    26048 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/subscription_product_component_group_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    25877 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/subscription_product_component_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    25751 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/subscription_product_fee_tier_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    25668 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/subscription_product_metered_fee_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    25637 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/subscription_product_period_fee_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    17101 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/subscription_product_retirement_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    21600 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/subscription_product_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    25606 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/subscription_product_setup_fee_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    17249 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/subscription_product_version_retirement_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    26362 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/subscription_product_version_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    52353 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/subscription_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    21322 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/subscription_suspension_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    12696 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/subscription_version_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    42795 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/token_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    17084 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/token_version_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    28985 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/transaction_comment_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    31186 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/transaction_completion_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)     4466 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/transaction_iframe_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    29116 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/transaction_invoice_comment_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    40567 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/transaction_invoice_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)     4474 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/transaction_lightbox_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    17306 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/transaction_line_item_version_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)     4372 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/transaction_mobile_sdk_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)     4499 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/transaction_payment_page_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    80365 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/transaction_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)     9929 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/transaction_terminal_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    21294 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/transaction_void_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    13193 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/user_account_role_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    12734 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/user_space_role_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    11966 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/web_app_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    25566 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/webhook_listener_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    25411 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api/webhook_url_service_api.py
--rw-r--r--   0 runner    (1001) docker     (122)    25632 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/api_client.py
--rw-r--r--   0 runner    (1001) docker     (122)     8532 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/configuration.py
-drwxr-xr-x   0 runner    (1001) docker     (122)        0 2023-07-20 14:43:32.488497 whitelabelmachinename-4.0.0/whitelabelmachinename/models/
--rw-r--r--   0 runner    (1001) docker     (122)    26892 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/__init__.py
--rw-r--r--   0 runner    (1001) docker     (122)     4372 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_account_update.py
--rw-r--r--   0 runner    (1001) docker     (122)     4062 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_application_user_update.py
--rw-r--r--   0 runner    (1001) docker     (122)     7742 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_customer_active.py
--rw-r--r--   0 runner    (1001) docker     (122)     3287 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_customer_address_active.py
--rw-r--r--   0 runner    (1001) docker     (122)     2494 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_customer_comment_active.py
--rw-r--r--   0 runner    (1001) docker     (122)     8982 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_debt_collection_case_update.py
--rw-r--r--   0 runner    (1001) docker     (122)     8520 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_human_user_update.py
--rw-r--r--   0 runner    (1001) docker     (122)    14228 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_payment_link_update.py
--rw-r--r--   0 runner    (1001) docker     (122)     2480 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_refund_comment_active.py
--rw-r--r--   0 runner    (1001) docker     (122)    16919 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_shopify_subscription_product_update.py
--rw-r--r--   0 runner    (1001) docker     (122)     9041 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_space_update.py
--rw-r--r--   0 runner    (1001) docker     (122)    11391 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_subscriber_update.py
--rw-r--r--   0 runner    (1001) docker     (122)     4911 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_subscription_affiliate_update.py
--rw-r--r--   0 runner    (1001) docker     (122)     3033 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_subscription_metric_update.py
--rw-r--r--   0 runner    (1001) docker     (122)     8738 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_subscription_product_active.py
--rw-r--r--   0 runner    (1001) docker     (122)     8747 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_token_update.py
--rw-r--r--   0 runner    (1001) docker     (122)     2515 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_transaction_comment_active.py
--rw-r--r--   0 runner    (1001) docker     (122)     2564 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_transaction_invoice_comment_active.py
--rw-r--r--   0 runner    (1001) docker     (122)    20178 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_transaction_pending.py
--rw-r--r--   0 runner    (1001) docker     (122)     5060 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_webhook_listener_update.py
--rw-r--r--   0 runner    (1001) docker     (122)     4087 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_webhook_url_update.py
--rw-r--r--   0 runner    (1001) docker     (122)    14712 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/account.py
--rw-r--r--   0 runner    (1001) docker     (122)     3326 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/account_create.py
--rw-r--r--   0 runner    (1001) docker     (122)      252 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/account_state.py
--rw-r--r--   0 runner    (1001) docker     (122)      163 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/account_type.py
--rw-r--r--   0 runner    (1001) docker     (122)     3430 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/account_update.py
--rw-r--r--   0 runner    (1001) docker     (122)    19096 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/address.py
--rw-r--r--   0 runner    (1001) docker     (122)    19676 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/address_create.py
--rw-r--r--   0 runner    (1001) docker     (122)     9337 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/analytics_query.py
--rw-r--r--   0 runner    (1001) docker     (122)    12454 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/analytics_query_execution.py
--rw-r--r--   0 runner    (1001) docker     (122)      210 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/analytics_query_execution_state.py
--rw-r--r--   0 runner    (1001) docker     (122)     5426 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/analytics_query_result_batch.py
--rw-r--r--   0 runner    (1001) docker     (122)     8401 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/analytics_schema_column.py
--rw-r--r--   0 runner    (1001) docker     (122)     3928 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/analytics_schema_table.py
--rw-r--r--   0 runner    (1001) docker     (122)     4183 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/application_user.py
--rw-r--r--   0 runner    (1001) docker     (122)     2781 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/application_user_create.py
--rw-r--r--   0 runner    (1001) docker     (122)     2690 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/application_user_create_with_mac_key.py
--rw-r--r--   0 runner    (1001) docker     (122)     3534 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/application_user_update.py
--rw-r--r--   0 runner    (1001) docker     (122)     3133 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/authenticated_card_data.py
--rw-r--r--   0 runner    (1001) docker     (122)    12532 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/authenticated_card_data_create.py
--rw-r--r--   0 runner    (1001) docker     (122)     7917 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/bank_account.py
--rw-r--r--   0 runner    (1001) docker     (122)      146 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/bank_account_environment.py
--rw-r--r--   0 runner    (1001) docker     (122)      186 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/bank_account_state.py
--rw-r--r--   0 runner    (1001) docker     (122)     4326 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/bank_account_type.py
--rw-r--r--   0 runner    (1001) docker     (122)    15797 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/bank_transaction.py
--rw-r--r--   0 runner    (1001) docker     (122)      150 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/bank_transaction_flow_direction.py
--rw-r--r--   0 runner    (1001) docker     (122)     3651 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/bank_transaction_source.py
--rw-r--r--   0 runner    (1001) docker     (122)      146 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/bank_transaction_state.py
--rw-r--r--   0 runner    (1001) docker     (122)     3621 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/bank_transaction_type.py
--rw-r--r--   0 runner    (1001) docker     (122)      366 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/card_authentication_response.py
--rw-r--r--   0 runner    (1001) docker     (122)      129 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/card_authentication_version.py
--rw-r--r--   0 runner    (1001) docker     (122)     2706 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/card_cryptogram.py
--rw-r--r--   0 runner    (1001) docker     (122)     2968 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/card_cryptogram_create.py
--rw-r--r--   0 runner    (1001) docker     (122)      128 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/card_cryptogram_type.py
--rw-r--r--   0 runner    (1001) docker     (122)     6794 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/cardholder_authentication.py
--rw-r--r--   0 runner    (1001) docker     (122)     7170 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/cardholder_authentication_create.py
--rw-r--r--   0 runner    (1001) docker     (122)    10311 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/charge.py
--rw-r--r--   0 runner    (1001) docker     (122)    21469 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/charge_attempt.py
--rw-r--r--   0 runner    (1001) docker     (122)      148 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/charge_attempt_environment.py
--rw-r--r--   0 runner    (1001) docker     (122)      176 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/charge_attempt_state.py
--rw-r--r--   0 runner    (1001) docker     (122)     8390 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/charge_bank_transaction.py
--rw-r--r--   0 runner    (1001) docker     (122)     8320 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/charge_flow.py
--rw-r--r--   0 runner    (1001) docker     (122)     9394 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/charge_flow_level.py
--rw-r--r--   0 runner    (1001) docker     (122)    10355 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/charge_flow_level_configuration.py
--rw-r--r--   0 runner    (1001) docker     (122)     4470 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/charge_flow_level_configuration_type.py
--rw-r--r--   0 runner    (1001) docker     (122)     3386 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/charge_flow_level_payment_link.py
--rw-r--r--   0 runner    (1001) docker     (122)      172 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/charge_flow_level_state.py
--rw-r--r--   0 runner    (1001) docker     (122)      163 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/charge_state.py
--rw-r--r--   0 runner    (1001) docker     (122)      198 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/charge_type.py
--rw-r--r--   0 runner    (1001) docker     (122)     4921 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/client_error.py
--rw-r--r--   0 runner    (1001) docker     (122)      217 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/client_error_type.py
--rw-r--r--   0 runner    (1001) docker     (122)     3972 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/completion_line_item.py
--rw-r--r--   0 runner    (1001) docker     (122)     4375 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/completion_line_item_create.py
--rw-r--r--   0 runner    (1001) docker     (122)     7163 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/condition.py
--rw-r--r--   0 runner    (1001) docker     (122)     3531 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/condition_type.py
--rw-r--r--   0 runner    (1001) docker     (122)     6649 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/connector_invocation.py
--rw-r--r--   0 runner    (1001) docker     (122)      254 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/connector_invocation_stage.py
--rw-r--r--   0 runner    (1001) docker     (122)      215 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/creation_entity_state.py
--rw-r--r--   0 runner    (1001) docker     (122)      520 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/criteria_operator.py
--rw-r--r--   0 runner    (1001) docker     (122)     5874 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/currency_bank_account.py
--rw-r--r--   0 runner    (1001) docker     (122)    10100 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/customer.py
--rw-r--r--   0 runner    (1001) docker     (122)     3443 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/customer_active.py
--rw-r--r--   0 runner    (1001) docker     (122)     7550 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/customer_address.py
--rw-r--r--   0 runner    (1001) docker     (122)     3534 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/customer_address_active.py
--rw-r--r--   0 runner    (1001) docker     (122)     2632 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/customer_address_create.py
--rw-r--r--   0 runner    (1001) docker     (122)      163 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/customer_address_type.py
--rw-r--r--   0 runner    (1001) docker     (122)     8846 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/customer_comment.py
--rw-r--r--   0 runner    (1001) docker     (122)     3534 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/customer_comment_active.py
--rw-r--r--   0 runner    (1001) docker     (122)     2632 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/customer_comment_create.py
--rw-r--r--   0 runner    (1001) docker     (122)     1781 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/customer_create.py
--rw-r--r--   0 runner    (1001) docker     (122)    20258 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/customer_postal_address.py
--rw-r--r--   0 runner    (1001) docker     (122)    20702 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/customer_postal_address_create.py
--rw-r--r--   0 runner    (1001) docker     (122)      207 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/customers_presence.py
--rw-r--r--   0 runner    (1001) docker     (122)      140 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/data_collection_type.py
--rw-r--r--   0 runner    (1001) docker     (122)    27693 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/debt_collection_case.py
--rw-r--r--   0 runner    (1001) docker     (122)     5190 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/debt_collection_case_create.py
--rw-r--r--   0 runner    (1001) docker     (122)    10485 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/debt_collection_case_document.py
--rw-r--r--   0 runner    (1001) docker     (122)     4592 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/debt_collection_case_source.py
--rw-r--r--   0 runner    (1001) docker     (122)      275 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/debt_collection_case_state.py
--rw-r--r--   0 runner    (1001) docker     (122)     3573 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/debt_collection_case_update.py
--rw-r--r--   0 runner    (1001) docker     (122)      149 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/debt_collection_environment.py
--rw-r--r--   0 runner    (1001) docker     (122)    10048 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/debt_collection_receipt.py
--rw-r--r--   0 runner    (1001) docker     (122)     3741 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/debt_collection_receipt_source.py
--rw-r--r--   0 runner    (1001) docker     (122)     3531 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/debt_collector.py
--rw-r--r--   0 runner    (1001) docker     (122)     7321 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/debt_collector_condition.py
--rw-r--r--   0 runner    (1001) docker     (122)     3726 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/debt_collector_condition_type.py
--rw-r--r--   0 runner    (1001) docker     (122)    11916 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/debt_collector_configuration.py
--rw-r--r--   0 runner    (1001) docker     (122)    10848 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/delivery_indication.py
--rw-r--r--   0 runner    (1001) docker     (122)     3816 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/delivery_indication_decision_reason.py
--rw-r--r--   0 runner    (1001) docker     (122)      235 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/delivery_indication_state.py
--rw-r--r--   0 runner    (1001) docker     (122)     9844 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/document_template.py
--rw-r--r--   0 runner    (1001) docker     (122)     4756 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/document_template_type.py
--rw-r--r--   0 runner    (1001) docker     (122)     2849 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/document_template_type_group.py
--rw-r--r--   0 runner    (1001) docker     (122)     3377 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/entity_export_request.py
--rw-r--r--   0 runner    (1001) docker     (122)     6248 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/entity_query.py
--rw-r--r--   0 runner    (1001) docker     (122)     6167 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/entity_query_filter.py
--rw-r--r--   0 runner    (1001) docker     (122)      145 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/entity_query_filter_type.py
--rw-r--r--   0 runner    (1001) docker     (122)     3117 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/entity_query_order_by.py
--rw-r--r--   0 runner    (1001) docker     (122)      132 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/entity_query_order_by_type.py
--rw-r--r--   0 runner    (1001) docker     (122)      129 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/environment.py
--rw-r--r--   0 runner    (1001) docker     (122)     7592 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/external_transfer_bank_transaction.py
--rw-r--r--   0 runner    (1001) docker     (122)      247 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/failure_category.py
--rw-r--r--   0 runner    (1001) docker     (122)     4783 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/failure_reason.py
--rw-r--r--   0 runner    (1001) docker     (122)     7624 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/feature.py
--rw-r--r--   0 runner    (1001) docker     (122)     4373 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/feature_category.py
--rw-r--r--   0 runner    (1001) docker     (122)      122 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/gender.py
--rw-r--r--   0 runner    (1001) docker     (122)    11579 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/human_user.py
--rw-r--r--   0 runner    (1001) docker     (122)     2608 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/human_user_create.py
--rw-r--r--   0 runner    (1001) docker     (122)     3456 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/human_user_update.py
--rw-r--r--   0 runner    (1001) docker     (122)     5683 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/installment_calculated_plan.py
--rw-r--r--   0 runner    (1001) docker     (122)     3836 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/installment_calculated_slice.py
--rw-r--r--   0 runner    (1001) docker     (122)     8613 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/installment_payment.py
--rw-r--r--   0 runner    (1001) docker     (122)     8164 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/installment_payment_slice.py
--rw-r--r--   0 runner    (1001) docker     (122)      308 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/installment_payment_slice_state.py
--rw-r--r--   0 runner    (1001) docker     (122)      303 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/installment_payment_state.py
--rw-r--r--   0 runner    (1001) docker     (122)    17626 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/installment_plan_configuration.py
--rw-r--r--   0 runner    (1001) docker     (122)    10797 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/installment_plan_slice_configuration.py
--rw-r--r--   0 runner    (1001) docker     (122)     5929 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/internal_transfer_bank_transaction.py
--rw-r--r--   0 runner    (1001) docker     (122)    25217 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/invoice_reconciliation_record.py
--rw-r--r--   0 runner    (1001) docker     (122)     6194 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/invoice_reconciliation_record_invoice_link.py
--rw-r--r--   0 runner    (1001) docker     (122)      198 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/invoice_reconciliation_record_rejection_status.py
--rw-r--r--   0 runner    (1001) docker     (122)      238 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/invoice_reconciliation_record_state.py
--rw-r--r--   0 runner    (1001) docker     (122)     3801 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/invoice_reconciliation_record_type.py
--rw-r--r--   0 runner    (1001) docker     (122)    17743 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/invoice_reimbursement.py
--rw-r--r--   0 runner    (1001) docker     (122)      247 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/invoice_reimbursement_state.py
--rw-r--r--   0 runner    (1001) docker     (122)     2859 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/invoice_reimbursement_with_refund_reference.py
--rw-r--r--   0 runner    (1001) docker     (122)     4736 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/label.py
--rw-r--r--   0 runner    (1001) docker     (122)     6878 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/label_descriptor.py
--rw-r--r--   0 runner    (1001) docker     (122)      151 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/label_descriptor_category.py
--rw-r--r--   0 runner    (1001) docker     (122)     4349 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/label_descriptor_group.py
--rw-r--r--   0 runner    (1001) docker     (122)     3621 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/label_descriptor_type.py
--rw-r--r--   0 runner    (1001) docker     (122)     5586 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/legal_organization_form.py
--rw-r--r--   0 runner    (1001) docker     (122)    18658 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/line_item.py
--rw-r--r--   0 runner    (1001) docker     (122)     3018 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/line_item_attribute.py
--rw-r--r--   0 runner    (1001) docker     (122)     3282 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/line_item_attribute_create.py
--rw-r--r--   0 runner    (1001) docker     (122)     9524 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/line_item_create.py
--rw-r--r--   0 runner    (1001) docker     (122)     4382 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/line_item_reduction.py
--rw-r--r--   0 runner    (1001) docker     (122)     4853 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/line_item_reduction_create.py
--rw-r--r--   0 runner    (1001) docker     (122)      196 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/line_item_type.py
--rw-r--r--   0 runner    (1001) docker     (122)     2840 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/localized_string.py
--rw-r--r--   0 runner    (1001) docker     (122)     8177 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/manual_task.py
--rw-r--r--   0 runner    (1001) docker     (122)     4161 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/manual_task_action.py
--rw-r--r--   0 runner    (1001) docker     (122)      167 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/manual_task_action_style.py
--rw-r--r--   0 runner    (1001) docker     (122)      151 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/manual_task_state.py
--rw-r--r--   0 runner    (1001) docker     (122)     4245 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/manual_task_type.py
--rw-r--r--   0 runner    (1001) docker     (122)     4856 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/metric_usage.py
--rw-r--r--   0 runner    (1001) docker     (122)      161 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/one_click_payment_mode.py
--rw-r--r--   0 runner    (1001) docker     (122)     5403 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_adjustment.py
--rw-r--r--   0 runner    (1001) docker     (122)     3651 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_adjustment_type.py
--rw-r--r--   0 runner    (1001) docker     (122)      162 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_app_charge_attempt_target_state.py
--rw-r--r--   0 runner    (1001) docker     (122)     7658 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_app_charge_attempt_update_request.py
--rw-r--r--   0 runner    (1001) docker     (122)     7987 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_app_completion_configuration.py
--rw-r--r--   0 runner    (1001) docker     (122)     8125 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_app_completion_configuration_create.py
--rw-r--r--   0 runner    (1001) docker     (122)      159 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_app_completion_target_state.py
--rw-r--r--   0 runner    (1001) docker     (122)     5881 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_app_completion_update_request.py
--rw-r--r--   0 runner    (1001) docker     (122)    14889 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_app_connector.py
--rw-r--r--   0 runner    (1001) docker     (122)    12593 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_app_connector_creation_request.py
--rw-r--r--   0 runner    (1001) docker     (122)      146 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_app_connector_state.py
--rw-r--r--   0 runner    (1001) docker     (122)    16126 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_app_processor.py
--rw-r--r--   0 runner    (1001) docker     (122)     7576 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_app_processor_creation_request.py
--rw-r--r--   0 runner    (1001) docker     (122)      146 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_app_processor_state.py
--rw-r--r--   0 runner    (1001) docker     (122)     5112 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_app_refund_configuration.py
--rw-r--r--   0 runner    (1001) docker     (122)     5202 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_app_refund_configuration_create.py
--rw-r--r--   0 runner    (1001) docker     (122)      155 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_app_refund_target_state.py
--rw-r--r--   0 runner    (1001) docker     (122)     5681 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_app_refund_update_request.py
--rw-r--r--   0 runner    (1001) docker     (122)      153 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_app_void_target_state.py
--rw-r--r--   0 runner    (1001) docker     (122)     5581 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_app_void_update_request.py
--rw-r--r--   0 runner    (1001) docker     (122)    11445 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_connector.py
--rw-r--r--   0 runner    (1001) docker     (122)    16324 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_connector_configuration.py
--rw-r--r--   0 runner    (1001) docker     (122)     3552 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_connector_feature.py
--rw-r--r--   0 runner    (1001) docker     (122)    12577 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_contract.py
--rw-r--r--   0 runner    (1001) docker     (122)      230 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_contract_state.py
--rw-r--r--   0 runner    (1001) docker     (122)     4238 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_contract_type.py
--rw-r--r--   0 runner    (1001) docker     (122)     3415 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_information_hash.py
--rw-r--r--   0 runner    (1001) docker     (122)     2842 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_information_hash_type.py
--rw-r--r--   0 runner    (1001) docker     (122)     9330 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_initiation_advice_file.py
--rw-r--r--   0 runner    (1001) docker     (122)      288 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_initiation_advice_file_state.py
--rw-r--r--   0 runner    (1001) docker     (122)    20033 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_link.py
--rw-r--r--   0 runner    (1001) docker     (122)     2443 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_link_active.py
--rw-r--r--   0 runner    (1001) docker     (122)      238 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_link_address_handling_mode.py
--rw-r--r--   0 runner    (1001) docker     (122)     4640 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_link_create.py
--rw-r--r--   0 runner    (1001) docker     (122)      167 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_link_protection_mode.py
--rw-r--r--   0 runner    (1001) docker     (122)    15538 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_link_update.py
--rw-r--r--   0 runner    (1001) docker     (122)     6738 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_method.py
--rw-r--r--   0 runner    (1001) docker     (122)     5729 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_method_brand.py
--rw-r--r--   0 runner    (1001) docker     (122)    17963 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_method_configuration.py
--rw-r--r--   0 runner    (1001) docker     (122)      183 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_primary_risk_taker.py
--rw-r--r--   0 runner    (1001) docker     (122)     7104 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_processor.py
--rw-r--r--   0 runner    (1001) docker     (122)    10017 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_processor_configuration.py
--rw-r--r--   0 runner    (1001) docker     (122)    12362 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_terminal.py
--rw-r--r--   0 runner    (1001) docker     (122)    13283 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_terminal_address.py
--rw-r--r--   0 runner    (1001) docker     (122)     7555 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_terminal_configuration.py
--rw-r--r--   0 runner    (1001) docker     (122)      203 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_terminal_configuration_state.py
--rw-r--r--   0 runner    (1001) docker     (122)    14186 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_terminal_configuration_version.py
--rw-r--r--   0 runner    (1001) docker     (122)      242 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_terminal_configuration_version_state.py
--rw-r--r--   0 runner    (1001) docker     (122)     7778 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_terminal_dcc_transaction_sum.py
--rw-r--r--   0 runner    (1001) docker     (122)     7852 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_terminal_location.py
--rw-r--r--   0 runner    (1001) docker     (122)      198 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_terminal_location_state.py
--rw-r--r--   0 runner    (1001) docker     (122)    10642 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_terminal_location_version.py
--rw-r--r--   0 runner    (1001) docker     (122)      237 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_terminal_location_version_state.py
--rw-r--r--   0 runner    (1001) docker     (122)     3726 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_terminal_receipt_type.py
--rw-r--r--   0 runner    (1001) docker     (122)      272 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_terminal_state.py
--rw-r--r--   0 runner    (1001) docker     (122)    10388 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_terminal_transaction_sum.py
--rw-r--r--   0 runner    (1001) docker     (122)     9759 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_terminal_transaction_summary.py
--rw-r--r--   0 runner    (1001) docker     (122)     4708 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_terminal_transaction_summary_fetch_request.py
--rw-r--r--   0 runner    (1001) docker     (122)     3621 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_terminal_type.py
--rw-r--r--   0 runner    (1001) docker     (122)     9149 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/permission.py
--rw-r--r--   0 runner    (1001) docker     (122)     2878 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/persistable_currency_amount.py
--rw-r--r--   0 runner    (1001) docker     (122)     2944 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/persistable_currency_amount_update.py
--rw-r--r--   0 runner    (1001) docker     (122)      180 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/product_fee_type.py
--rw-r--r--   0 runner    (1001) docker     (122)     8531 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/product_metered_fee.py
--rw-r--r--   0 runner    (1001) docker     (122)     7528 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/product_metered_fee_update.py
--rw-r--r--   0 runner    (1001) docker     (122)     5837 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/product_metered_tier_fee.py
--rw-r--r--   0 runner    (1001) docker     (122)     6283 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/product_metered_tier_fee_update.py
--rw-r--r--   0 runner    (1001) docker     (122)      219 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/product_metered_tier_pricing.py
--rw-r--r--   0 runner    (1001) docker     (122)     9919 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/product_period_fee.py
--rw-r--r--   0 runner    (1001) docker     (122)     9011 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/product_period_fee_update.py
--rw-r--r--   0 runner    (1001) docker     (122)    10385 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/product_setup_fee.py
--rw-r--r--   0 runner    (1001) docker     (122)     9521 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/product_setup_fee_update.py
--rw-r--r--   0 runner    (1001) docker     (122)      390 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/recurring_indicator.py
--rw-r--r--   0 runner    (1001) docker     (122)    24283 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/refund.py
--rw-r--r--   0 runner    (1001) docker     (122)     7428 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/refund_bank_transaction.py
--rw-r--r--   0 runner    (1001) docker     (122)     8644 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/refund_comment.py
--rw-r--r--   0 runner    (1001) docker     (122)     3508 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/refund_comment_active.py
--rw-r--r--   0 runner    (1001) docker     (122)     2494 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/refund_comment_create.py
--rw-r--r--   0 runner    (1001) docker     (122)     7096 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/refund_create.py
--rw-r--r--   0 runner    (1001) docker     (122)     8523 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/refund_recovery_bank_transaction.py
--rw-r--r--   0 runner    (1001) docker     (122)      247 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/refund_state.py
--rw-r--r--   0 runner    (1001) docker     (122)      334 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/refund_type.py
--rw-r--r--   0 runner    (1001) docker     (122)     4190 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/rendered_document.py
--rw-r--r--   0 runner    (1001) docker     (122)     5264 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/rendered_terminal_receipt.py
--rw-r--r--   0 runner    (1001) docker     (122)     3400 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/rendered_terminal_transaction_summary.py
--rw-r--r--   0 runner    (1001) docker     (122)     6775 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/resource_path.py
--rw-r--r--   0 runner    (1001) docker     (122)      161 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/resource_state.py
--rw-r--r--   0 runner    (1001) docker     (122)     5042 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/rest_address_format.py
--rw-r--r--   0 runner    (1001) docker     (122)      410 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/rest_address_format_field.py
--rw-r--r--   0 runner    (1001) docker     (122)     6297 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/rest_country.py
--rw-r--r--   0 runner    (1001) docker     (122)     4783 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/rest_country_state.py
--rw-r--r--   0 runner    (1001) docker     (122)     4662 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/rest_currency.py
--rw-r--r--   0 runner    (1001) docker     (122)     7056 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/rest_language.py
--rw-r--r--   0 runner    (1001) docker     (122)     7371 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/role.py
--rw-r--r--   0 runner    (1001) docker     (122)      179 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/role_state.py
--rw-r--r--   0 runner    (1001) docker     (122)     5255 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/sales_channel.py
--rw-r--r--   0 runner    (1001) docker     (122)    10254 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/scope.py
--rw-r--r--   0 runner    (1001) docker     (122)     3352 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/server_error.py
--rw-r--r--   0 runner    (1001) docker     (122)      149 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_additional_line_item_data.py
--rw-r--r--   0 runner    (1001) docker     (122)    23991 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_integration.py
--rw-r--r--   0 runner    (1001) docker     (122)      143 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_integration_payment_app_version.py
--rw-r--r--   0 runner    (1001) docker     (122)      202 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_integration_subscription_app_version.py
--rw-r--r--   0 runner    (1001) docker     (122)    12494 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_recurring_order.py
--rw-r--r--   0 runner    (1001) docker     (122)      248 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_recurring_order_state.py
--rw-r--r--   0 runner    (1001) docker     (122)     3307 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_recurring_order_update_request.py
--rw-r--r--   0 runner    (1001) docker     (122)     9518 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscriber.py
--rw-r--r--   0 runner    (1001) docker     (122)     6223 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscriber_active.py
--rw-r--r--   0 runner    (1001) docker     (122)     4338 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscriber_creation.py
--rw-r--r--   0 runner    (1001) docker     (122)      170 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscriber_state.py
--rw-r--r--   0 runner    (1001) docker     (122)    15120 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription.py
--rw-r--r--   0 runner    (1001) docker     (122)     1787 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription_address.py
--rw-r--r--   0 runner    (1001) docker     (122)    20480 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription_address_create.py
--rw-r--r--   0 runner    (1001) docker     (122)      238 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription_billing_interval_unit.py
--rw-r--r--   0 runner    (1001) docker     (122)    15014 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription_creation_request.py
--rw-r--r--   0 runner    (1001) docker     (122)    11797 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription_model_billing_configuration.py
--rw-r--r--   0 runner    (1001) docker     (122)     5444 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription_model_item.py
--rw-r--r--   0 runner    (1001) docker     (122)     2854 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription_model_tax_line.py
--rw-r--r--   0 runner    (1001) docker     (122)    27878 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription_product.py
--rw-r--r--   0 runner    (1001) docker     (122)     4520 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription_product_create.py
--rw-r--r--   0 runner    (1001) docker     (122)      317 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription_product_pricing_option.py
--rw-r--r--   0 runner    (1001) docker     (122)      253 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription_product_state.py
--rw-r--r--   0 runner    (1001) docker     (122)     3677 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription_product_update.py
--rw-r--r--   0 runner    (1001) docker     (122)      264 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription_state.py
--rw-r--r--   0 runner    (1001) docker     (122)    11116 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription_suspension.py
--rw-r--r--   0 runner    (1001) docker     (122)     4283 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription_suspension_create.py
--rw-r--r--   0 runner    (1001) docker     (122)      166 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription_suspension_initiator.py
--rw-r--r--   0 runner    (1001) docker     (122)      152 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription_suspension_state.py
--rw-r--r--   0 runner    (1001) docker     (122)      167 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription_suspension_type.py
--rw-r--r--   0 runner    (1001) docker     (122)     4129 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription_update_addresses_request.py
--rw-r--r--   0 runner    (1001) docker     (122)     6215 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription_update_request.py
--rw-r--r--   0 runner    (1001) docker     (122)    24539 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription_version.py
--rw-r--r--   0 runner    (1001) docker     (122)     5449 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription_version_item.py
--rw-r--r--   0 runner    (1001) docker     (122)      201 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription_version_item_price_strategy.py
--rw-r--r--   0 runner    (1001) docker     (122)      181 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription_version_state.py
--rw-r--r--   0 runner    (1001) docker     (122)      272 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription_weekday.py
--rw-r--r--   0 runner    (1001) docker     (122)     4695 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_tax_line.py
--rw-r--r--   0 runner    (1001) docker     (122)     8383 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_transaction.py
--rw-r--r--   0 runner    (1001) docker     (122)      235 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_transaction_state.py
--rw-r--r--   0 runner    (1001) docker     (122)    17704 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/space.py
--rw-r--r--   0 runner    (1001) docker     (122)    14295 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/space_address.py
--rw-r--r--   0 runner    (1001) docker     (122)    14673 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/space_address_create.py
--rw-r--r--   0 runner    (1001) docker     (122)     2518 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/space_create.py
--rw-r--r--   0 runner    (1001) docker     (122)     6678 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/space_reference.py
--rw-r--r--   0 runner    (1001) docker     (122)      237 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/space_reference_state.py
--rw-r--r--   0 runner    (1001) docker     (122)     3404 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/space_update.py
--rw-r--r--   0 runner    (1001) docker     (122)     7107 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/space_view.py
--rw-r--r--   0 runner    (1001) docker     (122)     4110 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/static_value.py
--rw-r--r--   0 runner    (1001) docker     (122)    15611 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscriber.py
--rw-r--r--   0 runner    (1001) docker     (122)     2434 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscriber_active.py
--rw-r--r--   0 runner    (1001) docker     (122)     3625 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscriber_create.py
--rw-r--r--   0 runner    (1001) docker     (122)    12757 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscriber_update.py
--rw-r--r--   0 runner    (1001) docker     (122)    16381 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription.py
--rw-r--r--   0 runner    (1001) docker     (122)    10010 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_affiliate.py
--rw-r--r--   0 runner    (1001) docker     (122)     4174 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_affiliate_create.py
--rw-r--r--   0 runner    (1001) docker     (122)     1821 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_affiliate_deleted.py
--rw-r--r--   0 runner    (1001) docker     (122)     1838 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_affiliate_deleting.py
--rw-r--r--   0 runner    (1001) docker     (122)     1836 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_affiliate_inactive.py
--rw-r--r--   0 runner    (1001) docker     (122)     6525 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_affiliate_update.py
--rw-r--r--   0 runner    (1001) docker     (122)     7470 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_change_request.py
--rw-r--r--   0 runner    (1001) docker     (122)    18892 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_charge.py
--rw-r--r--   0 runner    (1001) docker     (122)     9268 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_charge_create.py
--rw-r--r--   0 runner    (1001) docker     (122)      172 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_charge_processing_type.py
--rw-r--r--   0 runner    (1001) docker     (122)      237 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_charge_state.py
--rw-r--r--   0 runner    (1001) docker     (122)      148 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_charge_type.py
--rw-r--r--   0 runner    (1001) docker     (122)     3031 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_component_configuration.py
--rw-r--r--   0 runner    (1001) docker     (122)     3505 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_component_reference_configuration.py
--rw-r--r--   0 runner    (1001) docker     (122)     6112 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_create_request.py
--rw-r--r--   0 runner    (1001) docker     (122)    15330 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_ledger_entry.py
--rw-r--r--   0 runner    (1001) docker     (122)     7304 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_ledger_entry_create.py
--rw-r--r--   0 runner    (1001) docker     (122)      168 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_ledger_entry_state.py
--rw-r--r--   0 runner    (1001) docker     (122)     7405 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_metric.py
--rw-r--r--   0 runner    (1001) docker     (122)     1815 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_metric_active.py
--rw-r--r--   0 runner    (1001) docker     (122)     2499 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_metric_create.py
--rw-r--r--   0 runner    (1001) docker     (122)     4295 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_metric_type.py
--rw-r--r--   0 runner    (1001) docker     (122)     4687 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_metric_update.py
--rw-r--r--   0 runner    (1001) docker     (122)    11198 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_metric_usage_report.py
--rw-r--r--   0 runner    (1001) docker     (122)     6794 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_metric_usage_report_create.py
--rw-r--r--   0 runner    (1001) docker     (122)     3822 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_pending.py
--rw-r--r--   0 runner    (1001) docker     (122)    10613 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_period_bill.py
--rw-r--r--   0 runner    (1001) docker     (122)      149 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_period_bill_state.py
--rw-r--r--   0 runner    (1001) docker     (122)    13275 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_product.py
--rw-r--r--   0 runner    (1001) docker     (122)     3586 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_product_active.py
--rw-r--r--   0 runner    (1001) docker     (122)    14984 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_product_component.py
--rw-r--r--   0 runner    (1001) docker     (122)     7620 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_product_component_group.py
--rw-r--r--   0 runner    (1001) docker     (122)     7156 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_product_component_group_update.py
--rw-r--r--   0 runner    (1001) docker     (122)     7834 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_product_component_reference.py
--rw-r--r--   0 runner    (1001) docker     (122)      212 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_product_component_reference_state.py
--rw-r--r--   0 runner    (1001) docker     (122)    14570 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_product_component_update.py
--rw-r--r--   0 runner    (1001) docker     (122)     2989 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_product_create.py
--rw-r--r--   0 runner    (1001) docker     (122)     7432 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_product_retirement.py
--rw-r--r--   0 runner    (1001) docker     (122)     4401 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_product_retirement_create.py
--rw-r--r--   0 runner    (1001) docker     (122)      220 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_product_state.py
--rw-r--r--   0 runner    (1001) docker     (122)    20871 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_product_version.py
--rw-r--r--   0 runner    (1001) docker     (122)    13578 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_product_version_pending.py
--rw-r--r--   0 runner    (1001) docker     (122)     8003 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_product_version_retirement.py
--rw-r--r--   0 runner    (1001) docker     (122)     4855 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_product_version_retirement_create.py
--rw-r--r--   0 runner    (1001) docker     (122)      229 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_product_version_state.py
--rw-r--r--   0 runner    (1001) docker     (122)      337 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_state.py
--rw-r--r--   0 runner    (1001) docker     (122)    13218 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_suspension.py
--rw-r--r--   0 runner    (1001) docker     (122)      162 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_suspension_action.py
--rw-r--r--   0 runner    (1001) docker     (122)     5831 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_suspension_create.py
--rw-r--r--   0 runner    (1001) docker     (122)      226 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_suspension_reason.py
--rw-r--r--   0 runner    (1001) docker     (122)     1826 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_suspension_running.py
--rw-r--r--   0 runner    (1001) docker     (122)      147 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_suspension_state.py
--rw-r--r--   0 runner    (1001) docker     (122)     5688 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_update.py
--rw-r--r--   0 runner    (1001) docker     (122)     2486 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_update_request.py
--rw-r--r--   0 runner    (1001) docker     (122)    17339 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_version.py
--rw-r--r--   0 runner    (1001) docker     (122)      264 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_version_state.py
--rw-r--r--   0 runner    (1001) docker     (122)     2849 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/tax.py
--rw-r--r--   0 runner    (1001) docker     (122)      166 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/tax_calculation.py
--rw-r--r--   0 runner    (1001) docker     (122)     6892 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/tax_class.py
--rw-r--r--   0 runner    (1001) docker     (122)     3111 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/tax_create.py
--rw-r--r--   0 runner    (1001) docker     (122)     3670 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/tenant_database.py
--rw-r--r--   0 runner    (1001) docker     (122)     4471 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/terminal_receipt_fetch_request.py
--rw-r--r--   0 runner    (1001) docker     (122)      129 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/terminal_receipt_format.py
--rw-r--r--   0 runner    (1001) docker     (122)    13760 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/token.py
--rw-r--r--   0 runner    (1001) docker     (122)     3560 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/token_create.py
--rw-r--r--   0 runner    (1001) docker     (122)     3404 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/token_update.py
--rw-r--r--   0 runner    (1001) docker     (122)    19146 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/token_version.py
--rw-r--r--   0 runner    (1001) docker     (122)      177 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/token_version_state.py
--rw-r--r--   0 runner    (1001) docker     (122)     4181 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/token_version_type.py
--rw-r--r--   0 runner    (1001) docker     (122)      304 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/tokenization_mode.py
--rw-r--r--   0 runner    (1001) docker     (122)     4090 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/tokenized_card_data.py
--rw-r--r--   0 runner    (1001) docker     (122)    11009 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/tokenized_card_data_create.py
--rw-r--r--   0 runner    (1001) docker     (122)    63417 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction.py
--rw-r--r--   0 runner    (1001) docker     (122)     3861 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_aware_entity.py
--rw-r--r--   0 runner    (1001) docker     (122)     8949 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_comment.py
--rw-r--r--   0 runner    (1001) docker     (122)     3573 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_comment_active.py
--rw-r--r--   0 runner    (1001) docker     (122)     2639 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_comment_create.py
--rw-r--r--   0 runner    (1001) docker     (122)    24689 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_completion.py
--rw-r--r--   0 runner    (1001) docker     (122)      243 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_completion_behavior.py
--rw-r--r--   0 runner    (1001) docker     (122)      169 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_completion_mode.py
--rw-r--r--   0 runner    (1001) docker     (122)     8532 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_completion_request.py
--rw-r--r--   0 runner    (1001) docker     (122)      228 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_completion_state.py
--rw-r--r--   0 runner    (1001) docker     (122)    10944 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_create.py
--rw-r--r--   0 runner    (1001) docker     (122)      279 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_environment_selection_strategy.py
--rw-r--r--   0 runner    (1001) docker     (122)     7596 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_group.py
--rw-r--r--   0 runner    (1001) docker     (122)      173 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_group_state.py
--rw-r--r--   0 runner    (1001) docker     (122)    17796 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_invoice.py
--rw-r--r--   0 runner    (1001) docker     (122)     9393 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_invoice_comment.py
--rw-r--r--   0 runner    (1001) docker     (122)     3664 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_invoice_comment_active.py
--rw-r--r--   0 runner    (1001) docker     (122)     2861 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_invoice_comment_create.py
--rw-r--r--   0 runner    (1001) docker     (122)     7715 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_invoice_replacement.py
--rw-r--r--   0 runner    (1001) docker     (122)      279 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_invoice_state.py
--rw-r--r--   0 runner    (1001) docker     (122)    16354 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_line_item_version.py
--rw-r--r--   0 runner    (1001) docker     (122)     4584 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_line_item_version_create.py
--rw-r--r--   0 runner    (1001) docker     (122)      233 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_line_item_version_state.py
--rw-r--r--   0 runner    (1001) docker     (122)     3495 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_pending.py
--rw-r--r--   0 runner    (1001) docker     (122)      346 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_state.py
--rw-r--r--   0 runner    (1001) docker     (122)      242 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_user_interface_type.py
--rw-r--r--   0 runner    (1001) docker     (122)    13168 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_void.py
--rw-r--r--   0 runner    (1001) docker     (122)      141 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_void_mode.py
--rw-r--r--   0 runner    (1001) docker     (122)      194 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_void_state.py
--rw-r--r--   0 runner    (1001) docker     (122)     5137 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/two_factor_authentication_type.py
--rw-r--r--   0 runner    (1001) docker     (122)     5706 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/user.py
--rw-r--r--   0 runner    (1001) docker     (122)     5440 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/user_account_role.py
--rw-r--r--   0 runner    (1001) docker     (122)     4499 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/user_space_role.py
--rw-r--r--   0 runner    (1001) docker     (122)      272 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/user_type.py
--rw-r--r--   0 runner    (1001) docker     (122)      166 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/wallet_type.py
--rw-r--r--   0 runner    (1001) docker     (122)     2641 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/web_app_confirmation_request.py
--rw-r--r--   0 runner    (1001) docker     (122)     5748 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/web_app_confirmation_response.py
--rw-r--r--   0 runner    (1001) docker     (122)     6223 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/webhook_identity.py
--rw-r--r--   0 runner    (1001) docker     (122)    10015 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/webhook_listener.py
--rw-r--r--   0 runner    (1001) docker     (122)     4041 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/webhook_listener_create.py
--rw-r--r--   0 runner    (1001) docker     (122)     3775 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/webhook_listener_entity.py
--rw-r--r--   0 runner    (1001) docker     (122)     3534 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/webhook_listener_update.py
--rw-r--r--   0 runner    (1001) docker     (122)     8011 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/webhook_url.py
--rw-r--r--   0 runner    (1001) docker     (122)     1791 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/webhook_url_create.py
--rw-r--r--   0 runner    (1001) docker     (122)     3469 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/models/webhook_url_update.py
--rw-r--r--   0 runner    (1001) docker     (122)    13069 2023-07-20 14:43:17.000000 whitelabelmachinename-4.0.0/whitelabelmachinename/rest.py
-drwxr-xr-x   0 runner    (1001) docker     (122)        0 2023-07-20 14:43:32.412496 whitelabelmachinename-4.0.0/whitelabelmachinename.egg-info/
--rw-r--r--   0 runner    (1001) docker     (122)     4682 2023-07-20 14:43:32.000000 whitelabelmachinename-4.0.0/whitelabelmachinename.egg-info/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (122)    32125 2023-07-20 14:43:32.000000 whitelabelmachinename-4.0.0/whitelabelmachinename.egg-info/SOURCES.txt
--rw-r--r--   0 runner    (1001) docker     (122)        1 2023-07-20 14:43:32.000000 whitelabelmachinename-4.0.0/whitelabelmachinename.egg-info/dependency_links.txt
--rw-r--r--   0 runner    (1001) docker     (122)       64 2023-07-20 14:43:32.000000 whitelabelmachinename-4.0.0/whitelabelmachinename.egg-info/requires.txt
--rw-r--r--   0 runner    (1001) docker     (122)       22 2023-07-20 14:43:32.000000 whitelabelmachinename-4.0.0/whitelabelmachinename.egg-info/top_level.txt
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-05-16 11:25:17.370883 whitelabelmachinename-4.0.1/
+-rw-r--r--   0 runner    (1001) docker     (121)    11338 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (121)     4154 2022-05-16 11:25:17.370883 whitelabelmachinename-4.0.1/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (121)     3225 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/README.md
+-rw-r--r--   0 runner    (1001) docker     (121)       38 2022-05-16 11:25:17.370883 whitelabelmachinename-4.0.1/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (121)     1367 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-05-16 11:25:17.306880 whitelabelmachinename-4.0.1/whitelabelmachinename/
+-rw-r--r--   0 runner    (1001) docker     (121)    47704 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-05-16 11:25:17.318880 whitelabelmachinename-4.0.1/whitelabelmachinename/api/
+-rw-r--r--   0 runner    (1001) docker     (121)     7725 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (121)    21719 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/account_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    22025 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/application_user_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    12295 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/bank_account_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    12351 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/bank_transaction_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    12521 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/card_processing_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    12323 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/charge_attempt_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    12442 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/charge_bank_transaction_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    12526 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/charge_flow_level_payment_link_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    16538 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/charge_flow_level_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    30250 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/charge_flow_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)     6809 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/condition_type_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3236 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/country_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)     6983 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/country_state_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    12414 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/currency_bank_account_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3243 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/currency_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    28792 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/customer_address_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    32614 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/customer_comment_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    24549 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/customer_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    51197 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/debt_collection_case_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    12510 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/debt_collector_configuration_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)     6799 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/debt_collector_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    21118 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/delivery_indication_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    12365 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/document_template_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)     6890 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/document_template_type_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    12589 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/external_transfer_bank_transaction_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    25503 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/human_user_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    18163 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/installment_payment_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    12806 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/installment_payment_slice_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4675 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/installment_plan_calculation_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    12886 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/installment_plan_configuration_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    12975 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/installment_plan_slice_configuration_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    12589 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/internal_transfer_bank_transaction_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)     6909 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/label_description_group_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)     6850 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/label_description_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3241 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/language_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    10681 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/legal_organization_form_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    12281 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/manual_task_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)     5102 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/mertic_usage_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    12552 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/payment_connector_configuration_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)     6826 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/payment_connector_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    24776 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/payment_link_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)     6868 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/payment_method_brand_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    12510 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/payment_method_configuration_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)     6809 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/payment_method_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    12552 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/payment_processor_configuration_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)     6826 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/payment_processor_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    20436 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/payment_terminal_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    12243 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/payment_terminal_till_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    40630 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/payment_web_app_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)     6772 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/permission_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    12442 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/refund_bank_transaction_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    28028 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/refund_comment_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    12561 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/refund_recovery_bank_transaction_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    33912 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/refund_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    16610 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/shopify_recurring_order_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    16908 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/shopify_subscriber_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    21390 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/shopify_subscription_product_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    30524 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/shopify_subscription_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    20975 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/shopify_subscription_suspension_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    12512 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/shopify_subscription_version_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    12393 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/shopify_transaction_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    21657 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/space_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)     6803 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/static_value_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    24723 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/subscriber_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    25048 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/subscription_affiliate_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    20377 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/subscription_charge_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    16536 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/subscription_ledger_entry_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    25005 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/subscription_metric_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    16737 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/subscription_metric_usage_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    12456 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/subscription_period_bill_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    25406 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/subscription_product_component_group_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    25235 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/subscription_product_component_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    25109 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/subscription_product_fee_tier_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    25026 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/subscription_product_metered_fee_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    24995 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/subscription_product_period_fee_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    16673 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/subscription_product_retirement_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    21065 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/subscription_product_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    24964 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/subscription_product_setup_fee_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    16821 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/subscription_product_version_retirement_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    25720 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/subscription_product_version_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    51176 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/subscription_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    20787 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/subscription_suspension_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    12375 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/subscription_version_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    41725 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/token_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    16656 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/token_version_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    28236 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/transaction_comment_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    30437 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/transaction_completion_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4359 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/transaction_iframe_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    28367 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/transaction_invoice_comment_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    39604 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/transaction_invoice_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4367 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/transaction_lightbox_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    16878 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/transaction_line_item_version_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4265 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/transaction_mobile_sdk_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4392 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/transaction_payment_page_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    78439 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/transaction_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)     9715 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/transaction_terminal_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    20759 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/transaction_void_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    12872 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/user_account_role_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    12413 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/user_space_role_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    11645 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/web_app_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    24924 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/webhook_listener_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    24769 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api/webhook_url_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (121)    25167 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/api_client.py
+-rw-r--r--   0 runner    (1001) docker     (121)     8153 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/configuration.py
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-05-16 11:25:17.370883 whitelabelmachinename-4.0.1/whitelabelmachinename/models/
+-rw-r--r--   0 runner    (1001) docker     (121)    25633 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4406 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_account_update.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4228 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_application_user_update.py
+-rw-r--r--   0 runner    (1001) docker     (121)     7312 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_customer_active.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3125 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_customer_address_active.py
+-rw-r--r--   0 runner    (1001) docker     (121)     2436 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_customer_comment_active.py
+-rw-r--r--   0 runner    (1001) docker     (121)     8982 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_debt_collection_case_update.py
+-rw-r--r--   0 runner    (1001) docker     (121)     8544 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_human_user_update.py
+-rw-r--r--   0 runner    (1001) docker     (121)    14228 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_payment_link_update.py
+-rw-r--r--   0 runner    (1001) docker     (121)     2422 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_refund_comment_active.py
+-rw-r--r--   0 runner    (1001) docker     (121)    16919 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_shopify_subscription_product_update.py
+-rw-r--r--   0 runner    (1001) docker     (121)     9549 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_space_update.py
+-rw-r--r--   0 runner    (1001) docker     (121)    11397 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_subscriber_update.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4779 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_subscription_affiliate_update.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3129 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_subscription_metric_update.py
+-rw-r--r--   0 runner    (1001) docker     (121)     8684 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_subscription_product_active.py
+-rw-r--r--   0 runner    (1001) docker     (121)     8663 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_token_update.py
+-rw-r--r--   0 runner    (1001) docker     (121)     2457 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_transaction_comment_active.py
+-rw-r--r--   0 runner    (1001) docker     (121)     2506 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_transaction_invoice_comment_active.py
+-rw-r--r--   0 runner    (1001) docker     (121)    20145 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_transaction_pending.py
+-rw-r--r--   0 runner    (1001) docker     (121)     5530 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_webhook_listener_update.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4441 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_webhook_url_update.py
+-rw-r--r--   0 runner    (1001) docker     (121)    14918 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/account.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3352 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/account_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)      252 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/account_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)      163 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/account_type.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3430 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/account_update.py
+-rw-r--r--   0 runner    (1001) docker     (121)    17834 2022-05-16 11:24:58.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/address.py
+-rw-r--r--   0 runner    (1001) docker     (121)    18278 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/address_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4521 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/application_user.py
+-rw-r--r--   0 runner    (1001) docker     (121)     2887 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/application_user_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)     2470 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/application_user_create_with_mac_key.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3534 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/application_user_update.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3133 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/authenticated_card_data.py
+-rw-r--r--   0 runner    (1001) docker     (121)    12532 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/authenticated_card_data_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)     8085 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/bank_account.py
+-rw-r--r--   0 runner    (1001) docker     (121)      146 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/bank_account_environment.py
+-rw-r--r--   0 runner    (1001) docker     (121)      186 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/bank_account_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4268 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/bank_account_type.py
+-rw-r--r--   0 runner    (1001) docker     (121)    16049 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/bank_transaction.py
+-rw-r--r--   0 runner    (1001) docker     (121)      150 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/bank_transaction_flow_direction.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3593 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/bank_transaction_source.py
+-rw-r--r--   0 runner    (1001) docker     (121)      146 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/bank_transaction_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3563 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/bank_transaction_type.py
+-rw-r--r--   0 runner    (1001) docker     (121)      366 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/card_authentication_response.py
+-rw-r--r--   0 runner    (1001) docker     (121)      129 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/card_authentication_version.py
+-rw-r--r--   0 runner    (1001) docker     (121)     2706 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/card_cryptogram.py
+-rw-r--r--   0 runner    (1001) docker     (121)     2968 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/card_cryptogram_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)      128 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/card_cryptogram_type.py
+-rw-r--r--   0 runner    (1001) docker     (121)     6794 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/cardholder_authentication.py
+-rw-r--r--   0 runner    (1001) docker     (121)     7170 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/cardholder_authentication_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)    10239 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/charge.py
+-rw-r--r--   0 runner    (1001) docker     (121)    19782 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/charge_attempt.py
+-rw-r--r--   0 runner    (1001) docker     (121)      148 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/charge_attempt_environment.py
+-rw-r--r--   0 runner    (1001) docker     (121)      176 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/charge_attempt_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)     8354 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/charge_bank_transaction.py
+-rw-r--r--   0 runner    (1001) docker     (121)     8488 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/charge_flow.py
+-rw-r--r--   0 runner    (1001) docker     (121)     9490 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/charge_flow_level.py
+-rw-r--r--   0 runner    (1001) docker     (121)    10523 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/charge_flow_level_configuration.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4412 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/charge_flow_level_configuration_type.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3386 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/charge_flow_level_payment_link.py
+-rw-r--r--   0 runner    (1001) docker     (121)      172 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/charge_flow_level_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)      163 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/charge_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)      198 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/charge_type.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4921 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/client_error.py
+-rw-r--r--   0 runner    (1001) docker     (121)      217 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/client_error_type.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3972 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/completion_line_item.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4375 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/completion_line_item_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)     7331 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/condition.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3473 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/condition_type.py
+-rw-r--r--   0 runner    (1001) docker     (121)     6799 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/connector_invocation.py
+-rw-r--r--   0 runner    (1001) docker     (121)      254 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/connector_invocation_stage.py
+-rw-r--r--   0 runner    (1001) docker     (121)      215 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/creation_entity_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)      520 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/criteria_operator.py
+-rw-r--r--   0 runner    (1001) docker     (121)     6078 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/currency_bank_account.py
+-rw-r--r--   0 runner    (1001) docker     (121)     9958 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/customer.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3443 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/customer_active.py
+-rw-r--r--   0 runner    (1001) docker     (121)     7502 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/customer_address.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3534 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/customer_address_active.py
+-rw-r--r--   0 runner    (1001) docker     (121)     2552 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/customer_address_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)      163 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/customer_address_type.py
+-rw-r--r--   0 runner    (1001) docker     (121)     8708 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/customer_comment.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3534 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/customer_comment_active.py
+-rw-r--r--   0 runner    (1001) docker     (121)     2552 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/customer_comment_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)     1781 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/customer_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)    18996 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/customer_postal_address.py
+-rw-r--r--   0 runner    (1001) docker     (121)    19440 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/customer_postal_address_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)      207 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/customers_presence.py
+-rw-r--r--   0 runner    (1001) docker     (121)      140 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/data_collection_type.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3865 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/database_translated_string.py
+-rw-r--r--   0 runner    (1001) docker     (121)     2353 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/database_translated_string_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3924 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/database_translated_string_item.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3347 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/database_translated_string_item_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)    27945 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/debt_collection_case.py
+-rw-r--r--   0 runner    (1001) docker     (121)     5190 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/debt_collection_case_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)    10791 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/debt_collection_case_document.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4534 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/debt_collection_case_source.py
+-rw-r--r--   0 runner    (1001) docker     (121)      275 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/debt_collection_case_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3573 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/debt_collection_case_update.py
+-rw-r--r--   0 runner    (1001) docker     (121)      149 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/debt_collection_environment.py
+-rw-r--r--   0 runner    (1001) docker     (121)    10354 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/debt_collection_receipt.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3683 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/debt_collection_receipt_source.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3473 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/debt_collector.py
+-rw-r--r--   0 runner    (1001) docker     (121)     7489 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/debt_collector_condition.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3668 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/debt_collector_condition_type.py
+-rw-r--r--   0 runner    (1001) docker     (121)    12084 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/debt_collector_configuration.py
+-rw-r--r--   0 runner    (1001) docker     (121)    10896 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/delivery_indication.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3758 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/delivery_indication_decision_reason.py
+-rw-r--r--   0 runner    (1001) docker     (121)      235 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/delivery_indication_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)    10012 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/document_template.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4844 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/document_template_type.py
+-rw-r--r--   0 runner    (1001) docker     (121)     2937 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/document_template_type_group.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3377 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/entity_export_request.py
+-rw-r--r--   0 runner    (1001) docker     (121)     6248 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/entity_query.py
+-rw-r--r--   0 runner    (1001) docker     (121)     6167 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/entity_query_filter.py
+-rw-r--r--   0 runner    (1001) docker     (121)      145 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/entity_query_filter_type.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3117 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/entity_query_order_by.py
+-rw-r--r--   0 runner    (1001) docker     (121)      132 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/entity_query_order_by_type.py
+-rw-r--r--   0 runner    (1001) docker     (121)      129 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/environment.py
+-rw-r--r--   0 runner    (1001) docker     (121)     7796 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/external_transfer_bank_transaction.py
+-rw-r--r--   0 runner    (1001) docker     (121)      247 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/failure_category.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4725 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/failure_reason.py
+-rw-r--r--   0 runner    (1001) docker     (121)     7016 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/feature.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4181 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/feature_category.py
+-rw-r--r--   0 runner    (1001) docker     (121)      122 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/gender.py
+-rw-r--r--   0 runner    (1001) docker     (121)    11567 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/human_user.py
+-rw-r--r--   0 runner    (1001) docker     (121)     2632 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/human_user_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3456 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/human_user_update.py
+-rw-r--r--   0 runner    (1001) docker     (121)     5683 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/installment_calculated_plan.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3836 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/installment_calculated_slice.py
+-rw-r--r--   0 runner    (1001) docker     (121)     8865 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/installment_payment.py
+-rw-r--r--   0 runner    (1001) docker     (121)     8260 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/installment_payment_slice.py
+-rw-r--r--   0 runner    (1001) docker     (121)      308 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/installment_payment_slice_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)      303 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/installment_payment_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)    17824 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/installment_plan_configuration.py
+-rw-r--r--   0 runner    (1001) docker     (121)    10995 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/installment_plan_slice_configuration.py
+-rw-r--r--   0 runner    (1001) docker     (121)     6133 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/internal_transfer_bank_transaction.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4872 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/label.py
+-rw-r--r--   0 runner    (1001) docker     (121)     6454 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/label_descriptor.py
+-rw-r--r--   0 runner    (1001) docker     (121)      151 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/label_descriptor_category.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4169 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/label_descriptor_group.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3563 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/label_descriptor_type.py
+-rw-r--r--   0 runner    (1001) docker     (121)     5148 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/legal_organization_form.py
+-rw-r--r--   0 runner    (1001) docker     (121)    18658 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/line_item.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3018 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/line_item_attribute.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3282 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/line_item_attribute_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)     9524 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/line_item_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4382 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/line_item_reduction.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4853 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/line_item_reduction_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)      180 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/line_item_type.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3440 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/localized_string.py
+-rw-r--r--   0 runner    (1001) docker     (121)     8961 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/manual_task.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4077 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/manual_task_action.py
+-rw-r--r--   0 runner    (1001) docker     (121)      167 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/manual_task_action_style.py
+-rw-r--r--   0 runner    (1001) docker     (121)      151 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/manual_task_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4109 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/manual_task_type.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4856 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/metric_usage.py
+-rw-r--r--   0 runner    (1001) docker     (121)      161 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/one_click_payment_mode.py
+-rw-r--r--   0 runner    (1001) docker     (121)     5403 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_adjustment.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3593 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_adjustment_type.py
+-rw-r--r--   0 runner    (1001) docker     (121)      162 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_app_charge_attempt_target_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)     7658 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_app_charge_attempt_update_request.py
+-rw-r--r--   0 runner    (1001) docker     (121)     7987 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_app_completion_configuration.py
+-rw-r--r--   0 runner    (1001) docker     (121)     8125 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_app_completion_configuration_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)      159 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_app_completion_target_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)     5881 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_app_completion_update_request.py
+-rw-r--r--   0 runner    (1001) docker     (121)    15039 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_app_connector.py
+-rw-r--r--   0 runner    (1001) docker     (121)    12593 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_app_connector_creation_request.py
+-rw-r--r--   0 runner    (1001) docker     (121)      146 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_app_connector_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)    16276 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_app_processor.py
+-rw-r--r--   0 runner    (1001) docker     (121)     7576 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_app_processor_creation_request.py
+-rw-r--r--   0 runner    (1001) docker     (121)      146 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_app_processor_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)     5112 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_app_refund_configuration.py
+-rw-r--r--   0 runner    (1001) docker     (121)     5202 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_app_refund_configuration_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)      155 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_app_refund_target_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)     5681 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_app_refund_update_request.py
+-rw-r--r--   0 runner    (1001) docker     (121)      153 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_app_void_target_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)     5581 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_app_void_update_request.py
+-rw-r--r--   0 runner    (1001) docker     (121)    11387 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_connector.py
+-rw-r--r--   0 runner    (1001) docker     (121)    16492 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_connector_configuration.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3640 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_connector_feature.py
+-rw-r--r--   0 runner    (1001) docker     (121)    12743 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_contract.py
+-rw-r--r--   0 runner    (1001) docker     (121)      230 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_contract_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4180 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_contract_type.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3503 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_information_hash.py
+-rw-r--r--   0 runner    (1001) docker     (121)     2930 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_information_hash_type.py
+-rw-r--r--   0 runner    (1001) docker     (121)    20201 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_link.py
+-rw-r--r--   0 runner    (1001) docker     (121)     2389 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_link_active.py
+-rw-r--r--   0 runner    (1001) docker     (121)      238 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_link_address_handling_mode.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4586 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_link_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)      167 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_link_protection_mode.py
+-rw-r--r--   0 runner    (1001) docker     (121)    15538 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_link_update.py
+-rw-r--r--   0 runner    (1001) docker     (121)     6680 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_method.py
+-rw-r--r--   0 runner    (1001) docker     (121)     5671 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_method_brand.py
+-rw-r--r--   0 runner    (1001) docker     (121)    18191 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_method_configuration.py
+-rw-r--r--   0 runner    (1001) docker     (121)      183 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_primary_risk_taker.py
+-rw-r--r--   0 runner    (1001) docker     (121)     7046 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_processor.py
+-rw-r--r--   0 runner    (1001) docker     (121)    10185 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_processor_configuration.py
+-rw-r--r--   0 runner    (1001) docker     (121)    11709 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_terminal.py
+-rw-r--r--   0 runner    (1001) docker     (121)    12395 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_terminal_address.py
+-rw-r--r--   0 runner    (1001) docker     (121)     7723 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_terminal_configuration.py
+-rw-r--r--   0 runner    (1001) docker     (121)      203 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_terminal_configuration_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)    14438 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_terminal_configuration_version.py
+-rw-r--r--   0 runner    (1001) docker     (121)      242 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_terminal_configuration_version_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)     8020 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_terminal_location.py
+-rw-r--r--   0 runner    (1001) docker     (121)      198 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_terminal_location_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)    10894 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_terminal_location_version.py
+-rw-r--r--   0 runner    (1001) docker     (121)      237 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_terminal_location_version_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3668 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_terminal_receipt_type.py
+-rw-r--r--   0 runner    (1001) docker     (121)      272 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_terminal_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3563 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_terminal_type.py
+-rw-r--r--   0 runner    (1001) docker     (121)     8343 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/permission.py
+-rw-r--r--   0 runner    (1001) docker     (121)     2878 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/persistable_currency_amount.py
+-rw-r--r--   0 runner    (1001) docker     (121)     2944 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/persistable_currency_amount_update.py
+-rw-r--r--   0 runner    (1001) docker     (121)      180 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/product_fee_type.py
+-rw-r--r--   0 runner    (1001) docker     (121)     8795 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/product_metered_fee.py
+-rw-r--r--   0 runner    (1001) docker     (121)     7624 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/product_metered_fee_update.py
+-rw-r--r--   0 runner    (1001) docker     (121)     5973 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/product_metered_tier_fee.py
+-rw-r--r--   0 runner    (1001) docker     (121)     6283 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/product_metered_tier_fee_update.py
+-rw-r--r--   0 runner    (1001) docker     (121)      219 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/product_metered_tier_pricing.py
+-rw-r--r--   0 runner    (1001) docker     (121)    10213 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/product_period_fee.py
+-rw-r--r--   0 runner    (1001) docker     (121)     9155 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/product_period_fee_update.py
+-rw-r--r--   0 runner    (1001) docker     (121)    10649 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/product_setup_fee.py
+-rw-r--r--   0 runner    (1001) docker     (121)     9617 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/product_setup_fee_update.py
+-rw-r--r--   0 runner    (1001) docker     (121)      390 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/recurring_indicator.py
+-rw-r--r--   0 runner    (1001) docker     (121)    24451 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/refund.py
+-rw-r--r--   0 runner    (1001) docker     (121)     7392 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/refund_bank_transaction.py
+-rw-r--r--   0 runner    (1001) docker     (121)     8586 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/refund_comment.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3508 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/refund_comment_active.py
+-rw-r--r--   0 runner    (1001) docker     (121)     2494 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/refund_comment_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)     7096 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/refund_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)     8487 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/refund_recovery_bank_transaction.py
+-rw-r--r--   0 runner    (1001) docker     (121)      247 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/refund_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)      334 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/refund_type.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4190 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/rendered_document.py
+-rw-r--r--   0 runner    (1001) docker     (121)     5264 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/rendered_terminal_receipt.py
+-rw-r--r--   0 runner    (1001) docker     (121)     6943 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/resource_path.py
+-rw-r--r--   0 runner    (1001) docker     (121)      161 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/resource_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)     5382 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/rest_address_format.py
+-rw-r--r--   0 runner    (1001) docker     (121)      410 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/rest_address_format_field.py
+-rw-r--r--   0 runner    (1001) docker     (121)     6925 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/rest_country.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4792 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/rest_country_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4397 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/rest_currency.py
+-rw-r--r--   0 runner    (1001) docker     (121)     6797 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/rest_language.py
+-rw-r--r--   0 runner    (1001) docker     (121)     7773 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/role.py
+-rw-r--r--   0 runner    (1001) docker     (121)      179 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/role_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)     5197 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/sales_channel.py
+-rw-r--r--   0 runner    (1001) docker     (121)    10196 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/scope.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3352 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/server_error.py
+-rw-r--r--   0 runner    (1001) docker     (121)      149 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_additional_line_item_data.py
+-rw-r--r--   0 runner    (1001) docker     (121)    24091 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_integration.py
+-rw-r--r--   0 runner    (1001) docker     (121)      143 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_integration_payment_app_version.py
+-rw-r--r--   0 runner    (1001) docker     (121)      202 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_integration_subscription_app_version.py
+-rw-r--r--   0 runner    (1001) docker     (121)    12458 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_recurring_order.py
+-rw-r--r--   0 runner    (1001) docker     (121)      248 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_recurring_order_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3307 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_recurring_order_update_request.py
+-rw-r--r--   0 runner    (1001) docker     (121)     9686 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscriber.py
+-rw-r--r--   0 runner    (1001) docker     (121)     6223 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscriber_active.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4338 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscriber_creation.py
+-rw-r--r--   0 runner    (1001) docker     (121)      170 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscriber_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)    15186 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription.py
+-rw-r--r--   0 runner    (1001) docker     (121)     1787 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription_address.py
+-rw-r--r--   0 runner    (1001) docker     (121)    19218 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription_address_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)      238 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription_billing_interval_unit.py
+-rw-r--r--   0 runner    (1001) docker     (121)    15014 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription_creation_request.py
+-rw-r--r--   0 runner    (1001) docker     (121)    11797 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription_model_billing_configuration.py
+-rw-r--r--   0 runner    (1001) docker     (121)     5444 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription_model_item.py
+-rw-r--r--   0 runner    (1001) docker     (121)     2854 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription_model_tax_line.py
+-rw-r--r--   0 runner    (1001) docker     (121)    28046 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription_product.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4520 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription_product_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)      317 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription_product_pricing_option.py
+-rw-r--r--   0 runner    (1001) docker     (121)      253 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription_product_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3677 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription_product_update.py
+-rw-r--r--   0 runner    (1001) docker     (121)      264 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)    11266 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription_suspension.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4283 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription_suspension_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)      166 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription_suspension_initiator.py
+-rw-r--r--   0 runner    (1001) docker     (121)      152 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription_suspension_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)      167 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription_suspension_type.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4129 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription_update_addresses_request.py
+-rw-r--r--   0 runner    (1001) docker     (121)     6215 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription_update_request.py
+-rw-r--r--   0 runner    (1001) docker     (121)    24689 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription_version.py
+-rw-r--r--   0 runner    (1001) docker     (121)     5449 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription_version_item.py
+-rw-r--r--   0 runner    (1001) docker     (121)      201 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription_version_item_price_strategy.py
+-rw-r--r--   0 runner    (1001) docker     (121)      181 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription_version_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)      272 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription_weekday.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4831 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_tax_line.py
+-rw-r--r--   0 runner    (1001) docker     (121)     8533 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_transaction.py
+-rw-r--r--   0 runner    (1001) docker     (121)      235 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_transaction_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)    18398 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/space.py
+-rw-r--r--   0 runner    (1001) docker     (121)    11555 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/space_address.py
+-rw-r--r--   0 runner    (1001) docker     (121)    11885 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/space_address_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)     2526 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/space_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)     6846 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/space_reference.py
+-rw-r--r--   0 runner    (1001) docker     (121)      237 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/space_reference_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3404 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/space_update.py
+-rw-r--r--   0 runner    (1001) docker     (121)     7275 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/space_view.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4052 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/static_value.py
+-rw-r--r--   0 runner    (1001) docker     (121)    15785 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscriber.py
+-rw-r--r--   0 runner    (1001) docker     (121)     2380 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscriber_active.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3571 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscriber_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)    12763 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscriber_update.py
+-rw-r--r--   0 runner    (1001) docker     (121)    16465 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription.py
+-rw-r--r--   0 runner    (1001) docker     (121)    10100 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_affiliate.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4174 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_affiliate_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)     1821 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_affiliate_deleted.py
+-rw-r--r--   0 runner    (1001) docker     (121)     1838 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_affiliate_deleting.py
+-rw-r--r--   0 runner    (1001) docker     (121)     1836 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_affiliate_inactive.py
+-rw-r--r--   0 runner    (1001) docker     (121)     6393 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_affiliate_update.py
+-rw-r--r--   0 runner    (1001) docker     (121)     7470 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_change_request.py
+-rw-r--r--   0 runner    (1001) docker     (121)    18976 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_charge.py
+-rw-r--r--   0 runner    (1001) docker     (121)     9268 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_charge_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)      172 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_charge_processing_type.py
+-rw-r--r--   0 runner    (1001) docker     (121)      237 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_charge_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)      148 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_charge_type.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3031 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_component_configuration.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3505 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_component_reference_configuration.py
+-rw-r--r--   0 runner    (1001) docker     (121)     6112 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_create_request.py
+-rw-r--r--   0 runner    (1001) docker     (121)    15582 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_ledger_entry.py
+-rw-r--r--   0 runner    (1001) docker     (121)     7304 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_ledger_entry_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)      168 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_ledger_entry_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)     7633 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_metric.py
+-rw-r--r--   0 runner    (1001) docker     (121)     1815 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_metric_active.py
+-rw-r--r--   0 runner    (1001) docker     (121)     2499 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_metric_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4237 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_metric_type.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4783 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_metric_update.py
+-rw-r--r--   0 runner    (1001) docker     (121)    11420 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_metric_usage_report.py
+-rw-r--r--   0 runner    (1001) docker     (121)     6794 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_metric_usage_report_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3822 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_pending.py
+-rw-r--r--   0 runner    (1001) docker     (121)    10697 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_period_bill.py
+-rw-r--r--   0 runner    (1001) docker     (121)      149 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_period_bill_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)    13443 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_product.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3586 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_product_active.py
+-rw-r--r--   0 runner    (1001) docker     (121)    15248 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_product_component.py
+-rw-r--r--   0 runner    (1001) docker     (121)     7854 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_product_component_group.py
+-rw-r--r--   0 runner    (1001) docker     (121)     7204 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_product_component_group_update.py
+-rw-r--r--   0 runner    (1001) docker     (121)     8002 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_product_component_reference.py
+-rw-r--r--   0 runner    (1001) docker     (121)      212 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_product_component_reference_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)    14666 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_product_component_update.py
+-rw-r--r--   0 runner    (1001) docker     (121)     2989 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_product_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)     7720 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_product_retirement.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4401 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_product_retirement_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)      220 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_product_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)    21069 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_product_version.py
+-rw-r--r--   0 runner    (1001) docker     (121)    13572 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_product_version_pending.py
+-rw-r--r--   0 runner    (1001) docker     (121)     8291 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_product_version_retirement.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4855 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_product_version_retirement_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)      229 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_product_version_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)      337 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)    13386 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_suspension.py
+-rw-r--r--   0 runner    (1001) docker     (121)      162 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_suspension_action.py
+-rw-r--r--   0 runner    (1001) docker     (121)     5831 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_suspension_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)      226 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_suspension_reason.py
+-rw-r--r--   0 runner    (1001) docker     (121)     1826 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_suspension_running.py
+-rw-r--r--   0 runner    (1001) docker     (121)      147 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_suspension_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)     5688 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_update.py
+-rw-r--r--   0 runner    (1001) docker     (121)     2486 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_update_request.py
+-rw-r--r--   0 runner    (1001) docker     (121)    17423 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_version.py
+-rw-r--r--   0 runner    (1001) docker     (121)      264 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_version_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)     2849 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/tax.py
+-rw-r--r--   0 runner    (1001) docker     (121)      166 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/tax_calculation.py
+-rw-r--r--   0 runner    (1001) docker     (121)     7060 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/tax_class.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3111 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/tax_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3778 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/tenant_database.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4471 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/terminal_receipt_fetch_request.py
+-rw-r--r--   0 runner    (1001) docker     (121)      129 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/terminal_receipt_format.py
+-rw-r--r--   0 runner    (1001) docker     (121)    13928 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/token.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3506 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/token_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3404 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/token_update.py
+-rw-r--r--   0 runner    (1001) docker     (121)    19314 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/token_version.py
+-rw-r--r--   0 runner    (1001) docker     (121)      177 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/token_version_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4123 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/token_version_type.py
+-rw-r--r--   0 runner    (1001) docker     (121)      304 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/tokenization_mode.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4090 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/tokenized_card_data.py
+-rw-r--r--   0 runner    (1001) docker     (121)    11009 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/tokenized_card_data_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)    62797 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4017 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_aware_entity.py
+-rw-r--r--   0 runner    (1001) docker     (121)     8891 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_comment.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3573 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_comment_active.py
+-rw-r--r--   0 runner    (1001) docker     (121)     2639 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_comment_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)    23515 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_completion.py
+-rw-r--r--   0 runner    (1001) docker     (121)      243 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_completion_behavior.py
+-rw-r--r--   0 runner    (1001) docker     (121)      169 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_completion_mode.py
+-rw-r--r--   0 runner    (1001) docker     (121)     7318 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_completion_request.py
+-rw-r--r--   0 runner    (1001) docker     (121)      228 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_completion_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)    10944 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)      279 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_environment_selection_strategy.py
+-rw-r--r--   0 runner    (1001) docker     (121)     7764 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_group.py
+-rw-r--r--   0 runner    (1001) docker     (121)      173 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_group_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)    17724 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_invoice.py
+-rw-r--r--   0 runner    (1001) docker     (121)     9335 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_invoice_comment.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3664 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_invoice_comment_active.py
+-rw-r--r--   0 runner    (1001) docker     (121)     2861 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_invoice_comment_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)     7715 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_invoice_replacement.py
+-rw-r--r--   0 runner    (1001) docker     (121)      279 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_invoice_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3366 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_line_item_update_request.py
+-rw-r--r--   0 runner    (1001) docker     (121)    16366 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_line_item_version.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4584 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_line_item_version_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)      233 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_line_item_version_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3495 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_pending.py
+-rw-r--r--   0 runner    (1001) docker     (121)      346 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)      242 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_user_interface_type.py
+-rw-r--r--   0 runner    (1001) docker     (121)    13180 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_void.py
+-rw-r--r--   0 runner    (1001) docker     (121)      141 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_void_mode.py
+-rw-r--r--   0 runner    (1001) docker     (121)      194 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_void_state.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4903 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/two_factor_authentication_type.py
+-rw-r--r--   0 runner    (1001) docker     (121)     5630 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/user.py
+-rw-r--r--   0 runner    (1001) docker     (121)     5576 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/user_account_role.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4635 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/user_space_role.py
+-rw-r--r--   0 runner    (1001) docker     (121)      272 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/user_type.py
+-rw-r--r--   0 runner    (1001) docker     (121)     2641 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/web_app_confirmation_request.py
+-rw-r--r--   0 runner    (1001) docker     (121)     5748 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/web_app_confirmation_response.py
+-rw-r--r--   0 runner    (1001) docker     (121)     6681 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/webhook_identity.py
+-rw-r--r--   0 runner    (1001) docker     (121)    10907 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/webhook_listener.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4241 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/webhook_listener_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3613 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/webhook_listener_entity.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3534 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/webhook_listener_update.py
+-rw-r--r--   0 runner    (1001) docker     (121)     8549 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/webhook_url.py
+-rw-r--r--   0 runner    (1001) docker     (121)     1791 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/webhook_url_create.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3469 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/models/webhook_url_update.py
+-rw-r--r--   0 runner    (1001) docker     (121)    12802 2022-05-16 11:24:59.000000 whitelabelmachinename-4.0.1/whitelabelmachinename/rest.py
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-05-16 11:25:17.310880 whitelabelmachinename-4.0.1/whitelabelmachinename.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (121)     4154 2022-05-16 11:25:16.000000 whitelabelmachinename-4.0.1/whitelabelmachinename.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (121)    30686 2022-05-16 11:25:17.000000 whitelabelmachinename-4.0.1/whitelabelmachinename.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (121)        1 2022-05-16 11:25:16.000000 whitelabelmachinename-4.0.1/whitelabelmachinename.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (121)       64 2022-05-16 11:25:17.000000 whitelabelmachinename-4.0.1/whitelabelmachinename.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (121)       22 2022-05-16 11:25:17.000000 whitelabelmachinename-4.0.1/whitelabelmachinename.egg-info/top_level.txt
```

### Comparing `whitelabelmachinename-4.0.0/LICENSE` & `whitelabelmachinename-4.0.1/LICENSE`

 * *Files 0% similar despite different names*

```diff
@@ -182,15 +182,15 @@
       replaced with your own identifying information. (Don't include
       the brackets!)  The text should be enclosed in the appropriate
       comment syntax for the file format. We also recommend that a
       file or class name and description of purpose be included on the
       same "printed page" as the copyright notice for easier
       identification within third-party archives.
 
-   Copyright 2023 wallee AG
+   Copyright 2021 wallee AG
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
```

### Comparing `whitelabelmachinename-4.0.0/PKG-INFO` & `whitelabelmachinename-4.0.1/PKG-INFO`

 * *Files 16% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: whitelabelmachinename
-Version: 4.0.0
+Version: 4.0.1
 Summary: SDK that allows you to access WhiteLabelName
 Author: Wallee AG
 License: Apache-2.0
 Keywords: whitelabelmachinename,Payment,Payment Integration
 Classifier: Intended Audience :: Developers
 Classifier: Intended Audience :: Financial and Insurance Industry
 Classifier: License :: OSI Approved :: Apache Software License
@@ -57,34 +57,28 @@
 python setup.py install
 ```
 (or `sudo python setup.py install` to install the package for all users)
 
 ## Usage
 The library needs to be configured with your account's space id, user id, and secret key which are available in your [WhiteLabelName
 account dashboard](https://app-wallee.com/account/select). Set `space_id`, `user_id`, and `api_secret` to their values.
-You can also optionally set `default_headers` to set some headers that will be sent to all requests
 
 ### Configuring a Service
 
 ```python
 from whitelabelmachinename import Configuration
 from whitelabelmachinename.api import TransactionServiceApi, TransactionPaymentPageServiceApi
 from whitelabelmachinename.models import LineItem, LineItemType, TransactionCreate
 
 space_id = 405
 
-# default_headers is an optional param, that represents headers sent to all requests
 config = Configuration(
     user_id=512,
-    api_secret='FKrO76r5VwJtBrqZawBspljbBNOxp5veKQQkOnZxucQ=',
-    default_headers={'x-meta-custom-header': 'value-1', 'x-meta-custom-header-2': 'value-2'},
-    # set a custom request timeout if needed. (If not set, then the default value is: 25 seconds)
-    request_timeout = 30
+    api_secret='FKrO76r5VwJtBrqZawBspljbBNOxp5veKQQkOnZxucQ='
 )
-
 transaction_service = TransactionServiceApi(configuration=config)
 transaction_payment_page_service = TransactionPaymentPageServiceApi(configuration=config)
 
 ```
 
 To get started with sending transactions, please review the example below:
 
@@ -93,17 +87,15 @@
 from whitelabelmachinename.api import TransactionServiceApi, TransactionPaymentPageServiceApi
 from whitelabelmachinename.models import LineItem, LineItemType, TransactionCreate
 
 space_id = 405
 
 config = Configuration(
     user_id=512,
-    api_secret='FKrO76r5VwJtBrqZawBspljbBNOxp5veKQQkOnZxucQ=',
-    # set a custom request timeout if needed. (If not set, then the default value is: 25 seconds)
-    request_timeout = 30
+    api_secret='FKrO76r5VwJtBrqZawBspljbBNOxp5veKQQkOnZxucQ='
 )
 
 transaction_service = TransactionServiceApi(configuration=config)
 transaction_payment_page_service = TransactionPaymentPageServiceApi(configuration=config)
 
 # create line item
 line_item = LineItem(
```

### Comparing `whitelabelmachinename-4.0.0/README.md` & `whitelabelmachinename-4.0.1/README.md`

 * *Files 10% similar despite different names*

```diff
@@ -34,34 +34,28 @@
 python setup.py install
 ```
 (or `sudo python setup.py install` to install the package for all users)
 
 ## Usage
 The library needs to be configured with your account's space id, user id, and secret key which are available in your [WhiteLabelName
 account dashboard](https://app-wallee.com/account/select). Set `space_id`, `user_id`, and `api_secret` to their values.
-You can also optionally set `default_headers` to set some headers that will be sent to all requests
 
 ### Configuring a Service
 
 ```python
 from whitelabelmachinename import Configuration
 from whitelabelmachinename.api import TransactionServiceApi, TransactionPaymentPageServiceApi
 from whitelabelmachinename.models import LineItem, LineItemType, TransactionCreate
 
 space_id = 405
 
-# default_headers is an optional param, that represents headers sent to all requests
 config = Configuration(
     user_id=512,
-    api_secret='FKrO76r5VwJtBrqZawBspljbBNOxp5veKQQkOnZxucQ=',
-    default_headers={'x-meta-custom-header': 'value-1', 'x-meta-custom-header-2': 'value-2'},
-    # set a custom request timeout if needed. (If not set, then the default value is: 25 seconds)
-    request_timeout = 30
+    api_secret='FKrO76r5VwJtBrqZawBspljbBNOxp5veKQQkOnZxucQ='
 )
-
 transaction_service = TransactionServiceApi(configuration=config)
 transaction_payment_page_service = TransactionPaymentPageServiceApi(configuration=config)
 
 ```
 
 To get started with sending transactions, please review the example below:
 
@@ -70,17 +64,15 @@
 from whitelabelmachinename.api import TransactionServiceApi, TransactionPaymentPageServiceApi
 from whitelabelmachinename.models import LineItem, LineItemType, TransactionCreate
 
 space_id = 405
 
 config = Configuration(
     user_id=512,
-    api_secret='FKrO76r5VwJtBrqZawBspljbBNOxp5veKQQkOnZxucQ=',
-    # set a custom request timeout if needed. (If not set, then the default value is: 25 seconds)
-    request_timeout = 30
+    api_secret='FKrO76r5VwJtBrqZawBspljbBNOxp5veKQQkOnZxucQ='
 )
 
 transaction_service = TransactionServiceApi(configuration=config)
 transaction_payment_page_service = TransactionPaymentPageServiceApi(configuration=config)
 
 # create line item
 line_item = LineItem(
```

### Comparing `whitelabelmachinename-4.0.0/setup.py` & `whitelabelmachinename-4.0.1/setup.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 
 import setuptools
 
 with open("README.md", "r") as fh:
     long_description = fh.read()
 
 NAME = "whitelabelmachinename"
-VERSION = "4.0.0"
+VERSION = "4.0.1"
 
 REQUIRES = [
     "certifi>=2017.4.17",
     "python-dateutil>=2.1",
     "six>=1.10",
     "urllib3>=1.23"
 ]
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/__init__.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,13 +1,12 @@
 # coding: utf-8
 
 from __future__ import absolute_import
 
 from whitelabelmachinename.api.account_service_api import AccountServiceApi
-from whitelabelmachinename.api.analytics_query_service_api import AnalyticsQueryServiceApi
 from whitelabelmachinename.api.application_user_service_api import ApplicationUserServiceApi
 from whitelabelmachinename.api.bank_account_service_api import BankAccountServiceApi
 from whitelabelmachinename.api.bank_transaction_service_api import BankTransactionServiceApi
 from whitelabelmachinename.api.card_processing_service_api import CardProcessingServiceApi
 from whitelabelmachinename.api.charge_attempt_service_api import ChargeAttemptServiceApi
 from whitelabelmachinename.api.charge_bank_transaction_service_api import ChargeBankTransactionServiceApi
 from whitelabelmachinename.api.charge_flow_level_payment_link_service_api import ChargeFlowLevelPaymentLinkServiceApi
@@ -31,17 +30,14 @@
 from whitelabelmachinename.api.human_user_service_api import HumanUserServiceApi
 from whitelabelmachinename.api.installment_payment_service_api import InstallmentPaymentServiceApi
 from whitelabelmachinename.api.installment_payment_slice_service_api import InstallmentPaymentSliceServiceApi
 from whitelabelmachinename.api.installment_plan_calculation_service_api import InstallmentPlanCalculationServiceApi
 from whitelabelmachinename.api.installment_plan_configuration_service_api import InstallmentPlanConfigurationServiceApi
 from whitelabelmachinename.api.installment_plan_slice_configuration_service_api import InstallmentPlanSliceConfigurationServiceApi
 from whitelabelmachinename.api.internal_transfer_bank_transaction_service_api import InternalTransferBankTransactionServiceApi
-from whitelabelmachinename.api.invoice_reconciliation_record_invoice_link_service_api import InvoiceReconciliationRecordInvoiceLinkServiceApi
-from whitelabelmachinename.api.invoice_reconciliation_record_service_api import InvoiceReconciliationRecordServiceApi
-from whitelabelmachinename.api.invoice_reimbursement_service_api import InvoiceReimbursementServiceApi
 from whitelabelmachinename.api.label_description_group_service_api import LabelDescriptionGroupServiceApi
 from whitelabelmachinename.api.label_description_service_api import LabelDescriptionServiceApi
 from whitelabelmachinename.api.language_service_api import LanguageServiceApi
 from whitelabelmachinename.api.legal_organization_form_service_api import LegalOrganizationFormServiceApi
 from whitelabelmachinename.api.manual_task_service_api import ManualTaskServiceApi
 from whitelabelmachinename.api.mertic_usage_service_api import MerticUsageServiceApi
 from whitelabelmachinename.api.payment_connector_configuration_service_api import PaymentConnectorConfigurationServiceApi
@@ -50,15 +46,14 @@
 from whitelabelmachinename.api.payment_method_brand_service_api import PaymentMethodBrandServiceApi
 from whitelabelmachinename.api.payment_method_configuration_service_api import PaymentMethodConfigurationServiceApi
 from whitelabelmachinename.api.payment_method_service_api import PaymentMethodServiceApi
 from whitelabelmachinename.api.payment_processor_configuration_service_api import PaymentProcessorConfigurationServiceApi
 from whitelabelmachinename.api.payment_processor_service_api import PaymentProcessorServiceApi
 from whitelabelmachinename.api.payment_terminal_service_api import PaymentTerminalServiceApi
 from whitelabelmachinename.api.payment_terminal_till_service_api import PaymentTerminalTillServiceApi
-from whitelabelmachinename.api.payment_terminal_transaction_summary_service_api import PaymentTerminalTransactionSummaryServiceApi
 from whitelabelmachinename.api.payment_web_app_service_api import PaymentWebAppServiceApi
 from whitelabelmachinename.api.permission_service_api import PermissionServiceApi
 from whitelabelmachinename.api.refund_bank_transaction_service_api import RefundBankTransactionServiceApi
 from whitelabelmachinename.api.refund_comment_service_api import RefundCommentServiceApi
 from whitelabelmachinename.api.refund_recovery_bank_transaction_service_api import RefundRecoveryBankTransactionServiceApi
 from whitelabelmachinename.api.refund_service_api import RefundServiceApi
 from whitelabelmachinename.api.shopify_recurring_order_service_api import ShopifyRecurringOrderServiceApi
@@ -136,20 +131,14 @@
 from whitelabelmachinename.models.abstract_webhook_listener_update import AbstractWebhookListenerUpdate
 from whitelabelmachinename.models.abstract_webhook_url_update import AbstractWebhookUrlUpdate
 from whitelabelmachinename.models.account import Account
 from whitelabelmachinename.models.account_state import AccountState
 from whitelabelmachinename.models.account_type import AccountType
 from whitelabelmachinename.models.address import Address
 from whitelabelmachinename.models.address_create import AddressCreate
-from whitelabelmachinename.models.analytics_query import AnalyticsQuery
-from whitelabelmachinename.models.analytics_query_execution import AnalyticsQueryExecution
-from whitelabelmachinename.models.analytics_query_execution_state import AnalyticsQueryExecutionState
-from whitelabelmachinename.models.analytics_query_result_batch import AnalyticsQueryResultBatch
-from whitelabelmachinename.models.analytics_schema_column import AnalyticsSchemaColumn
-from whitelabelmachinename.models.analytics_schema_table import AnalyticsSchemaTable
 from whitelabelmachinename.models.authenticated_card_data_create import AuthenticatedCardDataCreate
 from whitelabelmachinename.models.bank_account import BankAccount
 from whitelabelmachinename.models.bank_account_environment import BankAccountEnvironment
 from whitelabelmachinename.models.bank_account_state import BankAccountState
 from whitelabelmachinename.models.bank_account_type import BankAccountType
 from whitelabelmachinename.models.bank_transaction import BankTransaction
 from whitelabelmachinename.models.bank_transaction_flow_direction import BankTransactionFlowDirection
@@ -185,14 +174,18 @@
 from whitelabelmachinename.models.customer_address import CustomerAddress
 from whitelabelmachinename.models.customer_address_type import CustomerAddressType
 from whitelabelmachinename.models.customer_comment import CustomerComment
 from whitelabelmachinename.models.customer_postal_address import CustomerPostalAddress
 from whitelabelmachinename.models.customer_postal_address_create import CustomerPostalAddressCreate
 from whitelabelmachinename.models.customers_presence import CustomersPresence
 from whitelabelmachinename.models.data_collection_type import DataCollectionType
+from whitelabelmachinename.models.database_translated_string import DatabaseTranslatedString
+from whitelabelmachinename.models.database_translated_string_create import DatabaseTranslatedStringCreate
+from whitelabelmachinename.models.database_translated_string_item import DatabaseTranslatedStringItem
+from whitelabelmachinename.models.database_translated_string_item_create import DatabaseTranslatedStringItemCreate
 from whitelabelmachinename.models.debt_collection_case import DebtCollectionCase
 from whitelabelmachinename.models.debt_collection_case_document import DebtCollectionCaseDocument
 from whitelabelmachinename.models.debt_collection_case_source import DebtCollectionCaseSource
 from whitelabelmachinename.models.debt_collection_case_state import DebtCollectionCaseState
 from whitelabelmachinename.models.debt_collection_environment import DebtCollectionEnvironment
 from whitelabelmachinename.models.debt_collection_receipt import DebtCollectionReceipt
 from whitelabelmachinename.models.debt_collection_receipt_source import DebtCollectionReceiptSource
@@ -223,20 +216,14 @@
 from whitelabelmachinename.models.installment_calculated_slice import InstallmentCalculatedSlice
 from whitelabelmachinename.models.installment_payment import InstallmentPayment
 from whitelabelmachinename.models.installment_payment_slice_state import InstallmentPaymentSliceState
 from whitelabelmachinename.models.installment_payment_state import InstallmentPaymentState
 from whitelabelmachinename.models.installment_plan_configuration import InstallmentPlanConfiguration
 from whitelabelmachinename.models.installment_plan_slice_configuration import InstallmentPlanSliceConfiguration
 from whitelabelmachinename.models.internal_transfer_bank_transaction import InternalTransferBankTransaction
-from whitelabelmachinename.models.invoice_reconciliation_record_invoice_link import InvoiceReconciliationRecordInvoiceLink
-from whitelabelmachinename.models.invoice_reconciliation_record_rejection_status import InvoiceReconciliationRecordRejectionStatus
-from whitelabelmachinename.models.invoice_reconciliation_record_state import InvoiceReconciliationRecordState
-from whitelabelmachinename.models.invoice_reconciliation_record_type import InvoiceReconciliationRecordType
-from whitelabelmachinename.models.invoice_reimbursement import InvoiceReimbursement
-from whitelabelmachinename.models.invoice_reimbursement_state import InvoiceReimbursementState
 from whitelabelmachinename.models.label import Label
 from whitelabelmachinename.models.label_descriptor import LabelDescriptor
 from whitelabelmachinename.models.label_descriptor_category import LabelDescriptorCategory
 from whitelabelmachinename.models.label_descriptor_group import LabelDescriptorGroup
 from whitelabelmachinename.models.label_descriptor_type import LabelDescriptorType
 from whitelabelmachinename.models.legal_organization_form import LegalOrganizationForm
 from whitelabelmachinename.models.line_item import LineItem
@@ -278,16 +265,14 @@
 from whitelabelmachinename.models.payment_connector_configuration import PaymentConnectorConfiguration
 from whitelabelmachinename.models.payment_connector_feature import PaymentConnectorFeature
 from whitelabelmachinename.models.payment_contract import PaymentContract
 from whitelabelmachinename.models.payment_contract_state import PaymentContractState
 from whitelabelmachinename.models.payment_contract_type import PaymentContractType
 from whitelabelmachinename.models.payment_information_hash import PaymentInformationHash
 from whitelabelmachinename.models.payment_information_hash_type import PaymentInformationHashType
-from whitelabelmachinename.models.payment_initiation_advice_file import PaymentInitiationAdviceFile
-from whitelabelmachinename.models.payment_initiation_advice_file_state import PaymentInitiationAdviceFileState
 from whitelabelmachinename.models.payment_link import PaymentLink
 from whitelabelmachinename.models.payment_link_address_handling_mode import PaymentLinkAddressHandlingMode
 from whitelabelmachinename.models.payment_link_protection_mode import PaymentLinkProtectionMode
 from whitelabelmachinename.models.payment_link_update import PaymentLinkUpdate
 from whitelabelmachinename.models.payment_method import PaymentMethod
 from whitelabelmachinename.models.payment_method_brand import PaymentMethodBrand
 from whitelabelmachinename.models.payment_method_configuration import PaymentMethodConfiguration
@@ -296,24 +281,20 @@
 from whitelabelmachinename.models.payment_processor_configuration import PaymentProcessorConfiguration
 from whitelabelmachinename.models.payment_terminal import PaymentTerminal
 from whitelabelmachinename.models.payment_terminal_address import PaymentTerminalAddress
 from whitelabelmachinename.models.payment_terminal_configuration import PaymentTerminalConfiguration
 from whitelabelmachinename.models.payment_terminal_configuration_state import PaymentTerminalConfigurationState
 from whitelabelmachinename.models.payment_terminal_configuration_version import PaymentTerminalConfigurationVersion
 from whitelabelmachinename.models.payment_terminal_configuration_version_state import PaymentTerminalConfigurationVersionState
-from whitelabelmachinename.models.payment_terminal_dcc_transaction_sum import PaymentTerminalDccTransactionSum
 from whitelabelmachinename.models.payment_terminal_location import PaymentTerminalLocation
 from whitelabelmachinename.models.payment_terminal_location_state import PaymentTerminalLocationState
 from whitelabelmachinename.models.payment_terminal_location_version import PaymentTerminalLocationVersion
 from whitelabelmachinename.models.payment_terminal_location_version_state import PaymentTerminalLocationVersionState
 from whitelabelmachinename.models.payment_terminal_receipt_type import PaymentTerminalReceiptType
 from whitelabelmachinename.models.payment_terminal_state import PaymentTerminalState
-from whitelabelmachinename.models.payment_terminal_transaction_sum import PaymentTerminalTransactionSum
-from whitelabelmachinename.models.payment_terminal_transaction_summary import PaymentTerminalTransactionSummary
-from whitelabelmachinename.models.payment_terminal_transaction_summary_fetch_request import PaymentTerminalTransactionSummaryFetchRequest
 from whitelabelmachinename.models.payment_terminal_type import PaymentTerminalType
 from whitelabelmachinename.models.permission import Permission
 from whitelabelmachinename.models.persistable_currency_amount import PersistableCurrencyAmount
 from whitelabelmachinename.models.persistable_currency_amount_update import PersistableCurrencyAmountUpdate
 from whitelabelmachinename.models.product_fee_type import ProductFeeType
 from whitelabelmachinename.models.product_metered_fee import ProductMeteredFee
 from whitelabelmachinename.models.product_metered_fee_update import ProductMeteredFeeUpdate
@@ -328,15 +309,14 @@
 from whitelabelmachinename.models.refund import Refund
 from whitelabelmachinename.models.refund_comment import RefundComment
 from whitelabelmachinename.models.refund_create import RefundCreate
 from whitelabelmachinename.models.refund_state import RefundState
 from whitelabelmachinename.models.refund_type import RefundType
 from whitelabelmachinename.models.rendered_document import RenderedDocument
 from whitelabelmachinename.models.rendered_terminal_receipt import RenderedTerminalReceipt
-from whitelabelmachinename.models.rendered_terminal_transaction_summary import RenderedTerminalTransactionSummary
 from whitelabelmachinename.models.resource_path import ResourcePath
 from whitelabelmachinename.models.resource_state import ResourceState
 from whitelabelmachinename.models.rest_address_format import RestAddressFormat
 from whitelabelmachinename.models.rest_address_format_field import RestAddressFormatField
 from whitelabelmachinename.models.rest_country import RestCountry
 from whitelabelmachinename.models.rest_country_state import RestCountryState
 from whitelabelmachinename.models.rest_currency import RestCurrency
@@ -460,26 +440,26 @@
 from whitelabelmachinename.models.transaction_completion_state import TransactionCompletionState
 from whitelabelmachinename.models.transaction_environment_selection_strategy import TransactionEnvironmentSelectionStrategy
 from whitelabelmachinename.models.transaction_group import TransactionGroup
 from whitelabelmachinename.models.transaction_group_state import TransactionGroupState
 from whitelabelmachinename.models.transaction_invoice_comment import TransactionInvoiceComment
 from whitelabelmachinename.models.transaction_invoice_replacement import TransactionInvoiceReplacement
 from whitelabelmachinename.models.transaction_invoice_state import TransactionInvoiceState
+from whitelabelmachinename.models.transaction_line_item_update_request import TransactionLineItemUpdateRequest
 from whitelabelmachinename.models.transaction_line_item_version_create import TransactionLineItemVersionCreate
 from whitelabelmachinename.models.transaction_line_item_version_state import TransactionLineItemVersionState
 from whitelabelmachinename.models.transaction_state import TransactionState
 from whitelabelmachinename.models.transaction_user_interface_type import TransactionUserInterfaceType
 from whitelabelmachinename.models.transaction_void_mode import TransactionVoidMode
 from whitelabelmachinename.models.transaction_void_state import TransactionVoidState
 from whitelabelmachinename.models.two_factor_authentication_type import TwoFactorAuthenticationType
 from whitelabelmachinename.models.user import User
 from whitelabelmachinename.models.user_account_role import UserAccountRole
 from whitelabelmachinename.models.user_space_role import UserSpaceRole
 from whitelabelmachinename.models.user_type import UserType
-from whitelabelmachinename.models.wallet_type import WalletType
 from whitelabelmachinename.models.web_app_confirmation_request import WebAppConfirmationRequest
 from whitelabelmachinename.models.web_app_confirmation_response import WebAppConfirmationResponse
 from whitelabelmachinename.models.webhook_identity import WebhookIdentity
 from whitelabelmachinename.models.webhook_listener import WebhookListener
 from whitelabelmachinename.models.webhook_listener_entity import WebhookListenerEntity
 from whitelabelmachinename.models.webhook_url import WebhookUrl
 from whitelabelmachinename.models.account_create import AccountCreate
@@ -502,16 +482,14 @@
 from whitelabelmachinename.models.customer_create import CustomerCreate
 from whitelabelmachinename.models.debt_collection_case_create import DebtCollectionCaseCreate
 from whitelabelmachinename.models.debt_collection_case_update import DebtCollectionCaseUpdate
 from whitelabelmachinename.models.delivery_indication import DeliveryIndication
 from whitelabelmachinename.models.human_user_create import HumanUserCreate
 from whitelabelmachinename.models.human_user_update import HumanUserUpdate
 from whitelabelmachinename.models.installment_payment_slice import InstallmentPaymentSlice
-from whitelabelmachinename.models.invoice_reconciliation_record import InvoiceReconciliationRecord
-from whitelabelmachinename.models.invoice_reimbursement_with_refund_reference import InvoiceReimbursementWithRefundReference
 from whitelabelmachinename.models.payment_link_active import PaymentLinkActive
 from whitelabelmachinename.models.payment_link_create import PaymentLinkCreate
 from whitelabelmachinename.models.refund_bank_transaction import RefundBankTransaction
 from whitelabelmachinename.models.refund_comment_active import RefundCommentActive
 from whitelabelmachinename.models.refund_comment_create import RefundCommentCreate
 from whitelabelmachinename.models.refund_recovery_bank_transaction import RefundRecoveryBankTransaction
 from whitelabelmachinename.models.shopify_recurring_order import ShopifyRecurringOrder
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/__init__.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,13 +1,12 @@
 # coding: utf-8
 
 from __future__ import absolute_import
 
 from .account_service_api import AccountServiceApi
-from .analytics_query_service_api import AnalyticsQueryServiceApi
 from .application_user_service_api import ApplicationUserServiceApi
 from .bank_account_service_api import BankAccountServiceApi
 from .bank_transaction_service_api import BankTransactionServiceApi
 from .card_processing_service_api import CardProcessingServiceApi
 from .charge_attempt_service_api import ChargeAttemptServiceApi
 from .charge_bank_transaction_service_api import ChargeBankTransactionServiceApi
 from .charge_flow_level_payment_link_service_api import ChargeFlowLevelPaymentLinkServiceApi
@@ -31,17 +30,14 @@
 from .human_user_service_api import HumanUserServiceApi
 from .installment_payment_service_api import InstallmentPaymentServiceApi
 from .installment_payment_slice_service_api import InstallmentPaymentSliceServiceApi
 from .installment_plan_calculation_service_api import InstallmentPlanCalculationServiceApi
 from .installment_plan_configuration_service_api import InstallmentPlanConfigurationServiceApi
 from .installment_plan_slice_configuration_service_api import InstallmentPlanSliceConfigurationServiceApi
 from .internal_transfer_bank_transaction_service_api import InternalTransferBankTransactionServiceApi
-from .invoice_reconciliation_record_invoice_link_service_api import InvoiceReconciliationRecordInvoiceLinkServiceApi
-from .invoice_reconciliation_record_service_api import InvoiceReconciliationRecordServiceApi
-from .invoice_reimbursement_service_api import InvoiceReimbursementServiceApi
 from .label_description_group_service_api import LabelDescriptionGroupServiceApi
 from .label_description_service_api import LabelDescriptionServiceApi
 from .language_service_api import LanguageServiceApi
 from .legal_organization_form_service_api import LegalOrganizationFormServiceApi
 from .manual_task_service_api import ManualTaskServiceApi
 from .mertic_usage_service_api import MerticUsageServiceApi
 from .payment_connector_configuration_service_api import PaymentConnectorConfigurationServiceApi
@@ -50,15 +46,14 @@
 from .payment_method_brand_service_api import PaymentMethodBrandServiceApi
 from .payment_method_configuration_service_api import PaymentMethodConfigurationServiceApi
 from .payment_method_service_api import PaymentMethodServiceApi
 from .payment_processor_configuration_service_api import PaymentProcessorConfigurationServiceApi
 from .payment_processor_service_api import PaymentProcessorServiceApi
 from .payment_terminal_service_api import PaymentTerminalServiceApi
 from .payment_terminal_till_service_api import PaymentTerminalTillServiceApi
-from .payment_terminal_transaction_summary_service_api import PaymentTerminalTransactionSummaryServiceApi
 from .payment_web_app_service_api import PaymentWebAppServiceApi
 from .permission_service_api import PermissionServiceApi
 from .refund_bank_transaction_service_api import RefundBankTransactionServiceApi
 from .refund_comment_service_api import RefundCommentServiceApi
 from .refund_recovery_bank_transaction_service_api import RefundRecoveryBankTransactionServiceApi
 from .refund_service_api import RefundServiceApi
 from .shopify_recurring_order_service_api import ShopifyRecurringOrderServiceApi
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/account_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/account_service_api.py`

 * *Files 4% similar despite different names*

```diff
@@ -12,56 +12,54 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(**kwargs)
         else:
             (data) = self.count_with_http_info(**kwargs)
             return data
 
     def count_with_http_info(self, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -103,64 +101,62 @@
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def create(self, entity, **kwargs):
         """Create
 
         Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create(entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param AccountCreate entity: The account object with the properties which should be created. (required)
         :return: Account
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.create_with_http_info(entity, **kwargs)
         else:
             (data) = self.create_with_http_info(entity, **kwargs)
             return data
 
     def create_with_http_info(self, entity, **kwargs):
         """Create
 
         Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_with_http_info(entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param AccountCreate entity: The account object with the properties which should be created. (required)
         :return: Account
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create" % key
@@ -206,64 +202,62 @@
             post_params=form_params,
             files=local_var_files,
             response_type='Account',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def delete(self, id, **kwargs):
         """Delete
 
         Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int id:  (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.delete_with_http_info(id, **kwargs)
         else:
             (data) = self.delete_with_http_info(id, **kwargs)
             return data
 
     def delete_with_http_info(self, id, **kwargs):
         """Delete
 
         Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_with_http_info(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int id:  (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete" % key
@@ -309,64 +303,62 @@
             post_params=form_params,
             files=local_var_files,
             response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int id: The id of the account which should be returned. (required)
         :return: Account
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(id, **kwargs)
         else:
             (data) = self.read_with_http_info(id, **kwargs)
             return data
 
     def read_with_http_info(self, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int id: The id of the account which should be returned. (required)
         :return: Account
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -412,64 +404,62 @@
             post_params=form_params,
             files=local_var_files,
             response_type='Account',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param EntityQuery query: The query restricts the accounts which are returned by the search. (required)
         :return: list[Account]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(query, **kwargs)
         else:
             (data) = self.search_with_http_info(query, **kwargs)
             return data
 
     def search_with_http_info(self, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param EntityQuery query: The query restricts the accounts which are returned by the search. (required)
         :return: list[Account]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -515,64 +505,62 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[Account]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def update(self, entity, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update(entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param AccountUpdate entity: The account object with all the properties which should be updated. The id and the version are required properties. (required)
         :return: Account
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.update_with_http_info(entity, **kwargs)
         else:
             (data) = self.update_with_http_info(entity, **kwargs)
             return data
 
     def update_with_http_info(self, entity, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_with_http_info(entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param AccountUpdate entity: The account object with all the properties which should be updated. The id and the version are required properties. (required)
         :return: Account
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update" % key
@@ -618,9 +606,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='Account',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/analytics_query_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/space_service_api.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,405 +2,385 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class AnalyticsQueryServiceApi:
+class SpaceServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
-    def cancel_execution(self, id, **kwargs):
-        """Cancel Execution
+    def count(self, **kwargs):
+        """Count
 
-        Cancels the specified query execution.
+        Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.cancel_execution(id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.count(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int id: The ID of the query execution to cancel. (required)
-        :return: None
+        :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
+        :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.cancel_execution_with_http_info(id, **kwargs)
+            return self.count_with_http_info(**kwargs)
         else:
-            (data) = self.cancel_execution_with_http_info(id, **kwargs)
+            (data) = self.count_with_http_info(**kwargs)
             return data
 
-    def cancel_execution_with_http_info(self, id, **kwargs):
-        """Cancel Execution
+    def count_with_http_info(self, **kwargs):
+        """Count
 
-        Cancels the specified query execution.
+        Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.cancel_execution_with_http_info(id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.count_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int id: The ID of the query execution to cancel. (required)
-        :return: None
+        :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
+        :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id']
+        all_params = ['filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method cancel_execution" % key
+                    " to method count" % key
                 )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'id' is set
-        if ('id' not in params or
-                params['id'] is None):
-            raise ValueError("Missing the required parameter `id` when calling `cancel_execution`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'id' in params:
-            query_params.append(('id', params['id']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+        if 'filter' in params:
+            body_params = params['filter']
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(
-            ['*/*'])
+            ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/analytics-query/cancel-execution', 'POST',
+            '/space/count', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type=None,
+            response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def fetch_result(self, id, **kwargs):
-        """Fetch Result
+    def create(self, entity, **kwargs):
+        """Create
 
-        Fetches one batch of the result of a query execution.
+        Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.fetch_result(id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.create(entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int id: The ID of the query execution for which to fetch the result. (required)
-        :param int timeout: The maximal time in seconds to wait for the result if it is not yet available. Use 0 (the default) to return immediately without waiting.
-        :param int max_rows: The maximum number of rows to return per batch. (Between 1 and 999. The default is 999.)
-        :param str next_token: The next-token of the preceding batch to get the next result batch or null to get the first result batch.
-        :return: AnalyticsQueryResultBatch
+        :param SpaceCreate entity: The space object with the properties which should be created. (required)
+        :return: Space
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.fetch_result_with_http_info(id, **kwargs)
+            return self.create_with_http_info(entity, **kwargs)
         else:
-            (data) = self.fetch_result_with_http_info(id, **kwargs)
+            (data) = self.create_with_http_info(entity, **kwargs)
             return data
 
-    def fetch_result_with_http_info(self, id, **kwargs):
-        """Fetch Result
+    def create_with_http_info(self, entity, **kwargs):
+        """Create
 
-        Fetches one batch of the result of a query execution.
+        Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.fetch_result_with_http_info(id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.create_with_http_info(entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int id: The ID of the query execution for which to fetch the result. (required)
-        :param int timeout: The maximal time in seconds to wait for the result if it is not yet available. Use 0 (the default) to return immediately without waiting.
-        :param int max_rows: The maximum number of rows to return per batch. (Between 1 and 999. The default is 999.)
-        :param str next_token: The next-token of the preceding batch to get the next result batch or null to get the first result batch.
-        :return: AnalyticsQueryResultBatch
+        :param SpaceCreate entity: The space object with the properties which should be created. (required)
+        :return: Space
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'timeout', 'max_rows', 'next_token']
+        all_params = ['entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method fetch_result" % key
+                    " to method create" % key
                 )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'id' is set
-        if ('id' not in params or
-                params['id'] is None):
-            raise ValueError("Missing the required parameter `id` when calling `fetch_result`")
+        # verify the required parameter 'entity' is set
+        if ('entity' not in params or
+                params['entity'] is None):
+            raise ValueError("Missing the required parameter `entity` when calling `create`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'id' in params:
-            query_params.append(('id', params['id']))
-        if 'timeout' in params:
-            query_params.append(('timeout', params['timeout']))
-        if 'max_rows' in params:
-            query_params.append(('maxRows', params['max_rows']))
-        if 'next_token' in params:
-            query_params.append(('nextToken', params['next_token']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+        if 'entity' in params:
+            body_params = params['entity']
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(
-            ['*/*'])
+            ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/analytics-query/fetch-result', 'GET',
+            '/space/create', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='AnalyticsQueryResultBatch',
+            response_type='Space',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def generate_download_url(self, id, **kwargs):
-        """Generate Download URL
+    def delete(self, id, **kwargs):
+        """Delete
 
-        Generate a URL from which the results of a query execution can be downloaded in CSV format.
+        Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.generate_download_url(id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.delete(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int id: The ID of the query execution for which to generate the download URL. (required)
-        :param int timeout: The maximal time in seconds to wait for the result if it is not yet available. Use 0 (the default) to return immediately without waiting.
-        :return: str
+        :param int id:  (required)
+        :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.generate_download_url_with_http_info(id, **kwargs)
+            return self.delete_with_http_info(id, **kwargs)
         else:
-            (data) = self.generate_download_url_with_http_info(id, **kwargs)
+            (data) = self.delete_with_http_info(id, **kwargs)
             return data
 
-    def generate_download_url_with_http_info(self, id, **kwargs):
-        """Generate Download URL
+    def delete_with_http_info(self, id, **kwargs):
+        """Delete
 
-        Generate a URL from which the results of a query execution can be downloaded in CSV format.
+        Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.generate_download_url_with_http_info(id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.delete_with_http_info(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int id: The ID of the query execution for which to generate the download URL. (required)
-        :param int timeout: The maximal time in seconds to wait for the result if it is not yet available. Use 0 (the default) to return immediately without waiting.
-        :return: str
+        :param int id:  (required)
+        :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'timeout']
+        all_params = ['id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method generate_download_url" % key
+                    " to method delete" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'id' is set
         if ('id' not in params or
                 params['id'] is None):
-            raise ValueError("Missing the required parameter `id` when calling `generate_download_url`")
+            raise ValueError("Missing the required parameter `id` when calling `delete`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'id' in params:
-            query_params.append(('id', params['id']))
-        if 'timeout' in params:
-            query_params.append(('timeout', params['timeout']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+        if 'id' in params:
+            body_params = params['id']
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
-            ['text/plain'])
+            ['application/json;charset=utf-8'])
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(
-            ['*/*'])
+            ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/analytics-query/generate-download-url', 'GET',
+            '/space/delete', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='str',
+            response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def schema(self, **kwargs):
-        """Get Schemas
+    def read(self, id, **kwargs):
+        """Read
 
-        Get the schemas describing the available tables and their columns.
+        Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.schema(async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.read(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :return: list[AnalyticsSchemaTable]
+        :param int id: The id of the space which should be returned. (required)
+        :return: Space
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.schema_with_http_info(**kwargs)
+            return self.read_with_http_info(id, **kwargs)
         else:
-            (data) = self.schema_with_http_info(**kwargs)
+            (data) = self.read_with_http_info(id, **kwargs)
             return data
 
-    def schema_with_http_info(self, **kwargs):
-        """Get Schemas
+    def read_with_http_info(self, id, **kwargs):
+        """Read
 
-        Get the schemas describing the available tables and their columns.
+        Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.schema_with_http_info(async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.read_with_http_info(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :return: list[AnalyticsSchemaTable]
+        :param int id: The id of the space which should be returned. (required)
+        :return: Space
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = []
+        all_params = ['id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method schema" % key
+                    " to method read" % key
                 )
             params[key] = val
         del params['kwargs']
+        # verify the required parameter 'id' is set
+        if ('id' not in params or
+                params['id'] is None):
+            raise ValueError("Missing the required parameter `id` when calling `read`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
+        if 'id' in params:
+            query_params.append(('id', params['id']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
@@ -412,227 +392,223 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/analytics-query/schema', 'GET',
+            '/space/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[AnalyticsSchemaTable]',
+            response_type='Space',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def status(self, id, **kwargs):
-        """Execution Status
+    def search(self, query, **kwargs):
+        """Search
 
-        Returns the current status of a query execution.
+        Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.status(id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.search(query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int id: The ID of the query execution for which to get the status. (required)
-        :return: AnalyticsQueryExecution
+        :param EntityQuery query: The query restricts the spaces which are returned by the search. (required)
+        :return: list[Space]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.status_with_http_info(id, **kwargs)
+            return self.search_with_http_info(query, **kwargs)
         else:
-            (data) = self.status_with_http_info(id, **kwargs)
+            (data) = self.search_with_http_info(query, **kwargs)
             return data
 
-    def status_with_http_info(self, id, **kwargs):
-        """Execution Status
+    def search_with_http_info(self, query, **kwargs):
+        """Search
 
-        Returns the current status of a query execution.
+        Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.status_with_http_info(id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.search_with_http_info(query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int id: The ID of the query execution for which to get the status. (required)
-        :return: AnalyticsQueryExecution
+        :param EntityQuery query: The query restricts the spaces which are returned by the search. (required)
+        :return: list[Space]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id']
+        all_params = ['query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method status" % key
+                    " to method search" % key
                 )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'id' is set
-        if ('id' not in params or
-                params['id'] is None):
-            raise ValueError("Missing the required parameter `id` when calling `status`")
+        # verify the required parameter 'query' is set
+        if ('query' not in params or
+                params['query'] is None):
+            raise ValueError("Missing the required parameter `query` when calling `search`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'id' in params:
-            query_params.append(('id', params['id']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+        if 'query' in params:
+            body_params = params['query']
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(
-            ['*/*'])
+            ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/analytics-query/status', 'GET',
+            '/space/search', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='AnalyticsQueryExecution',
+            response_type='list[Space]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def submit_query(self, query, **kwargs):
-        """Submit Query
+    def update(self, entity, **kwargs):
+        """Update
 
-        Submits a query for execution.
+        This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.submit_query(query, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.update(entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param AnalyticsQuery query: The query to submit. (required)
-        :return: AnalyticsQueryExecution
+        :param SpaceUpdate entity: The space object with all the properties which should be updated. The id and the version are required properties. (required)
+        :return: Space
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.submit_query_with_http_info(query, **kwargs)
+            return self.update_with_http_info(entity, **kwargs)
         else:
-            (data) = self.submit_query_with_http_info(query, **kwargs)
+            (data) = self.update_with_http_info(entity, **kwargs)
             return data
 
-    def submit_query_with_http_info(self, query, **kwargs):
-        """Submit Query
+    def update_with_http_info(self, entity, **kwargs):
+        """Update
 
-        Submits a query for execution.
+        This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.submit_query_with_http_info(query, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.update_with_http_info(entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param AnalyticsQuery query: The query to submit. (required)
-        :return: AnalyticsQueryExecution
+        :param SpaceUpdate entity: The space object with all the properties which should be updated. The id and the version are required properties. (required)
+        :return: Space
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['query']
+        all_params = ['entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method submit_query" % key
+                    " to method update" % key
                 )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'query' is set
-        if ('query' not in params or
-                params['query'] is None):
-            raise ValueError("Missing the required parameter `query` when calling `submit_query`")
+        # verify the required parameter 'entity' is set
+        if ('entity' not in params or
+                params['entity'] is None):
+            raise ValueError("Missing the required parameter `entity` when calling `update`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'query' in params:
-            body_params = params['query']
+        if 'entity' in params:
+            body_params = params['entity']
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/analytics-query/submit-query', 'POST',
+            '/space/update', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='AnalyticsQueryExecution',
+            response_type='Space',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/application_user_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/application_user_service_api.py`

 * *Files 5% similar despite different names*

```diff
@@ -12,56 +12,54 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(**kwargs)
         else:
             (data) = self.count_with_http_info(**kwargs)
             return data
 
     def count_with_http_info(self, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -103,64 +101,62 @@
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def create(self, entity, **kwargs):
         """Create
 
         Creates the application user with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create(entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param ApplicationUserCreate entity: The user object with the properties which should be created. (required)
         :return: ApplicationUserCreateWithMacKey
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.create_with_http_info(entity, **kwargs)
         else:
             (data) = self.create_with_http_info(entity, **kwargs)
             return data
 
     def create_with_http_info(self, entity, **kwargs):
         """Create
 
         Creates the application user with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_with_http_info(entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param ApplicationUserCreate entity: The user object with the properties which should be created. (required)
         :return: ApplicationUserCreateWithMacKey
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create" % key
@@ -206,64 +202,62 @@
             post_params=form_params,
             files=local_var_files,
             response_type='ApplicationUserCreateWithMacKey',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def delete(self, id, **kwargs):
         """Delete
 
         Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int id:  (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.delete_with_http_info(id, **kwargs)
         else:
             (data) = self.delete_with_http_info(id, **kwargs)
             return data
 
     def delete_with_http_info(self, id, **kwargs):
         """Delete
 
         Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_with_http_info(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int id:  (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete" % key
@@ -309,64 +303,62 @@
             post_params=form_params,
             files=local_var_files,
             response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int id: The id of the application user which should be returned. (required)
         :return: ApplicationUser
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(id, **kwargs)
         else:
             (data) = self.read_with_http_info(id, **kwargs)
             return data
 
     def read_with_http_info(self, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int id: The id of the application user which should be returned. (required)
         :return: ApplicationUser
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -412,64 +404,62 @@
             post_params=form_params,
             files=local_var_files,
             response_type='ApplicationUser',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param EntityQuery query: The query restricts the application users which are returned by the search. (required)
         :return: list[ApplicationUser]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(query, **kwargs)
         else:
             (data) = self.search_with_http_info(query, **kwargs)
             return data
 
     def search_with_http_info(self, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param EntityQuery query: The query restricts the application users which are returned by the search. (required)
         :return: list[ApplicationUser]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -515,64 +505,62 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[ApplicationUser]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def update(self, entity, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update(entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param ApplicationUserUpdate entity: The application user entity with all the properties which should be updated. The id and the version are required properties. (required)
         :return: ApplicationUser
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.update_with_http_info(entity, **kwargs)
         else:
             (data) = self.update_with_http_info(entity, **kwargs)
             return data
 
     def update_with_http_info(self, entity, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_with_http_info(entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param ApplicationUserUpdate entity: The application user entity with all the properties which should be updated. The id and the version are required properties. (required)
         :return: ApplicationUser
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update" % key
@@ -618,9 +606,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='ApplicationUser',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/bank_account_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/subscription_version_service_api.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,52 +2,50 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class BankAccountServiceApi:
+class SubscriptionVersionServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -99,78 +97,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/bank-account/count', 'POST',
+            '/subscription-version/count', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The ID of the bank account which should be returned. (required)
-        :return: BankAccount
+        :param int id: The id of the subscription which should be returned. (required)
+        :return: SubscriptionVersion
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The ID of the bank account which should be returned. (required)
-        :return: BankAccount
+        :param int id: The id of the subscription which should be returned. (required)
+        :return: SubscriptionVersion
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -210,78 +206,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/bank-account/read', 'GET',
+            '/subscription-version/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='BankAccount',
+            response_type='SubscriptionVersion',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the bank accounts which are returned by the search. (required)
-        :return: list[BankAccount]
+        :param EntityQuery query: The query restricts the subscriptions which are returned by the search. (required)
+        :return: list[SubscriptionVersion]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the bank accounts which are returned by the search. (required)
-        :return: list[BankAccount]
+        :param EntityQuery query: The query restricts the subscriptions which are returned by the search. (required)
+        :return: list[SubscriptionVersion]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -321,21 +315,21 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/bank-account/search', 'POST',
+            '/subscription-version/search', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[BankAccount]',
+            response_type='list[SubscriptionVersion]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/bank_transaction_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/refund_bank_transaction_service_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,52 +2,50 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class BankTransactionServiceApi:
+class RefundBankTransactionServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -99,78 +97,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/bank-transaction/count', 'POST',
+            '/refund-bank-transaction/count', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The ID of the bank transaction which should be returned. (required)
-        :return: BankTransaction
+        :param int id: The ID of the refund bank transaction which should be returned. (required)
+        :return: RefundBankTransaction
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The ID of the bank transaction which should be returned. (required)
-        :return: BankTransaction
+        :param int id: The ID of the refund bank transaction which should be returned. (required)
+        :return: RefundBankTransaction
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -210,78 +206,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/bank-transaction/read', 'GET',
+            '/refund-bank-transaction/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='BankTransaction',
+            response_type='RefundBankTransaction',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the bank transactions which are returned by the search. (required)
-        :return: list[BankTransaction]
+        :param EntityQuery query: The query restricts the refund bank transactions which are returned by the search. (required)
+        :return: list[RefundBankTransaction]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the bank transactions which are returned by the search. (required)
-        :return: list[BankTransaction]
+        :param EntityQuery query: The query restricts the refund bank transactions which are returned by the search. (required)
+        :return: list[RefundBankTransaction]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -321,21 +315,21 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/bank-transaction/search', 'POST',
+            '/refund-bank-transaction/search', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[BankTransaction]',
+            response_type='list[RefundBankTransaction]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/card_processing_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/card_processing_service_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -12,44 +12,42 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def process(self, space_id, transaction_id, payment_method_configuration_id, card_data, **kwargs):
         """Process
 
         The process method will process the transaction with the given card details without using 3-D secure.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.process(space_id, transaction_id, payment_method_configuration_id, card_data, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int transaction_id: The ID of the transaction which should be processed. (required)
         :param int payment_method_configuration_id: The payment method configuration ID which is applied to the transaction. (required)
         :param AuthenticatedCardDataCreate card_data: The card details as JSON in plain which should be used to authorize the payment. (required)
         :return: Transaction
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.process_with_http_info(space_id, transaction_id, payment_method_configuration_id, card_data, **kwargs)
         else:
             (data) = self.process_with_http_info(space_id, transaction_id, payment_method_configuration_id, card_data, **kwargs)
             return data
 
     def process_with_http_info(self, space_id, transaction_id, payment_method_configuration_id, card_data, **kwargs):
         """Process
 
         The process method will process the transaction with the given card details without using 3-D secure.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.process_with_http_info(space_id, transaction_id, payment_method_configuration_id, card_data, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int transaction_id: The ID of the transaction which should be processed. (required)
         :param int payment_method_configuration_id: The payment method configuration ID which is applied to the transaction. (required)
@@ -59,15 +57,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'transaction_id', 'payment_method_configuration_id', 'card_data']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method process" % key
@@ -131,52 +129,50 @@
             post_params=form_params,
             files=local_var_files,
             response_type='Transaction',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def process_with3_d_secure(self, space_id, transaction_id, payment_method_configuration_id, card_data, **kwargs):
         """Process With 3-D Secure
 
         The process method will process the transaction with the given card details by eventually using 3-D secure. The buyer has to be redirect to the URL returned by this method.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.process_with3_d_secure(space_id, transaction_id, payment_method_configuration_id, card_data, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int transaction_id: The ID of the transaction which should be processed. (required)
         :param int payment_method_configuration_id: The payment method configuration ID which is applied to the transaction. (required)
         :param TokenizedCardDataCreate card_data: The card details as JSON in plain which should be used to authorize the payment. (required)
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.process_with3_d_secure_with_http_info(space_id, transaction_id, payment_method_configuration_id, card_data, **kwargs)
         else:
             (data) = self.process_with3_d_secure_with_http_info(space_id, transaction_id, payment_method_configuration_id, card_data, **kwargs)
             return data
 
     def process_with3_d_secure_with_http_info(self, space_id, transaction_id, payment_method_configuration_id, card_data, **kwargs):
         """Process With 3-D Secure
 
         The process method will process the transaction with the given card details by eventually using 3-D secure. The buyer has to be redirect to the URL returned by this method.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.process_with3_d_secure_with_http_info(space_id, transaction_id, payment_method_configuration_id, card_data, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int transaction_id: The ID of the transaction which should be processed. (required)
         :param int payment_method_configuration_id: The payment method configuration ID which is applied to the transaction. (required)
@@ -186,15 +182,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'transaction_id', 'payment_method_configuration_id', 'card_data']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method process_with3_d_secure" % key
@@ -254,9 +250,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='str',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/charge_attempt_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/charge_attempt_service_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -12,42 +12,40 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -111,50 +109,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the charge attempt which should be returned. (required)
         :return: ChargeAttempt
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the charge attempt which should be returned. (required)
         :return: ChargeAttempt
@@ -162,15 +158,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -222,50 +218,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='ChargeAttempt',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the charge attempts which are returned by the search. (required)
         :return: list[ChargeAttempt]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the charge attempts which are returned by the search. (required)
         :return: list[ChargeAttempt]
@@ -273,15 +267,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -333,9 +327,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[ChargeAttempt]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/charge_bank_transaction_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/charge_bank_transaction_service_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -12,42 +12,40 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -111,50 +109,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The ID of the charge bank transaction which should be returned. (required)
         :return: ChargeBankTransaction
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The ID of the charge bank transaction which should be returned. (required)
         :return: ChargeBankTransaction
@@ -162,15 +158,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -222,50 +218,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='ChargeBankTransaction',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the charge bank transactions which are returned by the search. (required)
         :return: list[ChargeBankTransaction]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the charge bank transactions which are returned by the search. (required)
         :return: list[ChargeBankTransaction]
@@ -273,15 +267,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -333,9 +327,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[ChargeBankTransaction]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/charge_flow_level_payment_link_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/bank_transaction_service_api.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,52 +2,50 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class ChargeFlowLevelPaymentLinkServiceApi:
+class BankTransactionServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -99,78 +97,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/charge-flow-level-payment-link/count', 'POST',
+            '/bank-transaction/count', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The ID of the charge flow level payment link which should be returned. (required)
-        :return: ChargeFlowLevelPaymentLink
+        :param int id: The ID of the bank transaction which should be returned. (required)
+        :return: BankTransaction
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The ID of the charge flow level payment link which should be returned. (required)
-        :return: ChargeFlowLevelPaymentLink
+        :param int id: The ID of the bank transaction which should be returned. (required)
+        :return: BankTransaction
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -210,78 +206,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/charge-flow-level-payment-link/read', 'GET',
+            '/bank-transaction/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ChargeFlowLevelPaymentLink',
+            response_type='BankTransaction',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the charge flow level payment links which are returned by the search. (required)
-        :return: list[ChargeFlowLevelPaymentLink]
+        :param EntityQuery query: The query restricts the bank transactions which are returned by the search. (required)
+        :return: list[BankTransaction]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the charge flow level payment links which are returned by the search. (required)
-        :return: list[ChargeFlowLevelPaymentLink]
+        :param EntityQuery query: The query restricts the bank transactions which are returned by the search. (required)
+        :return: list[BankTransaction]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -321,21 +315,21 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/charge-flow-level-payment-link/search', 'POST',
+            '/bank-transaction/search', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[ChargeFlowLevelPaymentLink]',
+            response_type='list[BankTransaction]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/charge_flow_level_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/charge_flow_level_service_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -12,42 +12,40 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -111,50 +109,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the payment flow level which should be returned. (required)
         :return: ChargeFlowLevel
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the payment flow level which should be returned. (required)
         :return: ChargeFlowLevel
@@ -162,15 +158,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -222,50 +218,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='ChargeFlowLevel',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the payment flow levels which are returned by the search. (required)
         :return: list[ChargeFlowLevel]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the payment flow levels which are returned by the search. (required)
         :return: list[ChargeFlowLevel]
@@ -273,15 +267,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -333,50 +327,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[ChargeFlowLevel]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def send_message(self, space_id, id, **kwargs):
         """Send Payment Link
 
         Sends the payment link of the charge flow level with the given 'id'.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.send_message(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the charge flow level whose payment link should be sent. (required)
         :return: ChargeFlowLevel
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.send_message_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.send_message_with_http_info(space_id, id, **kwargs)
             return data
 
     def send_message_with_http_info(self, space_id, id, **kwargs):
         """Send Payment Link
 
         Sends the payment link of the charge flow level with the given 'id'.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.send_message_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the charge flow level whose payment link should be sent. (required)
         :return: ChargeFlowLevel
@@ -384,15 +376,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method send_message" % key
@@ -444,9 +436,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='ChargeFlowLevel',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/charge_flow_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/charge_flow_service_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -12,42 +12,40 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def apply_flow(self, space_id, id, **kwargs):
         """applyFlow
 
         
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.apply_flow(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The transaction id of the transaction which should be process asynchronously. (required)
         :return: Transaction
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.apply_flow_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.apply_flow_with_http_info(space_id, id, **kwargs)
             return data
 
     def apply_flow_with_http_info(self, space_id, id, **kwargs):
         """applyFlow
 
         
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.apply_flow_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The transaction id of the transaction which should be process asynchronously. (required)
         :return: Transaction
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method apply_flow" % key
@@ -111,50 +109,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='Transaction',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def cancel_charge_flow(self, space_id, id, **kwargs):
         """Cancel Charge Flow
 
         This operation cancels the charge flow that is linked with the transaction indicated by the given ID.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.cancel_charge_flow(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The ID of the transaction for which the charge flow should be canceled. (required)
         :return: Transaction
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.cancel_charge_flow_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.cancel_charge_flow_with_http_info(space_id, id, **kwargs)
             return data
 
     def cancel_charge_flow_with_http_info(self, space_id, id, **kwargs):
         """Cancel Charge Flow
 
         This operation cancels the charge flow that is linked with the transaction indicated by the given ID.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.cancel_charge_flow_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The ID of the transaction for which the charge flow should be canceled. (required)
         :return: Transaction
@@ -162,15 +158,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method cancel_charge_flow" % key
@@ -218,50 +214,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='Transaction',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -269,15 +263,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -325,50 +319,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def fetch_charge_flow_payment_page_url(self, space_id, id, **kwargs):
         """Fetch Charge Flow Payment Page URL
 
         This operation allows to fetch the payment page URL that is been applied on the charge flow linked with the provided transaction. The operation might return an empty result when no payment page is needed or can be invoked.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.fetch_charge_flow_payment_page_url(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The transaction id of the transaction for which the URL of the charge flow should be fetched. (required)
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.fetch_charge_flow_payment_page_url_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.fetch_charge_flow_payment_page_url_with_http_info(space_id, id, **kwargs)
             return data
 
     def fetch_charge_flow_payment_page_url_with_http_info(self, space_id, id, **kwargs):
         """Fetch Charge Flow Payment Page URL
 
         This operation allows to fetch the payment page URL that is been applied on the charge flow linked with the provided transaction. The operation might return an empty result when no payment page is needed or can be invoked.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.fetch_charge_flow_payment_page_url_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The transaction id of the transaction for which the URL of the charge flow should be fetched. (required)
         :return: str
@@ -376,15 +368,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method fetch_charge_flow_payment_page_url" % key
@@ -432,50 +424,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='str',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the charge flow which should be returned. (required)
         :return: ChargeFlow
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the charge flow which should be returned. (required)
         :return: ChargeFlow
@@ -483,15 +473,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -543,50 +533,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='ChargeFlow',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the charge flows which are returned by the search. (required)
         :return: list[ChargeFlow]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the charge flows which are returned by the search. (required)
         :return: list[ChargeFlow]
@@ -594,15 +582,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -654,52 +642,50 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[ChargeFlow]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def update_recipient(self, space_id, transaction_id, type, recipient, **kwargs):
         """updateRecipient
 
         
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_recipient(space_id, transaction_id, type, recipient, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int transaction_id: The transaction id of the transaction whose recipient should be updated. (required)
         :param int type: The id of the charge flow configuration type to recipient should be updated for. (required)
         :param str recipient: The recipient address that should be used to send the payment URL. (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.update_recipient_with_http_info(space_id, transaction_id, type, recipient, **kwargs)
         else:
             (data) = self.update_recipient_with_http_info(space_id, transaction_id, type, recipient, **kwargs)
             return data
 
     def update_recipient_with_http_info(self, space_id, transaction_id, type, recipient, **kwargs):
         """updateRecipient
 
         
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_recipient_with_http_info(space_id, transaction_id, type, recipient, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int transaction_id: The transaction id of the transaction whose recipient should be updated. (required)
         :param int type: The id of the charge flow configuration type to recipient should be updated for. (required)
@@ -709,15 +695,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'transaction_id', 'type', 'recipient']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update_recipient" % key
@@ -777,9 +763,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/condition_type_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/payment_processor_service_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,64 +2,62 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class ConditionTypeServiceApi:
+class PaymentProcessorServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
     def all(self, **kwargs):
         """All
 
         This operation returns all entities which are available.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.all(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :return: list[ConditionType]
+        :return: list[PaymentProcessor]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.all_with_http_info(**kwargs)
         else:
             (data) = self.all_with_http_info(**kwargs)
             return data
 
     def all_with_http_info(self, **kwargs):
         """All
 
         This operation returns all entities which are available.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.all_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :return: list[ConditionType]
+        :return: list[PaymentProcessor]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = []
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method all" % key
@@ -87,76 +85,74 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/condition-type/all', 'GET',
+            '/payment-processor/all', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[ConditionType]',
+            response_type='list[PaymentProcessor]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int id: The id of the condition type which should be returned. (required)
-        :return: ConditionType
+        :param int id: The id of the processor which should be returned. (required)
+        :return: PaymentProcessor
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(id, **kwargs)
         else:
             (data) = self.read_with_http_info(id, **kwargs)
             return data
 
     def read_with_http_info(self, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int id: The id of the condition type which should be returned. (required)
-        :return: ConditionType
+        :param int id: The id of the processor which should be returned. (required)
+        :return: PaymentProcessor
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -190,21 +186,21 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/condition-type/read', 'GET',
+            '/payment-processor/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ConditionType',
+            response_type='PaymentProcessor',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/country_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/country_service_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -12,54 +12,52 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def all(self, **kwargs):
         """All
 
         This operation returns all countries.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.all(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :return: list[RestCountry]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.all_with_http_info(**kwargs)
         else:
             (data) = self.all_with_http_info(**kwargs)
             return data
 
     def all_with_http_info(self, **kwargs):
         """All
 
         This operation returns all countries.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.all_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :return: list[RestCountry]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = []
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method all" % key
@@ -99,9 +97,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[RestCountry]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/country_state_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/country_state_service_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -12,54 +12,52 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def all(self, **kwargs):
         """All
 
         This operation returns all states of all countries.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.all(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :return: list[RestCountryState]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.all_with_http_info(**kwargs)
         else:
             (data) = self.all_with_http_info(**kwargs)
             return data
 
     def all_with_http_info(self, **kwargs):
         """All
 
         This operation returns all states of all countries.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.all_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :return: list[RestCountryState]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = []
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method all" % key
@@ -99,64 +97,62 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[RestCountryState]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def country(self, code, **kwargs):
         """Find by Country
 
         This operation returns all states for a given country.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.country(code, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str code: The country code in ISO code two letter format for which all states should be returned. (required)
         :return: list[RestCountryState]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.country_with_http_info(code, **kwargs)
         else:
             (data) = self.country_with_http_info(code, **kwargs)
             return data
 
     def country_with_http_info(self, code, **kwargs):
         """Find by Country
 
         This operation returns all states for a given country.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.country_with_http_info(code, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str code: The country code in ISO code two letter format for which all states should be returned. (required)
         :return: list[RestCountryState]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['code']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method country" % key
@@ -202,9 +198,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[RestCountryState]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/currency_bank_account_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/currency_bank_account_service_api.py`

 * *Files 5% similar despite different names*

```diff
@@ -12,42 +12,40 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -111,50 +109,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The ID of the currency bank account which should be returned. (required)
         :return: CurrencyBankAccount
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The ID of the currency bank account which should be returned. (required)
         :return: CurrencyBankAccount
@@ -162,15 +158,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -222,50 +218,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='CurrencyBankAccount',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the currency bank accounts which are returned by the search. (required)
         :return: list[CurrencyBankAccount]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the currency bank accounts which are returned by the search. (required)
         :return: list[CurrencyBankAccount]
@@ -273,15 +267,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -333,9 +327,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[CurrencyBankAccount]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/currency_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/currency_service_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -12,54 +12,52 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def all(self, **kwargs):
         """All
 
         This operation returns all currencies.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.all(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :return: list[RestCurrency]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.all_with_http_info(**kwargs)
         else:
             (data) = self.all_with_http_info(**kwargs)
             return data
 
     def all_with_http_info(self, **kwargs):
         """All
 
         This operation returns all currencies.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.all_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :return: list[RestCurrency]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = []
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method all" % key
@@ -99,9 +97,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[RestCurrency]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/customer_address_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/customer_address_service_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -12,42 +12,40 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -111,50 +109,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def create(self, space_id, entity, **kwargs):
         """Create
 
         Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param CustomerAddressCreate entity: The customer object which should be created. (required)
         :return: CustomerAddress
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.create_with_http_info(space_id, entity, **kwargs)
         else:
             (data) = self.create_with_http_info(space_id, entity, **kwargs)
             return data
 
     def create_with_http_info(self, space_id, entity, **kwargs):
         """Create
 
         Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param CustomerAddressCreate entity: The customer object which should be created. (required)
         :return: CustomerAddress
@@ -162,15 +158,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create" % key
@@ -222,50 +218,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='CustomerAddress',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def delete(self, space_id, id, **kwargs):
         """Delete
 
         Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id:  (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.delete_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.delete_with_http_info(space_id, id, **kwargs)
             return data
 
     def delete_with_http_info(self, space_id, id, **kwargs):
         """Delete
 
         Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id:  (required)
         :return: None
@@ -273,15 +267,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete" % key
@@ -333,50 +327,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the customer which should be returned. (required)
         :return: CustomerAddress
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the customer which should be returned. (required)
         :return: CustomerAddress
@@ -384,15 +376,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -444,50 +436,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='CustomerAddress',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the customers which are returned by the search. (required)
         :return: list[CustomerAddress]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the customers which are returned by the search. (required)
         :return: list[CustomerAddress]
@@ -495,15 +485,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -555,50 +545,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[CustomerAddress]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def select_default_address(self, space_id, id, **kwargs):
         """selectDefaultAddress
 
         
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.select_default_address(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the customer address to set as default. (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.select_default_address_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.select_default_address_with_http_info(space_id, id, **kwargs)
             return data
 
     def select_default_address_with_http_info(self, space_id, id, **kwargs):
         """selectDefaultAddress
 
         
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.select_default_address_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the customer address to set as default. (required)
         :return: None
@@ -606,15 +594,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method select_default_address" % key
@@ -666,50 +654,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def update(self, space_id, entity, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param CustomerAddressActive entity: The customer object with the properties which should be updated. (required)
         :return: CustomerAddress
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.update_with_http_info(space_id, entity, **kwargs)
         else:
             (data) = self.update_with_http_info(space_id, entity, **kwargs)
             return data
 
     def update_with_http_info(self, space_id, entity, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param CustomerAddressActive entity: The customer object with the properties which should be updated. (required)
         :return: CustomerAddress
@@ -717,15 +703,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update" % key
@@ -777,9 +763,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='CustomerAddress',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/customer_comment_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/transaction_invoice_comment_service_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,175 +2,175 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class CustomerCommentServiceApi:
+class TransactionInvoiceCommentServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
-    def count(self, space_id, **kwargs):
-        """Count
+    def all(self, space_id, invoice_id, **kwargs):
+        """Find by invoice
 
-        Counts the number of items in the database as restricted by the given filter.
+        Returns all comments of the given transaction invoice.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.count(space_id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.all(space_id, invoice_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
-        :return: int
+        :param int invoice_id:  (required)
+        :return: list[TransactionInvoiceComment]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.count_with_http_info(space_id, **kwargs)
+            return self.all_with_http_info(space_id, invoice_id, **kwargs)
         else:
-            (data) = self.count_with_http_info(space_id, **kwargs)
+            (data) = self.all_with_http_info(space_id, invoice_id, **kwargs)
             return data
 
-    def count_with_http_info(self, space_id, **kwargs):
-        """Count
+    def all_with_http_info(self, space_id, invoice_id, **kwargs):
+        """Find by invoice
 
-        Counts the number of items in the database as restricted by the given filter.
+        Returns all comments of the given transaction invoice.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.count_with_http_info(space_id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.all_with_http_info(space_id, invoice_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
-        :return: int
+        :param int invoice_id:  (required)
+        :return: list[TransactionInvoiceComment]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['space_id', 'filter']
+        all_params = ['space_id', 'invoice_id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method count" % key
+                    " to method all" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `count`")
+            raise ValueError("Missing the required parameter `space_id` when calling `all`")
+        # verify the required parameter 'invoice_id' is set
+        if ('invoice_id' not in params or
+                params['invoice_id'] is None):
+            raise ValueError("Missing the required parameter `invoice_id` when calling `all`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
             query_params.append(('spaceId', params['space_id']))
+        if 'invoice_id' in params:
+            query_params.append(('invoiceId', params['invoice_id']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'filter' in params:
-            body_params = params['filter']
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/customer-comment/count', 'POST',
+            '/transaction-invoice-comment/all', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='int',
+            response_type='list[TransactionInvoiceComment]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def create(self, space_id, entity, **kwargs):
         """Create
 
-        Creates the entity with the given properties.
+        Creates the comment with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param CustomerCommentCreate entity: The customer object which should be created. (required)
-        :return: CustomerComment
+        :param TransactionInvoiceCommentCreate entity:  (required)
+        :return: TransactionInvoiceComment
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.create_with_http_info(space_id, entity, **kwargs)
         else:
             (data) = self.create_with_http_info(space_id, entity, **kwargs)
             return data
 
     def create_with_http_info(self, space_id, entity, **kwargs):
         """Create
 
-        Creates the entity with the given properties.
+        Creates the comment with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param CustomerCommentCreate entity: The customer object which should be created. (required)
-        :return: CustomerComment
+        :param TransactionInvoiceCommentCreate entity:  (required)
+        :return: TransactionInvoiceComment
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create" % key
@@ -210,62 +210,60 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/customer-comment/create', 'POST',
+            '/transaction-invoice-comment/create', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='CustomerComment',
+            response_type='TransactionInvoiceComment',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def delete(self, space_id, id, **kwargs):
         """Delete
 
-        Deletes the entity with the given id.
+        Deletes the comment with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id:  (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.delete_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.delete_with_http_info(space_id, id, **kwargs)
             return data
 
     def delete_with_http_info(self, space_id, id, **kwargs):
         """Delete
 
-        Deletes the entity with the given id.
+        Deletes the comment with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id:  (required)
         :return: None
@@ -273,15 +271,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete" % key
@@ -300,117 +298,115 @@
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
             query_params.append(('spaceId', params['space_id']))
+        if 'id' in params:
+            query_params.append(('id', params['id']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'id' in params:
-            body_params = params['id']
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/customer-comment/delete', 'POST',
+            '/transaction-invoice-comment/delete', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def pin_comment(self, space_id, id, **kwargs):
-        """pinComment
+    def pin(self, space_id, id, **kwargs):
+        """Pin
 
-        
+        Pins the comment to the top.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.pin_comment(space_id, id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.pin(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the customer comment to pin to the top. (required)
+        :param int id:  (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.pin_comment_with_http_info(space_id, id, **kwargs)
+            return self.pin_with_http_info(space_id, id, **kwargs)
         else:
-            (data) = self.pin_comment_with_http_info(space_id, id, **kwargs)
+            (data) = self.pin_with_http_info(space_id, id, **kwargs)
             return data
 
-    def pin_comment_with_http_info(self, space_id, id, **kwargs):
-        """pinComment
+    def pin_with_http_info(self, space_id, id, **kwargs):
+        """Pin
 
-        
+        Pins the comment to the top.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.pin_comment_with_http_info(space_id, id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.pin_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the customer comment to pin to the top. (required)
+        :param int id:  (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method pin_comment" % key
+                    " to method pin" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `pin_comment`")
+            raise ValueError("Missing the required parameter `space_id` when calling `pin`")
         # verify the required parameter 'id' is set
         if ('id' not in params or
                 params['id'] is None):
-            raise ValueError("Missing the required parameter `id` when calling `pin_comment`")
+            raise ValueError("Missing the required parameter `id` when calling `pin`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
@@ -432,78 +428,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/customer-comment/pin-comment', 'GET',
+            '/transaction-invoice-comment/pin', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
-        Reads the entity with the given 'id' and returns it.
+        Reads the comment with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the customer which should be returned. (required)
-        :return: CustomerComment
+        :param int id:  (required)
+        :return: TransactionInvoiceComment
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
-        Reads the entity with the given 'id' and returns it.
+        Reads the comment with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the customer which should be returned. (required)
-        :return: CustomerComment
+        :param int id:  (required)
+        :return: TransactionInvoiceComment
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -543,207 +537,94 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/customer-comment/read', 'GET',
+            '/transaction-invoice-comment/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='CustomerComment',
+            response_type='TransactionInvoiceComment',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def search(self, space_id, query, **kwargs):
-        """Search
+    def unpin(self, space_id, id, **kwargs):
+        """Unpin
 
-        Searches for the entities as specified by the given query.
+        Unpins the comment from the top.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.search(space_id, query, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.unpin(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the customers which are returned by the search. (required)
-        :return: list[CustomerComment]
+        :param int id:  (required)
+        :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
-        if kwargs.get('async_req'):
-            return self.search_with_http_info(space_id, query, **kwargs)
-        else:
-            (data) = self.search_with_http_info(space_id, query, **kwargs)
-            return data
-
-    def search_with_http_info(self, space_id, query, **kwargs):
-        """Search
-
-        Searches for the entities as specified by the given query.
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.search_with_http_info(space_id, query, async_req=True)
-        >>> result = thread.get()
 
-        :param async_req bool
-        :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the customers which are returned by the search. (required)
-        :return: list[CustomerComment]
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
 
-        all_params = ['space_id', 'query']
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('request_timeout')
-
-        params = locals()
-        for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method search" % key
-                )
-            params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'space_id' is set
-        if ('space_id' not in params or
-                params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `search`")
-        # verify the required parameter 'query' is set
-        if ('query' not in params or
-                params['query'] is None):
-            raise ValueError("Missing the required parameter `query` when calling `search`")
-
-        collection_formats = {}
-
-        path_params = {}
-
-        query_params = []
-        if 'space_id' in params:
-            query_params.append(('spaceId', params['space_id']))
-
-        header_params = {}
-
-        form_params = []
-        local_var_files = {}
-
-        body_params = None
-        if 'query' in params:
-            body_params = params['query']
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json;charset=utf-8'])
-
-        # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(
-            ['application/json;charset=utf-8'])
-
-        # Authentication setting
-        auth_settings = []
-
-        return self.api_client.call_api(
-            '/customer-comment/search', 'POST',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='list[CustomerComment]',
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
-            collection_formats=collection_formats)
-
-    def unpin_comment(self, space_id, id, **kwargs):
-        """unpinComment
-
-        
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.unpin_comment(space_id, id, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool
-        :param int space_id:  (required)
-        :param int id: The id of the customer comment to unpin. (required)
-        :return: None
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-        kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
         if kwargs.get('async_req'):
-            return self.unpin_comment_with_http_info(space_id, id, **kwargs)
+            return self.unpin_with_http_info(space_id, id, **kwargs)
         else:
-            (data) = self.unpin_comment_with_http_info(space_id, id, **kwargs)
+            (data) = self.unpin_with_http_info(space_id, id, **kwargs)
             return data
 
-    def unpin_comment_with_http_info(self, space_id, id, **kwargs):
-        """unpinComment
+    def unpin_with_http_info(self, space_id, id, **kwargs):
+        """Unpin
 
-        
+        Unpins the comment from the top.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.unpin_comment_with_http_info(space_id, id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.unpin_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the customer comment to unpin. (required)
+        :param int id:  (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method unpin_comment" % key
+                    " to method unpin" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `unpin_comment`")
+            raise ValueError("Missing the required parameter `space_id` when calling `unpin`")
         # verify the required parameter 'id' is set
         if ('id' not in params or
                 params['id'] is None):
-            raise ValueError("Missing the required parameter `id` when calling `unpin_comment`")
+            raise ValueError("Missing the required parameter `id` when calling `unpin`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
@@ -765,78 +646,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/customer-comment/unpin-comment', 'GET',
+            '/transaction-invoice-comment/unpin', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def update(self, space_id, entity, **kwargs):
         """Update
 
-        This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
+        This updates the comment with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the comment.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param CustomerCommentActive entity: The customer object with the properties which should be updated. (required)
-        :return: CustomerComment
+        :param TransactionInvoiceCommentActive entity:  (required)
+        :return: TransactionInvoiceComment
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.update_with_http_info(space_id, entity, **kwargs)
         else:
             (data) = self.update_with_http_info(space_id, entity, **kwargs)
             return data
 
     def update_with_http_info(self, space_id, entity, **kwargs):
         """Update
 
-        This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
+        This updates the comment with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the comment.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param CustomerCommentActive entity: The customer object with the properties which should be updated. (required)
-        :return: CustomerComment
+        :param TransactionInvoiceCommentActive entity:  (required)
+        :return: TransactionInvoiceComment
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update" % key
@@ -876,21 +755,21 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/customer-comment/update', 'POST',
+            '/transaction-invoice-comment/update', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='CustomerComment',
+            response_type='TransactionInvoiceComment',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/customer_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/customer_service_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -12,42 +12,40 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -111,50 +109,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def create(self, space_id, entity, **kwargs):
         """Create
 
         Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param CustomerCreate entity: The customer object which should be created. (required)
         :return: Customer
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.create_with_http_info(space_id, entity, **kwargs)
         else:
             (data) = self.create_with_http_info(space_id, entity, **kwargs)
             return data
 
     def create_with_http_info(self, space_id, entity, **kwargs):
         """Create
 
         Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param CustomerCreate entity: The customer object which should be created. (required)
         :return: Customer
@@ -162,15 +158,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create" % key
@@ -222,50 +218,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='Customer',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def delete(self, space_id, id, **kwargs):
         """Delete
 
         Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id:  (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.delete_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.delete_with_http_info(space_id, id, **kwargs)
             return data
 
     def delete_with_http_info(self, space_id, id, **kwargs):
         """Delete
 
         Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id:  (required)
         :return: None
@@ -273,15 +267,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete" % key
@@ -333,50 +327,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the customer which should be returned. (required)
         :return: Customer
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the customer which should be returned. (required)
         :return: Customer
@@ -384,15 +376,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -444,50 +436,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='Customer',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the customers which are returned by the search. (required)
         :return: list[Customer]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the customers which are returned by the search. (required)
         :return: list[Customer]
@@ -495,15 +485,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -555,50 +545,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[Customer]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def update(self, space_id, entity, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param CustomerActive entity: The customer object with the properties which should be updated. (required)
         :return: Customer
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.update_with_http_info(space_id, entity, **kwargs)
         else:
             (data) = self.update_with_http_info(space_id, entity, **kwargs)
             return data
 
     def update_with_http_info(self, space_id, entity, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param CustomerActive entity: The customer object with the properties which should be updated. (required)
         :return: Customer
@@ -606,15 +594,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update" % key
@@ -666,9 +654,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='Customer',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/debt_collection_case_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/debt_collection_case_service_api.py`

 * *Files 4% similar despite different names*

```diff
@@ -12,44 +12,42 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def add_collected_amount(self, space_id, id, collected_amount, external_id, **kwargs):
         """Add Collected Amount
 
         Adds a new collected amount to the case, creating a new payment receipt.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.add_collected_amount(space_id, id, collected_amount, external_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the debt collection case for which the amount should be added. (required)
         :param float collected_amount: The amount that has been collected. (required)
         :param str external_id: The unique external id of this payment receipt. (required)
         :return: DebtCollectionReceipt
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.add_collected_amount_with_http_info(space_id, id, collected_amount, external_id, **kwargs)
         else:
             (data) = self.add_collected_amount_with_http_info(space_id, id, collected_amount, external_id, **kwargs)
             return data
 
     def add_collected_amount_with_http_info(self, space_id, id, collected_amount, external_id, **kwargs):
         """Add Collected Amount
 
         Adds a new collected amount to the case, creating a new payment receipt.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.add_collected_amount_with_http_info(space_id, id, collected_amount, external_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the debt collection case for which the amount should be added. (required)
         :param float collected_amount: The amount that has been collected. (required)
@@ -59,15 +57,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id', 'collected_amount', 'external_id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method add_collected_amount" % key
@@ -123,52 +121,50 @@
             post_params=form_params,
             files=local_var_files,
             response_type='DebtCollectionReceipt',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def attach_document(self, space_id, id, file_name, content_base64, **kwargs):
         """Attach Document
 
         Attach an additional supporting document to the case.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.attach_document(space_id, id, file_name, content_base64, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the debt collection case. (required)
         :param str file_name: The file name of the document that is uploaded. (required)
         :param str content_base64: The BASE64 encoded contents of the document. (required)
         :return: DebtCollectionCaseDocument
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.attach_document_with_http_info(space_id, id, file_name, content_base64, **kwargs)
         else:
             (data) = self.attach_document_with_http_info(space_id, id, file_name, content_base64, **kwargs)
             return data
 
     def attach_document_with_http_info(self, space_id, id, file_name, content_base64, **kwargs):
         """Attach Document
 
         Attach an additional supporting document to the case.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.attach_document_with_http_info(space_id, id, file_name, content_base64, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the debt collection case. (required)
         :param str file_name: The file name of the document that is uploaded. (required)
@@ -178,15 +174,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id', 'file_name', 'content_base64']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method attach_document" % key
@@ -242,50 +238,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='DebtCollectionCaseDocument',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def close(self, space_id, id, **kwargs):
         """Close
 
         Closes the debt collection case, meaning no further money can be collected.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.close(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the debt collection case which should be closed. (required)
         :return: DebtCollectionCase
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.close_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.close_with_http_info(space_id, id, **kwargs)
             return data
 
     def close_with_http_info(self, space_id, id, **kwargs):
         """Close
 
         Closes the debt collection case, meaning no further money can be collected.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.close_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the debt collection case which should be closed. (required)
         :return: DebtCollectionCase
@@ -293,15 +287,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method close" % key
@@ -345,50 +339,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='DebtCollectionCase',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -396,15 +388,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -452,50 +444,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def create(self, space_id, entity, **kwargs):
         """Create
 
         Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param DebtCollectionCaseCreate entity: The debt collection case object with the properties which should be created. (required)
         :return: DebtCollectionCase
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.create_with_http_info(space_id, entity, **kwargs)
         else:
             (data) = self.create_with_http_info(space_id, entity, **kwargs)
             return data
 
     def create_with_http_info(self, space_id, entity, **kwargs):
         """Create
 
         Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param DebtCollectionCaseCreate entity: The debt collection case object with the properties which should be created. (required)
         :return: DebtCollectionCase
@@ -503,15 +493,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create" % key
@@ -563,50 +553,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='DebtCollectionCase',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def delete(self, space_id, id, **kwargs):
         """Delete
 
         Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id:  (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.delete_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.delete_with_http_info(space_id, id, **kwargs)
             return data
 
     def delete_with_http_info(self, space_id, id, **kwargs):
         """Delete
 
         Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id:  (required)
         :return: None
@@ -614,15 +602,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete" % key
@@ -674,50 +662,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def documents(self, space_id, id, **kwargs):
         """Documents
 
         Returns all documents that are attached to a debt collection case.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.documents(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the debt collection case for which the attached documents are returned. (required)
         :return: list[DebtCollectionCaseDocument]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.documents_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.documents_with_http_info(space_id, id, **kwargs)
             return data
 
     def documents_with_http_info(self, space_id, id, **kwargs):
         """Documents
 
         Returns all documents that are attached to a debt collection case.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.documents_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the debt collection case for which the attached documents are returned. (required)
         :return: list[DebtCollectionCaseDocument]
@@ -725,15 +711,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method documents" % key
@@ -777,50 +763,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[DebtCollectionCaseDocument]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def mark_as_prepared(self, space_id, id, **kwargs):
         """Mark Case As Prepared
 
         This operation will mark a debt collection case as prepared and allow the collection process to proceed.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.mark_as_prepared(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the debt collection case which should be marked as prepared. (required)
         :return: DebtCollectionCase
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.mark_as_prepared_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.mark_as_prepared_with_http_info(space_id, id, **kwargs)
             return data
 
     def mark_as_prepared_with_http_info(self, space_id, id, **kwargs):
         """Mark Case As Prepared
 
         This operation will mark a debt collection case as prepared and allow the collection process to proceed.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.mark_as_prepared_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the debt collection case which should be marked as prepared. (required)
         :return: DebtCollectionCase
@@ -828,15 +812,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method mark_as_prepared" % key
@@ -880,50 +864,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='DebtCollectionCase',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def mark_as_reviewed(self, space_id, id, **kwargs):
         """Mark Case As Reviewed
 
         This operation will mark a debt collection case as reviewed and allow the collection process to proceed.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.mark_as_reviewed(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the debt collection case which should be reviewed. (required)
         :return: DebtCollectionCase
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.mark_as_reviewed_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.mark_as_reviewed_with_http_info(space_id, id, **kwargs)
             return data
 
     def mark_as_reviewed_with_http_info(self, space_id, id, **kwargs):
         """Mark Case As Reviewed
 
         This operation will mark a debt collection case as reviewed and allow the collection process to proceed.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.mark_as_reviewed_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the debt collection case which should be reviewed. (required)
         :return: DebtCollectionCase
@@ -931,15 +913,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method mark_as_reviewed" % key
@@ -983,50 +965,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='DebtCollectionCase',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the debt collection case which should be returned. (required)
         :return: DebtCollectionCase
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the debt collection case which should be returned. (required)
         :return: DebtCollectionCase
@@ -1034,15 +1014,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -1094,50 +1074,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='DebtCollectionCase',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the cases which are returned by the search. (required)
         :return: list[DebtCollectionCase]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the cases which are returned by the search. (required)
         :return: list[DebtCollectionCase]
@@ -1145,15 +1123,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -1205,50 +1183,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[DebtCollectionCase]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def update(self, space_id, entity, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param DebtCollectionCaseUpdate entity: The object with all the properties which should be updated. The id and the version are required properties. (required)
         :return: DebtCollectionCase
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.update_with_http_info(space_id, entity, **kwargs)
         else:
             (data) = self.update_with_http_info(space_id, entity, **kwargs)
             return data
 
     def update_with_http_info(self, space_id, entity, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param DebtCollectionCaseUpdate entity: The object with all the properties which should be updated. The id and the version are required properties. (required)
         :return: DebtCollectionCase
@@ -1256,15 +1232,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update" % key
@@ -1316,9 +1292,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='DebtCollectionCase',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/debt_collector_configuration_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/debt_collector_configuration_service_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -12,42 +12,40 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -111,50 +109,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the debt collector configuration which should be returned. (required)
         :return: DebtCollectorConfiguration
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the debt collector configuration which should be returned. (required)
         :return: DebtCollectorConfiguration
@@ -162,15 +158,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -222,50 +218,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='DebtCollectorConfiguration',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the debt collector configuration which are returned by the search. (required)
         :return: list[DebtCollectorConfiguration]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the debt collector configuration which are returned by the search. (required)
         :return: list[DebtCollectorConfiguration]
@@ -273,15 +267,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -333,9 +327,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[DebtCollectorConfiguration]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/debt_collector_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/payment_connector_service_api.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,64 +2,62 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class DebtCollectorServiceApi:
+class PaymentConnectorServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
     def all(self, **kwargs):
         """All
 
         This operation returns all entities which are available.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.all(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :return: list[DebtCollector]
+        :return: list[PaymentConnector]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.all_with_http_info(**kwargs)
         else:
             (data) = self.all_with_http_info(**kwargs)
             return data
 
     def all_with_http_info(self, **kwargs):
         """All
 
         This operation returns all entities which are available.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.all_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :return: list[DebtCollector]
+        :return: list[PaymentConnector]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = []
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method all" % key
@@ -87,76 +85,74 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/debt-collector/all', 'GET',
+            '/payment-connector/all', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[DebtCollector]',
+            response_type='list[PaymentConnector]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int id: The id of the collector which should be returned. (required)
-        :return: DebtCollector
+        :param int id: The id of the connector which should be returned. (required)
+        :return: PaymentConnector
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(id, **kwargs)
         else:
             (data) = self.read_with_http_info(id, **kwargs)
             return data
 
     def read_with_http_info(self, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int id: The id of the collector which should be returned. (required)
-        :return: DebtCollector
+        :param int id: The id of the connector which should be returned. (required)
+        :return: PaymentConnector
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -190,21 +186,21 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/debt-collector/read', 'GET',
+            '/payment-connector/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='DebtCollector',
+            response_type='PaymentConnector',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/delivery_indication_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/delivery_indication_service_api.py`

 * *Files 4% similar despite different names*

```diff
@@ -12,42 +12,40 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -111,50 +109,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def mark_as_not_suitable(self, space_id, delivery_indication_id, **kwargs):
         """markAsNotSuitable
 
         This operation marks the delivery indication as not suitable.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.mark_as_not_suitable(space_id, delivery_indication_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int delivery_indication_id: The delivery indication id which should be marked as not suitable. (required)
         :return: DeliveryIndication
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.mark_as_not_suitable_with_http_info(space_id, delivery_indication_id, **kwargs)
         else:
             (data) = self.mark_as_not_suitable_with_http_info(space_id, delivery_indication_id, **kwargs)
             return data
 
     def mark_as_not_suitable_with_http_info(self, space_id, delivery_indication_id, **kwargs):
         """markAsNotSuitable
 
         This operation marks the delivery indication as not suitable.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.mark_as_not_suitable_with_http_info(space_id, delivery_indication_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int delivery_indication_id: The delivery indication id which should be marked as not suitable. (required)
         :return: DeliveryIndication
@@ -162,15 +158,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'delivery_indication_id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method mark_as_not_suitable" % key
@@ -218,50 +214,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='DeliveryIndication',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def mark_as_suitable(self, space_id, delivery_indication_id, **kwargs):
         """markAsSuitable
 
         This operation marks the delivery indication as suitable.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.mark_as_suitable(space_id, delivery_indication_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int delivery_indication_id: The delivery indication id which should be marked as suitable. (required)
         :return: DeliveryIndication
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.mark_as_suitable_with_http_info(space_id, delivery_indication_id, **kwargs)
         else:
             (data) = self.mark_as_suitable_with_http_info(space_id, delivery_indication_id, **kwargs)
             return data
 
     def mark_as_suitable_with_http_info(self, space_id, delivery_indication_id, **kwargs):
         """markAsSuitable
 
         This operation marks the delivery indication as suitable.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.mark_as_suitable_with_http_info(space_id, delivery_indication_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int delivery_indication_id: The delivery indication id which should be marked as suitable. (required)
         :return: DeliveryIndication
@@ -269,15 +263,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'delivery_indication_id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method mark_as_suitable" % key
@@ -325,50 +319,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='DeliveryIndication',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the delivery indication which should be returned. (required)
         :return: DeliveryIndication
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the delivery indication which should be returned. (required)
         :return: DeliveryIndication
@@ -376,15 +368,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -436,50 +428,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='DeliveryIndication',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the delivery indications which are returned by the search. (required)
         :return: list[DeliveryIndication]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the delivery indications which are returned by the search. (required)
         :return: list[DeliveryIndication]
@@ -487,15 +477,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -547,9 +537,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[DeliveryIndication]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/document_template_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/document_template_service_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -12,42 +12,40 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -111,50 +109,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the document template which should be returned. (required)
         :return: DocumentTemplate
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the document template which should be returned. (required)
         :return: DocumentTemplate
@@ -162,15 +158,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -222,50 +218,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='DocumentTemplate',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the document templates which are returned by the search. (required)
         :return: list[DocumentTemplate]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the document templates which are returned by the search. (required)
         :return: list[DocumentTemplate]
@@ -273,15 +267,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -333,9 +327,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[DocumentTemplate]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/document_template_type_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/document_template_type_service_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -12,54 +12,52 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def all(self, **kwargs):
         """All
 
         This operation returns all entities which are available.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.all(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :return: list[DocumentTemplateType]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.all_with_http_info(**kwargs)
         else:
             (data) = self.all_with_http_info(**kwargs)
             return data
 
     def all_with_http_info(self, **kwargs):
         """All
 
         This operation returns all entities which are available.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.all_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :return: list[DocumentTemplateType]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = []
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method all" % key
@@ -99,64 +97,62 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[DocumentTemplateType]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int id: The id of the document template type which should be returned. (required)
         :return: DocumentTemplateType
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(id, **kwargs)
         else:
             (data) = self.read_with_http_info(id, **kwargs)
             return data
 
     def read_with_http_info(self, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int id: The id of the document template type which should be returned. (required)
         :return: DocumentTemplateType
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -202,9 +198,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='DocumentTemplateType',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/external_transfer_bank_transaction_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/external_transfer_bank_transaction_service_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -12,42 +12,40 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -111,50 +109,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The ID of the external transfer bank transaction which should be returned. (required)
         :return: ExternalTransferBankTransaction
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The ID of the external transfer bank transaction which should be returned. (required)
         :return: ExternalTransferBankTransaction
@@ -162,15 +158,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -222,50 +218,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='ExternalTransferBankTransaction',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the external transfer bank transactions which are returned by the search. (required)
         :return: list[ExternalTransferBankTransaction]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the external transfer bank transactions which are returned by the search. (required)
         :return: list[ExternalTransferBankTransaction]
@@ -273,15 +267,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -333,9 +327,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[ExternalTransferBankTransaction]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/human_user_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/human_user_service_api.py`

 * *Files 4% similar despite different names*

```diff
@@ -12,56 +12,54 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(**kwargs)
         else:
             (data) = self.count_with_http_info(**kwargs)
             return data
 
     def count_with_http_info(self, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -103,64 +101,62 @@
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def create(self, entity, **kwargs):
         """Create
 
         Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create(entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param HumanUserCreate entity: The human user object with the properties which should be created. (required)
         :return: HumanUser
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.create_with_http_info(entity, **kwargs)
         else:
             (data) = self.create_with_http_info(entity, **kwargs)
             return data
 
     def create_with_http_info(self, entity, **kwargs):
         """Create
 
         Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_with_http_info(entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param HumanUserCreate entity: The human user object with the properties which should be created. (required)
         :return: HumanUser
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create" % key
@@ -206,64 +202,62 @@
             post_params=form_params,
             files=local_var_files,
             response_type='HumanUser',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def delete(self, id, **kwargs):
         """Delete
 
         Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int id:  (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.delete_with_http_info(id, **kwargs)
         else:
             (data) = self.delete_with_http_info(id, **kwargs)
             return data
 
     def delete_with_http_info(self, id, **kwargs):
         """Delete
 
         Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_with_http_info(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int id:  (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete" % key
@@ -309,64 +303,62 @@
             post_params=form_params,
             files=local_var_files,
             response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def export(self, request, **kwargs):
         """Export
 
         Exports the human users into a CSV file. The file will contain the properties defined in the request.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.export(request, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param EntityExportRequest request: The request controls the entries which are exported. (required)
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.export_with_http_info(request, **kwargs)
         else:
             (data) = self.export_with_http_info(request, **kwargs)
             return data
 
     def export_with_http_info(self, request, **kwargs):
         """Export
 
         Exports the human users into a CSV file. The file will contain the properties defined in the request.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.export_with_http_info(request, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param EntityExportRequest request: The request controls the entries which are exported. (required)
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['request']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method export" % key
@@ -412,64 +404,62 @@
             post_params=form_params,
             files=local_var_files,
             response_type='str',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int id: The id of the human user which should be returned. (required)
         :return: HumanUser
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(id, **kwargs)
         else:
             (data) = self.read_with_http_info(id, **kwargs)
             return data
 
     def read_with_http_info(self, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int id: The id of the human user which should be returned. (required)
         :return: HumanUser
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -515,64 +505,62 @@
             post_params=form_params,
             files=local_var_files,
             response_type='HumanUser',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param EntityQuery query: The query restricts the human users which are returned by the search. (required)
         :return: list[HumanUser]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(query, **kwargs)
         else:
             (data) = self.search_with_http_info(query, **kwargs)
             return data
 
     def search_with_http_info(self, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param EntityQuery query: The query restricts the human users which are returned by the search. (required)
         :return: list[HumanUser]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -618,64 +606,62 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[HumanUser]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def update(self, entity, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update(entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param HumanUserUpdate entity: The object with all the properties which should be updated. The id and the version are required properties. (required)
         :return: HumanUser
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.update_with_http_info(entity, **kwargs)
         else:
             (data) = self.update_with_http_info(entity, **kwargs)
             return data
 
     def update_with_http_info(self, entity, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_with_http_info(entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param HumanUserUpdate entity: The object with all the properties which should be updated. The id and the version are required properties. (required)
         :return: HumanUser
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update" % key
@@ -721,9 +707,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='HumanUser',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/installment_payment_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/installment_payment_service_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -12,42 +12,40 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, filter, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, filter, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the installment payment which are used to calculate the count. (required)
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, filter, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, filter, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, filter, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, filter, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the installment payment which are used to calculate the count. (required)
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -115,51 +113,49 @@
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def create_installment_payment(self, space_id, transaction_id, installment_plan_configuration, **kwargs):
         """Create Installment Payment
 
         This operation creates based up on the given transaction an installment payment.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_installment_payment(space_id, transaction_id, installment_plan_configuration, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int transaction_id: The transaction which should be converted into an installment payment. (required)
         :param int installment_plan_configuration: The installment plan configuration ID which should be applied on the transaction. (required)
         :return: InstallmentPayment
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.create_installment_payment_with_http_info(space_id, transaction_id, installment_plan_configuration, **kwargs)
         else:
             (data) = self.create_installment_payment_with_http_info(space_id, transaction_id, installment_plan_configuration, **kwargs)
             return data
 
     def create_installment_payment_with_http_info(self, space_id, transaction_id, installment_plan_configuration, **kwargs):
         """Create Installment Payment
 
         This operation creates based up on the given transaction an installment payment.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_installment_payment_with_http_info(space_id, transaction_id, installment_plan_configuration, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int transaction_id: The transaction which should be converted into an installment payment. (required)
         :param int installment_plan_configuration: The installment plan configuration ID which should be applied on the transaction. (required)
@@ -168,15 +164,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'transaction_id', 'installment_plan_configuration']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create_installment_payment" % key
@@ -230,50 +226,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='InstallmentPayment',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the installment payment which should be returned. (required)
         :return: InstallmentPayment
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the installment payment which should be returned. (required)
         :return: InstallmentPayment
@@ -281,15 +275,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -341,50 +335,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='InstallmentPayment',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the installment payments which are returned by the search. (required)
         :return: list[InstallmentPayment]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the installment payments which are returned by the search. (required)
         :return: list[InstallmentPayment]
@@ -392,15 +384,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -452,9 +444,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[InstallmentPayment]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/installment_payment_slice_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/installment_payment_slice_service_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -12,42 +12,40 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, filter, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, filter, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the installment payment slices which are used to calculate the count. (required)
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, filter, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, filter, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, filter, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, filter, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the installment payment slices which are used to calculate the count. (required)
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -115,50 +113,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the installment payment slice which should be returned. (required)
         :return: InstallmentPaymentSlice
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the installment payment slice which should be returned. (required)
         :return: InstallmentPaymentSlice
@@ -166,15 +162,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -226,50 +222,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='InstallmentPaymentSlice',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the installment payment slices which are returned by the search. (required)
         :return: list[InstallmentPaymentSlice]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the installment payment slices which are returned by the search. (required)
         :return: list[InstallmentPaymentSlice]
@@ -277,15 +271,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -337,9 +331,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[InstallmentPaymentSlice]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/installment_plan_calculation_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/installment_plan_calculation_service_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -12,42 +12,40 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def calculate_plans(self, space_id, transaction_id, **kwargs):
         """Calculate Plans
 
         This operation allows to calculate all plans for the given transaction. The transaction will not be changed in any way.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.calculate_plans(space_id, transaction_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int transaction_id: The transaction for which the plans should be calculated for. (required)
         :return: list[InstallmentCalculatedPlan]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.calculate_plans_with_http_info(space_id, transaction_id, **kwargs)
         else:
             (data) = self.calculate_plans_with_http_info(space_id, transaction_id, **kwargs)
             return data
 
     def calculate_plans_with_http_info(self, space_id, transaction_id, **kwargs):
         """Calculate Plans
 
         This operation allows to calculate all plans for the given transaction. The transaction will not be changed in any way.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.calculate_plans_with_http_info(space_id, transaction_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int transaction_id: The transaction for which the plans should be calculated for. (required)
         :return: list[InstallmentCalculatedPlan]
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'transaction_id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method calculate_plans" % key
@@ -111,9 +109,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[InstallmentCalculatedPlan]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/installment_plan_configuration_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/installment_plan_slice_configuration_service_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,68 +2,66 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class InstallmentPlanConfigurationServiceApi:
+class InstallmentPlanSliceConfigurationServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, filter, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, filter, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQueryFilter filter: The filter which restricts the installment plan configurations which are used to calculate the count. (required)
+        :param EntityQueryFilter filter: The filter which restricts the installment plan slice configurations which are used to calculate the count. (required)
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, filter, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, filter, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, filter, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, filter, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQueryFilter filter: The filter which restricts the installment plan configurations which are used to calculate the count. (required)
+        :param EntityQueryFilter filter: The filter which restricts the installment plan slice configurations which are used to calculate the count. (required)
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -103,78 +101,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/installment-plan-configuration/count', 'POST',
+            '/installment-plan-slice-configuration/count', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the installment plan configuration which should be returned. (required)
-        :return: InstallmentPlanConfiguration
+        :param int id: The id of the installment plan slice configuration which should be returned. (required)
+        :return: InstallmentPlanSliceConfiguration
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the installment plan configuration which should be returned. (required)
-        :return: InstallmentPlanConfiguration
+        :param int id: The id of the installment plan slice configuration which should be returned. (required)
+        :return: InstallmentPlanSliceConfiguration
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -214,78 +210,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/installment-plan-configuration/read', 'GET',
+            '/installment-plan-slice-configuration/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='InstallmentPlanConfiguration',
+            response_type='InstallmentPlanSliceConfiguration',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the installment plan configurations which are returned by the search. (required)
-        :return: list[InstallmentPlanConfiguration]
+        :param EntityQuery query: The query restricts the installment plan slice configurations which are returned by the search. (required)
+        :return: list[InstallmentPlanSliceConfiguration]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the installment plan configurations which are returned by the search. (required)
-        :return: list[InstallmentPlanConfiguration]
+        :param EntityQuery query: The query restricts the installment plan slice configurations which are returned by the search. (required)
+        :return: list[InstallmentPlanSliceConfiguration]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -325,21 +319,21 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/installment-plan-configuration/search', 'POST',
+            '/installment-plan-slice-configuration/search', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[InstallmentPlanConfiguration]',
+            response_type='list[InstallmentPlanSliceConfiguration]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/installment_plan_slice_configuration_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/payment_connector_configuration_service_api.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,86 +2,80 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class InstallmentPlanSliceConfigurationServiceApi:
+class PaymentConnectorConfigurationServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
-    def count(self, space_id, filter, **kwargs):
+    def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.count(space_id, filter, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQueryFilter filter: The filter which restricts the installment plan slice configurations which are used to calculate the count. (required)
+        :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.count_with_http_info(space_id, filter, **kwargs)
+            return self.count_with_http_info(space_id, **kwargs)
         else:
-            (data) = self.count_with_http_info(space_id, filter, **kwargs)
+            (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
-    def count_with_http_info(self, space_id, filter, **kwargs):
+    def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.count_with_http_info(space_id, filter, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQueryFilter filter: The filter which restricts the installment plan slice configurations which are used to calculate the count. (required)
+        :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
             raise ValueError("Missing the required parameter `space_id` when calling `count`")
-        # verify the required parameter 'filter' is set
-        if ('filter' not in params or
-                params['filter'] is None):
-            raise ValueError("Missing the required parameter `filter` when calling `count`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
@@ -103,78 +97,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/installment-plan-slice-configuration/count', 'POST',
+            '/payment-connector-configuration/count', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the installment plan slice configuration which should be returned. (required)
-        :return: InstallmentPlanSliceConfiguration
+        :param int id: The id of the payment connector configuration which should be returned. (required)
+        :return: PaymentConnectorConfiguration
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the installment plan slice configuration which should be returned. (required)
-        :return: InstallmentPlanSliceConfiguration
+        :param int id: The id of the payment connector configuration which should be returned. (required)
+        :return: PaymentConnectorConfiguration
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -214,78 +206,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/installment-plan-slice-configuration/read', 'GET',
+            '/payment-connector-configuration/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='InstallmentPlanSliceConfiguration',
+            response_type='PaymentConnectorConfiguration',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the installment plan slice configurations which are returned by the search. (required)
-        :return: list[InstallmentPlanSliceConfiguration]
+        :param EntityQuery query: The query restricts the payment connector configuration which are returned by the search. (required)
+        :return: list[PaymentConnectorConfiguration]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the installment plan slice configurations which are returned by the search. (required)
-        :return: list[InstallmentPlanSliceConfiguration]
+        :param EntityQuery query: The query restricts the payment connector configuration which are returned by the search. (required)
+        :return: list[PaymentConnectorConfiguration]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -325,21 +315,21 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/installment-plan-slice-configuration/search', 'POST',
+            '/payment-connector-configuration/search', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[InstallmentPlanSliceConfiguration]',
+            response_type='list[PaymentConnectorConfiguration]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/internal_transfer_bank_transaction_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/payment_processor_configuration_service_api.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,52 +2,50 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class InternalTransferBankTransactionServiceApi:
+class PaymentProcessorConfigurationServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -99,78 +97,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/internal-transfer-bank-transaction/count', 'POST',
+            '/payment-processor-configuration/count', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The ID of the internal transfer bank transaction which should be returned. (required)
-        :return: InternalTransferBankTransaction
+        :param int id: The id of the payment processor configuration which should be returned. (required)
+        :return: PaymentProcessorConfiguration
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The ID of the internal transfer bank transaction which should be returned. (required)
-        :return: InternalTransferBankTransaction
+        :param int id: The id of the payment processor configuration which should be returned. (required)
+        :return: PaymentProcessorConfiguration
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -210,78 +206,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/internal-transfer-bank-transaction/read', 'GET',
+            '/payment-processor-configuration/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='InternalTransferBankTransaction',
+            response_type='PaymentProcessorConfiguration',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the internal transfer bank transactions which are returned by the search. (required)
-        :return: list[InternalTransferBankTransaction]
+        :param EntityQuery query: The query restricts the payment processor configuration which are returned by the search. (required)
+        :return: list[PaymentProcessorConfiguration]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the internal transfer bank transactions which are returned by the search. (required)
-        :return: list[InternalTransferBankTransaction]
+        :param EntityQuery query: The query restricts the payment processor configuration which are returned by the search. (required)
+        :return: list[PaymentProcessorConfiguration]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -321,21 +315,21 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/internal-transfer-bank-transaction/search', 'POST',
+            '/payment-processor-configuration/search', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[InternalTransferBankTransaction]',
+            response_type='list[PaymentProcessorConfiguration]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/invoice_reconciliation_record_invoice_link_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/subscription_suspension_service_api.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,52 +2,50 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class InvoiceReconciliationRecordInvoiceLinkServiceApi:
+class SubscriptionSuspensionServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -99,193 +97,185 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/invoice-reconciliation-record-invoice-link-service/count', 'POST',
+            '/subscription-suspension/count', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def link(self, space_id, record_id, completion_id, **kwargs):
-        """Link Invoice
+    def create(self, space_id, suspension, **kwargs):
+        """Create
 
-        Links the invoice reconciliation record with the provided invoice.
+        The create operation creates a new subscription suspension.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.link(space_id, record_id, completion_id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.create(space_id, suspension, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int record_id: The ID of the invoice reconciliation record which should be linked. (required)
-        :param int completion_id: The ID of the completion which should be linked. (required)
-        :param float amount: The amount of the invoice reconciliation record linked completion which should be changed.
-        :return: InvoiceReconciliationRecordInvoiceLink
+        :param SubscriptionSuspensionCreate suspension:  (required)
+        :return: SubscriptionSuspension
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.link_with_http_info(space_id, record_id, completion_id, **kwargs)
+            return self.create_with_http_info(space_id, suspension, **kwargs)
         else:
-            (data) = self.link_with_http_info(space_id, record_id, completion_id, **kwargs)
+            (data) = self.create_with_http_info(space_id, suspension, **kwargs)
             return data
 
-    def link_with_http_info(self, space_id, record_id, completion_id, **kwargs):
-        """Link Invoice
+    def create_with_http_info(self, space_id, suspension, **kwargs):
+        """Create
 
-        Links the invoice reconciliation record with the provided invoice.
+        The create operation creates a new subscription suspension.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.link_with_http_info(space_id, record_id, completion_id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.create_with_http_info(space_id, suspension, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int record_id: The ID of the invoice reconciliation record which should be linked. (required)
-        :param int completion_id: The ID of the completion which should be linked. (required)
-        :param float amount: The amount of the invoice reconciliation record linked completion which should be changed.
-        :return: InvoiceReconciliationRecordInvoiceLink
+        :param SubscriptionSuspensionCreate suspension:  (required)
+        :return: SubscriptionSuspension
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['space_id', 'record_id', 'completion_id', 'amount']
+        all_params = ['space_id', 'suspension']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method link" % key
+                    " to method create" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `link`")
-        # verify the required parameter 'record_id' is set
-        if ('record_id' not in params or
-                params['record_id'] is None):
-            raise ValueError("Missing the required parameter `record_id` when calling `link`")
-        # verify the required parameter 'completion_id' is set
-        if ('completion_id' not in params or
-                params['completion_id'] is None):
-            raise ValueError("Missing the required parameter `completion_id` when calling `link`")
+            raise ValueError("Missing the required parameter `space_id` when calling `create`")
+        # verify the required parameter 'suspension' is set
+        if ('suspension' not in params or
+                params['suspension'] is None):
+            raise ValueError("Missing the required parameter `suspension` when calling `create`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
             query_params.append(('spaceId', params['space_id']))
-        if 'record_id' in params:
-            query_params.append(('recordId', params['record_id']))
-        if 'completion_id' in params:
-            query_params.append(('completionId', params['completion_id']))
-        if 'amount' in params:
-            query_params.append(('amount', params['amount']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+        if 'suspension' in params:
+            body_params = params['suspension']
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json;charset=utf-8'])
+
+        # HTTP header `Content-Type`
+        header_params['Content-Type'] = self.api_client.select_header_content_type(
+            ['application/json;charset=utf-8'])
+
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/invoice-reconciliation-record-invoice-link-service/link', 'POST',
+            '/subscription-suspension/create', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='InvoiceReconciliationRecordInvoiceLink',
+            response_type='SubscriptionSuspension',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The ID of the invoice reconciliation record invoice link which should be returned. (required)
-        :return: InvoiceReconciliationRecordInvoiceLink
+        :param int id: The id of the suspension which should be returned. (required)
+        :return: SubscriptionSuspension
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The ID of the invoice reconciliation record invoice link which should be returned. (required)
-        :return: InvoiceReconciliationRecordInvoiceLink
+        :param int id: The id of the suspension which should be returned. (required)
+        :return: SubscriptionSuspension
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -325,78 +315,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/invoice-reconciliation-record-invoice-link-service/read', 'GET',
+            '/subscription-suspension/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='InvoiceReconciliationRecordInvoiceLink',
+            response_type='SubscriptionSuspension',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the invoice reconciliation record invoice link which are returned by the search. (required)
-        :return: list[InvoiceReconciliationRecordInvoiceLink]
+        :param EntityQuery query: The query restricts the subscription suspensions which are returned by the search. (required)
+        :return: list[SubscriptionSuspension]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the invoice reconciliation record invoice link which are returned by the search. (required)
-        :return: list[InvoiceReconciliationRecordInvoiceLink]
+        :param EntityQuery query: The query restricts the subscription suspensions which are returned by the search. (required)
+        :return: list[SubscriptionSuspension]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -436,132 +424,130 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/invoice-reconciliation-record-invoice-link-service/search', 'POST',
+            '/subscription-suspension/search', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[InvoiceReconciliationRecordInvoiceLink]',
+            response_type='list[SubscriptionSuspension]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def unlink_transaction(self, space_id, record_id, completion_id, **kwargs):
-        """Unlink Invoice
+    def terminate(self, space_id, suspension_id, **kwargs):
+        """terminate
 
-        Unlinks the invoice reconciliation record from the provided invoice.
+        The create operation creates a new subscription suspension.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.unlink_transaction(space_id, record_id, completion_id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.terminate(space_id, suspension_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int record_id: The ID of the invoice reconciliation record which should be unlinked. (required)
-        :param int completion_id: The ID of the completion which should be unlinked. (required)
-        :return: None
+        :param int suspension_id:  (required)
+        :return: SubscriptionSuspension
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.unlink_transaction_with_http_info(space_id, record_id, completion_id, **kwargs)
+            return self.terminate_with_http_info(space_id, suspension_id, **kwargs)
         else:
-            (data) = self.unlink_transaction_with_http_info(space_id, record_id, completion_id, **kwargs)
+            (data) = self.terminate_with_http_info(space_id, suspension_id, **kwargs)
             return data
 
-    def unlink_transaction_with_http_info(self, space_id, record_id, completion_id, **kwargs):
-        """Unlink Invoice
+    def terminate_with_http_info(self, space_id, suspension_id, **kwargs):
+        """terminate
 
-        Unlinks the invoice reconciliation record from the provided invoice.
+        The create operation creates a new subscription suspension.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.unlink_transaction_with_http_info(space_id, record_id, completion_id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.terminate_with_http_info(space_id, suspension_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int record_id: The ID of the invoice reconciliation record which should be unlinked. (required)
-        :param int completion_id: The ID of the completion which should be unlinked. (required)
-        :return: None
+        :param int suspension_id:  (required)
+        :return: SubscriptionSuspension
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['space_id', 'record_id', 'completion_id']
+        all_params = ['space_id', 'suspension_id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method unlink_transaction" % key
+                    " to method terminate" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `unlink_transaction`")
-        # verify the required parameter 'record_id' is set
-        if ('record_id' not in params or
-                params['record_id'] is None):
-            raise ValueError("Missing the required parameter `record_id` when calling `unlink_transaction`")
-        # verify the required parameter 'completion_id' is set
-        if ('completion_id' not in params or
-                params['completion_id'] is None):
-            raise ValueError("Missing the required parameter `completion_id` when calling `unlink_transaction`")
+            raise ValueError("Missing the required parameter `space_id` when calling `terminate`")
+        # verify the required parameter 'suspension_id' is set
+        if ('suspension_id' not in params or
+                params['suspension_id'] is None):
+            raise ValueError("Missing the required parameter `suspension_id` when calling `terminate`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
             query_params.append(('spaceId', params['space_id']))
-        if 'record_id' in params:
-            query_params.append(('recordId', params['record_id']))
-        if 'completion_id' in params:
-            query_params.append(('completionId', params['completion_id']))
+        if 'suspension_id' in params:
+            query_params.append(('suspensionId', params['suspension_id']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json;charset=utf-8'])
+
+        # HTTP header `Content-Type`
+        header_params['Content-Type'] = self.api_client.select_header_content_type(
+            ['application/json;charset=utf-8'])
+
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/invoice-reconciliation-record-invoice-link-service/unlink-transaction', 'POST',
+            '/subscription-suspension/terminate', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type=None,
+            response_type='SubscriptionSuspension',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/invoice_reconciliation_record_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/subscription_product_fee_tier_service_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,52 +2,50 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class InvoiceReconciliationRecordServiceApi:
+class SubscriptionProductFeeTierServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -99,310 +97,312 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/invoice-reconciliation-record-service/count', 'POST',
+            '/subscription-product-fee-tier/count', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def discard(self, space_id, id, **kwargs):
-        """Discard
+    def create(self, space_id, entity, **kwargs):
+        """Create
 
-        Discards the invoice reconciliation record.
+        Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.discard(space_id, id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.create(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The ID of the invoice reconciliation record which should be discarded. (required)
-        :return: None
+        :param ProductMeteredTierFeeUpdate entity: The metered fee tier object with the properties which should be created. (required)
+        :return: ProductMeteredTierFee
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.discard_with_http_info(space_id, id, **kwargs)
+            return self.create_with_http_info(space_id, entity, **kwargs)
         else:
-            (data) = self.discard_with_http_info(space_id, id, **kwargs)
+            (data) = self.create_with_http_info(space_id, entity, **kwargs)
             return data
 
-    def discard_with_http_info(self, space_id, id, **kwargs):
-        """Discard
+    def create_with_http_info(self, space_id, entity, **kwargs):
+        """Create
 
-        Discards the invoice reconciliation record.
+        Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.discard_with_http_info(space_id, id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.create_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The ID of the invoice reconciliation record which should be discarded. (required)
-        :return: None
+        :param ProductMeteredTierFeeUpdate entity: The metered fee tier object with the properties which should be created. (required)
+        :return: ProductMeteredTierFee
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['space_id', 'id']
+        all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method discard" % key
+                    " to method create" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `discard`")
-        # verify the required parameter 'id' is set
-        if ('id' not in params or
-                params['id'] is None):
-            raise ValueError("Missing the required parameter `id` when calling `discard`")
+            raise ValueError("Missing the required parameter `space_id` when calling `create`")
+        # verify the required parameter 'entity' is set
+        if ('entity' not in params or
+                params['entity'] is None):
+            raise ValueError("Missing the required parameter `entity` when calling `create`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
             query_params.append(('spaceId', params['space_id']))
-        if 'id' in params:
-            query_params.append(('id', params['id']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+        if 'entity' in params:
+            body_params = params['entity']
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json;charset=utf-8'])
+
+        # HTTP header `Content-Type`
+        header_params['Content-Type'] = self.api_client.select_header_content_type(
+            ['application/json;charset=utf-8'])
+
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/invoice-reconciliation-record-service/discard', 'POST',
+            '/subscription-product-fee-tier/create', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type=None,
+            response_type='ProductMeteredTierFee',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def read(self, space_id, id, **kwargs):
-        """Read
+    def delete(self, space_id, id, **kwargs):
+        """Delete
 
-        Reads the entity with the given 'id' and returns it.
+        Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.read(space_id, id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.delete(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The ID of the invoice reconciliation record which should be returned. (required)
-        :return: InvoiceReconciliationRecord
+        :param int id:  (required)
+        :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.read_with_http_info(space_id, id, **kwargs)
+            return self.delete_with_http_info(space_id, id, **kwargs)
         else:
-            (data) = self.read_with_http_info(space_id, id, **kwargs)
+            (data) = self.delete_with_http_info(space_id, id, **kwargs)
             return data
 
-    def read_with_http_info(self, space_id, id, **kwargs):
-        """Read
+    def delete_with_http_info(self, space_id, id, **kwargs):
+        """Delete
 
-        Reads the entity with the given 'id' and returns it.
+        Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.read_with_http_info(space_id, id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.delete_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The ID of the invoice reconciliation record which should be returned. (required)
-        :return: InvoiceReconciliationRecord
+        :param int id:  (required)
+        :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method read" % key
+                    " to method delete" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `read`")
+            raise ValueError("Missing the required parameter `space_id` when calling `delete`")
         # verify the required parameter 'id' is set
         if ('id' not in params or
                 params['id'] is None):
-            raise ValueError("Missing the required parameter `id` when calling `read`")
+            raise ValueError("Missing the required parameter `id` when calling `delete`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
             query_params.append(('spaceId', params['space_id']))
-        if 'id' in params:
-            query_params.append(('id', params['id']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+        if 'id' in params:
+            body_params = params['id']
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(
-            ['*/*'])
+            ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/invoice-reconciliation-record-service/read', 'GET',
+            '/subscription-product-fee-tier/delete', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='InvoiceReconciliationRecord',
+            response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def resolve(self, space_id, id, **kwargs):
-        """Resolve
+    def read(self, space_id, id, **kwargs):
+        """Read
 
-        Resolves the invoice reconciliation record.
+        Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.resolve(space_id, id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The ID of the invoice reconciliation record which should be resolved. (required)
-        :return: None
+        :param int id: The id of the metered fee tier which should be returned. (required)
+        :return: ProductMeteredTierFee
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.resolve_with_http_info(space_id, id, **kwargs)
+            return self.read_with_http_info(space_id, id, **kwargs)
         else:
-            (data) = self.resolve_with_http_info(space_id, id, **kwargs)
+            (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
-    def resolve_with_http_info(self, space_id, id, **kwargs):
-        """Resolve
+    def read_with_http_info(self, space_id, id, **kwargs):
+        """Read
 
-        Resolves the invoice reconciliation record.
+        Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.resolve_with_http_info(space_id, id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The ID of the invoice reconciliation record which should be resolved. (required)
-        :return: None
+        :param int id: The id of the metered fee tier which should be returned. (required)
+        :return: ProductMeteredTierFee
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method resolve" % key
+                    " to method read" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `resolve`")
+            raise ValueError("Missing the required parameter `space_id` when calling `read`")
         # verify the required parameter 'id' is set
         if ('id' not in params or
                 params['id'] is None):
-            raise ValueError("Missing the required parameter `id` when calling `resolve`")
+            raise ValueError("Missing the required parameter `id` when calling `read`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
@@ -412,82 +412,88 @@
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json;charset=utf-8'])
+
+        # HTTP header `Content-Type`
+        header_params['Content-Type'] = self.api_client.select_header_content_type(
+            ['*/*'])
+
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/invoice-reconciliation-record-service/resolve', 'POST',
+            '/subscription-product-fee-tier/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type=None,
+            response_type='ProductMeteredTierFee',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the invoice reconciliation records which are returned by the search. (required)
-        :return: list[InvoiceReconciliationRecord]
+        :param EntityQuery query: The query restricts the metered fee tiers which are returned by the search. (required)
+        :return: list[ProductMeteredTierFee]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the invoice reconciliation records which are returned by the search. (required)
-        :return: list[InvoiceReconciliationRecord]
+        :param EntityQuery query: The query restricts the metered fee tiers which are returned by the search. (required)
+        :return: list[ProductMeteredTierFee]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -527,96 +533,94 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/invoice-reconciliation-record-service/search', 'POST',
+            '/subscription-product-fee-tier/search', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[InvoiceReconciliationRecord]',
+            response_type='list[ProductMeteredTierFee]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def search_for_invoices_by_query(self, space_id, query, **kwargs):
-        """Search for matchable invoices by query
+    def update(self, space_id, entity, **kwargs):
+        """Update
 
-        Searches for transaction invoices by given query.
+        This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.search_for_invoices_by_query(space_id, query, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.update(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the invoices which are returned by the search. (required)
-        :return: list[TransactionInvoice]
+        :param ProductMeteredTierFeeUpdate entity: The metered fee tier object with all the properties which should be updated. The id and the version are required properties. (required)
+        :return: ProductMeteredTierFee
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.search_for_invoices_by_query_with_http_info(space_id, query, **kwargs)
+            return self.update_with_http_info(space_id, entity, **kwargs)
         else:
-            (data) = self.search_for_invoices_by_query_with_http_info(space_id, query, **kwargs)
+            (data) = self.update_with_http_info(space_id, entity, **kwargs)
             return data
 
-    def search_for_invoices_by_query_with_http_info(self, space_id, query, **kwargs):
-        """Search for matchable invoices by query
+    def update_with_http_info(self, space_id, entity, **kwargs):
+        """Update
 
-        Searches for transaction invoices by given query.
+        This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.search_for_invoices_by_query_with_http_info(space_id, query, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.update_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the invoices which are returned by the search. (required)
-        :return: list[TransactionInvoice]
+        :param ProductMeteredTierFeeUpdate entity: The metered fee tier object with all the properties which should be updated. The id and the version are required properties. (required)
+        :return: ProductMeteredTierFee
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['space_id', 'query']
+        all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method search_for_invoices_by_query" % key
+                    " to method update" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `search_for_invoices_by_query`")
-        # verify the required parameter 'query' is set
-        if ('query' not in params or
-                params['query'] is None):
-            raise ValueError("Missing the required parameter `query` when calling `search_for_invoices_by_query`")
+            raise ValueError("Missing the required parameter `space_id` when calling `update`")
+        # verify the required parameter 'entity' is set
+        if ('entity' not in params or
+                params['entity'] is None):
+            raise ValueError("Missing the required parameter `entity` when calling `update`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
@@ -624,35 +628,35 @@
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'query' in params:
-            body_params = params['query']
+        if 'entity' in params:
+            body_params = params['entity']
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/invoice-reconciliation-record-service/search-for-invoices-by-query', 'POST',
+            '/subscription-product-fee-tier/update', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[TransactionInvoice]',
+            response_type='ProductMeteredTierFee',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/invoice_reimbursement_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/subscription_product_service_api.py`

 * *Files 11% similar despite different names*

```diff
@@ -2,52 +2,50 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class InvoiceReimbursementServiceApi:
+class SubscriptionProductServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -99,465 +97,457 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/invoice-reimbursement-service/count', 'POST',
+            '/subscription-product/count', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def read(self, space_id, id, **kwargs):
-        """Read
+    def create(self, space_id, entity, **kwargs):
+        """Create
 
-        Reads the entity with the given 'id' and returns it.
+        Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.read(space_id, id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.create(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The ID of the invoice reimbursement which should be returned. (required)
-        :return: InvoiceReimbursement
+        :param SubscriptionProductCreate entity: The product object with the properties which should be created. (required)
+        :return: SubscriptionProduct
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.read_with_http_info(space_id, id, **kwargs)
+            return self.create_with_http_info(space_id, entity, **kwargs)
         else:
-            (data) = self.read_with_http_info(space_id, id, **kwargs)
+            (data) = self.create_with_http_info(space_id, entity, **kwargs)
             return data
 
-    def read_with_http_info(self, space_id, id, **kwargs):
-        """Read
+    def create_with_http_info(self, space_id, entity, **kwargs):
+        """Create
 
-        Reads the entity with the given 'id' and returns it.
+        Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.read_with_http_info(space_id, id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.create_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The ID of the invoice reimbursement which should be returned. (required)
-        :return: InvoiceReimbursement
+        :param SubscriptionProductCreate entity: The product object with the properties which should be created. (required)
+        :return: SubscriptionProduct
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['space_id', 'id']
+        all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method read" % key
+                    " to method create" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `read`")
-        # verify the required parameter 'id' is set
-        if ('id' not in params or
-                params['id'] is None):
-            raise ValueError("Missing the required parameter `id` when calling `read`")
+            raise ValueError("Missing the required parameter `space_id` when calling `create`")
+        # verify the required parameter 'entity' is set
+        if ('entity' not in params or
+                params['entity'] is None):
+            raise ValueError("Missing the required parameter `entity` when calling `create`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
             query_params.append(('spaceId', params['space_id']))
-        if 'id' in params:
-            query_params.append(('id', params['id']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+        if 'entity' in params:
+            body_params = params['entity']
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(
-            ['*/*'])
+            ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/invoice-reimbursement-service/read', 'GET',
+            '/subscription-product/create', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='InvoiceReimbursement',
+            response_type='SubscriptionProduct',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def search(self, space_id, query, **kwargs):
-        """Search
+    def read(self, space_id, id, **kwargs):
+        """Read
 
-        Searches for the entities as specified by the given query.
+        Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.search(space_id, query, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the invoice reimbursements which are returned by the search. (required)
-        :return: list[InvoiceReimbursementWithRefundReference]
+        :param int id: The id of the product which should be returned. (required)
+        :return: SubscriptionProduct
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.search_with_http_info(space_id, query, **kwargs)
+            return self.read_with_http_info(space_id, id, **kwargs)
         else:
-            (data) = self.search_with_http_info(space_id, query, **kwargs)
+            (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
-    def search_with_http_info(self, space_id, query, **kwargs):
-        """Search
+    def read_with_http_info(self, space_id, id, **kwargs):
+        """Read
 
-        Searches for the entities as specified by the given query.
+        Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.search_with_http_info(space_id, query, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the invoice reimbursements which are returned by the search. (required)
-        :return: list[InvoiceReimbursementWithRefundReference]
+        :param int id: The id of the product which should be returned. (required)
+        :return: SubscriptionProduct
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['space_id', 'query']
+        all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method search" % key
+                    " to method read" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `search`")
-        # verify the required parameter 'query' is set
-        if ('query' not in params or
-                params['query'] is None):
-            raise ValueError("Missing the required parameter `query` when calling `search`")
+            raise ValueError("Missing the required parameter `space_id` when calling `read`")
+        # verify the required parameter 'id' is set
+        if ('id' not in params or
+                params['id'] is None):
+            raise ValueError("Missing the required parameter `id` when calling `read`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
             query_params.append(('spaceId', params['space_id']))
+        if 'id' in params:
+            query_params.append(('id', params['id']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'query' in params:
-            body_params = params['query']
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(
-            ['application/json;charset=utf-8'])
+            ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/invoice-reimbursement-service/search', 'POST',
+            '/subscription-product/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[InvoiceReimbursementWithRefundReference]',
+            response_type='SubscriptionProduct',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def update_connector(self, space_id, id, payment_connector_configuration_id, **kwargs):
-        """Update payment connector configuration
+    def search(self, space_id, query, **kwargs):
+        """Search
 
-        Updates payment connector configuration for reimbursement which is in manual review.
+        Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.update_connector(space_id, id, payment_connector_configuration_id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The ID of the invoice reimbursement of which connector should be updated. (required)
-        :param int payment_connector_configuration_id:  (required)
-        :return: None
+        :param EntityQuery query: The query restricts the products which are returned by the search. (required)
+        :return: list[SubscriptionProduct]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.update_connector_with_http_info(space_id, id, payment_connector_configuration_id, **kwargs)
+            return self.search_with_http_info(space_id, query, **kwargs)
         else:
-            (data) = self.update_connector_with_http_info(space_id, id, payment_connector_configuration_id, **kwargs)
+            (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
-    def update_connector_with_http_info(self, space_id, id, payment_connector_configuration_id, **kwargs):
-        """Update payment connector configuration
+    def search_with_http_info(self, space_id, query, **kwargs):
+        """Search
 
-        Updates payment connector configuration for reimbursement which is in manual review.
+        Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.update_connector_with_http_info(space_id, id, payment_connector_configuration_id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The ID of the invoice reimbursement of which connector should be updated. (required)
-        :param int payment_connector_configuration_id:  (required)
-        :return: None
+        :param EntityQuery query: The query restricts the products which are returned by the search. (required)
+        :return: list[SubscriptionProduct]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['space_id', 'id', 'payment_connector_configuration_id']
+        all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method update_connector" % key
+                    " to method search" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `update_connector`")
-        # verify the required parameter 'id' is set
-        if ('id' not in params or
-                params['id'] is None):
-            raise ValueError("Missing the required parameter `id` when calling `update_connector`")
-        # verify the required parameter 'payment_connector_configuration_id' is set
-        if ('payment_connector_configuration_id' not in params or
-                params['payment_connector_configuration_id'] is None):
-            raise ValueError("Missing the required parameter `payment_connector_configuration_id` when calling `update_connector`")
+            raise ValueError("Missing the required parameter `space_id` when calling `search`")
+        # verify the required parameter 'query' is set
+        if ('query' not in params or
+                params['query'] is None):
+            raise ValueError("Missing the required parameter `query` when calling `search`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
             query_params.append(('spaceId', params['space_id']))
-        if 'id' in params:
-            query_params.append(('id', params['id']))
-        if 'payment_connector_configuration_id' in params:
-            query_params.append(('paymentConnectorConfigurationId', params['payment_connector_configuration_id']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+        if 'query' in params:
+            body_params = params['query']
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json;charset=utf-8'])
+
+        # HTTP header `Content-Type`
+        header_params['Content-Type'] = self.api_client.select_header_content_type(
+            ['application/json;charset=utf-8'])
+
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/invoice-reimbursement-service/update-connector', 'POST',
+            '/subscription-product/search', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type=None,
+            response_type='list[SubscriptionProduct]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def update_iban(self, space_id, id, **kwargs):
-        """Update IBAN
+    def update(self, space_id, entity, **kwargs):
+        """Update
 
-        Updates recipient and/or sender IBAN for reimbursement which is in manual review.
+        This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.update_iban(space_id, id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.update(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The ID of the invoice reimbursement of which IBANs should be updated. (required)
-        :param str recipient_iban: 
-        :param str sender_iban: 
-        :return: None
+        :param SubscriptionProductActive entity: The products object with all the properties which should be updated. The id and the version are required properties. (required)
+        :return: SubscriptionProduct
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.update_iban_with_http_info(space_id, id, **kwargs)
+            return self.update_with_http_info(space_id, entity, **kwargs)
         else:
-            (data) = self.update_iban_with_http_info(space_id, id, **kwargs)
+            (data) = self.update_with_http_info(space_id, entity, **kwargs)
             return data
 
-    def update_iban_with_http_info(self, space_id, id, **kwargs):
-        """Update IBAN
+    def update_with_http_info(self, space_id, entity, **kwargs):
+        """Update
 
-        Updates recipient and/or sender IBAN for reimbursement which is in manual review.
+        This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.update_iban_with_http_info(space_id, id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.update_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The ID of the invoice reimbursement of which IBANs should be updated. (required)
-        :param str recipient_iban: 
-        :param str sender_iban: 
-        :return: None
+        :param SubscriptionProductActive entity: The products object with all the properties which should be updated. The id and the version are required properties. (required)
+        :return: SubscriptionProduct
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['space_id', 'id', 'recipient_iban', 'sender_iban']
+        all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method update_iban" % key
+                    " to method update" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `update_iban`")
-        # verify the required parameter 'id' is set
-        if ('id' not in params or
-                params['id'] is None):
-            raise ValueError("Missing the required parameter `id` when calling `update_iban`")
+            raise ValueError("Missing the required parameter `space_id` when calling `update`")
+        # verify the required parameter 'entity' is set
+        if ('entity' not in params or
+                params['entity'] is None):
+            raise ValueError("Missing the required parameter `entity` when calling `update`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
             query_params.append(('spaceId', params['space_id']))
-        if 'id' in params:
-            query_params.append(('id', params['id']))
-        if 'recipient_iban' in params:
-            query_params.append(('recipientIban', params['recipient_iban']))
-        if 'sender_iban' in params:
-            query_params.append(('senderIban', params['sender_iban']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+        if 'entity' in params:
+            body_params = params['entity']
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json;charset=utf-8'])
+
+        # HTTP header `Content-Type`
+        header_params['Content-Type'] = self.api_client.select_header_content_type(
+            ['application/json;charset=utf-8'])
+
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/invoice-reimbursement-service/update-iban', 'POST',
+            '/subscription-product/update', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type=None,
+            response_type='SubscriptionProduct',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/label_description_group_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/label_description_group_service_api.py`

 * *Files 4% similar despite different names*

```diff
@@ -12,54 +12,52 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def all(self, **kwargs):
         """All
 
         This operation returns all entities which are available.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.all(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :return: list[LabelDescriptorGroup]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.all_with_http_info(**kwargs)
         else:
             (data) = self.all_with_http_info(**kwargs)
             return data
 
     def all_with_http_info(self, **kwargs):
         """All
 
         This operation returns all entities which are available.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.all_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :return: list[LabelDescriptorGroup]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = []
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method all" % key
@@ -99,64 +97,62 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[LabelDescriptorGroup]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int id: The id of the label descriptor group which should be returned. (required)
         :return: LabelDescriptorGroup
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(id, **kwargs)
         else:
             (data) = self.read_with_http_info(id, **kwargs)
             return data
 
     def read_with_http_info(self, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int id: The id of the label descriptor group which should be returned. (required)
         :return: LabelDescriptorGroup
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -202,9 +198,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='LabelDescriptorGroup',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/label_description_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/label_description_service_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -12,54 +12,52 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def all(self, **kwargs):
         """All
 
         This operation returns all entities which are available.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.all(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :return: list[LabelDescriptor]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.all_with_http_info(**kwargs)
         else:
             (data) = self.all_with_http_info(**kwargs)
             return data
 
     def all_with_http_info(self, **kwargs):
         """All
 
         This operation returns all entities which are available.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.all_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :return: list[LabelDescriptor]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = []
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method all" % key
@@ -99,64 +97,62 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[LabelDescriptor]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int id: The id of the label descriptor which should be returned. (required)
         :return: LabelDescriptor
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(id, **kwargs)
         else:
             (data) = self.read_with_http_info(id, **kwargs)
             return data
 
     def read_with_http_info(self, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int id: The id of the label descriptor which should be returned. (required)
         :return: LabelDescriptor
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -202,9 +198,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='LabelDescriptor',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/language_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/language_service_api.py`

 * *Files 5% similar despite different names*

```diff
@@ -12,54 +12,52 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def all(self, **kwargs):
         """All
 
         This operation returns all languages.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.all(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :return: list[RestLanguage]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.all_with_http_info(**kwargs)
         else:
             (data) = self.all_with_http_info(**kwargs)
             return data
 
     def all_with_http_info(self, **kwargs):
         """All
 
         This operation returns all languages.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.all_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :return: list[RestLanguage]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = []
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method all" % key
@@ -99,9 +97,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[RestLanguage]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/legal_organization_form_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/legal_organization_form_service_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -12,54 +12,52 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def all(self, **kwargs):
         """All
 
         This operation returns all entities which are available.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.all(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :return: list[LegalOrganizationForm]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.all_with_http_info(**kwargs)
         else:
             (data) = self.all_with_http_info(**kwargs)
             return data
 
     def all_with_http_info(self, **kwargs):
         """All
 
         This operation returns all entities which are available.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.all_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :return: list[LegalOrganizationForm]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = []
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method all" % key
@@ -99,64 +97,62 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[LegalOrganizationForm]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def country(self, code, **kwargs):
         """Find by Country
 
         This operation returns all legal organization forms for a given country.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.country(code, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str code: The country in ISO 3166-1 alpha-2 format, for which all legal organization forms should be returned. (required)
         :return: list[LegalOrganizationForm]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.country_with_http_info(code, **kwargs)
         else:
             (data) = self.country_with_http_info(code, **kwargs)
             return data
 
     def country_with_http_info(self, code, **kwargs):
         """Find by Country
 
         This operation returns all legal organization forms for a given country.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.country_with_http_info(code, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str code: The country in ISO 3166-1 alpha-2 format, for which all legal organization forms should be returned. (required)
         :return: list[LegalOrganizationForm]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['code']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method country" % key
@@ -202,64 +198,62 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[LegalOrganizationForm]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int id: The id of the legal organization form which should be returned. (required)
         :return: LegalOrganizationForm
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(id, **kwargs)
         else:
             (data) = self.read_with_http_info(id, **kwargs)
             return data
 
     def read_with_http_info(self, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int id: The id of the legal organization form which should be returned. (required)
         :return: LegalOrganizationForm
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -305,9 +299,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='LegalOrganizationForm',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/manual_task_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/manual_task_service_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -12,42 +12,40 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -111,50 +109,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the manual task which should be returned. (required)
         :return: ManualTask
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the manual task which should be returned. (required)
         :return: ManualTask
@@ -162,15 +158,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -222,50 +218,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='ManualTask',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the manual tasks which are returned by the search. (required)
         :return: list[ManualTask]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the manual tasks which are returned by the search. (required)
         :return: list[ManualTask]
@@ -273,15 +267,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -333,9 +327,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[ManualTask]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/mertic_usage_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/mertic_usage_service_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -12,43 +12,41 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def calculate(self, space_id, start, end, **kwargs):
         """Calculate
 
         Calculates the consumed resources for the given space and time range.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.calculate(space_id, start, end, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param datetime start: The start date from which on the consumed units should be returned from. (required)
         :param datetime end: The end date to which the consumed units should be returned to. The end date is not included in the result. (required)
         :return: list[MetricUsage]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.calculate_with_http_info(space_id, start, end, **kwargs)
         else:
             (data) = self.calculate_with_http_info(space_id, start, end, **kwargs)
             return data
 
     def calculate_with_http_info(self, space_id, start, end, **kwargs):
         """Calculate
 
         Calculates the consumed resources for the given space and time range.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.calculate_with_http_info(space_id, start, end, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param datetime start: The start date from which on the consumed units should be returned from. (required)
         :param datetime end: The end date to which the consumed units should be returned to. The end date is not included in the result. (required)
@@ -57,15 +55,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'start', 'end']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method calculate" % key
@@ -123,9 +121,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[MetricUsage]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/payment_connector_configuration_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/installment_plan_configuration_service_api.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,82 +2,84 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class PaymentConnectorConfigurationServiceApi:
+class InstallmentPlanConfigurationServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
-    def count(self, space_id, **kwargs):
+    def count(self, space_id, filter, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.count(space_id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.count(space_id, filter, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
+        :param EntityQueryFilter filter: The filter which restricts the installment plan configurations which are used to calculate the count. (required)
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.count_with_http_info(space_id, **kwargs)
+            return self.count_with_http_info(space_id, filter, **kwargs)
         else:
-            (data) = self.count_with_http_info(space_id, **kwargs)
+            (data) = self.count_with_http_info(space_id, filter, **kwargs)
             return data
 
-    def count_with_http_info(self, space_id, **kwargs):
+    def count_with_http_info(self, space_id, filter, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.count_with_http_info(space_id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.count_with_http_info(space_id, filter, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
+        :param EntityQueryFilter filter: The filter which restricts the installment plan configurations which are used to calculate the count. (required)
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
             raise ValueError("Missing the required parameter `space_id` when calling `count`")
+        # verify the required parameter 'filter' is set
+        if ('filter' not in params or
+                params['filter'] is None):
+            raise ValueError("Missing the required parameter `filter` when calling `count`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
@@ -99,78 +101,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/payment-connector-configuration/count', 'POST',
+            '/installment-plan-configuration/count', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the payment connector configuration which should be returned. (required)
-        :return: PaymentConnectorConfiguration
+        :param int id: The id of the installment plan configuration which should be returned. (required)
+        :return: InstallmentPlanConfiguration
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the payment connector configuration which should be returned. (required)
-        :return: PaymentConnectorConfiguration
+        :param int id: The id of the installment plan configuration which should be returned. (required)
+        :return: InstallmentPlanConfiguration
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -210,78 +210,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/payment-connector-configuration/read', 'GET',
+            '/installment-plan-configuration/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='PaymentConnectorConfiguration',
+            response_type='InstallmentPlanConfiguration',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the payment connector configuration which are returned by the search. (required)
-        :return: list[PaymentConnectorConfiguration]
+        :param EntityQuery query: The query restricts the installment plan configurations which are returned by the search. (required)
+        :return: list[InstallmentPlanConfiguration]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the payment connector configuration which are returned by the search. (required)
-        :return: list[PaymentConnectorConfiguration]
+        :param EntityQuery query: The query restricts the installment plan configurations which are returned by the search. (required)
+        :return: list[InstallmentPlanConfiguration]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -321,21 +319,21 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/payment-connector-configuration/search', 'POST',
+            '/installment-plan-configuration/search', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[PaymentConnectorConfiguration]',
+            response_type='list[InstallmentPlanConfiguration]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/payment_connector_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/permission_service_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,64 +2,62 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class PaymentConnectorServiceApi:
+class PermissionServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
     def all(self, **kwargs):
         """All
 
         This operation returns all entities which are available.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.all(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :return: list[PaymentConnector]
+        :return: list[Permission]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.all_with_http_info(**kwargs)
         else:
             (data) = self.all_with_http_info(**kwargs)
             return data
 
     def all_with_http_info(self, **kwargs):
         """All
 
         This operation returns all entities which are available.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.all_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :return: list[PaymentConnector]
+        :return: list[Permission]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = []
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method all" % key
@@ -87,76 +85,74 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/payment-connector/all', 'GET',
+            '/permission/all', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[PaymentConnector]',
+            response_type='list[Permission]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int id: The id of the connector which should be returned. (required)
-        :return: PaymentConnector
+        :param int id: The id of the permission which should be returned. (required)
+        :return: Permission
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(id, **kwargs)
         else:
             (data) = self.read_with_http_info(id, **kwargs)
             return data
 
     def read_with_http_info(self, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int id: The id of the connector which should be returned. (required)
-        :return: PaymentConnector
+        :param int id: The id of the permission which should be returned. (required)
+        :return: Permission
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -190,21 +186,21 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/payment-connector/read', 'GET',
+            '/permission/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='PaymentConnector',
+            response_type='Permission',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/payment_link_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/payment_link_service_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -12,42 +12,40 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -111,50 +109,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def create(self, space_id, entity, **kwargs):
         """Create
 
         Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param PaymentLinkCreate entity: The payment link object with the properties which should be created. (required)
         :return: PaymentLink
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.create_with_http_info(space_id, entity, **kwargs)
         else:
             (data) = self.create_with_http_info(space_id, entity, **kwargs)
             return data
 
     def create_with_http_info(self, space_id, entity, **kwargs):
         """Create
 
         Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param PaymentLinkCreate entity: The payment link object with the properties which should be created. (required)
         :return: PaymentLink
@@ -162,15 +158,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create" % key
@@ -222,50 +218,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='PaymentLink',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def delete(self, space_id, id, **kwargs):
         """Delete
 
         Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id:  (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.delete_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.delete_with_http_info(space_id, id, **kwargs)
             return data
 
     def delete_with_http_info(self, space_id, id, **kwargs):
         """Delete
 
         Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id:  (required)
         :return: None
@@ -273,15 +267,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete" % key
@@ -333,50 +327,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the payment links which should be returned. (required)
         :return: PaymentLink
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the payment links which should be returned. (required)
         :return: PaymentLink
@@ -384,15 +376,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -444,50 +436,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='PaymentLink',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the payment links which are returned by the search. (required)
         :return: list[PaymentLink]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the payment links which are returned by the search. (required)
         :return: list[PaymentLink]
@@ -495,15 +485,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -555,50 +545,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[PaymentLink]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def update(self, space_id, entity, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param PaymentLinkUpdate entity: The object with all the properties which should be updated. The id and the version are required properties. (required)
         :return: PaymentLink
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.update_with_http_info(space_id, entity, **kwargs)
         else:
             (data) = self.update_with_http_info(space_id, entity, **kwargs)
             return data
 
     def update_with_http_info(self, space_id, entity, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param PaymentLinkUpdate entity: The object with all the properties which should be updated. The id and the version are required properties. (required)
         :return: PaymentLink
@@ -606,15 +594,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update" % key
@@ -666,9 +654,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='PaymentLink',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/payment_method_brand_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/payment_method_brand_service_api.py`

 * *Files 4% similar despite different names*

```diff
@@ -12,54 +12,52 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def all(self, **kwargs):
         """All
 
         This operation returns all entities which are available.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.all(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :return: list[PaymentMethodBrand]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.all_with_http_info(**kwargs)
         else:
             (data) = self.all_with_http_info(**kwargs)
             return data
 
     def all_with_http_info(self, **kwargs):
         """All
 
         This operation returns all entities which are available.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.all_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :return: list[PaymentMethodBrand]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = []
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method all" % key
@@ -99,64 +97,62 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[PaymentMethodBrand]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int id: The id of the payment method brand which should be returned. (required)
         :return: PaymentMethodBrand
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(id, **kwargs)
         else:
             (data) = self.read_with_http_info(id, **kwargs)
             return data
 
     def read_with_http_info(self, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int id: The id of the payment method brand which should be returned. (required)
         :return: PaymentMethodBrand
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -202,9 +198,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='PaymentMethodBrand',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/payment_method_configuration_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/payment_method_configuration_service_api.py`

 * *Files 4% similar despite different names*

```diff
@@ -12,42 +12,40 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -111,50 +109,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the payment method configuration which should be returned. (required)
         :return: PaymentMethodConfiguration
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the payment method configuration which should be returned. (required)
         :return: PaymentMethodConfiguration
@@ -162,15 +158,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -222,50 +218,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='PaymentMethodConfiguration',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the payment method configuration which are returned by the search. (required)
         :return: list[PaymentMethodConfiguration]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the payment method configuration which are returned by the search. (required)
         :return: list[PaymentMethodConfiguration]
@@ -273,15 +267,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -333,9 +327,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[PaymentMethodConfiguration]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/payment_method_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/static_value_service_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,64 +2,62 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class PaymentMethodServiceApi:
+class StaticValueServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
     def all(self, **kwargs):
         """All
 
         This operation returns all entities which are available.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.all(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :return: list[PaymentMethod]
+        :return: list[StaticValue]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.all_with_http_info(**kwargs)
         else:
             (data) = self.all_with_http_info(**kwargs)
             return data
 
     def all_with_http_info(self, **kwargs):
         """All
 
         This operation returns all entities which are available.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.all_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :return: list[PaymentMethod]
+        :return: list[StaticValue]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = []
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method all" % key
@@ -87,76 +85,74 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/payment-method/all', 'GET',
+            '/static-value-service/all', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[PaymentMethod]',
+            response_type='list[StaticValue]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int id: The id of the payment method which should be returned. (required)
-        :return: PaymentMethod
+        :param int id: The id of the static value which should be returned. (required)
+        :return: StaticValue
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(id, **kwargs)
         else:
             (data) = self.read_with_http_info(id, **kwargs)
             return data
 
     def read_with_http_info(self, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int id: The id of the payment method which should be returned. (required)
-        :return: PaymentMethod
+        :param int id: The id of the static value which should be returned. (required)
+        :return: StaticValue
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -190,21 +186,21 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/payment-method/read', 'GET',
+            '/static-value-service/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='PaymentMethod',
+            response_type='StaticValue',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/payment_processor_configuration_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/charge_flow_level_payment_link_service_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,52 +2,50 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class PaymentProcessorConfigurationServiceApi:
+class ChargeFlowLevelPaymentLinkServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -99,78 +97,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/payment-processor-configuration/count', 'POST',
+            '/charge-flow-level-payment-link/count', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the payment processor configuration which should be returned. (required)
-        :return: PaymentProcessorConfiguration
+        :param int id: The ID of the charge flow level payment link which should be returned. (required)
+        :return: ChargeFlowLevelPaymentLink
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the payment processor configuration which should be returned. (required)
-        :return: PaymentProcessorConfiguration
+        :param int id: The ID of the charge flow level payment link which should be returned. (required)
+        :return: ChargeFlowLevelPaymentLink
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -210,78 +206,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/payment-processor-configuration/read', 'GET',
+            '/charge-flow-level-payment-link/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='PaymentProcessorConfiguration',
+            response_type='ChargeFlowLevelPaymentLink',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the payment processor configuration which are returned by the search. (required)
-        :return: list[PaymentProcessorConfiguration]
+        :param EntityQuery query: The query restricts the charge flow level payment links which are returned by the search. (required)
+        :return: list[ChargeFlowLevelPaymentLink]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the payment processor configuration which are returned by the search. (required)
-        :return: list[PaymentProcessorConfiguration]
+        :param EntityQuery query: The query restricts the charge flow level payment links which are returned by the search. (required)
+        :return: list[ChargeFlowLevelPaymentLink]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -321,21 +315,21 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/payment-processor-configuration/search', 'POST',
+            '/charge-flow-level-payment-link/search', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[PaymentProcessorConfiguration]',
+            response_type='list[ChargeFlowLevelPaymentLink]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/payment_processor_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/payment_method_service_api.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,64 +2,62 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class PaymentProcessorServiceApi:
+class PaymentMethodServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
     def all(self, **kwargs):
         """All
 
         This operation returns all entities which are available.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.all(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :return: list[PaymentProcessor]
+        :return: list[PaymentMethod]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.all_with_http_info(**kwargs)
         else:
             (data) = self.all_with_http_info(**kwargs)
             return data
 
     def all_with_http_info(self, **kwargs):
         """All
 
         This operation returns all entities which are available.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.all_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :return: list[PaymentProcessor]
+        :return: list[PaymentMethod]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = []
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method all" % key
@@ -87,76 +85,74 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/payment-processor/all', 'GET',
+            '/payment-method/all', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[PaymentProcessor]',
+            response_type='list[PaymentMethod]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int id: The id of the processor which should be returned. (required)
-        :return: PaymentProcessor
+        :param int id: The id of the payment method which should be returned. (required)
+        :return: PaymentMethod
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(id, **kwargs)
         else:
             (data) = self.read_with_http_info(id, **kwargs)
             return data
 
     def read_with_http_info(self, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int id: The id of the processor which should be returned. (required)
-        :return: PaymentProcessor
+        :param int id: The id of the payment method which should be returned. (required)
+        :return: PaymentMethod
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -190,21 +186,21 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/payment-processor/read', 'GET',
+            '/payment-method/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='PaymentProcessor',
+            response_type='PaymentMethod',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/payment_terminal_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/customer_comment_service_api.py`

 * *Files 9% similar despite different names*

```diff
@@ -2,52 +2,50 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class PaymentTerminalServiceApi:
+class CustomerCommentServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -99,207 +97,312 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/payment-terminal/count', 'POST',
+            '/customer-comment/count', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def link(self, space_id, terminal_id, serial_number, **kwargs):
-        """Link Device With Terminal
+    def create(self, space_id, entity, **kwargs):
+        """Create
 
-        Links the device with given serial number with terminal.
+        Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.link(space_id, terminal_id, serial_number, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.create(space_id, entity, async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool
+        :param int space_id:  (required)
+        :param CustomerCommentCreate entity: The customer object which should be created. (required)
+        :return: CustomerComment
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+        kwargs['_return_http_data_only'] = True
+
+
+        if kwargs.get('async_req'):
+            return self.create_with_http_info(space_id, entity, **kwargs)
+        else:
+            (data) = self.create_with_http_info(space_id, entity, **kwargs)
+            return data
+
+    def create_with_http_info(self, space_id, entity, **kwargs):
+        """Create
+
+        Creates the entity with the given properties.
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.create_with_http_info(space_id, entity, async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool
+        :param int space_id:  (required)
+        :param CustomerCommentCreate entity: The customer object which should be created. (required)
+        :return: CustomerComment
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+
+        all_params = ['space_id', 'entity']
+        all_params.append('async_req')
+        all_params.append('_return_http_data_only')
+        all_params.append('_preload_content')
+        all_params.append('_request_timeout')
+
+        params = locals()
+        for key, val in six.iteritems(params['kwargs']):
+            if key not in all_params:
+                raise TypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method create" % key
+                )
+            params[key] = val
+        del params['kwargs']
+        # verify the required parameter 'space_id' is set
+        if ('space_id' not in params or
+                params['space_id'] is None):
+            raise ValueError("Missing the required parameter `space_id` when calling `create`")
+        # verify the required parameter 'entity' is set
+        if ('entity' not in params or
+                params['entity'] is None):
+            raise ValueError("Missing the required parameter `entity` when calling `create`")
+
+        collection_formats = {}
+
+        path_params = {}
+
+        query_params = []
+        if 'space_id' in params:
+            query_params.append(('spaceId', params['space_id']))
+
+        header_params = {}
+
+        form_params = []
+        local_var_files = {}
+
+        body_params = None
+        if 'entity' in params:
+            body_params = params['entity']
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json;charset=utf-8'])
+
+        # HTTP header `Content-Type`
+        header_params['Content-Type'] = self.api_client.select_header_content_type(
+            ['application/json;charset=utf-8'])
+
+        # Authentication setting
+        auth_settings = []
+
+        return self.api_client.call_api(
+            '/customer-comment/create', 'POST',
+            path_params,
+            query_params,
+            header_params,
+            body=body_params,
+            post_params=form_params,
+            files=local_var_files,
+            response_type='CustomerComment',
+            auth_settings=auth_settings,
+            async_req=params.get('async_req'),
+            _return_http_data_only=params.get('_return_http_data_only'),
+            _preload_content=params.get('_preload_content', True),
+            _request_timeout=params.get('_request_timeout'),
+            collection_formats=collection_formats)
+
+    def delete(self, space_id, id, **kwargs):
+        """Delete
+
+        Deletes the entity with the given id.
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.delete(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int terminal_id:  (required)
-        :param str serial_number:  (required)
+        :param int id:  (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.link_with_http_info(space_id, terminal_id, serial_number, **kwargs)
+            return self.delete_with_http_info(space_id, id, **kwargs)
         else:
-            (data) = self.link_with_http_info(space_id, terminal_id, serial_number, **kwargs)
+            (data) = self.delete_with_http_info(space_id, id, **kwargs)
             return data
 
-    def link_with_http_info(self, space_id, terminal_id, serial_number, **kwargs):
-        """Link Device With Terminal
+    def delete_with_http_info(self, space_id, id, **kwargs):
+        """Delete
 
-        Links the device with given serial number with terminal.
+        Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.link_with_http_info(space_id, terminal_id, serial_number, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.delete_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int terminal_id:  (required)
-        :param str serial_number:  (required)
+        :param int id:  (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['space_id', 'terminal_id', 'serial_number']
+        all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method link" % key
+                    " to method delete" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `link`")
-        # verify the required parameter 'terminal_id' is set
-        if ('terminal_id' not in params or
-                params['terminal_id'] is None):
-            raise ValueError("Missing the required parameter `terminal_id` when calling `link`")
-        # verify the required parameter 'serial_number' is set
-        if ('serial_number' not in params or
-                params['serial_number'] is None):
-            raise ValueError("Missing the required parameter `serial_number` when calling `link`")
+            raise ValueError("Missing the required parameter `space_id` when calling `delete`")
+        # verify the required parameter 'id' is set
+        if ('id' not in params or
+                params['id'] is None):
+            raise ValueError("Missing the required parameter `id` when calling `delete`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
             query_params.append(('spaceId', params['space_id']))
-        if 'terminal_id' in params:
-            query_params.append(('terminalId', params['terminal_id']))
-        if 'serial_number' in params:
-            query_params.append(('serialNumber', params['serial_number']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+        if 'id' in params:
+            body_params = params['id']
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json;charset=utf-8'])
+
+        # HTTP header `Content-Type`
+        header_params['Content-Type'] = self.api_client.select_header_content_type(
+            ['application/json;charset=utf-8'])
+
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/payment-terminal/link', 'POST',
+            '/customer-comment/delete', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def read(self, space_id, id, **kwargs):
-        """Read
+    def pin_comment(self, space_id, id, **kwargs):
+        """pinComment
 
-        Reads the entity with the given 'id' and returns it.
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
         
-        >>> thread = api.read(space_id, id, async_req=True)
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.pin_comment(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the payment terminal which should be returned. (required)
-        :return: PaymentTerminal
+        :param int id: The id of the customer comment to pin to the top. (required)
+        :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.read_with_http_info(space_id, id, **kwargs)
+            return self.pin_comment_with_http_info(space_id, id, **kwargs)
         else:
-            (data) = self.read_with_http_info(space_id, id, **kwargs)
+            (data) = self.pin_comment_with_http_info(space_id, id, **kwargs)
             return data
 
-    def read_with_http_info(self, space_id, id, **kwargs):
-        """Read
+    def pin_comment_with_http_info(self, space_id, id, **kwargs):
+        """pinComment
 
-        Reads the entity with the given 'id' and returns it.
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
         
-        >>> thread = api.read_with_http_info(space_id, id, async_req=True)
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.pin_comment_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the payment terminal which should be returned. (required)
-        :return: PaymentTerminal
+        :param int id: The id of the customer comment to pin to the top. (required)
+        :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method read" % key
+                    " to method pin_comment" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `read`")
+            raise ValueError("Missing the required parameter `space_id` when calling `pin_comment`")
         # verify the required parameter 'id' is set
         if ('id' not in params or
                 params['id'] is None):
-            raise ValueError("Missing the required parameter `id` when calling `read`")
+            raise ValueError("Missing the required parameter `id` when calling `pin_comment`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
@@ -321,441 +424,457 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/payment-terminal/read', 'GET',
+            '/customer-comment/pin-comment', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='PaymentTerminal',
+            response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def search(self, space_id, query, **kwargs):
-        """Search
+    def read(self, space_id, id, **kwargs):
+        """Read
 
-        Searches for the entities as specified by the given query.
+        Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.search(space_id, query, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the payment terminals which are returned by the search. (required)
-        :return: list[PaymentTerminal]
+        :param int id: The id of the customer which should be returned. (required)
+        :return: CustomerComment
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.search_with_http_info(space_id, query, **kwargs)
+            return self.read_with_http_info(space_id, id, **kwargs)
         else:
-            (data) = self.search_with_http_info(space_id, query, **kwargs)
+            (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
-    def search_with_http_info(self, space_id, query, **kwargs):
-        """Search
+    def read_with_http_info(self, space_id, id, **kwargs):
+        """Read
 
-        Searches for the entities as specified by the given query.
+        Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.search_with_http_info(space_id, query, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the payment terminals which are returned by the search. (required)
-        :return: list[PaymentTerminal]
+        :param int id: The id of the customer which should be returned. (required)
+        :return: CustomerComment
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['space_id', 'query']
+        all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method search" % key
+                    " to method read" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `search`")
-        # verify the required parameter 'query' is set
-        if ('query' not in params or
-                params['query'] is None):
-            raise ValueError("Missing the required parameter `query` when calling `search`")
+            raise ValueError("Missing the required parameter `space_id` when calling `read`")
+        # verify the required parameter 'id' is set
+        if ('id' not in params or
+                params['id'] is None):
+            raise ValueError("Missing the required parameter `id` when calling `read`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
             query_params.append(('spaceId', params['space_id']))
+        if 'id' in params:
+            query_params.append(('id', params['id']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'query' in params:
-            body_params = params['query']
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(
-            ['application/json;charset=utf-8'])
+            ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/payment-terminal/search', 'POST',
+            '/customer-comment/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[PaymentTerminal]',
+            response_type='CustomerComment',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def trigger_final_balance(self, space_id, terminal_id, **kwargs):
-        """Remotely Trigger Final Balance
+    def search(self, space_id, query, **kwargs):
+        """Search
 
-        Remotely triggers the final balance receipt on the terminal.
+        Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.trigger_final_balance(space_id, terminal_id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int terminal_id:  (required)
-        :return: None
+        :param EntityQuery query: The query restricts the customers which are returned by the search. (required)
+        :return: list[CustomerComment]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.trigger_final_balance_with_http_info(space_id, terminal_id, **kwargs)
+            return self.search_with_http_info(space_id, query, **kwargs)
         else:
-            (data) = self.trigger_final_balance_with_http_info(space_id, terminal_id, **kwargs)
+            (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
-    def trigger_final_balance_with_http_info(self, space_id, terminal_id, **kwargs):
-        """Remotely Trigger Final Balance
+    def search_with_http_info(self, space_id, query, **kwargs):
+        """Search
 
-        Remotely triggers the final balance receipt on the terminal.
+        Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.trigger_final_balance_with_http_info(space_id, terminal_id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int terminal_id:  (required)
-        :return: None
+        :param EntityQuery query: The query restricts the customers which are returned by the search. (required)
+        :return: list[CustomerComment]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['space_id', 'terminal_id']
+        all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method trigger_final_balance" % key
+                    " to method search" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `trigger_final_balance`")
-        # verify the required parameter 'terminal_id' is set
-        if ('terminal_id' not in params or
-                params['terminal_id'] is None):
-            raise ValueError("Missing the required parameter `terminal_id` when calling `trigger_final_balance`")
+            raise ValueError("Missing the required parameter `space_id` when calling `search`")
+        # verify the required parameter 'query' is set
+        if ('query' not in params or
+                params['query'] is None):
+            raise ValueError("Missing the required parameter `query` when calling `search`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
             query_params.append(('spaceId', params['space_id']))
-        if 'terminal_id' in params:
-            query_params.append(('terminalId', params['terminal_id']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+        if 'query' in params:
+            body_params = params['query']
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json;charset=utf-8'])
+
+        # HTTP header `Content-Type`
+        header_params['Content-Type'] = self.api_client.select_header_content_type(
+            ['application/json;charset=utf-8'])
+
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/payment-terminal/trigger-final-balance', 'POST',
+            '/customer-comment/search', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type=None,
+            response_type='list[CustomerComment]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def trigger_final_balance_by_identifier(self, space_id, terminal_identifier, **kwargs):
-        """Remotely Trigger Final Balance By Identifier
+    def unpin_comment(self, space_id, id, **kwargs):
+        """unpinComment
 
-        Remotely triggers the final balance receipt on the terminal by terminal identifier.
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
         
-        >>> thread = api.trigger_final_balance_by_identifier(space_id, terminal_identifier, async_req=True)
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.unpin_comment(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param str terminal_identifier:  (required)
+        :param int id: The id of the customer comment to unpin. (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.trigger_final_balance_by_identifier_with_http_info(space_id, terminal_identifier, **kwargs)
+            return self.unpin_comment_with_http_info(space_id, id, **kwargs)
         else:
-            (data) = self.trigger_final_balance_by_identifier_with_http_info(space_id, terminal_identifier, **kwargs)
+            (data) = self.unpin_comment_with_http_info(space_id, id, **kwargs)
             return data
 
-    def trigger_final_balance_by_identifier_with_http_info(self, space_id, terminal_identifier, **kwargs):
-        """Remotely Trigger Final Balance By Identifier
+    def unpin_comment_with_http_info(self, space_id, id, **kwargs):
+        """unpinComment
 
-        Remotely triggers the final balance receipt on the terminal by terminal identifier.
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
         
-        >>> thread = api.trigger_final_balance_by_identifier_with_http_info(space_id, terminal_identifier, async_req=True)
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.unpin_comment_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param str terminal_identifier:  (required)
+        :param int id: The id of the customer comment to unpin. (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['space_id', 'terminal_identifier']
+        all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method trigger_final_balance_by_identifier" % key
+                    " to method unpin_comment" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `trigger_final_balance_by_identifier`")
-        # verify the required parameter 'terminal_identifier' is set
-        if ('terminal_identifier' not in params or
-                params['terminal_identifier'] is None):
-            raise ValueError("Missing the required parameter `terminal_identifier` when calling `trigger_final_balance_by_identifier`")
+            raise ValueError("Missing the required parameter `space_id` when calling `unpin_comment`")
+        # verify the required parameter 'id' is set
+        if ('id' not in params or
+                params['id'] is None):
+            raise ValueError("Missing the required parameter `id` when calling `unpin_comment`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
             query_params.append(('spaceId', params['space_id']))
-        if 'terminal_identifier' in params:
-            query_params.append(('terminalIdentifier', params['terminal_identifier']))
+        if 'id' in params:
+            query_params.append(('id', params['id']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json;charset=utf-8'])
+
+        # HTTP header `Content-Type`
+        header_params['Content-Type'] = self.api_client.select_header_content_type(
+            ['*/*'])
+
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/payment-terminal/trigger-final-balance-by-identifier', 'POST',
+            '/customer-comment/unpin-comment', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def unlink(self, space_id, terminal_id, **kwargs):
-        """Unlink Device With Terminal
+    def update(self, space_id, entity, **kwargs):
+        """Update
 
-        Unlinks the device from terminal.
+        This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.unlink(space_id, terminal_id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.update(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int terminal_id:  (required)
-        :return: None
+        :param CustomerCommentActive entity: The customer object with the properties which should be updated. (required)
+        :return: CustomerComment
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.unlink_with_http_info(space_id, terminal_id, **kwargs)
+            return self.update_with_http_info(space_id, entity, **kwargs)
         else:
-            (data) = self.unlink_with_http_info(space_id, terminal_id, **kwargs)
+            (data) = self.update_with_http_info(space_id, entity, **kwargs)
             return data
 
-    def unlink_with_http_info(self, space_id, terminal_id, **kwargs):
-        """Unlink Device With Terminal
+    def update_with_http_info(self, space_id, entity, **kwargs):
+        """Update
 
-        Unlinks the device from terminal.
+        This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.unlink_with_http_info(space_id, terminal_id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.update_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int terminal_id:  (required)
-        :return: None
+        :param CustomerCommentActive entity: The customer object with the properties which should be updated. (required)
+        :return: CustomerComment
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['space_id', 'terminal_id']
+        all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method unlink" % key
+                    " to method update" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `unlink`")
-        # verify the required parameter 'terminal_id' is set
-        if ('terminal_id' not in params or
-                params['terminal_id'] is None):
-            raise ValueError("Missing the required parameter `terminal_id` when calling `unlink`")
+            raise ValueError("Missing the required parameter `space_id` when calling `update`")
+        # verify the required parameter 'entity' is set
+        if ('entity' not in params or
+                params['entity'] is None):
+            raise ValueError("Missing the required parameter `entity` when calling `update`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
             query_params.append(('spaceId', params['space_id']))
-        if 'terminal_id' in params:
-            query_params.append(('terminalId', params['terminal_id']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+        if 'entity' in params:
+            body_params = params['entity']
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json;charset=utf-8'])
+
+        # HTTP header `Content-Type`
+        header_params['Content-Type'] = self.api_client.select_header_content_type(
+            ['application/json;charset=utf-8'])
+
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/payment-terminal/unlink', 'POST',
+            '/customer-comment/update', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type=None,
+            response_type='CustomerComment',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/payment_terminal_till_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/payment_terminal_till_service_api.py`

 * *Files 4% similar despite different names*

```diff
@@ -12,44 +12,43 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def perform_transaction(self, space_id, transaction_id, terminal_id, **kwargs):
         """Perform Payment Terminal Transaction
 
         Starts a payment terminal transaction and waits for its completion. If the call returns with a long polling timeout status, you may try again. The processing of the transaction will be picked up where it was left off.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        Time out for this request is 90 seconds.
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.perform_transaction(space_id, transaction_id, terminal_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int transaction_id: The ID of the transaction which is used to process with the terminal. (required)
         :param int terminal_id: The ID of the terminal which should be used to process the transaction. (required)
         :param str language: The language in which the messages should be rendered in.
         :return: Transaction
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        kwargs['request_timeout'] = 90
-        
+
+        kwargs['_request_timeout'] = 90
+
         if kwargs.get('async_req'):
             return self.perform_transaction_with_http_info(space_id, transaction_id, terminal_id, **kwargs)
         else:
             (data) = self.perform_transaction_with_http_info(space_id, transaction_id, terminal_id, **kwargs)
             return data
 
     def perform_transaction_with_http_info(self, space_id, transaction_id, terminal_id, **kwargs):
         """Perform Payment Terminal Transaction
 
         Starts a payment terminal transaction and waits for its completion. If the call returns with a long polling timeout status, you may try again. The processing of the transaction will be picked up where it was left off.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        Time out for this request is 90 seconds.
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.perform_transaction_with_http_info(space_id, transaction_id, terminal_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int transaction_id: The ID of the transaction which is used to process with the terminal. (required)
         :param int terminal_id: The ID of the terminal which should be used to process the transaction. (required)
@@ -59,15 +58,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'transaction_id', 'terminal_id', 'language']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method perform_transaction" % key
@@ -109,15 +108,15 @@
         body_params = None
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(
-            ['*/*'])
+            ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
             '/payment-terminal-till/perform-transaction', 'GET',
             path_params,
@@ -127,52 +126,51 @@
             post_params=form_params,
             files=local_var_files,
             response_type='Transaction',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def perform_transaction_by_identifier(self, space_id, transaction_id, terminal_identifier, **kwargs):
         """Perform Payment Terminal Transaction (using TID)
 
         Starts a payment terminal transaction and waits for its completion. If the call returns with a long polling timeout status, you may try again. The processing of the transaction will be picked up where it was left off.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        Time out for this request is 90 seconds.
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.perform_transaction_by_identifier(space_id, transaction_id, terminal_identifier, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int transaction_id: The ID of the transaction which is used to process with the terminal. (required)
         :param str terminal_identifier: The identifier (aka TID) of the terminal which should be used to process the transaction. (required)
         :param str language: The language in which the messages should be rendered in.
         :return: Transaction
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        kwargs['request_timeout'] = 90
-        
+
+        kwargs['_request_timeout'] = 90
+
         if kwargs.get('async_req'):
             return self.perform_transaction_by_identifier_with_http_info(space_id, transaction_id, terminal_identifier, **kwargs)
         else:
             (data) = self.perform_transaction_by_identifier_with_http_info(space_id, transaction_id, terminal_identifier, **kwargs)
             return data
 
     def perform_transaction_by_identifier_with_http_info(self, space_id, transaction_id, terminal_identifier, **kwargs):
         """Perform Payment Terminal Transaction (using TID)
 
         Starts a payment terminal transaction and waits for its completion. If the call returns with a long polling timeout status, you may try again. The processing of the transaction will be picked up where it was left off.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        Time out for this request is 90 seconds.
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.perform_transaction_by_identifier_with_http_info(space_id, transaction_id, terminal_identifier, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int transaction_id: The ID of the transaction which is used to process with the terminal. (required)
         :param str terminal_identifier: The identifier (aka TID) of the terminal which should be used to process the transaction. (required)
@@ -182,15 +180,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'transaction_id', 'terminal_identifier', 'language']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method perform_transaction_by_identifier" % key
@@ -232,15 +230,15 @@
         body_params = None
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(
-            ['*/*'])
+            ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
             '/payment-terminal-till/perform-transaction-by-identifier', 'GET',
             path_params,
@@ -250,9 +248,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='Transaction',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/payment_terminal_transaction_summary_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/subscription_ledger_entry_service_api.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,52 +2,50 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class PaymentTerminalTransactionSummaryServiceApi:
+class SubscriptionLedgerEntryServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -99,96 +97,94 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/payment-terminal-transaction-summary/count', 'POST',
+            '/subscription-ledger-entry/count', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def fetch_receipt(self, space_id, request, **kwargs):
-        """Fetch Receipt
+    def create(self, space_id, entry, **kwargs):
+        """Create
 
-        Returns the terminal receipt corresponding to the specified transaction summary id.
+        The create operation creates a new subscription ledger entry.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.fetch_receipt(space_id, request, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.create(space_id, entry, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param PaymentTerminalTransactionSummaryFetchRequest request:  (required)
-        :return: RenderedTerminalTransactionSummary
+        :param SubscriptionLedgerEntryCreate entry:  (required)
+        :return: SubscriptionLedgerEntry
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.fetch_receipt_with_http_info(space_id, request, **kwargs)
+            return self.create_with_http_info(space_id, entry, **kwargs)
         else:
-            (data) = self.fetch_receipt_with_http_info(space_id, request, **kwargs)
+            (data) = self.create_with_http_info(space_id, entry, **kwargs)
             return data
 
-    def fetch_receipt_with_http_info(self, space_id, request, **kwargs):
-        """Fetch Receipt
+    def create_with_http_info(self, space_id, entry, **kwargs):
+        """Create
 
-        Returns the terminal receipt corresponding to the specified transaction summary id.
+        The create operation creates a new subscription ledger entry.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.fetch_receipt_with_http_info(space_id, request, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.create_with_http_info(space_id, entry, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param PaymentTerminalTransactionSummaryFetchRequest request:  (required)
-        :return: RenderedTerminalTransactionSummary
+        :param SubscriptionLedgerEntryCreate entry:  (required)
+        :return: SubscriptionLedgerEntry
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['space_id', 'request']
+        all_params = ['space_id', 'entry']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method fetch_receipt" % key
+                    " to method create" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `fetch_receipt`")
-        # verify the required parameter 'request' is set
-        if ('request' not in params or
-                params['request'] is None):
-            raise ValueError("Missing the required parameter `request` when calling `fetch_receipt`")
+            raise ValueError("Missing the required parameter `space_id` when calling `create`")
+        # verify the required parameter 'entry' is set
+        if ('entry' not in params or
+                params['entry'] is None):
+            raise ValueError("Missing the required parameter `entry` when calling `create`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
@@ -196,92 +192,90 @@
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'request' in params:
-            body_params = params['request']
+        if 'entry' in params:
+            body_params = params['entry']
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/payment-terminal-transaction-summary/fetch-receipt', 'POST',
+            '/subscription-ledger-entry/create', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='RenderedTerminalTransactionSummary',
+            response_type='SubscriptionLedgerEntry',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the transaction summary report which should be returned. (required)
-        :return: PaymentTerminalTransactionSummary
+        :param int id: The id of the subscription charge which should be returned. (required)
+        :return: SubscriptionLedgerEntry
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the transaction summary report which should be returned. (required)
-        :return: PaymentTerminalTransactionSummary
+        :param int id: The id of the subscription charge which should be returned. (required)
+        :return: SubscriptionLedgerEntry
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -321,78 +315,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/payment-terminal-transaction-summary/read', 'GET',
+            '/subscription-ledger-entry/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='PaymentTerminalTransactionSummary',
+            response_type='SubscriptionLedgerEntry',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the transaction summary reports which are returned by the search. (required)
-        :return: list[PaymentTerminalTransactionSummary]
+        :param EntityQuery query: The query restricts the subscription charges which are returned by the search. (required)
+        :return: list[SubscriptionLedgerEntry]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the transaction summary reports which are returned by the search. (required)
-        :return: list[PaymentTerminalTransactionSummary]
+        :param EntityQuery query: The query restricts the subscription charges which are returned by the search. (required)
+        :return: list[SubscriptionLedgerEntry]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -432,21 +424,21 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/payment-terminal-transaction-summary/search', 'POST',
+            '/subscription-ledger-entry/search', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[PaymentTerminalTransactionSummary]',
+            response_type='list[SubscriptionLedgerEntry]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/payment_web_app_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/payment_web_app_service_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -12,42 +12,40 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def activate_processor_for_production(self, space_id, external_id, **kwargs):
         """Activate Processor for Production
 
         This operation marks the processor to be usable within the production environment.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.activate_processor_for_production(space_id, external_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id: The space ID identifies the space in which the processor is installed in. (required)
         :param str external_id: The external ID identifies the processor. The external ID corresponds to the ID provided during inserting of the processor. (required)
         :return: PaymentAppProcessor
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.activate_processor_for_production_with_http_info(space_id, external_id, **kwargs)
         else:
             (data) = self.activate_processor_for_production_with_http_info(space_id, external_id, **kwargs)
             return data
 
     def activate_processor_for_production_with_http_info(self, space_id, external_id, **kwargs):
         """Activate Processor for Production
 
         This operation marks the processor to be usable within the production environment.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.activate_processor_for_production_with_http_info(space_id, external_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id: The space ID identifies the space in which the processor is installed in. (required)
         :param str external_id: The external ID identifies the processor. The external ID corresponds to the ID provided during inserting of the processor. (required)
         :return: PaymentAppProcessor
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'external_id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method activate_processor_for_production" % key
@@ -111,50 +109,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='PaymentAppProcessor',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def delete_connector(self, space_id, external_id, **kwargs):
         """Delete Connector
 
         This operation removes the web app payment connector from the given space.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_connector(space_id, external_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id: The space ID identifies the space in which the connector is installed in. (required)
         :param str external_id: The external ID identifies the connector. The external ID corresponds to the ID provided during inserting of the connector. (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.delete_connector_with_http_info(space_id, external_id, **kwargs)
         else:
             (data) = self.delete_connector_with_http_info(space_id, external_id, **kwargs)
             return data
 
     def delete_connector_with_http_info(self, space_id, external_id, **kwargs):
         """Delete Connector
 
         This operation removes the web app payment connector from the given space.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_connector_with_http_info(space_id, external_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id: The space ID identifies the space in which the connector is installed in. (required)
         :param str external_id: The external ID identifies the connector. The external ID corresponds to the ID provided during inserting of the connector. (required)
         :return: None
@@ -162,15 +158,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'external_id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete_connector" % key
@@ -214,50 +210,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def delete_processor(self, space_id, external_id, **kwargs):
         """Delete Processor
 
         This operation removes the web app payment processor and its connectors from the given space.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_processor(space_id, external_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id: The space ID identifies the space in which the processor is installed in. (required)
         :param str external_id: The external ID identifies the processor. The external ID corresponds to the ID provided during inserting of the processor. (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.delete_processor_with_http_info(space_id, external_id, **kwargs)
         else:
             (data) = self.delete_processor_with_http_info(space_id, external_id, **kwargs)
             return data
 
     def delete_processor_with_http_info(self, space_id, external_id, **kwargs):
         """Delete Processor
 
         This operation removes the web app payment processor and its connectors from the given space.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_processor_with_http_info(space_id, external_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id: The space ID identifies the space in which the processor is installed in. (required)
         :param str external_id: The external ID identifies the processor. The external ID corresponds to the ID provided during inserting of the processor. (required)
         :return: None
@@ -265,15 +259,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'external_id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete_processor" % key
@@ -317,50 +311,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def insert_or_update_connector(self, space_id, request, **kwargs):
         """Insert or Update Connector
 
         This operation inserts or updates a web app payment connector.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.insert_or_update_connector(space_id, request, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id: The space ID identifies the space into which the connector should be inserted into. (required)
         :param PaymentAppConnectorCreationRequest request: The connector object contains all the details required to create or update a web app connector. (required)
         :return: PaymentAppConnector
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.insert_or_update_connector_with_http_info(space_id, request, **kwargs)
         else:
             (data) = self.insert_or_update_connector_with_http_info(space_id, request, **kwargs)
             return data
 
     def insert_or_update_connector_with_http_info(self, space_id, request, **kwargs):
         """Insert or Update Connector
 
         This operation inserts or updates a web app payment connector.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.insert_or_update_connector_with_http_info(space_id, request, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id: The space ID identifies the space into which the connector should be inserted into. (required)
         :param PaymentAppConnectorCreationRequest request: The connector object contains all the details required to create or update a web app connector. (required)
         :return: PaymentAppConnector
@@ -368,15 +360,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'request']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method insert_or_update_connector" % key
@@ -420,50 +412,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='PaymentAppConnector',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def insert_or_update_processor(self, space_id, request, **kwargs):
         """Insert or Update Processor
 
         This operation inserts or updates a web app payment processor.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.insert_or_update_processor(space_id, request, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id: The space ID identifies the space into which the processor should be inserted into. (required)
         :param PaymentAppProcessorCreationRequest request: The processor object contains all the details required to create or update a web app processor. (required)
         :return: PaymentAppProcessor
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.insert_or_update_processor_with_http_info(space_id, request, **kwargs)
         else:
             (data) = self.insert_or_update_processor_with_http_info(space_id, request, **kwargs)
             return data
 
     def insert_or_update_processor_with_http_info(self, space_id, request, **kwargs):
         """Insert or Update Processor
 
         This operation inserts or updates a web app payment processor.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.insert_or_update_processor_with_http_info(space_id, request, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id: The space ID identifies the space into which the processor should be inserted into. (required)
         :param PaymentAppProcessorCreationRequest request: The processor object contains all the details required to create or update a web app processor. (required)
         :return: PaymentAppProcessor
@@ -471,15 +461,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'request']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method insert_or_update_processor" % key
@@ -523,50 +513,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='PaymentAppProcessor',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def update_charge_attempt(self, space_id, request, **kwargs):
         """Update Charge Attempt
 
         This operation updates the state of the charge attempt. This method can be invoked for transactions originally created with a processor associated with the web app that invokes this operation. The returned charge attempt corresponds to the charge attempt indicated in the request.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_charge_attempt(space_id, request, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id: This is the ID of the space in which the charge attempt is located in. (required)
         :param PaymentAppChargeAttemptUpdateRequest request: The charge attempt update request allows to update the state of a charge attempt. (required)
         :return: ChargeAttempt
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.update_charge_attempt_with_http_info(space_id, request, **kwargs)
         else:
             (data) = self.update_charge_attempt_with_http_info(space_id, request, **kwargs)
             return data
 
     def update_charge_attempt_with_http_info(self, space_id, request, **kwargs):
         """Update Charge Attempt
 
         This operation updates the state of the charge attempt. This method can be invoked for transactions originally created with a processor associated with the web app that invokes this operation. The returned charge attempt corresponds to the charge attempt indicated in the request.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_charge_attempt_with_http_info(space_id, request, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id: This is the ID of the space in which the charge attempt is located in. (required)
         :param PaymentAppChargeAttemptUpdateRequest request: The charge attempt update request allows to update the state of a charge attempt. (required)
         :return: ChargeAttempt
@@ -574,15 +562,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'request']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update_charge_attempt" % key
@@ -626,50 +614,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='ChargeAttempt',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def update_completion(self, space_id, request, **kwargs):
         """Update Completion
 
         This operation updates the state of the transaction completion. This method can be invoked for transactions originally created with a processor associated with the web app that invokes this operation. The returned completion corresponds to the completion indicated in the request.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_completion(space_id, request, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id: This is the ID of the space in which the completion is located in. (required)
         :param PaymentAppCompletionUpdateRequest request: The completion update request allows to update the state of a completion. (required)
         :return: TransactionCompletion
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.update_completion_with_http_info(space_id, request, **kwargs)
         else:
             (data) = self.update_completion_with_http_info(space_id, request, **kwargs)
             return data
 
     def update_completion_with_http_info(self, space_id, request, **kwargs):
         """Update Completion
 
         This operation updates the state of the transaction completion. This method can be invoked for transactions originally created with a processor associated with the web app that invokes this operation. The returned completion corresponds to the completion indicated in the request.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_completion_with_http_info(space_id, request, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id: This is the ID of the space in which the completion is located in. (required)
         :param PaymentAppCompletionUpdateRequest request: The completion update request allows to update the state of a completion. (required)
         :return: TransactionCompletion
@@ -677,15 +663,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'request']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update_completion" % key
@@ -729,50 +715,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='TransactionCompletion',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def update_refund(self, space_id, request, **kwargs):
         """Update Refund
 
         This operation updates the state of the refund. This method can be invoked for transactions originally created with a processor associated with the web app that invokes this operation. The returned refund corresponds to the refund indicated in the request.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_refund(space_id, request, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id: This is the ID of the space in which the refund is located in. (required)
         :param PaymentAppRefundUpdateRequest request: The refund update request allows to update the state of a refund. (required)
         :return: Refund
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.update_refund_with_http_info(space_id, request, **kwargs)
         else:
             (data) = self.update_refund_with_http_info(space_id, request, **kwargs)
             return data
 
     def update_refund_with_http_info(self, space_id, request, **kwargs):
         """Update Refund
 
         This operation updates the state of the refund. This method can be invoked for transactions originally created with a processor associated with the web app that invokes this operation. The returned refund corresponds to the refund indicated in the request.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_refund_with_http_info(space_id, request, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id: This is the ID of the space in which the refund is located in. (required)
         :param PaymentAppRefundUpdateRequest request: The refund update request allows to update the state of a refund. (required)
         :return: Refund
@@ -780,15 +764,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'request']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update_refund" % key
@@ -832,50 +816,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='Refund',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def update_void(self, space_id, request, **kwargs):
         """Update Void
 
         This operation updates the state of the transaction void. This method can be invoked for transactions originally created with a processor associated with the web app that invokes this operation. The returned void corresponds to the void indicated in the request.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_void(space_id, request, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id: This is the ID of the space in which the void is located in. (required)
         :param PaymentAppVoidUpdateRequest request: The void update request allows to update the state of a void. (required)
         :return: TransactionVoid
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.update_void_with_http_info(space_id, request, **kwargs)
         else:
             (data) = self.update_void_with_http_info(space_id, request, **kwargs)
             return data
 
     def update_void_with_http_info(self, space_id, request, **kwargs):
         """Update Void
 
         This operation updates the state of the transaction void. This method can be invoked for transactions originally created with a processor associated with the web app that invokes this operation. The returned void corresponds to the void indicated in the request.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_void_with_http_info(space_id, request, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id: This is the ID of the space in which the void is located in. (required)
         :param PaymentAppVoidUpdateRequest request: The void update request allows to update the state of a void. (required)
         :return: TransactionVoid
@@ -883,15 +865,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'request']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update_void" % key
@@ -935,9 +917,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='TransactionVoid',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/permission_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/debt_collector_service_api.py`

 * *Files 11% similar despite different names*

```diff
@@ -2,64 +2,62 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class PermissionServiceApi:
+class DebtCollectorServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
     def all(self, **kwargs):
         """All
 
         This operation returns all entities which are available.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.all(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :return: list[Permission]
+        :return: list[DebtCollector]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.all_with_http_info(**kwargs)
         else:
             (data) = self.all_with_http_info(**kwargs)
             return data
 
     def all_with_http_info(self, **kwargs):
         """All
 
         This operation returns all entities which are available.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.all_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :return: list[Permission]
+        :return: list[DebtCollector]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = []
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method all" % key
@@ -87,76 +85,74 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/permission/all', 'GET',
+            '/debt-collector/all', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[Permission]',
+            response_type='list[DebtCollector]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int id: The id of the permission which should be returned. (required)
-        :return: Permission
+        :param int id: The id of the collector which should be returned. (required)
+        :return: DebtCollector
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(id, **kwargs)
         else:
             (data) = self.read_with_http_info(id, **kwargs)
             return data
 
     def read_with_http_info(self, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int id: The id of the permission which should be returned. (required)
-        :return: Permission
+        :param int id: The id of the collector which should be returned. (required)
+        :return: DebtCollector
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -190,21 +186,21 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/permission/read', 'GET',
+            '/debt-collector/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='Permission',
+            response_type='DebtCollector',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/refund_bank_transaction_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/internal_transfer_bank_transaction_service_api.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,52 +2,50 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class RefundBankTransactionServiceApi:
+class InternalTransferBankTransactionServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -99,78 +97,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/refund-bank-transaction/count', 'POST',
+            '/internal-transfer-bank-transaction/count', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The ID of the refund bank transaction which should be returned. (required)
-        :return: RefundBankTransaction
+        :param int id: The ID of the internal transfer bank transaction which should be returned. (required)
+        :return: InternalTransferBankTransaction
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The ID of the refund bank transaction which should be returned. (required)
-        :return: RefundBankTransaction
+        :param int id: The ID of the internal transfer bank transaction which should be returned. (required)
+        :return: InternalTransferBankTransaction
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -210,78 +206,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/refund-bank-transaction/read', 'GET',
+            '/internal-transfer-bank-transaction/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='RefundBankTransaction',
+            response_type='InternalTransferBankTransaction',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the refund bank transactions which are returned by the search. (required)
-        :return: list[RefundBankTransaction]
+        :param EntityQuery query: The query restricts the internal transfer bank transactions which are returned by the search. (required)
+        :return: list[InternalTransferBankTransaction]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the refund bank transactions which are returned by the search. (required)
-        :return: list[RefundBankTransaction]
+        :param EntityQuery query: The query restricts the internal transfer bank transactions which are returned by the search. (required)
+        :return: list[InternalTransferBankTransaction]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -321,21 +315,21 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/refund-bank-transaction/search', 'POST',
+            '/internal-transfer-bank-transaction/search', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[RefundBankTransaction]',
+            response_type='list[InternalTransferBankTransaction]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/refund_comment_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/refund_comment_service_api.py`

 * *Files 4% similar despite different names*

```diff
@@ -12,42 +12,40 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def all(self, space_id, refund_id, **kwargs):
         """Find by refund
 
         Returns all comments of the given refund.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.all(space_id, refund_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int refund_id:  (required)
         :return: list[RefundComment]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.all_with_http_info(space_id, refund_id, **kwargs)
         else:
             (data) = self.all_with_http_info(space_id, refund_id, **kwargs)
             return data
 
     def all_with_http_info(self, space_id, refund_id, **kwargs):
         """Find by refund
 
         Returns all comments of the given refund.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.all_with_http_info(space_id, refund_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int refund_id:  (required)
         :return: list[RefundComment]
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'refund_id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method all" % key
@@ -115,50 +113,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[RefundComment]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def create(self, space_id, entity, **kwargs):
         """Create
 
         Creates the comment with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param RefundCommentCreate entity:  (required)
         :return: RefundComment
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.create_with_http_info(space_id, entity, **kwargs)
         else:
             (data) = self.create_with_http_info(space_id, entity, **kwargs)
             return data
 
     def create_with_http_info(self, space_id, entity, **kwargs):
         """Create
 
         Creates the comment with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param RefundCommentCreate entity:  (required)
         :return: RefundComment
@@ -166,15 +162,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create" % key
@@ -226,50 +222,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='RefundComment',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def delete(self, space_id, id, **kwargs):
         """Delete
 
         Deletes the comment with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id:  (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.delete_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.delete_with_http_info(space_id, id, **kwargs)
             return data
 
     def delete_with_http_info(self, space_id, id, **kwargs):
         """Delete
 
         Deletes the comment with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id:  (required)
         :return: None
@@ -277,15 +271,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete" % key
@@ -337,50 +331,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def pin(self, space_id, id, **kwargs):
         """Pin
 
         Pins the comment to the top.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.pin(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id:  (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.pin_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.pin_with_http_info(space_id, id, **kwargs)
             return data
 
     def pin_with_http_info(self, space_id, id, **kwargs):
         """Pin
 
         Pins the comment to the top.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.pin_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id:  (required)
         :return: None
@@ -388,15 +380,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method pin" % key
@@ -448,50 +440,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the comment with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id:  (required)
         :return: RefundComment
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the comment with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id:  (required)
         :return: RefundComment
@@ -499,15 +489,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -559,50 +549,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='RefundComment',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def unpin(self, space_id, id, **kwargs):
         """Unpin
 
         Unpins the comment from the top.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.unpin(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id:  (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.unpin_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.unpin_with_http_info(space_id, id, **kwargs)
             return data
 
     def unpin_with_http_info(self, space_id, id, **kwargs):
         """Unpin
 
         Unpins the comment from the top.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.unpin_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id:  (required)
         :return: None
@@ -610,15 +598,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method unpin" % key
@@ -670,50 +658,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def update(self, space_id, entity, **kwargs):
         """Update
 
         This updates the comment with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the comment.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param RefundCommentActive entity:  (required)
         :return: RefundComment
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.update_with_http_info(space_id, entity, **kwargs)
         else:
             (data) = self.update_with_http_info(space_id, entity, **kwargs)
             return data
 
     def update_with_http_info(self, space_id, entity, **kwargs):
         """Update
 
         This updates the comment with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the comment.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param RefundCommentActive entity:  (required)
         :return: RefundComment
@@ -721,15 +707,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update" % key
@@ -781,9 +767,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='RefundComment',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/refund_recovery_bank_transaction_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/refund_recovery_bank_transaction_service_api.py`

 * *Files 5% similar despite different names*

```diff
@@ -12,42 +12,40 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -111,50 +109,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The ID of the refund recovery bank transaction which should be returned. (required)
         :return: RefundRecoveryBankTransaction
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The ID of the refund recovery bank transaction which should be returned. (required)
         :return: RefundRecoveryBankTransaction
@@ -162,15 +158,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -222,50 +218,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='RefundRecoveryBankTransaction',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the refund recovery bank transactions which are returned by the search. (required)
         :return: list[RefundRecoveryBankTransaction]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the refund recovery bank transactions which are returned by the search. (required)
         :return: list[RefundRecoveryBankTransaction]
@@ -273,15 +267,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -333,9 +327,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[RefundRecoveryBankTransaction]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/refund_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/refund_service_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -12,42 +12,40 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -111,50 +109,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def fail(self, space_id, refund_id, **kwargs):
         """fail
 
         This operation allows to mark a refund as failed which is in state MANUAL_CHECK.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.fail(space_id, refund_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int refund_id: The id of the refund which should be marked as failed. (required)
         :return: Refund
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.fail_with_http_info(space_id, refund_id, **kwargs)
         else:
             (data) = self.fail_with_http_info(space_id, refund_id, **kwargs)
             return data
 
     def fail_with_http_info(self, space_id, refund_id, **kwargs):
         """fail
 
         This operation allows to mark a refund as failed which is in state MANUAL_CHECK.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.fail_with_http_info(space_id, refund_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int refund_id: The id of the refund which should be marked as failed. (required)
         :return: Refund
@@ -162,15 +158,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'refund_id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method fail" % key
@@ -218,50 +214,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='Refund',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def get_refund_document(self, space_id, id, **kwargs):
         """getRefundDocument
 
         Returns the PDF document for the refund with given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_refund_document(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the refund to get the document for. (required)
         :return: RenderedDocument
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.get_refund_document_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.get_refund_document_with_http_info(space_id, id, **kwargs)
             return data
 
     def get_refund_document_with_http_info(self, space_id, id, **kwargs):
         """getRefundDocument
 
         Returns the PDF document for the refund with given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_refund_document_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the refund to get the document for. (required)
         :return: RenderedDocument
@@ -269,15 +263,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_refund_document" % key
@@ -329,51 +323,49 @@
             post_params=form_params,
             files=local_var_files,
             response_type='RenderedDocument',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def get_refund_document_with_target_media_type(self, space_id, id, target_media_type_id, **kwargs):
         """getRefundDocumentWithTargetMediaType
 
         Returns the PDF document for the refund with given id and the given target media type.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_refund_document_with_target_media_type(space_id, id, target_media_type_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the refund to get the document for. (required)
         :param int target_media_type_id: The id of the target media type for which the refund should be generated for. (required)
         :return: RenderedDocument
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.get_refund_document_with_target_media_type_with_http_info(space_id, id, target_media_type_id, **kwargs)
         else:
             (data) = self.get_refund_document_with_target_media_type_with_http_info(space_id, id, target_media_type_id, **kwargs)
             return data
 
     def get_refund_document_with_target_media_type_with_http_info(self, space_id, id, target_media_type_id, **kwargs):
         """getRefundDocumentWithTargetMediaType
 
         Returns the PDF document for the refund with given id and the given target media type.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_refund_document_with_target_media_type_with_http_info(space_id, id, target_media_type_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the refund to get the document for. (required)
         :param int target_media_type_id: The id of the target media type for which the refund should be generated for. (required)
@@ -382,15 +374,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id', 'target_media_type_id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_refund_document_with_target_media_type" % key
@@ -448,50 +440,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='RenderedDocument',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the refund which should be returned. (required)
         :return: Refund
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the refund which should be returned. (required)
         :return: Refund
@@ -499,15 +489,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -559,50 +549,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='Refund',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def refund(self, space_id, refund, **kwargs):
         """create
 
         This operation creates and executes a refund of a particular transaction.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.refund(space_id, refund, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param RefundCreate refund: The refund object which should be created. (required)
         :return: Refund
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.refund_with_http_info(space_id, refund, **kwargs)
         else:
             (data) = self.refund_with_http_info(space_id, refund, **kwargs)
             return data
 
     def refund_with_http_info(self, space_id, refund, **kwargs):
         """create
 
         This operation creates and executes a refund of a particular transaction.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.refund_with_http_info(space_id, refund, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param RefundCreate refund: The refund object which should be created. (required)
         :return: Refund
@@ -610,15 +598,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'refund']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method refund" % key
@@ -670,50 +658,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='Refund',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the refunds which are returned by the search. (required)
         :return: list[Refund]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the refunds which are returned by the search. (required)
         :return: list[Refund]
@@ -721,15 +707,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -781,50 +767,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[Refund]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def succeed(self, space_id, refund_id, **kwargs):
         """succeed
 
         This operation allows to mark a refund as successful which is in state MANUAL_CHECK.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.succeed(space_id, refund_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int refund_id: The id of the refund which should be marked as successful. (required)
         :return: Refund
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.succeed_with_http_info(space_id, refund_id, **kwargs)
         else:
             (data) = self.succeed_with_http_info(space_id, refund_id, **kwargs)
             return data
 
     def succeed_with_http_info(self, space_id, refund_id, **kwargs):
         """succeed
 
         This operation allows to mark a refund as successful which is in state MANUAL_CHECK.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.succeed_with_http_info(space_id, refund_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int refund_id: The id of the refund which should be marked as successful. (required)
         :return: Refund
@@ -832,15 +816,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'refund_id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method succeed" % key
@@ -888,9 +872,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='Refund',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/shopify_recurring_order_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/shopify_recurring_order_service_api.py`

 * *Files 5% similar despite different names*

```diff
@@ -12,42 +12,40 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -111,50 +109,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the Shopify recurring order which should be returned. (required)
         :return: ShopifyRecurringOrder
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the Shopify recurring order which should be returned. (required)
         :return: ShopifyRecurringOrder
@@ -162,15 +158,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -222,50 +218,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='ShopifyRecurringOrder',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the Shopify recurring orders which are returned by the search. (required)
         :return: list[ShopifyRecurringOrder]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the Shopify recurring orders which are returned by the search. (required)
         :return: list[ShopifyRecurringOrder]
@@ -273,15 +267,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -333,50 +327,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[ShopifyRecurringOrder]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def update(self, space_id, update_request, **kwargs):
         """Update
 
         This operation allows to update a Shopify recurring order.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update(space_id, update_request, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param ShopifyRecurringOrderUpdateRequest update_request:  (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.update_with_http_info(space_id, update_request, **kwargs)
         else:
             (data) = self.update_with_http_info(space_id, update_request, **kwargs)
             return data
 
     def update_with_http_info(self, space_id, update_request, **kwargs):
         """Update
 
         This operation allows to update a Shopify recurring order.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_with_http_info(space_id, update_request, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param ShopifyRecurringOrderUpdateRequest update_request:  (required)
         :return: None
@@ -384,15 +376,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'update_request']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update" % key
@@ -444,9 +436,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/shopify_subscriber_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/shopify_subscriber_service_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -12,42 +12,40 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -111,50 +109,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the Shopify subscriber which should be returned. (required)
         :return: ShopifySubscriber
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the Shopify subscriber which should be returned. (required)
         :return: ShopifySubscriber
@@ -162,15 +158,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -222,50 +218,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='ShopifySubscriber',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the Shopify subscribers which are returned by the search. (required)
         :return: list[ShopifySubscriber]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the Shopify subscribers which are returned by the search. (required)
         :return: list[ShopifySubscriber]
@@ -273,15 +267,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -333,50 +327,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[ShopifySubscriber]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def update(self, space_id, query, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param ShopifySubscriberActive query: The Shopify subscriber object with all the properties which should be updated. The id and the version are required properties. (required)
         :return: ShopifySubscriber
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.update_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.update_with_http_info(space_id, query, **kwargs)
             return data
 
     def update_with_http_info(self, space_id, query, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param ShopifySubscriberActive query: The Shopify subscriber object with all the properties which should be updated. The id and the version are required properties. (required)
         :return: ShopifySubscriber
@@ -384,15 +376,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update" % key
@@ -444,9 +436,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='ShopifySubscriber',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/shopify_subscription_product_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/subscription_product_version_service_api.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,52 +2,159 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class ShopifySubscriptionProductServiceApi:
+class SubscriptionProductVersionServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
+    def activate(self, space_id, product_version_id, **kwargs):
+        """activate
+
+        This operation activates a new product version.
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.activate(space_id, product_version_id, async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool
+        :param int space_id:  (required)
+        :param int product_version_id: The product version id identifies the product version which should be activated. (required)
+        :return: SubscriptionProductVersion
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+        kwargs['_return_http_data_only'] = True
+
+
+        if kwargs.get('async_req'):
+            return self.activate_with_http_info(space_id, product_version_id, **kwargs)
+        else:
+            (data) = self.activate_with_http_info(space_id, product_version_id, **kwargs)
+            return data
+
+    def activate_with_http_info(self, space_id, product_version_id, **kwargs):
+        """activate
+
+        This operation activates a new product version.
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.activate_with_http_info(space_id, product_version_id, async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool
+        :param int space_id:  (required)
+        :param int product_version_id: The product version id identifies the product version which should be activated. (required)
+        :return: SubscriptionProductVersion
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+
+        all_params = ['space_id', 'product_version_id']
+        all_params.append('async_req')
+        all_params.append('_return_http_data_only')
+        all_params.append('_preload_content')
+        all_params.append('_request_timeout')
+
+        params = locals()
+        for key, val in six.iteritems(params['kwargs']):
+            if key not in all_params:
+                raise TypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method activate" % key
+                )
+            params[key] = val
+        del params['kwargs']
+        # verify the required parameter 'space_id' is set
+        if ('space_id' not in params or
+                params['space_id'] is None):
+            raise ValueError("Missing the required parameter `space_id` when calling `activate`")
+        # verify the required parameter 'product_version_id' is set
+        if ('product_version_id' not in params or
+                params['product_version_id'] is None):
+            raise ValueError("Missing the required parameter `product_version_id` when calling `activate`")
+
+        collection_formats = {}
+
+        path_params = {}
+
+        query_params = []
+        if 'space_id' in params:
+            query_params.append(('spaceId', params['space_id']))
+        if 'product_version_id' in params:
+            query_params.append(('productVersionId', params['product_version_id']))
+
+        header_params = {}
+
+        form_params = []
+        local_var_files = {}
+
+        body_params = None
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json;charset=utf-8'])
+
+        # HTTP header `Content-Type`
+        header_params['Content-Type'] = self.api_client.select_header_content_type(
+            ['application/json;charset=utf-8'])
+
+        # Authentication setting
+        auth_settings = []
+
+        return self.api_client.call_api(
+            '/subscription-product-version/activate', 'POST',
+            path_params,
+            query_params,
+            header_params,
+            body=body_params,
+            post_params=form_params,
+            files=local_var_files,
+            response_type='SubscriptionProductVersion',
+            auth_settings=auth_settings,
+            async_req=params.get('async_req'),
+            _return_http_data_only=params.get('_return_http_data_only'),
+            _preload_content=params.get('_preload_content', True),
+            _request_timeout=params.get('_request_timeout'),
+            collection_formats=collection_formats)
+
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +162,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -99,78 +206,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/shopify-subscription-product/count', 'POST',
+            '/subscription-product-version/count', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def create(self, space_id, entity, **kwargs):
         """Create
 
         Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param ShopifySubscriptionProductCreate entity: The Shopify subscription product object with the properties which should be created. (required)
-        :return: ShopifySubscriptionProduct
+        :param SubscriptionProductVersionPending entity: The product version object with the properties which should be created. (required)
+        :return: SubscriptionProductVersion
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.create_with_http_info(space_id, entity, **kwargs)
         else:
             (data) = self.create_with_http_info(space_id, entity, **kwargs)
             return data
 
     def create_with_http_info(self, space_id, entity, **kwargs):
         """Create
 
         Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param ShopifySubscriptionProductCreate entity: The Shopify subscription product object with the properties which should be created. (required)
-        :return: ShopifySubscriptionProduct
+        :param SubscriptionProductVersionPending entity: The product version object with the properties which should be created. (required)
+        :return: SubscriptionProductVersion
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create" % key
@@ -210,78 +315,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/shopify-subscription-product/create', 'POST',
+            '/subscription-product-version/create', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ShopifySubscriptionProduct',
+            response_type='SubscriptionProductVersion',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the Shopify subscription product which should be returned. (required)
-        :return: ShopifySubscriptionProduct
+        :param int id: The id of the product version which should be returned. (required)
+        :return: SubscriptionProductVersion
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the Shopify subscription product which should be returned. (required)
-        :return: ShopifySubscriptionProduct
+        :param int id: The id of the product version which should be returned. (required)
+        :return: SubscriptionProductVersion
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -321,78 +424,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/shopify-subscription-product/read', 'GET',
+            '/subscription-product-version/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ShopifySubscriptionProduct',
+            response_type='SubscriptionProductVersion',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the Shopify subscription products which are returned by the search. (required)
-        :return: list[ShopifySubscriptionProduct]
+        :param EntityQuery query: The query restricts the product versions which are returned by the search. (required)
+        :return: list[SubscriptionProductVersion]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the Shopify subscription products which are returned by the search. (required)
-        :return: list[ShopifySubscriptionProduct]
+        :param EntityQuery query: The query restricts the product versions which are returned by the search. (required)
+        :return: list[SubscriptionProductVersion]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -432,78 +533,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/shopify-subscription-product/search', 'POST',
+            '/subscription-product-version/search', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[ShopifySubscriptionProduct]',
+            response_type='list[SubscriptionProductVersion]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def update(self, space_id, entity, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param ShopifySubscriptionProductUpdate entity: The Shopify subscription product object with all the properties which should be updated. The id and the version are required properties. (required)
-        :return: ShopifySubscriptionProduct
+        :param SubscriptionProductVersionPending entity: The product version object with all the properties which should be updated. The id and the version are required properties. (required)
+        :return: SubscriptionProductVersion
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.update_with_http_info(space_id, entity, **kwargs)
         else:
             (data) = self.update_with_http_info(space_id, entity, **kwargs)
             return data
 
     def update_with_http_info(self, space_id, entity, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param ShopifySubscriptionProductUpdate entity: The Shopify subscription product object with all the properties which should be updated. The id and the version are required properties. (required)
-        :return: ShopifySubscriptionProduct
+        :param SubscriptionProductVersionPending entity: The product version object with all the properties which should be updated. The id and the version are required properties. (required)
+        :return: SubscriptionProductVersion
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update" % key
@@ -543,21 +642,21 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/shopify-subscription-product/update', 'POST',
+            '/subscription-product-version/update', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ShopifySubscriptionProduct',
+            response_type='SubscriptionProductVersion',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/shopify_subscription_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/shopify_subscription_service_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -12,42 +12,40 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -111,50 +109,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def create(self, space_id, creation_request, **kwargs):
         """Create
 
         This operation allows to create a Shopify subscription.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create(space_id, creation_request, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param ShopifySubscriptionCreationRequest creation_request:  (required)
         :return: ShopifySubscriptionVersion
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.create_with_http_info(space_id, creation_request, **kwargs)
         else:
             (data) = self.create_with_http_info(space_id, creation_request, **kwargs)
             return data
 
     def create_with_http_info(self, space_id, creation_request, **kwargs):
         """Create
 
         This operation allows to create a Shopify subscription.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_with_http_info(space_id, creation_request, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param ShopifySubscriptionCreationRequest creation_request:  (required)
         :return: ShopifySubscriptionVersion
@@ -162,15 +158,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'creation_request']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create" % key
@@ -222,50 +218,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='ShopifySubscriptionVersion',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the Shopify subscription which should be returned. (required)
         :return: ShopifySubscription
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the Shopify subscription which should be returned. (required)
         :return: ShopifySubscription
@@ -273,15 +267,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -333,50 +327,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='ShopifySubscription',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the Shopify subscriptions which are returned by the search. (required)
         :return: list[ShopifySubscription]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the Shopify subscriptions which are returned by the search. (required)
         :return: list[ShopifySubscription]
@@ -384,15 +376,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -444,51 +436,49 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[ShopifySubscription]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def terminate(self, space_id, subscription_id, respect_termination_period, **kwargs):
         """Terminate
 
         This operation allows to terminate a Shopify subscription.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.terminate(space_id, subscription_id, respect_termination_period, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int subscription_id: The ID identifies the Shopify subscription which should be terminated. (required)
         :param bool respect_termination_period: The respect termination period controls whether the termination period configured on the product version should be respected or if the operation should take effect immediately. (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.terminate_with_http_info(space_id, subscription_id, respect_termination_period, **kwargs)
         else:
             (data) = self.terminate_with_http_info(space_id, subscription_id, respect_termination_period, **kwargs)
             return data
 
     def terminate_with_http_info(self, space_id, subscription_id, respect_termination_period, **kwargs):
         """Terminate
 
         This operation allows to terminate a Shopify subscription.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.terminate_with_http_info(space_id, subscription_id, respect_termination_period, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int subscription_id: The ID identifies the Shopify subscription which should be terminated. (required)
         :param bool respect_termination_period: The respect termination period controls whether the termination period configured on the product version should be respected or if the operation should take effect immediately. (required)
@@ -497,15 +487,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'subscription_id', 'respect_termination_period']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method terminate" % key
@@ -559,50 +549,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def update(self, space_id, subscription, **kwargs):
         """Update
 
         This operation allows to update a Shopify subscription.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update(space_id, subscription, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param ShopifySubscriptionUpdateRequest subscription:  (required)
         :return: ShopifySubscriptionVersion
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.update_with_http_info(space_id, subscription, **kwargs)
         else:
             (data) = self.update_with_http_info(space_id, subscription, **kwargs)
             return data
 
     def update_with_http_info(self, space_id, subscription, **kwargs):
         """Update
 
         This operation allows to update a Shopify subscription.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_with_http_info(space_id, subscription, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param ShopifySubscriptionUpdateRequest subscription:  (required)
         :return: ShopifySubscriptionVersion
@@ -610,15 +598,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'subscription']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update" % key
@@ -670,50 +658,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='ShopifySubscriptionVersion',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def update_addresses(self, space_id, update_request, **kwargs):
         """Update Addresses
 
         This operation allows to update a Shopify subscription addresses.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_addresses(space_id, update_request, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param ShopifySubscriptionUpdateAddressesRequest update_request:  (required)
         :return: ShopifySubscriptionVersion
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.update_addresses_with_http_info(space_id, update_request, **kwargs)
         else:
             (data) = self.update_addresses_with_http_info(space_id, update_request, **kwargs)
             return data
 
     def update_addresses_with_http_info(self, space_id, update_request, **kwargs):
         """Update Addresses
 
         This operation allows to update a Shopify subscription addresses.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_addresses_with_http_info(space_id, update_request, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param ShopifySubscriptionUpdateAddressesRequest update_request:  (required)
         :return: ShopifySubscriptionVersion
@@ -721,15 +707,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'update_request']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update_addresses" % key
@@ -781,9 +767,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='ShopifySubscriptionVersion',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/shopify_subscription_suspension_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/shopify_subscription_suspension_service_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -12,42 +12,40 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -111,50 +109,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def reactivate(self, space_id, subscription_id, **kwargs):
         """Reactivate
 
         This operation allows to reactivate a suspended Shopify subscription.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.reactivate(space_id, subscription_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int subscription_id: The ID identifies the suspended Shopify subscription which should be reactivated. (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.reactivate_with_http_info(space_id, subscription_id, **kwargs)
         else:
             (data) = self.reactivate_with_http_info(space_id, subscription_id, **kwargs)
             return data
 
     def reactivate_with_http_info(self, space_id, subscription_id, **kwargs):
         """Reactivate
 
         This operation allows to reactivate a suspended Shopify subscription.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.reactivate_with_http_info(space_id, subscription_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int subscription_id: The ID identifies the suspended Shopify subscription which should be reactivated. (required)
         :return: None
@@ -162,15 +158,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'subscription_id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method reactivate" % key
@@ -218,50 +214,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the Shopify subscription suspension which should be returned. (required)
         :return: ShopifySubscriptionSuspension
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the Shopify subscription suspension which should be returned. (required)
         :return: ShopifySubscriptionSuspension
@@ -269,15 +263,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -329,50 +323,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='ShopifySubscriptionSuspension',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the Shopify subscription suspensions which are returned by the search. (required)
         :return: list[ShopifySubscriptionSuspension]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the Shopify subscription suspensions which are returned by the search. (required)
         :return: list[ShopifySubscriptionSuspension]
@@ -380,15 +372,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -440,50 +432,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[ShopifySubscriptionSuspension]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def suspend(self, space_id, suspension, **kwargs):
         """Suspend
 
         This operation allows to suspend a Shopify subscription.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.suspend(space_id, suspension, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param ShopifySubscriptionSuspensionCreate suspension:  (required)
         :return: ShopifySubscriptionSuspension
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.suspend_with_http_info(space_id, suspension, **kwargs)
         else:
             (data) = self.suspend_with_http_info(space_id, suspension, **kwargs)
             return data
 
     def suspend_with_http_info(self, space_id, suspension, **kwargs):
         """Suspend
 
         This operation allows to suspend a Shopify subscription.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.suspend_with_http_info(space_id, suspension, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param ShopifySubscriptionSuspensionCreate suspension:  (required)
         :return: ShopifySubscriptionSuspension
@@ -491,15 +481,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'suspension']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method suspend" % key
@@ -551,9 +541,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='ShopifySubscriptionSuspension',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/shopify_subscription_version_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/shopify_subscription_version_service_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -12,42 +12,40 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -111,50 +109,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the Shopify subscription version which should be returned. (required)
         :return: ShopifySubscriptionVersion
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the Shopify subscription version which should be returned. (required)
         :return: ShopifySubscriptionVersion
@@ -162,15 +158,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -222,50 +218,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='ShopifySubscriptionVersion',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the Shopify subscription versions which are returned by the search. (required)
         :return: list[ShopifySubscriptionVersion]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the Shopify subscription versions which are returned by the search. (required)
         :return: list[ShopifySubscriptionVersion]
@@ -273,15 +267,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -333,9 +327,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[ShopifySubscriptionVersion]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/shopify_transaction_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/shopify_transaction_service_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -12,42 +12,40 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -111,50 +109,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the Shopify transaction which should be returned. (required)
         :return: ShopifyTransaction
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the Shopify transaction which should be returned. (required)
         :return: ShopifyTransaction
@@ -162,15 +158,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -222,50 +218,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='ShopifyTransaction',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the Shopify transactions which are returned by the search. (required)
         :return: list[ShopifyTransaction]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the Shopify transactions which are returned by the search. (required)
         :return: list[ShopifyTransaction]
@@ -273,15 +267,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -333,9 +327,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[ShopifyTransaction]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/space_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/subscription_product_metered_fee_service_api.py`

 * *Files 9% similar despite different names*

```diff
@@ -2,82 +2,88 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class SpaceServiceApi:
+class SubscriptionProductMeteredFeeServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
-    def count(self, **kwargs):
+    def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.count(async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
+        :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.count_with_http_info(**kwargs)
+            return self.count_with_http_info(space_id, **kwargs)
         else:
-            (data) = self.count_with_http_info(**kwargs)
+            (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
-    def count_with_http_info(self, **kwargs):
+    def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.count_with_http_info(async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
+        :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['filter']
+        all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
                 )
             params[key] = val
         del params['kwargs']
+        # verify the required parameter 'space_id' is set
+        if ('space_id' not in params or
+                params['space_id'] is None):
+            raise ValueError("Missing the required parameter `space_id` when calling `count`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
+        if 'space_id' in params:
+            query_params.append(('spaceId', params['space_id']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
@@ -91,96 +97,102 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/space/count', 'POST',
+            '/subscription-product-metered-fee/count', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def create(self, entity, **kwargs):
+    def create(self, space_id, entity, **kwargs):
         """Create
 
         Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.create(entity, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.create(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param SpaceCreate entity: The space object with the properties which should be created. (required)
-        :return: Space
+        :param int space_id:  (required)
+        :param ProductMeteredFeeUpdate entity: The metered fee object with the properties which should be created. (required)
+        :return: ProductMeteredFee
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.create_with_http_info(entity, **kwargs)
+            return self.create_with_http_info(space_id, entity, **kwargs)
         else:
-            (data) = self.create_with_http_info(entity, **kwargs)
+            (data) = self.create_with_http_info(space_id, entity, **kwargs)
             return data
 
-    def create_with_http_info(self, entity, **kwargs):
+    def create_with_http_info(self, space_id, entity, **kwargs):
         """Create
 
         Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.create_with_http_info(entity, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.create_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param SpaceCreate entity: The space object with the properties which should be created. (required)
-        :return: Space
+        :param int space_id:  (required)
+        :param ProductMeteredFeeUpdate entity: The metered fee object with the properties which should be created. (required)
+        :return: ProductMeteredFee
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['entity']
+        all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create" % key
                 )
             params[key] = val
         del params['kwargs']
+        # verify the required parameter 'space_id' is set
+        if ('space_id' not in params or
+                params['space_id'] is None):
+            raise ValueError("Missing the required parameter `space_id` when calling `create`")
         # verify the required parameter 'entity' is set
         if ('entity' not in params or
                 params['entity'] is None):
             raise ValueError("Missing the required parameter `entity` when calling `create`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
+        if 'space_id' in params:
+            query_params.append(('spaceId', params['space_id']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
@@ -194,96 +206,102 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/space/create', 'POST',
+            '/subscription-product-metered-fee/create', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='Space',
+            response_type='ProductMeteredFee',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def delete(self, id, **kwargs):
+    def delete(self, space_id, id, **kwargs):
         """Delete
 
         Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.delete(id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.delete(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
+        :param int space_id:  (required)
         :param int id:  (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.delete_with_http_info(id, **kwargs)
+            return self.delete_with_http_info(space_id, id, **kwargs)
         else:
-            (data) = self.delete_with_http_info(id, **kwargs)
+            (data) = self.delete_with_http_info(space_id, id, **kwargs)
             return data
 
-    def delete_with_http_info(self, id, **kwargs):
+    def delete_with_http_info(self, space_id, id, **kwargs):
         """Delete
 
         Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.delete_with_http_info(id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.delete_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
+        :param int space_id:  (required)
         :param int id:  (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id']
+        all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete" % key
                 )
             params[key] = val
         del params['kwargs']
+        # verify the required parameter 'space_id' is set
+        if ('space_id' not in params or
+                params['space_id'] is None):
+            raise ValueError("Missing the required parameter `space_id` when calling `delete`")
         # verify the required parameter 'id' is set
         if ('id' not in params or
                 params['id'] is None):
             raise ValueError("Missing the required parameter `id` when calling `delete`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
+        if 'space_id' in params:
+            query_params.append(('spaceId', params['space_id']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
@@ -297,96 +315,102 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/space/delete', 'POST',
+            '/subscription-product-metered-fee/delete', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def read(self, id, **kwargs):
+    def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.read(id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int id: The id of the space which should be returned. (required)
-        :return: Space
+        :param int space_id:  (required)
+        :param int id: The id of the metered fee which should be returned. (required)
+        :return: ProductMeteredFee
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.read_with_http_info(id, **kwargs)
+            return self.read_with_http_info(space_id, id, **kwargs)
         else:
-            (data) = self.read_with_http_info(id, **kwargs)
+            (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
-    def read_with_http_info(self, id, **kwargs):
+    def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.read_with_http_info(id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int id: The id of the space which should be returned. (required)
-        :return: Space
+        :param int space_id:  (required)
+        :param int id: The id of the metered fee which should be returned. (required)
+        :return: ProductMeteredFee
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id']
+        all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
                 )
             params[key] = val
         del params['kwargs']
+        # verify the required parameter 'space_id' is set
+        if ('space_id' not in params or
+                params['space_id'] is None):
+            raise ValueError("Missing the required parameter `space_id` when calling `read`")
         # verify the required parameter 'id' is set
         if ('id' not in params or
                 params['id'] is None):
             raise ValueError("Missing the required parameter `id` when calling `read`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
+        if 'space_id' in params:
+            query_params.append(('spaceId', params['space_id']))
         if 'id' in params:
             query_params.append(('id', params['id']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
@@ -400,96 +424,102 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/space/read', 'GET',
+            '/subscription-product-metered-fee/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='Space',
+            response_type='ProductMeteredFee',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def search(self, query, **kwargs):
+    def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.search(query, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param EntityQuery query: The query restricts the spaces which are returned by the search. (required)
-        :return: list[Space]
+        :param int space_id:  (required)
+        :param EntityQuery query: The query restricts the metered fees which are returned by the search. (required)
+        :return: list[ProductMeteredFee]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.search_with_http_info(query, **kwargs)
+            return self.search_with_http_info(space_id, query, **kwargs)
         else:
-            (data) = self.search_with_http_info(query, **kwargs)
+            (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
-    def search_with_http_info(self, query, **kwargs):
+    def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.search_with_http_info(query, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param EntityQuery query: The query restricts the spaces which are returned by the search. (required)
-        :return: list[Space]
+        :param int space_id:  (required)
+        :param EntityQuery query: The query restricts the metered fees which are returned by the search. (required)
+        :return: list[ProductMeteredFee]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['query']
+        all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
                 )
             params[key] = val
         del params['kwargs']
+        # verify the required parameter 'space_id' is set
+        if ('space_id' not in params or
+                params['space_id'] is None):
+            raise ValueError("Missing the required parameter `space_id` when calling `search`")
         # verify the required parameter 'query' is set
         if ('query' not in params or
                 params['query'] is None):
             raise ValueError("Missing the required parameter `query` when calling `search`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
+        if 'space_id' in params:
+            query_params.append(('spaceId', params['space_id']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
@@ -503,96 +533,102 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/space/search', 'POST',
+            '/subscription-product-metered-fee/search', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[Space]',
+            response_type='list[ProductMeteredFee]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def update(self, entity, **kwargs):
+    def update(self, space_id, entity, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.update(entity, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.update(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param SpaceUpdate entity: The space object with all the properties which should be updated. The id and the version are required properties. (required)
-        :return: Space
+        :param int space_id:  (required)
+        :param ProductMeteredFeeUpdate entity: The metered fee object with all the properties which should be updated. The id and the version are required properties. (required)
+        :return: ProductMeteredFee
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.update_with_http_info(entity, **kwargs)
+            return self.update_with_http_info(space_id, entity, **kwargs)
         else:
-            (data) = self.update_with_http_info(entity, **kwargs)
+            (data) = self.update_with_http_info(space_id, entity, **kwargs)
             return data
 
-    def update_with_http_info(self, entity, **kwargs):
+    def update_with_http_info(self, space_id, entity, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.update_with_http_info(entity, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.update_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param SpaceUpdate entity: The space object with all the properties which should be updated. The id and the version are required properties. (required)
-        :return: Space
+        :param int space_id:  (required)
+        :param ProductMeteredFeeUpdate entity: The metered fee object with all the properties which should be updated. The id and the version are required properties. (required)
+        :return: ProductMeteredFee
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['entity']
+        all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update" % key
                 )
             params[key] = val
         del params['kwargs']
+        # verify the required parameter 'space_id' is set
+        if ('space_id' not in params or
+                params['space_id'] is None):
+            raise ValueError("Missing the required parameter `space_id` when calling `update`")
         # verify the required parameter 'entity' is set
         if ('entity' not in params or
                 params['entity'] is None):
             raise ValueError("Missing the required parameter `entity` when calling `update`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
+        if 'space_id' in params:
+            query_params.append(('spaceId', params['space_id']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
@@ -606,21 +642,21 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/space/update', 'POST',
+            '/subscription-product-metered-fee/update', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='Space',
+            response_type='ProductMeteredFee',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/static_value_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/condition_type_service_api.py`

 * *Files 16% similar despite different names*

```diff
@@ -2,64 +2,62 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class StaticValueServiceApi:
+class ConditionTypeServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
     def all(self, **kwargs):
         """All
 
         This operation returns all entities which are available.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.all(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :return: list[StaticValue]
+        :return: list[ConditionType]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.all_with_http_info(**kwargs)
         else:
             (data) = self.all_with_http_info(**kwargs)
             return data
 
     def all_with_http_info(self, **kwargs):
         """All
 
         This operation returns all entities which are available.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.all_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :return: list[StaticValue]
+        :return: list[ConditionType]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = []
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method all" % key
@@ -87,76 +85,74 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/static-value-service/all', 'GET',
+            '/condition-type/all', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[StaticValue]',
+            response_type='list[ConditionType]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int id: The id of the static value which should be returned. (required)
-        :return: StaticValue
+        :param int id: The id of the condition type which should be returned. (required)
+        :return: ConditionType
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(id, **kwargs)
         else:
             (data) = self.read_with_http_info(id, **kwargs)
             return data
 
     def read_with_http_info(self, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int id: The id of the static value which should be returned. (required)
-        :return: StaticValue
+        :param int id: The id of the condition type which should be returned. (required)
+        :return: ConditionType
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -190,21 +186,21 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/static-value-service/read', 'GET',
+            '/condition-type/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='StaticValue',
+            response_type='ConditionType',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/subscriber_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/subscriber_service_api.py`

 * *Files 4% similar despite different names*

```diff
@@ -12,42 +12,40 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -111,50 +109,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def create(self, space_id, entity, **kwargs):
         """Create
 
         Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param SubscriberCreate entity: The customer object with the properties which should be created. (required)
         :return: Subscriber
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.create_with_http_info(space_id, entity, **kwargs)
         else:
             (data) = self.create_with_http_info(space_id, entity, **kwargs)
             return data
 
     def create_with_http_info(self, space_id, entity, **kwargs):
         """Create
 
         Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param SubscriberCreate entity: The customer object with the properties which should be created. (required)
         :return: Subscriber
@@ -162,15 +158,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create" % key
@@ -222,50 +218,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='Subscriber',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def delete(self, space_id, id, **kwargs):
         """Delete
 
         Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id:  (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.delete_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.delete_with_http_info(space_id, id, **kwargs)
             return data
 
     def delete_with_http_info(self, space_id, id, **kwargs):
         """Delete
 
         Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id:  (required)
         :return: None
@@ -273,15 +267,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete" % key
@@ -333,50 +327,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the customer which should be returned. (required)
         :return: Subscriber
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the customer which should be returned. (required)
         :return: Subscriber
@@ -384,15 +376,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -444,50 +436,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='Subscriber',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the customer which are returned by the search. (required)
         :return: list[Subscriber]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the customer which are returned by the search. (required)
         :return: list[Subscriber]
@@ -495,15 +485,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -555,50 +545,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[Subscriber]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def update(self, space_id, entity, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param SubscriberUpdate entity: The customer with all the properties which should be updated. The id and the version are required properties. (required)
         :return: Subscriber
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.update_with_http_info(space_id, entity, **kwargs)
         else:
             (data) = self.update_with_http_info(space_id, entity, **kwargs)
             return data
 
     def update_with_http_info(self, space_id, entity, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param SubscriberUpdate entity: The customer with all the properties which should be updated. The id and the version are required properties. (required)
         :return: Subscriber
@@ -606,15 +594,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update" % key
@@ -666,9 +654,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='Subscriber',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/subscription_affiliate_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/subscription_affiliate_service_api.py`

 * *Files 5% similar despite different names*

```diff
@@ -12,42 +12,40 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -111,50 +109,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def create(self, space_id, entity, **kwargs):
         """Create
 
         Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param SubscriptionAffiliateCreate entity: The subscription affiliate object with the properties which should be created. (required)
         :return: SubscriptionAffiliate
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.create_with_http_info(space_id, entity, **kwargs)
         else:
             (data) = self.create_with_http_info(space_id, entity, **kwargs)
             return data
 
     def create_with_http_info(self, space_id, entity, **kwargs):
         """Create
 
         Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param SubscriptionAffiliateCreate entity: The subscription affiliate object with the properties which should be created. (required)
         :return: SubscriptionAffiliate
@@ -162,15 +158,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create" % key
@@ -222,50 +218,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='SubscriptionAffiliate',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def delete(self, space_id, id, **kwargs):
         """Delete
 
         Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id:  (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.delete_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.delete_with_http_info(space_id, id, **kwargs)
             return data
 
     def delete_with_http_info(self, space_id, id, **kwargs):
         """Delete
 
         Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id:  (required)
         :return: None
@@ -273,15 +267,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete" % key
@@ -333,50 +327,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the subscription affiliate case which should be returned. (required)
         :return: SubscriptionAffiliate
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the subscription affiliate case which should be returned. (required)
         :return: SubscriptionAffiliate
@@ -384,15 +376,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -444,50 +436,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='SubscriptionAffiliate',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the affiliates which are returned by the search. (required)
         :return: list[SubscriptionAffiliate]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the affiliates which are returned by the search. (required)
         :return: list[SubscriptionAffiliate]
@@ -495,15 +485,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -555,50 +545,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[SubscriptionAffiliate]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def update(self, space_id, entity, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param SubscriptionAffiliateUpdate entity: The object with all the properties which should be updated. The id and the version are required properties. (required)
         :return: SubscriptionAffiliate
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.update_with_http_info(space_id, entity, **kwargs)
         else:
             (data) = self.update_with_http_info(space_id, entity, **kwargs)
             return data
 
     def update_with_http_info(self, space_id, entity, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param SubscriptionAffiliateUpdate entity: The object with all the properties which should be updated. The id and the version are required properties. (required)
         :return: SubscriptionAffiliate
@@ -606,15 +594,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update" % key
@@ -666,9 +654,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='SubscriptionAffiliate',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/subscription_charge_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/payment_terminal_service_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,52 +2,50 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class SubscriptionChargeServiceApi:
+class PaymentTerminalServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -99,461 +97,449 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-charge/count', 'POST',
+            '/payment-terminal/count', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def create(self, space_id, charge, **kwargs):
-        """Create
+    def link(self, space_id, terminal_id, serial_number, **kwargs):
+        """Link Device With Terminal
 
-        The create operation creates a new subscription charge.
+        Links the device with given serial number with terminal.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.create(space_id, charge, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.link(space_id, terminal_id, serial_number, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param SubscriptionChargeCreate charge:  (required)
-        :return: SubscriptionCharge
+        :param int terminal_id:  (required)
+        :param str serial_number:  (required)
+        :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.create_with_http_info(space_id, charge, **kwargs)
+            return self.link_with_http_info(space_id, terminal_id, serial_number, **kwargs)
         else:
-            (data) = self.create_with_http_info(space_id, charge, **kwargs)
+            (data) = self.link_with_http_info(space_id, terminal_id, serial_number, **kwargs)
             return data
 
-    def create_with_http_info(self, space_id, charge, **kwargs):
-        """Create
+    def link_with_http_info(self, space_id, terminal_id, serial_number, **kwargs):
+        """Link Device With Terminal
 
-        The create operation creates a new subscription charge.
+        Links the device with given serial number with terminal.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.create_with_http_info(space_id, charge, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.link_with_http_info(space_id, terminal_id, serial_number, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param SubscriptionChargeCreate charge:  (required)
-        :return: SubscriptionCharge
+        :param int terminal_id:  (required)
+        :param str serial_number:  (required)
+        :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['space_id', 'charge']
+        all_params = ['space_id', 'terminal_id', 'serial_number']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method create" % key
+                    " to method link" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `create`")
-        # verify the required parameter 'charge' is set
-        if ('charge' not in params or
-                params['charge'] is None):
-            raise ValueError("Missing the required parameter `charge` when calling `create`")
+            raise ValueError("Missing the required parameter `space_id` when calling `link`")
+        # verify the required parameter 'terminal_id' is set
+        if ('terminal_id' not in params or
+                params['terminal_id'] is None):
+            raise ValueError("Missing the required parameter `terminal_id` when calling `link`")
+        # verify the required parameter 'serial_number' is set
+        if ('serial_number' not in params or
+                params['serial_number'] is None):
+            raise ValueError("Missing the required parameter `serial_number` when calling `link`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
             query_params.append(('spaceId', params['space_id']))
+        if 'terminal_id' in params:
+            query_params.append(('terminalId', params['terminal_id']))
+        if 'serial_number' in params:
+            query_params.append(('serialNumber', params['serial_number']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'charge' in params:
-            body_params = params['charge']
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json;charset=utf-8'])
-
-        # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(
-            ['application/json;charset=utf-8'])
-
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-charge/create', 'POST',
+            '/payment-terminal/link', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='SubscriptionCharge',
+            response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def discard(self, space_id, charge_id, **kwargs):
-        """discard
+    def read(self, space_id, id, **kwargs):
+        """Read
 
-        This operation allows to discard a scheduled charge.
+        Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.discard(space_id, charge_id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int charge_id:  (required)
-        :return: SubscriptionCharge
+        :param int id: The id of the payment terminal which should be returned. (required)
+        :return: PaymentTerminal
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.discard_with_http_info(space_id, charge_id, **kwargs)
+            return self.read_with_http_info(space_id, id, **kwargs)
         else:
-            (data) = self.discard_with_http_info(space_id, charge_id, **kwargs)
+            (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
-    def discard_with_http_info(self, space_id, charge_id, **kwargs):
-        """discard
+    def read_with_http_info(self, space_id, id, **kwargs):
+        """Read
 
-        This operation allows to discard a scheduled charge.
+        Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.discard_with_http_info(space_id, charge_id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int charge_id:  (required)
-        :return: SubscriptionCharge
+        :param int id: The id of the payment terminal which should be returned. (required)
+        :return: PaymentTerminal
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['space_id', 'charge_id']
+        all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method discard" % key
+                    " to method read" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `discard`")
-        # verify the required parameter 'charge_id' is set
-        if ('charge_id' not in params or
-                params['charge_id'] is None):
-            raise ValueError("Missing the required parameter `charge_id` when calling `discard`")
+            raise ValueError("Missing the required parameter `space_id` when calling `read`")
+        # verify the required parameter 'id' is set
+        if ('id' not in params or
+                params['id'] is None):
+            raise ValueError("Missing the required parameter `id` when calling `read`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
             query_params.append(('spaceId', params['space_id']))
-        if 'charge_id' in params:
-            query_params.append(('chargeId', params['charge_id']))
+        if 'id' in params:
+            query_params.append(('id', params['id']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
+        # HTTP header `Content-Type`
+        header_params['Content-Type'] = self.api_client.select_header_content_type(
+            ['*/*'])
+
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-charge/discard', 'POST',
+            '/payment-terminal/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='SubscriptionCharge',
+            response_type='PaymentTerminal',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def read(self, space_id, id, **kwargs):
-        """Read
+    def search(self, space_id, query, **kwargs):
+        """Search
 
-        Reads the entity with the given 'id' and returns it.
+        Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.read(space_id, id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the subscription charge which should be returned. (required)
-        :return: SubscriptionCharge
+        :param EntityQuery query: The query restricts the payment terminals which are returned by the search. (required)
+        :return: list[PaymentTerminal]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.read_with_http_info(space_id, id, **kwargs)
+            return self.search_with_http_info(space_id, query, **kwargs)
         else:
-            (data) = self.read_with_http_info(space_id, id, **kwargs)
+            (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
-    def read_with_http_info(self, space_id, id, **kwargs):
-        """Read
+    def search_with_http_info(self, space_id, query, **kwargs):
+        """Search
 
-        Reads the entity with the given 'id' and returns it.
+        Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.read_with_http_info(space_id, id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the subscription charge which should be returned. (required)
-        :return: SubscriptionCharge
+        :param EntityQuery query: The query restricts the payment terminals which are returned by the search. (required)
+        :return: list[PaymentTerminal]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['space_id', 'id']
+        all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method read" % key
+                    " to method search" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `read`")
-        # verify the required parameter 'id' is set
-        if ('id' not in params or
-                params['id'] is None):
-            raise ValueError("Missing the required parameter `id` when calling `read`")
+            raise ValueError("Missing the required parameter `space_id` when calling `search`")
+        # verify the required parameter 'query' is set
+        if ('query' not in params or
+                params['query'] is None):
+            raise ValueError("Missing the required parameter `query` when calling `search`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
             query_params.append(('spaceId', params['space_id']))
-        if 'id' in params:
-            query_params.append(('id', params['id']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+        if 'query' in params:
+            body_params = params['query']
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(
-            ['*/*'])
+            ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-charge/read', 'GET',
+            '/payment-terminal/search', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='SubscriptionCharge',
+            response_type='list[PaymentTerminal]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def search(self, space_id, query, **kwargs):
-        """Search
+    def unlink(self, space_id, terminal_id, **kwargs):
+        """Unlink Device With Terminal
 
-        Searches for the entities as specified by the given query.
+        Unlinks the device from terminal.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.search(space_id, query, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.unlink(space_id, terminal_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the subscription charges which are returned by the search. (required)
-        :return: list[SubscriptionCharge]
+        :param int terminal_id:  (required)
+        :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.search_with_http_info(space_id, query, **kwargs)
+            return self.unlink_with_http_info(space_id, terminal_id, **kwargs)
         else:
-            (data) = self.search_with_http_info(space_id, query, **kwargs)
+            (data) = self.unlink_with_http_info(space_id, terminal_id, **kwargs)
             return data
 
-    def search_with_http_info(self, space_id, query, **kwargs):
-        """Search
+    def unlink_with_http_info(self, space_id, terminal_id, **kwargs):
+        """Unlink Device With Terminal
 
-        Searches for the entities as specified by the given query.
+        Unlinks the device from terminal.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.search_with_http_info(space_id, query, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.unlink_with_http_info(space_id, terminal_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the subscription charges which are returned by the search. (required)
-        :return: list[SubscriptionCharge]
+        :param int terminal_id:  (required)
+        :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['space_id', 'query']
+        all_params = ['space_id', 'terminal_id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method search" % key
+                    " to method unlink" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `search`")
-        # verify the required parameter 'query' is set
-        if ('query' not in params or
-                params['query'] is None):
-            raise ValueError("Missing the required parameter `query` when calling `search`")
+            raise ValueError("Missing the required parameter `space_id` when calling `unlink`")
+        # verify the required parameter 'terminal_id' is set
+        if ('terminal_id' not in params or
+                params['terminal_id'] is None):
+            raise ValueError("Missing the required parameter `terminal_id` when calling `unlink`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
             query_params.append(('spaceId', params['space_id']))
+        if 'terminal_id' in params:
+            query_params.append(('terminalId', params['terminal_id']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'query' in params:
-            body_params = params['query']
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json;charset=utf-8'])
-
-        # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(
-            ['application/json;charset=utf-8'])
-
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-charge/search', 'POST',
+            '/payment-terminal/unlink', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[SubscriptionCharge]',
+            response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/subscription_ledger_entry_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/subscription_metric_usage_service_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,52 +2,50 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class SubscriptionLedgerEntryServiceApi:
+class SubscriptionMetricUsageServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -99,96 +97,94 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-ledger-entry/count', 'POST',
+            '/subscription-metric-usage/count', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def create(self, space_id, entry, **kwargs):
+    def create(self, space_id, usage_report, **kwargs):
         """Create
 
-        The create operation creates a new subscription ledger entry.
+        This operation creates a new metric usage report.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.create(space_id, entry, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.create(space_id, usage_report, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param SubscriptionLedgerEntryCreate entry:  (required)
-        :return: SubscriptionLedgerEntry
+        :param SubscriptionMetricUsageReportCreate usage_report: The usage report which should be created. (required)
+        :return: SubscriptionMetricUsageReport
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.create_with_http_info(space_id, entry, **kwargs)
+            return self.create_with_http_info(space_id, usage_report, **kwargs)
         else:
-            (data) = self.create_with_http_info(space_id, entry, **kwargs)
+            (data) = self.create_with_http_info(space_id, usage_report, **kwargs)
             return data
 
-    def create_with_http_info(self, space_id, entry, **kwargs):
+    def create_with_http_info(self, space_id, usage_report, **kwargs):
         """Create
 
-        The create operation creates a new subscription ledger entry.
+        This operation creates a new metric usage report.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.create_with_http_info(space_id, entry, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.create_with_http_info(space_id, usage_report, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param SubscriptionLedgerEntryCreate entry:  (required)
-        :return: SubscriptionLedgerEntry
+        :param SubscriptionMetricUsageReportCreate usage_report: The usage report which should be created. (required)
+        :return: SubscriptionMetricUsageReport
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['space_id', 'entry']
+        all_params = ['space_id', 'usage_report']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
             raise ValueError("Missing the required parameter `space_id` when calling `create`")
-        # verify the required parameter 'entry' is set
-        if ('entry' not in params or
-                params['entry'] is None):
-            raise ValueError("Missing the required parameter `entry` when calling `create`")
+        # verify the required parameter 'usage_report' is set
+        if ('usage_report' not in params or
+                params['usage_report'] is None):
+            raise ValueError("Missing the required parameter `usage_report` when calling `create`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
@@ -196,92 +192,90 @@
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'entry' in params:
-            body_params = params['entry']
+        if 'usage_report' in params:
+            body_params = params['usage_report']
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-ledger-entry/create', 'POST',
+            '/subscription-metric-usage/create', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='SubscriptionLedgerEntry',
+            response_type='SubscriptionMetricUsageReport',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the subscription charge which should be returned. (required)
-        :return: SubscriptionLedgerEntry
+        :param int id: The id of the usage report which should be returned. (required)
+        :return: SubscriptionMetricUsageReport
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the subscription charge which should be returned. (required)
-        :return: SubscriptionLedgerEntry
+        :param int id: The id of the usage report which should be returned. (required)
+        :return: SubscriptionMetricUsageReport
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -321,78 +315,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-ledger-entry/read', 'GET',
+            '/subscription-metric-usage/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='SubscriptionLedgerEntry',
+            response_type='SubscriptionMetricUsageReport',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the subscription charges which are returned by the search. (required)
-        :return: list[SubscriptionLedgerEntry]
+        :param EntityQuery query: The query restricts the usage reports which are returned by the search. (required)
+        :return: list[SubscriptionMetricUsageReport]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the subscription charges which are returned by the search. (required)
-        :return: list[SubscriptionLedgerEntry]
+        :param EntityQuery query: The query restricts the usage reports which are returned by the search. (required)
+        :return: list[SubscriptionMetricUsageReport]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -432,21 +424,21 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-ledger-entry/search', 'POST',
+            '/subscription-metric-usage/search', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[SubscriptionLedgerEntry]',
+            response_type='list[SubscriptionMetricUsageReport]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/subscription_metric_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/subscription_product_component_group_service_api.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,52 +2,50 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class SubscriptionMetricServiceApi:
+class SubscriptionProductComponentGroupServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -99,78 +97,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-metric/count', 'POST',
+            '/subscription-product-component-group/count', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def create(self, space_id, entity, **kwargs):
         """Create
 
         Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param SubscriptionMetricCreate entity: The metric object with the properties which should be created. (required)
-        :return: SubscriptionMetric
+        :param SubscriptionProductComponentGroupUpdate entity: The product component group object with the properties which should be created. (required)
+        :return: SubscriptionProductComponentGroup
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.create_with_http_info(space_id, entity, **kwargs)
         else:
             (data) = self.create_with_http_info(space_id, entity, **kwargs)
             return data
 
     def create_with_http_info(self, space_id, entity, **kwargs):
         """Create
 
         Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param SubscriptionMetricCreate entity: The metric object with the properties which should be created. (required)
-        :return: SubscriptionMetric
+        :param SubscriptionProductComponentGroupUpdate entity: The product component group object with the properties which should be created. (required)
+        :return: SubscriptionProductComponentGroup
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create" % key
@@ -210,78 +206,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-metric/create', 'POST',
+            '/subscription-product-component-group/create', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='SubscriptionMetric',
+            response_type='SubscriptionProductComponentGroup',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def delete(self, space_id, id, **kwargs):
         """Delete
 
         Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the metric which should be deleted. (required)
+        :param int id:  (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.delete_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.delete_with_http_info(space_id, id, **kwargs)
             return data
 
     def delete_with_http_info(self, space_id, id, **kwargs):
         """Delete
 
         Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the metric which should be deleted. (required)
+        :param int id:  (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete" % key
@@ -321,78 +315,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-metric/delete', 'POST',
+            '/subscription-product-component-group/delete', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the metric which should be returned. (required)
-        :return: SubscriptionMetric
+        :param int id: The id of the product component group which should be returned. (required)
+        :return: SubscriptionProductComponentGroup
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the metric which should be returned. (required)
-        :return: SubscriptionMetric
+        :param int id: The id of the product component group which should be returned. (required)
+        :return: SubscriptionProductComponentGroup
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -432,78 +424,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-metric/read', 'GET',
+            '/subscription-product-component-group/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='SubscriptionMetric',
+            response_type='SubscriptionProductComponentGroup',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the metric which are returned by the search. (required)
-        :return: list[SubscriptionMetric]
+        :param EntityQuery query: The query restricts the product component groups which are returned by the search. (required)
+        :return: list[SubscriptionProductComponentGroup]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the metric which are returned by the search. (required)
-        :return: list[SubscriptionMetric]
+        :param EntityQuery query: The query restricts the product component groups which are returned by the search. (required)
+        :return: list[SubscriptionProductComponentGroup]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -543,78 +533,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-metric/search', 'POST',
+            '/subscription-product-component-group/search', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[SubscriptionMetric]',
+            response_type='list[SubscriptionProductComponentGroup]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def update(self, space_id, entity, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param SubscriptionMetricActive entity: The products metric with all the properties which should be updated. The id and the version are required properties. (required)
-        :return: SubscriptionMetric
+        :param SubscriptionProductComponentGroupUpdate entity: The product component group object with all the properties which should be updated. The id and the version are required properties. (required)
+        :return: SubscriptionProductComponentGroup
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.update_with_http_info(space_id, entity, **kwargs)
         else:
             (data) = self.update_with_http_info(space_id, entity, **kwargs)
             return data
 
     def update_with_http_info(self, space_id, entity, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param SubscriptionMetricActive entity: The products metric with all the properties which should be updated. The id and the version are required properties. (required)
-        :return: SubscriptionMetric
+        :param SubscriptionProductComponentGroupUpdate entity: The product component group object with all the properties which should be updated. The id and the version are required properties. (required)
+        :return: SubscriptionProductComponentGroup
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update" % key
@@ -654,21 +642,21 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-metric/update', 'POST',
+            '/subscription-product-component-group/update', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='SubscriptionMetric',
+            response_type='SubscriptionProductComponentGroup',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/subscription_metric_usage_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/subscription_product_retirement_service_api.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,52 +2,50 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class SubscriptionMetricUsageServiceApi:
+class SubscriptionProductRetirementServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -99,96 +97,94 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-metric-usage/count', 'POST',
+            '/subscription-product-retirement/count', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def create(self, space_id, usage_report, **kwargs):
+    def create(self, space_id, retirement, **kwargs):
         """Create
 
-        This operation creates a new metric usage report.
+        The create operation creates a new product retirement.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.create(space_id, usage_report, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.create(space_id, retirement, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param SubscriptionMetricUsageReportCreate usage_report: The usage report which should be created. (required)
-        :return: SubscriptionMetricUsageReport
+        :param SubscriptionProductRetirementCreate retirement:  (required)
+        :return: SubscriptionProductRetirement
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.create_with_http_info(space_id, usage_report, **kwargs)
+            return self.create_with_http_info(space_id, retirement, **kwargs)
         else:
-            (data) = self.create_with_http_info(space_id, usage_report, **kwargs)
+            (data) = self.create_with_http_info(space_id, retirement, **kwargs)
             return data
 
-    def create_with_http_info(self, space_id, usage_report, **kwargs):
+    def create_with_http_info(self, space_id, retirement, **kwargs):
         """Create
 
-        This operation creates a new metric usage report.
+        The create operation creates a new product retirement.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.create_with_http_info(space_id, usage_report, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.create_with_http_info(space_id, retirement, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param SubscriptionMetricUsageReportCreate usage_report: The usage report which should be created. (required)
-        :return: SubscriptionMetricUsageReport
+        :param SubscriptionProductRetirementCreate retirement:  (required)
+        :return: SubscriptionProductRetirement
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['space_id', 'usage_report']
+        all_params = ['space_id', 'retirement']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
             raise ValueError("Missing the required parameter `space_id` when calling `create`")
-        # verify the required parameter 'usage_report' is set
-        if ('usage_report' not in params or
-                params['usage_report'] is None):
-            raise ValueError("Missing the required parameter `usage_report` when calling `create`")
+        # verify the required parameter 'retirement' is set
+        if ('retirement' not in params or
+                params['retirement'] is None):
+            raise ValueError("Missing the required parameter `retirement` when calling `create`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
@@ -196,92 +192,90 @@
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'usage_report' in params:
-            body_params = params['usage_report']
+        if 'retirement' in params:
+            body_params = params['retirement']
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-metric-usage/create', 'POST',
+            '/subscription-product-retirement/create', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='SubscriptionMetricUsageReport',
+            response_type='SubscriptionProductRetirement',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the usage report which should be returned. (required)
-        :return: SubscriptionMetricUsageReport
+        :param int id: The id of the retirement which should be returned. (required)
+        :return: SubscriptionProductRetirement
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the usage report which should be returned. (required)
-        :return: SubscriptionMetricUsageReport
+        :param int id: The id of the retirement which should be returned. (required)
+        :return: SubscriptionProductRetirement
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -321,78 +315,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-metric-usage/read', 'GET',
+            '/subscription-product-retirement/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='SubscriptionMetricUsageReport',
+            response_type='SubscriptionProductRetirement',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the usage reports which are returned by the search. (required)
-        :return: list[SubscriptionMetricUsageReport]
+        :param EntityQuery query: The query restricts the product retirements which are returned by the search. (required)
+        :return: list[SubscriptionProductRetirement]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the usage reports which are returned by the search. (required)
-        :return: list[SubscriptionMetricUsageReport]
+        :param EntityQuery query: The query restricts the product retirements which are returned by the search. (required)
+        :return: list[SubscriptionProductRetirement]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -432,21 +424,21 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-metric-usage/search', 'POST',
+            '/subscription-product-retirement/search', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[SubscriptionMetricUsageReport]',
+            response_type='list[SubscriptionProductRetirement]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/subscription_period_bill_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/subscription_period_bill_service_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -12,42 +12,40 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -111,50 +109,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the subscription period bill which should be returned. (required)
         :return: SubscriptionPeriodBill
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the subscription period bill which should be returned. (required)
         :return: SubscriptionPeriodBill
@@ -162,15 +158,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -222,50 +218,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='SubscriptionPeriodBill',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the subscription period bills which are returned by the search. (required)
         :return: list[SubscriptionPeriodBill]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the subscription period bills which are returned by the search. (required)
         :return: list[SubscriptionPeriodBill]
@@ -273,15 +267,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -333,9 +327,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[SubscriptionPeriodBill]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/subscription_product_component_group_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/webhook_url_service_api.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,52 +2,50 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class SubscriptionProductComponentGroupServiceApi:
+class WebhookUrlServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -99,78 +97,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-component-group/count', 'POST',
+            '/webhook-url/count', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def create(self, space_id, entity, **kwargs):
         """Create
 
         Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param SubscriptionProductComponentGroupUpdate entity: The product component group object with the properties which should be created. (required)
-        :return: SubscriptionProductComponentGroup
+        :param WebhookUrlCreate entity: The webhook url object with the properties which should be created. (required)
+        :return: WebhookUrl
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.create_with_http_info(space_id, entity, **kwargs)
         else:
             (data) = self.create_with_http_info(space_id, entity, **kwargs)
             return data
 
     def create_with_http_info(self, space_id, entity, **kwargs):
         """Create
 
         Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param SubscriptionProductComponentGroupUpdate entity: The product component group object with the properties which should be created. (required)
-        :return: SubscriptionProductComponentGroup
+        :param WebhookUrlCreate entity: The webhook url object with the properties which should be created. (required)
+        :return: WebhookUrl
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create" % key
@@ -210,62 +206,60 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-component-group/create', 'POST',
+            '/webhook-url/create', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='SubscriptionProductComponentGroup',
+            response_type='WebhookUrl',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def delete(self, space_id, id, **kwargs):
         """Delete
 
         Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id:  (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.delete_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.delete_with_http_info(space_id, id, **kwargs)
             return data
 
     def delete_with_http_info(self, space_id, id, **kwargs):
         """Delete
 
         Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id:  (required)
         :return: None
@@ -273,15 +267,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete" % key
@@ -321,78 +315,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-component-group/delete', 'POST',
+            '/webhook-url/delete', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the product component group which should be returned. (required)
-        :return: SubscriptionProductComponentGroup
+        :param int id: The id of the webhook url which should be returned. (required)
+        :return: WebhookUrl
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the product component group which should be returned. (required)
-        :return: SubscriptionProductComponentGroup
+        :param int id: The id of the webhook url which should be returned. (required)
+        :return: WebhookUrl
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -432,78 +424,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-component-group/read', 'GET',
+            '/webhook-url/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='SubscriptionProductComponentGroup',
+            response_type='WebhookUrl',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the product component groups which are returned by the search. (required)
-        :return: list[SubscriptionProductComponentGroup]
+        :param EntityQuery query: The query restricts the webhook urls which are returned by the search. (required)
+        :return: list[WebhookUrl]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the product component groups which are returned by the search. (required)
-        :return: list[SubscriptionProductComponentGroup]
+        :param EntityQuery query: The query restricts the webhook urls which are returned by the search. (required)
+        :return: list[WebhookUrl]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -543,78 +533,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-component-group/search', 'POST',
+            '/webhook-url/search', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[SubscriptionProductComponentGroup]',
+            response_type='list[WebhookUrl]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def update(self, space_id, entity, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param SubscriptionProductComponentGroupUpdate entity: The product component group object with all the properties which should be updated. The id and the version are required properties. (required)
-        :return: SubscriptionProductComponentGroup
+        :param WebhookUrlUpdate entity: The webhook url object with all the properties which should be updated. The id and the version are required properties. (required)
+        :return: WebhookUrl
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.update_with_http_info(space_id, entity, **kwargs)
         else:
             (data) = self.update_with_http_info(space_id, entity, **kwargs)
             return data
 
     def update_with_http_info(self, space_id, entity, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param SubscriptionProductComponentGroupUpdate entity: The product component group object with all the properties which should be updated. The id and the version are required properties. (required)
-        :return: SubscriptionProductComponentGroup
+        :param WebhookUrlUpdate entity: The webhook url object with all the properties which should be updated. The id and the version are required properties. (required)
+        :return: WebhookUrl
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update" % key
@@ -654,21 +642,21 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-component-group/update', 'POST',
+            '/webhook-url/update', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='SubscriptionProductComponentGroup',
+            response_type='WebhookUrl',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/subscription_product_component_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/subscription_product_component_service_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -12,42 +12,40 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -111,50 +109,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def create(self, space_id, entity, **kwargs):
         """Create
 
         Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param SubscriptionProductComponentUpdate entity: The product component object with the properties which should be created. (required)
         :return: SubscriptionProductComponent
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.create_with_http_info(space_id, entity, **kwargs)
         else:
             (data) = self.create_with_http_info(space_id, entity, **kwargs)
             return data
 
     def create_with_http_info(self, space_id, entity, **kwargs):
         """Create
 
         Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param SubscriptionProductComponentUpdate entity: The product component object with the properties which should be created. (required)
         :return: SubscriptionProductComponent
@@ -162,15 +158,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create" % key
@@ -222,50 +218,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='SubscriptionProductComponent',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def delete(self, space_id, id, **kwargs):
         """Delete
 
         Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id:  (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.delete_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.delete_with_http_info(space_id, id, **kwargs)
             return data
 
     def delete_with_http_info(self, space_id, id, **kwargs):
         """Delete
 
         Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id:  (required)
         :return: None
@@ -273,15 +267,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete" % key
@@ -333,50 +327,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the product component which should be returned. (required)
         :return: SubscriptionProductComponent
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the product component which should be returned. (required)
         :return: SubscriptionProductComponent
@@ -384,15 +376,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -444,50 +436,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='SubscriptionProductComponent',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the product component which are returned by the search. (required)
         :return: list[SubscriptionProductComponent]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the product component which are returned by the search. (required)
         :return: list[SubscriptionProductComponent]
@@ -495,15 +485,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -555,50 +545,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[SubscriptionProductComponent]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def update(self, space_id, entity, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param SubscriptionProductComponentUpdate entity: The product component object with all the properties which should be updated. The id and the version are required properties. (required)
         :return: SubscriptionProductComponent
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.update_with_http_info(space_id, entity, **kwargs)
         else:
             (data) = self.update_with_http_info(space_id, entity, **kwargs)
             return data
 
     def update_with_http_info(self, space_id, entity, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param SubscriptionProductComponentUpdate entity: The product component object with all the properties which should be updated. The id and the version are required properties. (required)
         :return: SubscriptionProductComponent
@@ -606,15 +594,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update" % key
@@ -666,9 +654,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='SubscriptionProductComponent',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/subscription_product_fee_tier_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/subscription_product_setup_fee_service_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,52 +2,50 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class SubscriptionProductFeeTierServiceApi:
+class SubscriptionProductSetupFeeServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -99,78 +97,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-fee-tier/count', 'POST',
+            '/subscription-product-setup-fee/count', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def create(self, space_id, entity, **kwargs):
         """Create
 
         Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param ProductMeteredTierFeeUpdate entity: The metered fee tier object with the properties which should be created. (required)
-        :return: ProductMeteredTierFee
+        :param ProductSetupFeeUpdate entity: The setup fee object with the properties which should be created. (required)
+        :return: ProductSetupFee
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.create_with_http_info(space_id, entity, **kwargs)
         else:
             (data) = self.create_with_http_info(space_id, entity, **kwargs)
             return data
 
     def create_with_http_info(self, space_id, entity, **kwargs):
         """Create
 
         Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param ProductMeteredTierFeeUpdate entity: The metered fee tier object with the properties which should be created. (required)
-        :return: ProductMeteredTierFee
+        :param ProductSetupFeeUpdate entity: The setup fee object with the properties which should be created. (required)
+        :return: ProductSetupFee
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create" % key
@@ -210,62 +206,60 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-fee-tier/create', 'POST',
+            '/subscription-product-setup-fee/create', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ProductMeteredTierFee',
+            response_type='ProductSetupFee',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def delete(self, space_id, id, **kwargs):
         """Delete
 
         Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id:  (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.delete_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.delete_with_http_info(space_id, id, **kwargs)
             return data
 
     def delete_with_http_info(self, space_id, id, **kwargs):
         """Delete
 
         Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id:  (required)
         :return: None
@@ -273,15 +267,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete" % key
@@ -321,78 +315,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-fee-tier/delete', 'POST',
+            '/subscription-product-setup-fee/delete', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the metered fee tier which should be returned. (required)
-        :return: ProductMeteredTierFee
+        :param int id: The id of the setup fee which should be returned. (required)
+        :return: ProductSetupFee
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the metered fee tier which should be returned. (required)
-        :return: ProductMeteredTierFee
+        :param int id: The id of the setup fee which should be returned. (required)
+        :return: ProductSetupFee
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -432,78 +424,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-fee-tier/read', 'GET',
+            '/subscription-product-setup-fee/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ProductMeteredTierFee',
+            response_type='ProductSetupFee',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the metered fee tiers which are returned by the search. (required)
-        :return: list[ProductMeteredTierFee]
+        :param EntityQuery query: The query restricts the setup fees which are returned by the search. (required)
+        :return: list[ProductSetupFee]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the metered fee tiers which are returned by the search. (required)
-        :return: list[ProductMeteredTierFee]
+        :param EntityQuery query: The query restricts the setup fees which are returned by the search. (required)
+        :return: list[ProductSetupFee]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -543,78 +533,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-fee-tier/search', 'POST',
+            '/subscription-product-setup-fee/search', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[ProductMeteredTierFee]',
+            response_type='list[ProductSetupFee]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def update(self, space_id, entity, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param ProductMeteredTierFeeUpdate entity: The metered fee tier object with all the properties which should be updated. The id and the version are required properties. (required)
-        :return: ProductMeteredTierFee
+        :param ProductSetupFeeUpdate entity: The setup fee object with all the properties which should be updated. The id and the version are required properties. (required)
+        :return: ProductSetupFee
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.update_with_http_info(space_id, entity, **kwargs)
         else:
             (data) = self.update_with_http_info(space_id, entity, **kwargs)
             return data
 
     def update_with_http_info(self, space_id, entity, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param ProductMeteredTierFeeUpdate entity: The metered fee tier object with all the properties which should be updated. The id and the version are required properties. (required)
-        :return: ProductMeteredTierFee
+        :param ProductSetupFeeUpdate entity: The setup fee object with all the properties which should be updated. The id and the version are required properties. (required)
+        :return: ProductSetupFee
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update" % key
@@ -654,21 +642,21 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-fee-tier/update', 'POST',
+            '/subscription-product-setup-fee/update', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ProductMeteredTierFee',
+            response_type='ProductSetupFee',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/subscription_product_metered_fee_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/subscription_product_period_fee_service_api.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,52 +2,50 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class SubscriptionProductMeteredFeeServiceApi:
+class SubscriptionProductPeriodFeeServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -99,78 +97,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-metered-fee/count', 'POST',
+            '/subscription-product-period-fee/count', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def create(self, space_id, entity, **kwargs):
         """Create
 
         Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param ProductMeteredFeeUpdate entity: The metered fee object with the properties which should be created. (required)
-        :return: ProductMeteredFee
+        :param ProductPeriodFeeUpdate entity: The period fee object with the properties which should be created. (required)
+        :return: ProductPeriodFee
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.create_with_http_info(space_id, entity, **kwargs)
         else:
             (data) = self.create_with_http_info(space_id, entity, **kwargs)
             return data
 
     def create_with_http_info(self, space_id, entity, **kwargs):
         """Create
 
         Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param ProductMeteredFeeUpdate entity: The metered fee object with the properties which should be created. (required)
-        :return: ProductMeteredFee
+        :param ProductPeriodFeeUpdate entity: The period fee object with the properties which should be created. (required)
+        :return: ProductPeriodFee
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create" % key
@@ -210,62 +206,60 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-metered-fee/create', 'POST',
+            '/subscription-product-period-fee/create', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ProductMeteredFee',
+            response_type='ProductPeriodFee',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def delete(self, space_id, id, **kwargs):
         """Delete
 
         Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id:  (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.delete_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.delete_with_http_info(space_id, id, **kwargs)
             return data
 
     def delete_with_http_info(self, space_id, id, **kwargs):
         """Delete
 
         Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id:  (required)
         :return: None
@@ -273,15 +267,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete" % key
@@ -321,78 +315,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-metered-fee/delete', 'POST',
+            '/subscription-product-period-fee/delete', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the metered fee which should be returned. (required)
-        :return: ProductMeteredFee
+        :param int id: The id of the period fee which should be returned. (required)
+        :return: ProductPeriodFee
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the metered fee which should be returned. (required)
-        :return: ProductMeteredFee
+        :param int id: The id of the period fee which should be returned. (required)
+        :return: ProductPeriodFee
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -432,78 +424,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-metered-fee/read', 'GET',
+            '/subscription-product-period-fee/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ProductMeteredFee',
+            response_type='ProductPeriodFee',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the metered fees which are returned by the search. (required)
-        :return: list[ProductMeteredFee]
+        :param EntityQuery query: The query restricts the period fees which are returned by the search. (required)
+        :return: list[ProductPeriodFee]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the metered fees which are returned by the search. (required)
-        :return: list[ProductMeteredFee]
+        :param EntityQuery query: The query restricts the period fees which are returned by the search. (required)
+        :return: list[ProductPeriodFee]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -543,78 +533,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-metered-fee/search', 'POST',
+            '/subscription-product-period-fee/search', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[ProductMeteredFee]',
+            response_type='list[ProductPeriodFee]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def update(self, space_id, entity, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param ProductMeteredFeeUpdate entity: The metered fee object with all the properties which should be updated. The id and the version are required properties. (required)
-        :return: ProductMeteredFee
+        :param ProductPeriodFeeUpdate entity: The period fee object with all the properties which should be updated. The id and the version are required properties. (required)
+        :return: ProductPeriodFee
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.update_with_http_info(space_id, entity, **kwargs)
         else:
             (data) = self.update_with_http_info(space_id, entity, **kwargs)
             return data
 
     def update_with_http_info(self, space_id, entity, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param ProductMeteredFeeUpdate entity: The metered fee object with all the properties which should be updated. The id and the version are required properties. (required)
-        :return: ProductMeteredFee
+        :param ProductPeriodFeeUpdate entity: The period fee object with all the properties which should be updated. The id and the version are required properties. (required)
+        :return: ProductPeriodFee
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update" % key
@@ -654,21 +642,21 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-metered-fee/update', 'POST',
+            '/subscription-product-period-fee/update', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ProductMeteredFee',
+            response_type='ProductPeriodFee',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/subscription_product_period_fee_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/webhook_listener_service_api.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,52 +2,50 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class SubscriptionProductPeriodFeeServiceApi:
+class WebhookListenerServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -99,78 +97,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-period-fee/count', 'POST',
+            '/webhook-listener/count', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def create(self, space_id, entity, **kwargs):
         """Create
 
         Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param ProductPeriodFeeUpdate entity: The period fee object with the properties which should be created. (required)
-        :return: ProductPeriodFee
+        :param WebhookListenerCreate entity: The webhook listener object with the properties which should be created. (required)
+        :return: WebhookListener
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.create_with_http_info(space_id, entity, **kwargs)
         else:
             (data) = self.create_with_http_info(space_id, entity, **kwargs)
             return data
 
     def create_with_http_info(self, space_id, entity, **kwargs):
         """Create
 
         Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param ProductPeriodFeeUpdate entity: The period fee object with the properties which should be created. (required)
-        :return: ProductPeriodFee
+        :param WebhookListenerCreate entity: The webhook listener object with the properties which should be created. (required)
+        :return: WebhookListener
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create" % key
@@ -210,62 +206,60 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-period-fee/create', 'POST',
+            '/webhook-listener/create', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ProductPeriodFee',
+            response_type='WebhookListener',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def delete(self, space_id, id, **kwargs):
         """Delete
 
         Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id:  (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.delete_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.delete_with_http_info(space_id, id, **kwargs)
             return data
 
     def delete_with_http_info(self, space_id, id, **kwargs):
         """Delete
 
         Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id:  (required)
         :return: None
@@ -273,15 +267,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete" % key
@@ -321,78 +315,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-period-fee/delete', 'POST',
+            '/webhook-listener/delete', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the period fee which should be returned. (required)
-        :return: ProductPeriodFee
+        :param int id: The id of the webhook listener which should be returned. (required)
+        :return: WebhookListener
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the period fee which should be returned. (required)
-        :return: ProductPeriodFee
+        :param int id: The id of the webhook listener which should be returned. (required)
+        :return: WebhookListener
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -432,78 +424,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-period-fee/read', 'GET',
+            '/webhook-listener/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ProductPeriodFee',
+            response_type='WebhookListener',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the period fees which are returned by the search. (required)
-        :return: list[ProductPeriodFee]
+        :param EntityQuery query: The query restricts the webhook listeners which are returned by the search. (required)
+        :return: list[WebhookListener]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the period fees which are returned by the search. (required)
-        :return: list[ProductPeriodFee]
+        :param EntityQuery query: The query restricts the webhook listeners which are returned by the search. (required)
+        :return: list[WebhookListener]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -543,78 +533,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-period-fee/search', 'POST',
+            '/webhook-listener/search', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[ProductPeriodFee]',
+            response_type='list[WebhookListener]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def update(self, space_id, entity, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param ProductPeriodFeeUpdate entity: The period fee object with all the properties which should be updated. The id and the version are required properties. (required)
-        :return: ProductPeriodFee
+        :param WebhookListenerUpdate entity: The webhook listener object with all the properties which should be updated. The id and the version are required properties. (required)
+        :return: WebhookListener
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.update_with_http_info(space_id, entity, **kwargs)
         else:
             (data) = self.update_with_http_info(space_id, entity, **kwargs)
             return data
 
     def update_with_http_info(self, space_id, entity, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param ProductPeriodFeeUpdate entity: The period fee object with all the properties which should be updated. The id and the version are required properties. (required)
-        :return: ProductPeriodFee
+        :param WebhookListenerUpdate entity: The webhook listener object with all the properties which should be updated. The id and the version are required properties. (required)
+        :return: WebhookListener
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update" % key
@@ -654,21 +642,21 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-period-fee/update', 'POST',
+            '/webhook-listener/update', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ProductPeriodFee',
+            response_type='WebhookListener',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/subscription_product_retirement_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/subscription_product_version_retirement_service_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,52 +2,50 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class SubscriptionProductRetirementServiceApi:
+class SubscriptionProductVersionRetirementServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -99,78 +97,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-retirement/count', 'POST',
+            '/subscription-product-version-retirement/count', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def create(self, space_id, retirement, **kwargs):
         """Create
 
-        The create operation creates a new product retirement.
+        The create operation creates a new product version retirement.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create(space_id, retirement, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param SubscriptionProductRetirementCreate retirement:  (required)
-        :return: SubscriptionProductRetirement
+        :param SubscriptionProductVersionRetirementCreate retirement:  (required)
+        :return: SubscriptionProductVersionRetirement
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.create_with_http_info(space_id, retirement, **kwargs)
         else:
             (data) = self.create_with_http_info(space_id, retirement, **kwargs)
             return data
 
     def create_with_http_info(self, space_id, retirement, **kwargs):
         """Create
 
-        The create operation creates a new product retirement.
+        The create operation creates a new product version retirement.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_with_http_info(space_id, retirement, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param SubscriptionProductRetirementCreate retirement:  (required)
-        :return: SubscriptionProductRetirement
+        :param SubscriptionProductVersionRetirementCreate retirement:  (required)
+        :return: SubscriptionProductVersionRetirement
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'retirement']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create" % key
@@ -210,78 +206,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-retirement/create', 'POST',
+            '/subscription-product-version-retirement/create', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='SubscriptionProductRetirement',
+            response_type='SubscriptionProductVersionRetirement',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the retirement which should be returned. (required)
-        :return: SubscriptionProductRetirement
+        :return: SubscriptionProductVersionRetirement
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the retirement which should be returned. (required)
-        :return: SubscriptionProductRetirement
+        :return: SubscriptionProductVersionRetirement
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -321,78 +315,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-retirement/read', 'GET',
+            '/subscription-product-version-retirement/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='SubscriptionProductRetirement',
+            response_type='SubscriptionProductVersionRetirement',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the product retirements which are returned by the search. (required)
-        :return: list[SubscriptionProductRetirement]
+        :param EntityQuery query: The query restricts the product version retirements which are returned by the search. (required)
+        :return: list[SubscriptionProductVersionRetirement]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the product retirements which are returned by the search. (required)
-        :return: list[SubscriptionProductRetirement]
+        :param EntityQuery query: The query restricts the product version retirements which are returned by the search. (required)
+        :return: list[SubscriptionProductVersionRetirement]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -432,21 +424,21 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-retirement/search', 'POST',
+            '/subscription-product-version-retirement/search', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[SubscriptionProductRetirement]',
+            response_type='list[SubscriptionProductVersionRetirement]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/subscription_product_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/shopify_subscription_product_service_api.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,52 +2,50 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class SubscriptionProductServiceApi:
+class ShopifySubscriptionProductServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -99,78 +97,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product/count', 'POST',
+            '/shopify-subscription-product/count', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def create(self, space_id, entity, **kwargs):
         """Create
 
         Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param SubscriptionProductCreate entity: The product object with the properties which should be created. (required)
-        :return: SubscriptionProduct
+        :param ShopifySubscriptionProductCreate entity: The Shopify subscription product object with the properties which should be created. (required)
+        :return: ShopifySubscriptionProduct
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.create_with_http_info(space_id, entity, **kwargs)
         else:
             (data) = self.create_with_http_info(space_id, entity, **kwargs)
             return data
 
     def create_with_http_info(self, space_id, entity, **kwargs):
         """Create
 
         Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param SubscriptionProductCreate entity: The product object with the properties which should be created. (required)
-        :return: SubscriptionProduct
+        :param ShopifySubscriptionProductCreate entity: The Shopify subscription product object with the properties which should be created. (required)
+        :return: ShopifySubscriptionProduct
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create" % key
@@ -210,78 +206,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product/create', 'POST',
+            '/shopify-subscription-product/create', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='SubscriptionProduct',
+            response_type='ShopifySubscriptionProduct',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the product which should be returned. (required)
-        :return: SubscriptionProduct
+        :param int id: The id of the Shopify subscription product which should be returned. (required)
+        :return: ShopifySubscriptionProduct
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the product which should be returned. (required)
-        :return: SubscriptionProduct
+        :param int id: The id of the Shopify subscription product which should be returned. (required)
+        :return: ShopifySubscriptionProduct
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -321,78 +315,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product/read', 'GET',
+            '/shopify-subscription-product/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='SubscriptionProduct',
+            response_type='ShopifySubscriptionProduct',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the products which are returned by the search. (required)
-        :return: list[SubscriptionProduct]
+        :param EntityQuery query: The query restricts the Shopify subscription products which are returned by the search. (required)
+        :return: list[ShopifySubscriptionProduct]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the products which are returned by the search. (required)
-        :return: list[SubscriptionProduct]
+        :param EntityQuery query: The query restricts the Shopify subscription products which are returned by the search. (required)
+        :return: list[ShopifySubscriptionProduct]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -432,78 +424,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product/search', 'POST',
+            '/shopify-subscription-product/search', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[SubscriptionProduct]',
+            response_type='list[ShopifySubscriptionProduct]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def update(self, space_id, entity, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param SubscriptionProductActive entity: The products object with all the properties which should be updated. The id and the version are required properties. (required)
-        :return: SubscriptionProduct
+        :param ShopifySubscriptionProductUpdate entity: The Shopify subscription product object with all the properties which should be updated. The id and the version are required properties. (required)
+        :return: ShopifySubscriptionProduct
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.update_with_http_info(space_id, entity, **kwargs)
         else:
             (data) = self.update_with_http_info(space_id, entity, **kwargs)
             return data
 
     def update_with_http_info(self, space_id, entity, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param SubscriptionProductActive entity: The products object with all the properties which should be updated. The id and the version are required properties. (required)
-        :return: SubscriptionProduct
+        :param ShopifySubscriptionProductUpdate entity: The Shopify subscription product object with all the properties which should be updated. The id and the version are required properties. (required)
+        :return: ShopifySubscriptionProduct
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update" % key
@@ -543,21 +533,21 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product/update', 'POST',
+            '/shopify-subscription-product/update', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='SubscriptionProduct',
+            response_type='ShopifySubscriptionProduct',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/subscription_product_setup_fee_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/transaction_comment_service_api.py`

 * *Files 13% similar despite different names*

```diff
@@ -2,175 +2,175 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class SubscriptionProductSetupFeeServiceApi:
+class TransactionCommentServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
-    def count(self, space_id, **kwargs):
-        """Count
+    def all(self, space_id, transaction_id, **kwargs):
+        """Find by transaction
 
-        Counts the number of items in the database as restricted by the given filter.
+        Returns all comments of the transaction.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.count(space_id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.all(space_id, transaction_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
-        :return: int
+        :param int transaction_id:  (required)
+        :return: list[TransactionComment]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.count_with_http_info(space_id, **kwargs)
+            return self.all_with_http_info(space_id, transaction_id, **kwargs)
         else:
-            (data) = self.count_with_http_info(space_id, **kwargs)
+            (data) = self.all_with_http_info(space_id, transaction_id, **kwargs)
             return data
 
-    def count_with_http_info(self, space_id, **kwargs):
-        """Count
+    def all_with_http_info(self, space_id, transaction_id, **kwargs):
+        """Find by transaction
 
-        Counts the number of items in the database as restricted by the given filter.
+        Returns all comments of the transaction.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.count_with_http_info(space_id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.all_with_http_info(space_id, transaction_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
-        :return: int
+        :param int transaction_id:  (required)
+        :return: list[TransactionComment]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['space_id', 'filter']
+        all_params = ['space_id', 'transaction_id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method count" % key
+                    " to method all" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `count`")
+            raise ValueError("Missing the required parameter `space_id` when calling `all`")
+        # verify the required parameter 'transaction_id' is set
+        if ('transaction_id' not in params or
+                params['transaction_id'] is None):
+            raise ValueError("Missing the required parameter `transaction_id` when calling `all`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
             query_params.append(('spaceId', params['space_id']))
+        if 'transaction_id' in params:
+            query_params.append(('transactionId', params['transaction_id']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'filter' in params:
-            body_params = params['filter']
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-setup-fee/count', 'POST',
+            '/transaction-comment/all', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='int',
+            response_type='list[TransactionComment]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def create(self, space_id, entity, **kwargs):
         """Create
 
-        Creates the entity with the given properties.
+        Creates the comment with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param ProductSetupFeeUpdate entity: The setup fee object with the properties which should be created. (required)
-        :return: ProductSetupFee
+        :param TransactionCommentCreate entity:  (required)
+        :return: TransactionComment
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.create_with_http_info(space_id, entity, **kwargs)
         else:
             (data) = self.create_with_http_info(space_id, entity, **kwargs)
             return data
 
     def create_with_http_info(self, space_id, entity, **kwargs):
         """Create
 
-        Creates the entity with the given properties.
+        Creates the comment with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param ProductSetupFeeUpdate entity: The setup fee object with the properties which should be created. (required)
-        :return: ProductSetupFee
+        :param TransactionCommentCreate entity:  (required)
+        :return: TransactionComment
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create" % key
@@ -210,62 +210,60 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-setup-fee/create', 'POST',
+            '/transaction-comment/create', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ProductSetupFee',
+            response_type='TransactionComment',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def delete(self, space_id, id, **kwargs):
         """Delete
 
-        Deletes the entity with the given id.
+        Deletes the comment with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id:  (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.delete_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.delete_with_http_info(space_id, id, **kwargs)
             return data
 
     def delete_with_http_info(self, space_id, id, **kwargs):
         """Delete
 
-        Deletes the entity with the given id.
+        Deletes the comment with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id:  (required)
         :return: None
@@ -273,15 +271,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete" % key
@@ -300,99 +298,206 @@
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
             query_params.append(('spaceId', params['space_id']))
+        if 'id' in params:
+            query_params.append(('id', params['id']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'id' in params:
-            body_params = params['id']
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-setup-fee/delete', 'POST',
+            '/transaction-comment/delete', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
+            collection_formats=collection_formats)
+
+    def pin(self, space_id, id, **kwargs):
+        """Pin
+
+        Pins the comment to the top.
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.pin(space_id, id, async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool
+        :param int space_id:  (required)
+        :param int id:  (required)
+        :return: None
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+        kwargs['_return_http_data_only'] = True
+
+
+        if kwargs.get('async_req'):
+            return self.pin_with_http_info(space_id, id, **kwargs)
+        else:
+            (data) = self.pin_with_http_info(space_id, id, **kwargs)
+            return data
+
+    def pin_with_http_info(self, space_id, id, **kwargs):
+        """Pin
+
+        Pins the comment to the top.
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.pin_with_http_info(space_id, id, async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool
+        :param int space_id:  (required)
+        :param int id:  (required)
+        :return: None
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+
+        all_params = ['space_id', 'id']
+        all_params.append('async_req')
+        all_params.append('_return_http_data_only')
+        all_params.append('_preload_content')
+        all_params.append('_request_timeout')
+
+        params = locals()
+        for key, val in six.iteritems(params['kwargs']):
+            if key not in all_params:
+                raise TypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method pin" % key
+                )
+            params[key] = val
+        del params['kwargs']
+        # verify the required parameter 'space_id' is set
+        if ('space_id' not in params or
+                params['space_id'] is None):
+            raise ValueError("Missing the required parameter `space_id` when calling `pin`")
+        # verify the required parameter 'id' is set
+        if ('id' not in params or
+                params['id'] is None):
+            raise ValueError("Missing the required parameter `id` when calling `pin`")
+
+        collection_formats = {}
+
+        path_params = {}
+
+        query_params = []
+        if 'space_id' in params:
+            query_params.append(('spaceId', params['space_id']))
+        if 'id' in params:
+            query_params.append(('id', params['id']))
+
+        header_params = {}
+
+        form_params = []
+        local_var_files = {}
+
+        body_params = None
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json;charset=utf-8'])
+
+        # HTTP header `Content-Type`
+        header_params['Content-Type'] = self.api_client.select_header_content_type(
+            ['*/*'])
+
+        # Authentication setting
+        auth_settings = []
+
+        return self.api_client.call_api(
+            '/transaction-comment/pin', 'GET',
+            path_params,
+            query_params,
+            header_params,
+            body=body_params,
+            post_params=form_params,
+            files=local_var_files,
+            response_type=None,
+            auth_settings=auth_settings,
+            async_req=params.get('async_req'),
+            _return_http_data_only=params.get('_return_http_data_only'),
+            _preload_content=params.get('_preload_content', True),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
-        Reads the entity with the given 'id' and returns it.
+        Reads the comment with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the setup fee which should be returned. (required)
-        :return: ProductSetupFee
+        :param int id:  (required)
+        :return: TransactionComment
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
-        Reads the entity with the given 'id' and returns it.
+        Reads the comment with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the setup fee which should be returned. (required)
-        :return: ProductSetupFee
+        :param int id:  (required)
+        :return: TransactionComment
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -432,189 +537,185 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-setup-fee/read', 'GET',
+            '/transaction-comment/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ProductSetupFee',
+            response_type='TransactionComment',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def search(self, space_id, query, **kwargs):
-        """Search
+    def unpin(self, space_id, id, **kwargs):
+        """Unpin
 
-        Searches for the entities as specified by the given query.
+        Unpins the comment from the top.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.search(space_id, query, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.unpin(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the setup fees which are returned by the search. (required)
-        :return: list[ProductSetupFee]
+        :param int id:  (required)
+        :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.search_with_http_info(space_id, query, **kwargs)
+            return self.unpin_with_http_info(space_id, id, **kwargs)
         else:
-            (data) = self.search_with_http_info(space_id, query, **kwargs)
+            (data) = self.unpin_with_http_info(space_id, id, **kwargs)
             return data
 
-    def search_with_http_info(self, space_id, query, **kwargs):
-        """Search
+    def unpin_with_http_info(self, space_id, id, **kwargs):
+        """Unpin
 
-        Searches for the entities as specified by the given query.
+        Unpins the comment from the top.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.search_with_http_info(space_id, query, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.unpin_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the setup fees which are returned by the search. (required)
-        :return: list[ProductSetupFee]
+        :param int id:  (required)
+        :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['space_id', 'query']
+        all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method search" % key
+                    " to method unpin" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `search`")
-        # verify the required parameter 'query' is set
-        if ('query' not in params or
-                params['query'] is None):
-            raise ValueError("Missing the required parameter `query` when calling `search`")
+            raise ValueError("Missing the required parameter `space_id` when calling `unpin`")
+        # verify the required parameter 'id' is set
+        if ('id' not in params or
+                params['id'] is None):
+            raise ValueError("Missing the required parameter `id` when calling `unpin`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
             query_params.append(('spaceId', params['space_id']))
+        if 'id' in params:
+            query_params.append(('id', params['id']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'query' in params:
-            body_params = params['query']
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(
-            ['application/json;charset=utf-8'])
+            ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-setup-fee/search', 'POST',
+            '/transaction-comment/unpin', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[ProductSetupFee]',
+            response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def update(self, space_id, entity, **kwargs):
         """Update
 
-        This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
+        This updates the comment with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the comment.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param ProductSetupFeeUpdate entity: The setup fee object with all the properties which should be updated. The id and the version are required properties. (required)
-        :return: ProductSetupFee
+        :param TransactionCommentActive entity:  (required)
+        :return: TransactionComment
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.update_with_http_info(space_id, entity, **kwargs)
         else:
             (data) = self.update_with_http_info(space_id, entity, **kwargs)
             return data
 
     def update_with_http_info(self, space_id, entity, **kwargs):
         """Update
 
-        This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
+        This updates the comment with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the comment.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param ProductSetupFeeUpdate entity: The setup fee object with all the properties which should be updated. The id and the version are required properties. (required)
-        :return: ProductSetupFee
+        :param TransactionCommentActive entity:  (required)
+        :return: TransactionComment
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update" % key
@@ -654,21 +755,21 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-setup-fee/update', 'POST',
+            '/transaction-comment/update', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ProductSetupFee',
+            response_type='TransactionComment',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/subscription_product_version_retirement_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/token_version_service_api.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,193 +2,189 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class SubscriptionProductVersionRetirementServiceApi:
+class TokenVersionServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
-    def count(self, space_id, **kwargs):
-        """Count
+    def active_version(self, space_id, id, **kwargs):
+        """Active Version
 
-        Counts the number of items in the database as restricted by the given filter.
+        Returns the token version which is currently active given by the token id. In case no token version is active the method will return null.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.count(space_id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.active_version(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
-        :return: int
+        :param int id: The id of a token for which you want to look up the current active token version. (required)
+        :return: TokenVersion
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.count_with_http_info(space_id, **kwargs)
+            return self.active_version_with_http_info(space_id, id, **kwargs)
         else:
-            (data) = self.count_with_http_info(space_id, **kwargs)
+            (data) = self.active_version_with_http_info(space_id, id, **kwargs)
             return data
 
-    def count_with_http_info(self, space_id, **kwargs):
-        """Count
+    def active_version_with_http_info(self, space_id, id, **kwargs):
+        """Active Version
 
-        Counts the number of items in the database as restricted by the given filter.
+        Returns the token version which is currently active given by the token id. In case no token version is active the method will return null.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.count_with_http_info(space_id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.active_version_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
-        :return: int
+        :param int id: The id of a token for which you want to look up the current active token version. (required)
+        :return: TokenVersion
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['space_id', 'filter']
+        all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method count" % key
+                    " to method active_version" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `count`")
+            raise ValueError("Missing the required parameter `space_id` when calling `active_version`")
+        # verify the required parameter 'id' is set
+        if ('id' not in params or
+                params['id'] is None):
+            raise ValueError("Missing the required parameter `id` when calling `active_version`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
             query_params.append(('spaceId', params['space_id']))
+        if 'id' in params:
+            query_params.append(('id', params['id']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'filter' in params:
-            body_params = params['filter']
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(
-            ['application/json;charset=utf-8'])
+            ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-version-retirement/count', 'POST',
+            '/token-version/active-version', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='int',
+            response_type='TokenVersion',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def create(self, space_id, retirement, **kwargs):
-        """Create
+    def count(self, space_id, **kwargs):
+        """Count
 
-        The create operation creates a new product version retirement.
+        Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.create(space_id, retirement, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param SubscriptionProductVersionRetirementCreate retirement:  (required)
-        :return: SubscriptionProductVersionRetirement
+        :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
+        :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.create_with_http_info(space_id, retirement, **kwargs)
+            return self.count_with_http_info(space_id, **kwargs)
         else:
-            (data) = self.create_with_http_info(space_id, retirement, **kwargs)
+            (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
-    def create_with_http_info(self, space_id, retirement, **kwargs):
-        """Create
+    def count_with_http_info(self, space_id, **kwargs):
+        """Count
 
-        The create operation creates a new product version retirement.
+        Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.create_with_http_info(space_id, retirement, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param SubscriptionProductVersionRetirementCreate retirement:  (required)
-        :return: SubscriptionProductVersionRetirement
+        :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
+        :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['space_id', 'retirement']
+        all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method create" % key
+                    " to method count" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `create`")
-        # verify the required parameter 'retirement' is set
-        if ('retirement' not in params or
-                params['retirement'] is None):
-            raise ValueError("Missing the required parameter `retirement` when calling `create`")
+            raise ValueError("Missing the required parameter `space_id` when calling `count`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
@@ -196,92 +192,90 @@
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'retirement' in params:
-            body_params = params['retirement']
+        if 'filter' in params:
+            body_params = params['filter']
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-version-retirement/create', 'POST',
+            '/token-version/count', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='SubscriptionProductVersionRetirement',
+            response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the retirement which should be returned. (required)
-        :return: SubscriptionProductVersionRetirement
+        :param int id: The id of the token version which should be returned. (required)
+        :return: TokenVersion
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the retirement which should be returned. (required)
-        :return: SubscriptionProductVersionRetirement
+        :param int id: The id of the token version which should be returned. (required)
+        :return: TokenVersion
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -321,78 +315,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-version-retirement/read', 'GET',
+            '/token-version/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='SubscriptionProductVersionRetirement',
+            response_type='TokenVersion',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the product version retirements which are returned by the search. (required)
-        :return: list[SubscriptionProductVersionRetirement]
+        :param EntityQuery query: The query restricts the token versions which are returned by the search. (required)
+        :return: list[TokenVersion]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the product version retirements which are returned by the search. (required)
-        :return: list[SubscriptionProductVersionRetirement]
+        :param EntityQuery query: The query restricts the token versions which are returned by the search. (required)
+        :return: list[TokenVersion]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -432,21 +424,21 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-version-retirement/search', 'POST',
+            '/token-version/search', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[SubscriptionProductVersionRetirement]',
+            response_type='list[TokenVersion]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/subscription_product_version_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/transaction_invoice_service_api.py`

 * *Files 21% similar despite different names*

```diff
@@ -2,397 +2,724 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class SubscriptionProductVersionServiceApi:
+class TransactionInvoiceServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
-    def activate(self, space_id, product_version_id, **kwargs):
-        """activate
+    def count(self, space_id, **kwargs):
+        """Count
 
-        This operation activates a new product version.
+        Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.activate(space_id, product_version_id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int product_version_id: The product version id identifies the product version which should be activated. (required)
-        :return: SubscriptionProductVersion
+        :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
+        :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.activate_with_http_info(space_id, product_version_id, **kwargs)
+            return self.count_with_http_info(space_id, **kwargs)
         else:
-            (data) = self.activate_with_http_info(space_id, product_version_id, **kwargs)
+            (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
-    def activate_with_http_info(self, space_id, product_version_id, **kwargs):
-        """activate
+    def count_with_http_info(self, space_id, **kwargs):
+        """Count
 
-        This operation activates a new product version.
+        Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.activate_with_http_info(space_id, product_version_id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int product_version_id: The product version id identifies the product version which should be activated. (required)
-        :return: SubscriptionProductVersion
+        :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
+        :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['space_id', 'product_version_id']
+        all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method activate" % key
+                    " to method count" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `activate`")
-        # verify the required parameter 'product_version_id' is set
-        if ('product_version_id' not in params or
-                params['product_version_id'] is None):
-            raise ValueError("Missing the required parameter `product_version_id` when calling `activate`")
+            raise ValueError("Missing the required parameter `space_id` when calling `count`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
             query_params.append(('spaceId', params['space_id']))
-        if 'product_version_id' in params:
-            query_params.append(('productVersionId', params['product_version_id']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+        if 'filter' in params:
+            body_params = params['filter']
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-version/activate', 'POST',
+            '/transaction-invoice/count', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='SubscriptionProductVersion',
+            response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def count(self, space_id, **kwargs):
-        """Count
+    def get_invoice_document(self, space_id, id, **kwargs):
+        """getInvoiceDocument
 
-        Counts the number of items in the database as restricted by the given filter.
+        Returns the PDF document for the transaction invoice with given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.count(space_id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.get_invoice_document(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
-        :return: int
+        :param int id: The id of the transaction invoice to get the document for. (required)
+        :return: RenderedDocument
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.count_with_http_info(space_id, **kwargs)
+            return self.get_invoice_document_with_http_info(space_id, id, **kwargs)
         else:
-            (data) = self.count_with_http_info(space_id, **kwargs)
+            (data) = self.get_invoice_document_with_http_info(space_id, id, **kwargs)
             return data
 
-    def count_with_http_info(self, space_id, **kwargs):
-        """Count
+    def get_invoice_document_with_http_info(self, space_id, id, **kwargs):
+        """getInvoiceDocument
 
-        Counts the number of items in the database as restricted by the given filter.
+        Returns the PDF document for the transaction invoice with given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.count_with_http_info(space_id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.get_invoice_document_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
-        :return: int
+        :param int id: The id of the transaction invoice to get the document for. (required)
+        :return: RenderedDocument
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['space_id', 'filter']
+        all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method count" % key
+                    " to method get_invoice_document" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `count`")
+            raise ValueError("Missing the required parameter `space_id` when calling `get_invoice_document`")
+        # verify the required parameter 'id' is set
+        if ('id' not in params or
+                params['id'] is None):
+            raise ValueError("Missing the required parameter `id` when calling `get_invoice_document`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
             query_params.append(('spaceId', params['space_id']))
+        if 'id' in params:
+            query_params.append(('id', params['id']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'filter' in params:
-            body_params = params['filter']
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(
+            ['*/*'])
+
+        # Authentication setting
+        auth_settings = []
+
+        return self.api_client.call_api(
+            '/transaction-invoice/getInvoiceDocument', 'GET',
+            path_params,
+            query_params,
+            header_params,
+            body=body_params,
+            post_params=form_params,
+            files=local_var_files,
+            response_type='RenderedDocument',
+            auth_settings=auth_settings,
+            async_req=params.get('async_req'),
+            _return_http_data_only=params.get('_return_http_data_only'),
+            _preload_content=params.get('_preload_content', True),
+            _request_timeout=params.get('_request_timeout'),
+            collection_formats=collection_formats)
+
+    def get_invoice_document_with_target_media_type(self, space_id, id, target_media_type_id, **kwargs):
+        """getInvoiceDocumentWithTargetMediaType
+
+        Returns the PDF document for the transaction invoice with given id and target media type id.
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.get_invoice_document_with_target_media_type(space_id, id, target_media_type_id, async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool
+        :param int space_id:  (required)
+        :param int id: The id of the transaction invoice to get the document for. (required)
+        :param int target_media_type_id: The id of the target media type for which the invoice should be generated for. (required)
+        :return: RenderedDocument
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+        kwargs['_return_http_data_only'] = True
+
+
+        if kwargs.get('async_req'):
+            return self.get_invoice_document_with_target_media_type_with_http_info(space_id, id, target_media_type_id, **kwargs)
+        else:
+            (data) = self.get_invoice_document_with_target_media_type_with_http_info(space_id, id, target_media_type_id, **kwargs)
+            return data
+
+    def get_invoice_document_with_target_media_type_with_http_info(self, space_id, id, target_media_type_id, **kwargs):
+        """getInvoiceDocumentWithTargetMediaType
+
+        Returns the PDF document for the transaction invoice with given id and target media type id.
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.get_invoice_document_with_target_media_type_with_http_info(space_id, id, target_media_type_id, async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool
+        :param int space_id:  (required)
+        :param int id: The id of the transaction invoice to get the document for. (required)
+        :param int target_media_type_id: The id of the target media type for which the invoice should be generated for. (required)
+        :return: RenderedDocument
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+
+        all_params = ['space_id', 'id', 'target_media_type_id']
+        all_params.append('async_req')
+        all_params.append('_return_http_data_only')
+        all_params.append('_preload_content')
+        all_params.append('_request_timeout')
+
+        params = locals()
+        for key, val in six.iteritems(params['kwargs']):
+            if key not in all_params:
+                raise TypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method get_invoice_document_with_target_media_type" % key
+                )
+            params[key] = val
+        del params['kwargs']
+        # verify the required parameter 'space_id' is set
+        if ('space_id' not in params or
+                params['space_id'] is None):
+            raise ValueError("Missing the required parameter `space_id` when calling `get_invoice_document_with_target_media_type`")
+        # verify the required parameter 'id' is set
+        if ('id' not in params or
+                params['id'] is None):
+            raise ValueError("Missing the required parameter `id` when calling `get_invoice_document_with_target_media_type`")
+        # verify the required parameter 'target_media_type_id' is set
+        if ('target_media_type_id' not in params or
+                params['target_media_type_id'] is None):
+            raise ValueError("Missing the required parameter `target_media_type_id` when calling `get_invoice_document_with_target_media_type`")
+
+        collection_formats = {}
+
+        path_params = {}
+
+        query_params = []
+        if 'space_id' in params:
+            query_params.append(('spaceId', params['space_id']))
+        if 'id' in params:
+            query_params.append(('id', params['id']))
+        if 'target_media_type_id' in params:
+            query_params.append(('targetMediaTypeId', params['target_media_type_id']))
+
+        header_params = {}
+
+        form_params = []
+        local_var_files = {}
+
+        body_params = None
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
+        # HTTP header `Content-Type`
+        header_params['Content-Type'] = self.api_client.select_header_content_type(
+            ['*/*'])
+
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-version/count', 'POST',
+            '/transaction-invoice/getInvoiceDocumentWithTargetMediaType', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='int',
+            response_type='RenderedDocument',
+            auth_settings=auth_settings,
+            async_req=params.get('async_req'),
+            _return_http_data_only=params.get('_return_http_data_only'),
+            _preload_content=params.get('_preload_content', True),
+            _request_timeout=params.get('_request_timeout'),
+            collection_formats=collection_formats)
+
+    def is_replacement_possible(self, space_id, id, **kwargs):
+        """isReplacementPossible
+
+        Returns whether the transaction invoice with the given id can be replaced.
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.is_replacement_possible(space_id, id, async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool
+        :param int space_id:  (required)
+        :param int id: The invoice which should be checked if a replacement is possible. (required)
+        :return: bool
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+        kwargs['_return_http_data_only'] = True
+
+
+        if kwargs.get('async_req'):
+            return self.is_replacement_possible_with_http_info(space_id, id, **kwargs)
+        else:
+            (data) = self.is_replacement_possible_with_http_info(space_id, id, **kwargs)
+            return data
+
+    def is_replacement_possible_with_http_info(self, space_id, id, **kwargs):
+        """isReplacementPossible
+
+        Returns whether the transaction invoice with the given id can be replaced.
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.is_replacement_possible_with_http_info(space_id, id, async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool
+        :param int space_id:  (required)
+        :param int id: The invoice which should be checked if a replacement is possible. (required)
+        :return: bool
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+
+        all_params = ['space_id', 'id']
+        all_params.append('async_req')
+        all_params.append('_return_http_data_only')
+        all_params.append('_preload_content')
+        all_params.append('_request_timeout')
+
+        params = locals()
+        for key, val in six.iteritems(params['kwargs']):
+            if key not in all_params:
+                raise TypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method is_replacement_possible" % key
+                )
+            params[key] = val
+        del params['kwargs']
+        # verify the required parameter 'space_id' is set
+        if ('space_id' not in params or
+                params['space_id'] is None):
+            raise ValueError("Missing the required parameter `space_id` when calling `is_replacement_possible`")
+        # verify the required parameter 'id' is set
+        if ('id' not in params or
+                params['id'] is None):
+            raise ValueError("Missing the required parameter `id` when calling `is_replacement_possible`")
+
+        collection_formats = {}
+
+        path_params = {}
+
+        query_params = []
+        if 'space_id' in params:
+            query_params.append(('spaceId', params['space_id']))
+        if 'id' in params:
+            query_params.append(('id', params['id']))
+
+        header_params = {}
+
+        form_params = []
+        local_var_files = {}
+
+        body_params = None
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json;charset=utf-8'])
+
+        # HTTP header `Content-Type`
+        header_params['Content-Type'] = self.api_client.select_header_content_type(
+            ['*/*'])
+
+        # Authentication setting
+        auth_settings = []
+
+        return self.api_client.call_api(
+            '/transaction-invoice/isReplacementPossible', 'GET',
+            path_params,
+            query_params,
+            header_params,
+            body=body_params,
+            post_params=form_params,
+            files=local_var_files,
+            response_type='bool',
+            auth_settings=auth_settings,
+            async_req=params.get('async_req'),
+            _return_http_data_only=params.get('_return_http_data_only'),
+            _preload_content=params.get('_preload_content', True),
+            _request_timeout=params.get('_request_timeout'),
+            collection_formats=collection_formats)
+
+    def mark_as_derecognized(self, space_id, id, **kwargs):
+        """Mark as Derecognized
+
+        Marks the transaction invoice with the given id as derecognized.
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.mark_as_derecognized(space_id, id, async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool
+        :param int space_id:  (required)
+        :param int id: The id of the transaction invoice which should be marked as derecognized. (required)
+        :return: TransactionInvoice
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+        kwargs['_return_http_data_only'] = True
+
+
+        if kwargs.get('async_req'):
+            return self.mark_as_derecognized_with_http_info(space_id, id, **kwargs)
+        else:
+            (data) = self.mark_as_derecognized_with_http_info(space_id, id, **kwargs)
+            return data
+
+    def mark_as_derecognized_with_http_info(self, space_id, id, **kwargs):
+        """Mark as Derecognized
+
+        Marks the transaction invoice with the given id as derecognized.
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.mark_as_derecognized_with_http_info(space_id, id, async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool
+        :param int space_id:  (required)
+        :param int id: The id of the transaction invoice which should be marked as derecognized. (required)
+        :return: TransactionInvoice
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+
+        all_params = ['space_id', 'id']
+        all_params.append('async_req')
+        all_params.append('_return_http_data_only')
+        all_params.append('_preload_content')
+        all_params.append('_request_timeout')
+
+        params = locals()
+        for key, val in six.iteritems(params['kwargs']):
+            if key not in all_params:
+                raise TypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method mark_as_derecognized" % key
+                )
+            params[key] = val
+        del params['kwargs']
+        # verify the required parameter 'space_id' is set
+        if ('space_id' not in params or
+                params['space_id'] is None):
+            raise ValueError("Missing the required parameter `space_id` when calling `mark_as_derecognized`")
+        # verify the required parameter 'id' is set
+        if ('id' not in params or
+                params['id'] is None):
+            raise ValueError("Missing the required parameter `id` when calling `mark_as_derecognized`")
+
+        collection_formats = {}
+
+        path_params = {}
+
+        query_params = []
+        if 'space_id' in params:
+            query_params.append(('spaceId', params['space_id']))
+        if 'id' in params:
+            query_params.append(('id', params['id']))
+
+        header_params = {}
+
+        form_params = []
+        local_var_files = {}
+
+        body_params = None
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json;charset=utf-8'])
+
+        # HTTP header `Content-Type`
+        header_params['Content-Type'] = self.api_client.select_header_content_type(
+            ['application/json;charset=utf-8'])
+
+        # Authentication setting
+        auth_settings = []
+
+        return self.api_client.call_api(
+            '/transaction-invoice/markAsDerecognized', 'POST',
+            path_params,
+            query_params,
+            header_params,
+            body=body_params,
+            post_params=form_params,
+            files=local_var_files,
+            response_type='TransactionInvoice',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def create(self, space_id, entity, **kwargs):
-        """Create
+    def mark_as_paid(self, space_id, id, **kwargs):
+        """Mark as Paid
 
-        Creates the entity with the given properties.
+        Marks the transaction invoice with the given id as paid.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.create(space_id, entity, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.mark_as_paid(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param SubscriptionProductVersionPending entity: The product version object with the properties which should be created. (required)
-        :return: SubscriptionProductVersion
+        :param int id: The id of the transaction invoice which should be marked as paid. (required)
+        :return: TransactionInvoice
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.create_with_http_info(space_id, entity, **kwargs)
+            return self.mark_as_paid_with_http_info(space_id, id, **kwargs)
         else:
-            (data) = self.create_with_http_info(space_id, entity, **kwargs)
+            (data) = self.mark_as_paid_with_http_info(space_id, id, **kwargs)
             return data
 
-    def create_with_http_info(self, space_id, entity, **kwargs):
-        """Create
+    def mark_as_paid_with_http_info(self, space_id, id, **kwargs):
+        """Mark as Paid
 
-        Creates the entity with the given properties.
+        Marks the transaction invoice with the given id as paid.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.create_with_http_info(space_id, entity, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.mark_as_paid_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param SubscriptionProductVersionPending entity: The product version object with the properties which should be created. (required)
-        :return: SubscriptionProductVersion
+        :param int id: The id of the transaction invoice which should be marked as paid. (required)
+        :return: TransactionInvoice
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['space_id', 'entity']
+        all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method create" % key
+                    " to method mark_as_paid" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `create`")
-        # verify the required parameter 'entity' is set
-        if ('entity' not in params or
-                params['entity'] is None):
-            raise ValueError("Missing the required parameter `entity` when calling `create`")
+            raise ValueError("Missing the required parameter `space_id` when calling `mark_as_paid`")
+        # verify the required parameter 'id' is set
+        if ('id' not in params or
+                params['id'] is None):
+            raise ValueError("Missing the required parameter `id` when calling `mark_as_paid`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
             query_params.append(('spaceId', params['space_id']))
+        if 'id' in params:
+            query_params.append(('id', params['id']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'entity' in params:
-            body_params = params['entity']
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-version/create', 'POST',
+            '/transaction-invoice/markAsPaid', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='SubscriptionProductVersion',
+            response_type='TransactionInvoice',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the product version which should be returned. (required)
-        :return: SubscriptionProductVersion
+        :param int id: The id of the transaction invoices which should be returned. (required)
+        :return: TransactionInvoice
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the product version which should be returned. (required)
-        :return: SubscriptionProductVersion
+        :param int id: The id of the transaction invoices which should be returned. (required)
+        :return: TransactionInvoice
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -432,207 +759,211 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-version/read', 'GET',
+            '/transaction-invoice/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='SubscriptionProductVersion',
+            response_type='TransactionInvoice',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def search(self, space_id, query, **kwargs):
-        """Search
+    def replace(self, space_id, id, replacement, **kwargs):
+        """replace
 
-        Searches for the entities as specified by the given query.
+        Replaces the transaction invoice with given id with the replacement and returns the new transaction invoice.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.search(space_id, query, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.replace(space_id, id, replacement, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the product versions which are returned by the search. (required)
-        :return: list[SubscriptionProductVersion]
+        :param int id: The id of the transaction invoices which should be replaced. (required)
+        :param TransactionInvoiceReplacement replacement:  (required)
+        :return: TransactionInvoice
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.search_with_http_info(space_id, query, **kwargs)
+            return self.replace_with_http_info(space_id, id, replacement, **kwargs)
         else:
-            (data) = self.search_with_http_info(space_id, query, **kwargs)
+            (data) = self.replace_with_http_info(space_id, id, replacement, **kwargs)
             return data
 
-    def search_with_http_info(self, space_id, query, **kwargs):
-        """Search
+    def replace_with_http_info(self, space_id, id, replacement, **kwargs):
+        """replace
 
-        Searches for the entities as specified by the given query.
+        Replaces the transaction invoice with given id with the replacement and returns the new transaction invoice.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.search_with_http_info(space_id, query, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.replace_with_http_info(space_id, id, replacement, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the product versions which are returned by the search. (required)
-        :return: list[SubscriptionProductVersion]
+        :param int id: The id of the transaction invoices which should be replaced. (required)
+        :param TransactionInvoiceReplacement replacement:  (required)
+        :return: TransactionInvoice
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['space_id', 'query']
+        all_params = ['space_id', 'id', 'replacement']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method search" % key
+                    " to method replace" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `search`")
-        # verify the required parameter 'query' is set
-        if ('query' not in params or
-                params['query'] is None):
-            raise ValueError("Missing the required parameter `query` when calling `search`")
+            raise ValueError("Missing the required parameter `space_id` when calling `replace`")
+        # verify the required parameter 'id' is set
+        if ('id' not in params or
+                params['id'] is None):
+            raise ValueError("Missing the required parameter `id` when calling `replace`")
+        # verify the required parameter 'replacement' is set
+        if ('replacement' not in params or
+                params['replacement'] is None):
+            raise ValueError("Missing the required parameter `replacement` when calling `replace`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
             query_params.append(('spaceId', params['space_id']))
+        if 'id' in params:
+            query_params.append(('id', params['id']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'query' in params:
-            body_params = params['query']
+        if 'replacement' in params:
+            body_params = params['replacement']
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-version/search', 'POST',
+            '/transaction-invoice/replace', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[SubscriptionProductVersion]',
+            response_type='TransactionInvoice',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def update(self, space_id, entity, **kwargs):
-        """Update
+    def search(self, space_id, query, **kwargs):
+        """Search
 
-        This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
+        Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.update(space_id, entity, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param SubscriptionProductVersionPending entity: The product version object with all the properties which should be updated. The id and the version are required properties. (required)
-        :return: SubscriptionProductVersion
+        :param EntityQuery query: The query restricts the transaction invoices which are returned by the search. (required)
+        :return: list[TransactionInvoice]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.update_with_http_info(space_id, entity, **kwargs)
+            return self.search_with_http_info(space_id, query, **kwargs)
         else:
-            (data) = self.update_with_http_info(space_id, entity, **kwargs)
+            (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
-    def update_with_http_info(self, space_id, entity, **kwargs):
-        """Update
+    def search_with_http_info(self, space_id, query, **kwargs):
+        """Search
 
-        This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
+        Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.update_with_http_info(space_id, entity, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param SubscriptionProductVersionPending entity: The product version object with all the properties which should be updated. The id and the version are required properties. (required)
-        :return: SubscriptionProductVersion
+        :param EntityQuery query: The query restricts the transaction invoices which are returned by the search. (required)
+        :return: list[TransactionInvoice]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['space_id', 'entity']
+        all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method update" % key
+                    " to method search" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `update`")
-        # verify the required parameter 'entity' is set
-        if ('entity' not in params or
-                params['entity'] is None):
-            raise ValueError("Missing the required parameter `entity` when calling `update`")
+            raise ValueError("Missing the required parameter `space_id` when calling `search`")
+        # verify the required parameter 'query' is set
+        if ('query' not in params or
+                params['query'] is None):
+            raise ValueError("Missing the required parameter `query` when calling `search`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
@@ -640,35 +971,35 @@
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'entity' in params:
-            body_params = params['entity']
+        if 'query' in params:
+            body_params = params['query']
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-product-version/update', 'POST',
+            '/transaction-invoice/search', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='SubscriptionProductVersion',
+            response_type='list[TransactionInvoice]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/subscription_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/subscription_service_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -12,42 +12,40 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def apply_changes(self, space_id, request, **kwargs):
         """apply changes
 
         This operation allows to apply changes on a subscription.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.apply_changes(space_id, request, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param SubscriptionChangeRequest request:  (required)
         :return: SubscriptionVersion
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.apply_changes_with_http_info(space_id, request, **kwargs)
         else:
             (data) = self.apply_changes_with_http_info(space_id, request, **kwargs)
             return data
 
     def apply_changes_with_http_info(self, space_id, request, **kwargs):
         """apply changes
 
         This operation allows to apply changes on a subscription.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.apply_changes_with_http_info(space_id, request, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param SubscriptionChangeRequest request:  (required)
         :return: SubscriptionVersion
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'request']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method apply_changes" % key
@@ -115,50 +113,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='SubscriptionVersion',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -166,15 +162,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -222,50 +218,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def create(self, space_id, create_request, **kwargs):
         """Create
 
         The create operation creates a new subscription and a corresponding subscription version.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create(space_id, create_request, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param SubscriptionCreateRequest create_request:  (required)
         :return: SubscriptionVersion
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.create_with_http_info(space_id, create_request, **kwargs)
         else:
             (data) = self.create_with_http_info(space_id, create_request, **kwargs)
             return data
 
     def create_with_http_info(self, space_id, create_request, **kwargs):
         """Create
 
         The create operation creates a new subscription and a corresponding subscription version.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_with_http_info(space_id, create_request, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param SubscriptionCreateRequest create_request:  (required)
         :return: SubscriptionVersion
@@ -273,15 +267,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'create_request']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create" % key
@@ -333,50 +327,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='SubscriptionVersion',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def initialize(self, space_id, subscription_id, **kwargs):
         """initialize
 
         The initialize operation initializes a subscription. This method uses charge flows to carry out the transaction.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.initialize(space_id, subscription_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int subscription_id: The provided subscription id will be used to lookup the subscription which should be initialized. (required)
         :return: SubscriptionCharge
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.initialize_with_http_info(space_id, subscription_id, **kwargs)
         else:
             (data) = self.initialize_with_http_info(space_id, subscription_id, **kwargs)
             return data
 
     def initialize_with_http_info(self, space_id, subscription_id, **kwargs):
         """initialize
 
         The initialize operation initializes a subscription. This method uses charge flows to carry out the transaction.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.initialize_with_http_info(space_id, subscription_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int subscription_id: The provided subscription id will be used to lookup the subscription which should be initialized. (required)
         :return: SubscriptionCharge
@@ -384,15 +376,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'subscription_id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method initialize" % key
@@ -440,52 +432,50 @@
             post_params=form_params,
             files=local_var_files,
             response_type='SubscriptionCharge',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def initialize_subscriber_present(self, space_id, subscription_id, **kwargs):
         """initializeSubscriberPresent
 
         The initialize operation initializes a subscription when the subscriber is present. The method will initialize a transaction which has to be completed by using the transaction service.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.initialize_subscriber_present(space_id, subscription_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int subscription_id:  (required)
         :param str success_url: The subscriber will be redirected to the success URL when the transaction is successful.
         :param str failed_url: The subscriber will be redirected to the fail URL when the transaction fails.
         :return: SubscriptionCharge
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.initialize_subscriber_present_with_http_info(space_id, subscription_id, **kwargs)
         else:
             (data) = self.initialize_subscriber_present_with_http_info(space_id, subscription_id, **kwargs)
             return data
 
     def initialize_subscriber_present_with_http_info(self, space_id, subscription_id, **kwargs):
         """initializeSubscriberPresent
 
         The initialize operation initializes a subscription when the subscriber is present. The method will initialize a transaction which has to be completed by using the transaction service.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.initialize_subscriber_present_with_http_info(space_id, subscription_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int subscription_id:  (required)
         :param str success_url: The subscriber will be redirected to the success URL when the transaction is successful.
@@ -495,15 +485,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'subscription_id', 'success_url', 'failed_url']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method initialize_subscriber_present" % key
@@ -555,50 +545,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='SubscriptionCharge',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the subscription which should be returned. (required)
         :return: Subscription
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the subscription which should be returned. (required)
         :return: Subscription
@@ -606,15 +594,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -666,50 +654,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='Subscription',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the subscriptions which are returned by the search. (required)
         :return: list[Subscription]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the subscriptions which are returned by the search. (required)
         :return: list[Subscription]
@@ -717,15 +703,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -777,51 +763,49 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[Subscription]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search_subscription_invoices(self, space_id, subscription_id, query, **kwargs):
         """Search Subscription Invoices
 
         This operation allows to search for subscription invoices.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_subscription_invoices(space_id, subscription_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int subscription_id: The id of the subscription for which the invoices should be searched for. (required)
         :param EntityQuery query: The query restricts the invoices which are returned by the search. (required)
         :return: list[TransactionInvoice]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_subscription_invoices_with_http_info(space_id, subscription_id, query, **kwargs)
         else:
             (data) = self.search_subscription_invoices_with_http_info(space_id, subscription_id, query, **kwargs)
             return data
 
     def search_subscription_invoices_with_http_info(self, space_id, subscription_id, query, **kwargs):
         """Search Subscription Invoices
 
         This operation allows to search for subscription invoices.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_subscription_invoices_with_http_info(space_id, subscription_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int subscription_id: The id of the subscription for which the invoices should be searched for. (required)
         :param EntityQuery query: The query restricts the invoices which are returned by the search. (required)
@@ -830,15 +814,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'subscription_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search_subscription_invoices" % key
@@ -896,51 +880,49 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[TransactionInvoice]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def terminate(self, space_id, subscription_id, respect_termination_period, **kwargs):
         """terminate
 
         This operation allows to terminate a subscription.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.terminate(space_id, subscription_id, respect_termination_period, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int subscription_id: The subscription id identifies the subscription which should be terminated. (required)
         :param bool respect_termination_period: The respect termination period controls whether the termination period configured on the product version should be respected or if the operation should take effect immediately. (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.terminate_with_http_info(space_id, subscription_id, respect_termination_period, **kwargs)
         else:
             (data) = self.terminate_with_http_info(space_id, subscription_id, respect_termination_period, **kwargs)
             return data
 
     def terminate_with_http_info(self, space_id, subscription_id, respect_termination_period, **kwargs):
         """terminate
 
         This operation allows to terminate a subscription.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.terminate_with_http_info(space_id, subscription_id, respect_termination_period, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int subscription_id: The subscription id identifies the subscription which should be terminated. (required)
         :param bool respect_termination_period: The respect termination period controls whether the termination period configured on the product version should be respected or if the operation should take effect immediately. (required)
@@ -949,15 +931,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'subscription_id', 'respect_termination_period']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method terminate" % key
@@ -1011,51 +993,49 @@
             post_params=form_params,
             files=local_var_files,
             response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def update(self, space_id, subscription_id, request, **kwargs):
         """update
 
         This operation allows to update the subscription.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update(space_id, subscription_id, request, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int subscription_id:  (required)
         :param SubscriptionUpdateRequest request:  (required)
         :return: Subscription
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.update_with_http_info(space_id, subscription_id, request, **kwargs)
         else:
             (data) = self.update_with_http_info(space_id, subscription_id, request, **kwargs)
             return data
 
     def update_with_http_info(self, space_id, subscription_id, request, **kwargs):
         """update
 
         This operation allows to update the subscription.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_with_http_info(space_id, subscription_id, request, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int subscription_id:  (required)
         :param SubscriptionUpdateRequest request:  (required)
@@ -1064,15 +1044,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'subscription_id', 'request']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update" % key
@@ -1130,51 +1110,49 @@
             post_params=form_params,
             files=local_var_files,
             response_type='Subscription',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def update_product_version(self, space_id, subscription_id, respect_termination_period, **kwargs):
         """update product version
 
         The update product version operation updates the product version of the subscription to the latest active product version.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_product_version(space_id, subscription_id, respect_termination_period, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int subscription_id: The subscription id identifies the subscription which should be updated to the latest version. (required)
         :param bool respect_termination_period: The subscription version may be retired. The respect termination period controls whether the termination period configured on the product version should be respected or if the operation should take effect immediately. (required)
         :return: SubscriptionVersion
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.update_product_version_with_http_info(space_id, subscription_id, respect_termination_period, **kwargs)
         else:
             (data) = self.update_product_version_with_http_info(space_id, subscription_id, respect_termination_period, **kwargs)
             return data
 
     def update_product_version_with_http_info(self, space_id, subscription_id, respect_termination_period, **kwargs):
         """update product version
 
         The update product version operation updates the product version of the subscription to the latest active product version.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_product_version_with_http_info(space_id, subscription_id, respect_termination_period, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int subscription_id: The subscription id identifies the subscription which should be updated to the latest version. (required)
         :param bool respect_termination_period: The subscription version may be retired. The respect termination period controls whether the termination period configured on the product version should be respected or if the operation should take effect immediately. (required)
@@ -1183,15 +1161,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'subscription_id', 'respect_termination_period']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update_product_version" % key
@@ -1245,9 +1223,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='SubscriptionVersion',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/subscription_suspension_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/subscription_charge_service_api.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,52 +2,50 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class SubscriptionSuspensionServiceApi:
+class SubscriptionChargeServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -99,96 +97,94 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-suspension/count', 'POST',
+            '/subscription-charge/count', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def create(self, space_id, suspension, **kwargs):
+    def create(self, space_id, charge, **kwargs):
         """Create
 
-        The create operation creates a new subscription suspension.
+        The create operation creates a new subscription charge.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.create(space_id, suspension, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.create(space_id, charge, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param SubscriptionSuspensionCreate suspension:  (required)
-        :return: SubscriptionSuspension
+        :param SubscriptionChargeCreate charge:  (required)
+        :return: SubscriptionCharge
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.create_with_http_info(space_id, suspension, **kwargs)
+            return self.create_with_http_info(space_id, charge, **kwargs)
         else:
-            (data) = self.create_with_http_info(space_id, suspension, **kwargs)
+            (data) = self.create_with_http_info(space_id, charge, **kwargs)
             return data
 
-    def create_with_http_info(self, space_id, suspension, **kwargs):
+    def create_with_http_info(self, space_id, charge, **kwargs):
         """Create
 
-        The create operation creates a new subscription suspension.
+        The create operation creates a new subscription charge.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.create_with_http_info(space_id, suspension, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.create_with_http_info(space_id, charge, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param SubscriptionSuspensionCreate suspension:  (required)
-        :return: SubscriptionSuspension
+        :param SubscriptionChargeCreate charge:  (required)
+        :return: SubscriptionCharge
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['space_id', 'suspension']
+        all_params = ['space_id', 'charge']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
             raise ValueError("Missing the required parameter `space_id` when calling `create`")
-        # verify the required parameter 'suspension' is set
-        if ('suspension' not in params or
-                params['suspension'] is None):
-            raise ValueError("Missing the required parameter `suspension` when calling `create`")
+        # verify the required parameter 'charge' is set
+        if ('charge' not in params or
+                params['charge'] is None):
+            raise ValueError("Missing the required parameter `charge` when calling `create`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
@@ -196,368 +192,358 @@
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'suspension' in params:
-            body_params = params['suspension']
+        if 'charge' in params:
+            body_params = params['charge']
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-suspension/create', 'POST',
+            '/subscription-charge/create', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='SubscriptionSuspension',
+            response_type='SubscriptionCharge',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def read(self, space_id, id, **kwargs):
-        """Read
+    def discard(self, space_id, charge_id, **kwargs):
+        """discard
 
-        Reads the entity with the given 'id' and returns it.
+        This operation allows to discard a scheduled charge.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.read(space_id, id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.discard(space_id, charge_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the suspension which should be returned. (required)
-        :return: SubscriptionSuspension
+        :param int charge_id:  (required)
+        :return: SubscriptionCharge
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.read_with_http_info(space_id, id, **kwargs)
+            return self.discard_with_http_info(space_id, charge_id, **kwargs)
         else:
-            (data) = self.read_with_http_info(space_id, id, **kwargs)
+            (data) = self.discard_with_http_info(space_id, charge_id, **kwargs)
             return data
 
-    def read_with_http_info(self, space_id, id, **kwargs):
-        """Read
+    def discard_with_http_info(self, space_id, charge_id, **kwargs):
+        """discard
 
-        Reads the entity with the given 'id' and returns it.
+        This operation allows to discard a scheduled charge.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.read_with_http_info(space_id, id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.discard_with_http_info(space_id, charge_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the suspension which should be returned. (required)
-        :return: SubscriptionSuspension
+        :param int charge_id:  (required)
+        :return: SubscriptionCharge
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['space_id', 'id']
+        all_params = ['space_id', 'charge_id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method read" % key
+                    " to method discard" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `read`")
-        # verify the required parameter 'id' is set
-        if ('id' not in params or
-                params['id'] is None):
-            raise ValueError("Missing the required parameter `id` when calling `read`")
+            raise ValueError("Missing the required parameter `space_id` when calling `discard`")
+        # verify the required parameter 'charge_id' is set
+        if ('charge_id' not in params or
+                params['charge_id'] is None):
+            raise ValueError("Missing the required parameter `charge_id` when calling `discard`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
             query_params.append(('spaceId', params['space_id']))
-        if 'id' in params:
-            query_params.append(('id', params['id']))
+        if 'charge_id' in params:
+            query_params.append(('chargeId', params['charge_id']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
-        # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(
-            ['*/*'])
-
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-suspension/read', 'GET',
+            '/subscription-charge/discard', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='SubscriptionSuspension',
+            response_type='SubscriptionCharge',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def search(self, space_id, query, **kwargs):
-        """Search
+    def read(self, space_id, id, **kwargs):
+        """Read
 
-        Searches for the entities as specified by the given query.
+        Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.search(space_id, query, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the subscription suspensions which are returned by the search. (required)
-        :return: list[SubscriptionSuspension]
+        :param int id: The id of the subscription charge which should be returned. (required)
+        :return: SubscriptionCharge
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.search_with_http_info(space_id, query, **kwargs)
+            return self.read_with_http_info(space_id, id, **kwargs)
         else:
-            (data) = self.search_with_http_info(space_id, query, **kwargs)
+            (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
-    def search_with_http_info(self, space_id, query, **kwargs):
-        """Search
+    def read_with_http_info(self, space_id, id, **kwargs):
+        """Read
 
-        Searches for the entities as specified by the given query.
+        Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.search_with_http_info(space_id, query, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the subscription suspensions which are returned by the search. (required)
-        :return: list[SubscriptionSuspension]
+        :param int id: The id of the subscription charge which should be returned. (required)
+        :return: SubscriptionCharge
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['space_id', 'query']
+        all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method search" % key
+                    " to method read" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `search`")
-        # verify the required parameter 'query' is set
-        if ('query' not in params or
-                params['query'] is None):
-            raise ValueError("Missing the required parameter `query` when calling `search`")
+            raise ValueError("Missing the required parameter `space_id` when calling `read`")
+        # verify the required parameter 'id' is set
+        if ('id' not in params or
+                params['id'] is None):
+            raise ValueError("Missing the required parameter `id` when calling `read`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
             query_params.append(('spaceId', params['space_id']))
+        if 'id' in params:
+            query_params.append(('id', params['id']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'query' in params:
-            body_params = params['query']
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(
-            ['application/json;charset=utf-8'])
+            ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-suspension/search', 'POST',
+            '/subscription-charge/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[SubscriptionSuspension]',
+            response_type='SubscriptionCharge',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def terminate(self, space_id, suspension_id, **kwargs):
-        """terminate
+    def search(self, space_id, query, **kwargs):
+        """Search
 
-        The create operation creates a new subscription suspension.
+        Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.terminate(space_id, suspension_id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int suspension_id:  (required)
-        :return: SubscriptionSuspension
+        :param EntityQuery query: The query restricts the subscription charges which are returned by the search. (required)
+        :return: list[SubscriptionCharge]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.terminate_with_http_info(space_id, suspension_id, **kwargs)
+            return self.search_with_http_info(space_id, query, **kwargs)
         else:
-            (data) = self.terminate_with_http_info(space_id, suspension_id, **kwargs)
+            (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
-    def terminate_with_http_info(self, space_id, suspension_id, **kwargs):
-        """terminate
+    def search_with_http_info(self, space_id, query, **kwargs):
+        """Search
 
-        The create operation creates a new subscription suspension.
+        Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.terminate_with_http_info(space_id, suspension_id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int suspension_id:  (required)
-        :return: SubscriptionSuspension
+        :param EntityQuery query: The query restricts the subscription charges which are returned by the search. (required)
+        :return: list[SubscriptionCharge]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['space_id', 'suspension_id']
+        all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method terminate" % key
+                    " to method search" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `terminate`")
-        # verify the required parameter 'suspension_id' is set
-        if ('suspension_id' not in params or
-                params['suspension_id'] is None):
-            raise ValueError("Missing the required parameter `suspension_id` when calling `terminate`")
+            raise ValueError("Missing the required parameter `space_id` when calling `search`")
+        # verify the required parameter 'query' is set
+        if ('query' not in params or
+                params['query'] is None):
+            raise ValueError("Missing the required parameter `query` when calling `search`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
             query_params.append(('spaceId', params['space_id']))
-        if 'suspension_id' in params:
-            query_params.append(('suspensionId', params['suspension_id']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+        if 'query' in params:
+            body_params = params['query']
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-suspension/terminate', 'POST',
+            '/subscription-charge/search', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='SubscriptionSuspension',
+            response_type='list[SubscriptionCharge]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/subscription_version_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/bank_account_service_api.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,52 +2,50 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class SubscriptionVersionServiceApi:
+class BankAccountServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -99,78 +97,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-version/count', 'POST',
+            '/bank-account/count', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the subscription which should be returned. (required)
-        :return: SubscriptionVersion
+        :param int id: The ID of the bank account which should be returned. (required)
+        :return: BankAccount
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the subscription which should be returned. (required)
-        :return: SubscriptionVersion
+        :param int id: The ID of the bank account which should be returned. (required)
+        :return: BankAccount
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -210,78 +206,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-version/read', 'GET',
+            '/bank-account/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='SubscriptionVersion',
+            response_type='BankAccount',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the subscriptions which are returned by the search. (required)
-        :return: list[SubscriptionVersion]
+        :param EntityQuery query: The query restricts the bank accounts which are returned by the search. (required)
+        :return: list[BankAccount]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the subscriptions which are returned by the search. (required)
-        :return: list[SubscriptionVersion]
+        :param EntityQuery query: The query restricts the bank accounts which are returned by the search. (required)
+        :return: list[BankAccount]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -321,21 +315,21 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/subscription-version/search', 'POST',
+            '/bank-account/search', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[SubscriptionVersion]',
+            response_type='list[BankAccount]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/token_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/token_service_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -12,42 +12,40 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def check_token_creation_possible(self, space_id, transaction_id, **kwargs):
         """Check If Token Creation Is Possible
 
         This operation checks if the given transaction can be used to create a token out of it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.check_token_creation_possible(space_id, transaction_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int transaction_id: The id of the transaction for which we want to check if the token can be created or not. (required)
         :return: bool
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.check_token_creation_possible_with_http_info(space_id, transaction_id, **kwargs)
         else:
             (data) = self.check_token_creation_possible_with_http_info(space_id, transaction_id, **kwargs)
             return data
 
     def check_token_creation_possible_with_http_info(self, space_id, transaction_id, **kwargs):
         """Check If Token Creation Is Possible
 
         This operation checks if the given transaction can be used to create a token out of it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.check_token_creation_possible_with_http_info(space_id, transaction_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int transaction_id: The id of the transaction for which we want to check if the token can be created or not. (required)
         :return: bool
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'transaction_id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method check_token_creation_possible" % key
@@ -107,50 +105,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='bool',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -158,15 +154,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -214,50 +210,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def create(self, space_id, entity, **kwargs):
         """Create
 
         Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param TokenCreate entity: The token object with the properties which should be created. (required)
         :return: Token
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.create_with_http_info(space_id, entity, **kwargs)
         else:
             (data) = self.create_with_http_info(space_id, entity, **kwargs)
             return data
 
     def create_with_http_info(self, space_id, entity, **kwargs):
         """Create
 
         Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param TokenCreate entity: The token object with the properties which should be created. (required)
         :return: Token
@@ -265,15 +259,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create" % key
@@ -325,50 +319,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='Token',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def create_token_based_on_transaction(self, space_id, transaction_id, **kwargs):
         """Create Token Based On Transaction
 
         This operation creates a token for the given transaction and fills it with the stored payment information of the transaction.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_token_based_on_transaction(space_id, transaction_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int transaction_id: The id of the transaction for which we want to create the token. (required)
         :return: TokenVersion
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.create_token_based_on_transaction_with_http_info(space_id, transaction_id, **kwargs)
         else:
             (data) = self.create_token_based_on_transaction_with_http_info(space_id, transaction_id, **kwargs)
             return data
 
     def create_token_based_on_transaction_with_http_info(self, space_id, transaction_id, **kwargs):
         """Create Token Based On Transaction
 
         This operation creates a token for the given transaction and fills it with the stored payment information of the transaction.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_token_based_on_transaction_with_http_info(space_id, transaction_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int transaction_id: The id of the transaction for which we want to create the token. (required)
         :return: TokenVersion
@@ -376,15 +368,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'transaction_id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create_token_based_on_transaction" % key
@@ -428,50 +420,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='TokenVersion',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def create_transaction_for_token_update(self, space_id, token_id, **kwargs):
         """Create Transaction for Token Update
 
         This operation creates a transaction which allows the updating of the provided token.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_transaction_for_token_update(space_id, token_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int token_id: The id of the token which should be updated. (required)
         :return: Transaction
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.create_transaction_for_token_update_with_http_info(space_id, token_id, **kwargs)
         else:
             (data) = self.create_transaction_for_token_update_with_http_info(space_id, token_id, **kwargs)
             return data
 
     def create_transaction_for_token_update_with_http_info(self, space_id, token_id, **kwargs):
         """Create Transaction for Token Update
 
         This operation creates a transaction which allows the updating of the provided token.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_transaction_for_token_update_with_http_info(space_id, token_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int token_id: The id of the token which should be updated. (required)
         :return: Transaction
@@ -479,15 +469,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'token_id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create_transaction_for_token_update" % key
@@ -531,50 +521,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='Transaction',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def delete(self, space_id, id, **kwargs):
         """Delete
 
         Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id:  (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.delete_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.delete_with_http_info(space_id, id, **kwargs)
             return data
 
     def delete_with_http_info(self, space_id, id, **kwargs):
         """Delete
 
         Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id:  (required)
         :return: None
@@ -582,15 +570,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete" % key
@@ -642,50 +630,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def process_transaction(self, space_id, transaction_id, **kwargs):
         """Process Transaction
 
         This operation processes the given transaction by using the token associated with the transaction.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.process_transaction(space_id, transaction_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int transaction_id: The id of the transaction for which we want to check if the token can be created or not. (required)
         :return: Charge
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.process_transaction_with_http_info(space_id, transaction_id, **kwargs)
         else:
             (data) = self.process_transaction_with_http_info(space_id, transaction_id, **kwargs)
             return data
 
     def process_transaction_with_http_info(self, space_id, transaction_id, **kwargs):
         """Process Transaction
 
         This operation processes the given transaction by using the token associated with the transaction.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.process_transaction_with_http_info(space_id, transaction_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int transaction_id: The id of the transaction for which we want to check if the token can be created or not. (required)
         :return: Charge
@@ -693,15 +679,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'transaction_id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method process_transaction" % key
@@ -745,50 +731,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='Charge',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the token which should be returned. (required)
         :return: Token
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the token which should be returned. (required)
         :return: Token
@@ -796,15 +780,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -856,50 +840,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='Token',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the tokens which are returned by the search. (required)
         :return: list[Token]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the tokens which are returned by the search. (required)
         :return: list[Token]
@@ -907,15 +889,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -967,50 +949,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[Token]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def update(self, space_id, entity, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param TokenUpdate entity: The object with all the properties which should be updated. The id and the version are required properties. (required)
         :return: Token
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.update_with_http_info(space_id, entity, **kwargs)
         else:
             (data) = self.update_with_http_info(space_id, entity, **kwargs)
             return data
 
     def update_with_http_info(self, space_id, entity, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param TokenUpdate entity: The object with all the properties which should be updated. The id and the version are required properties. (required)
         :return: Token
@@ -1018,15 +998,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update" % key
@@ -1078,9 +1058,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='Token',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/token_version_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/transaction_line_item_version_service_api.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,193 +2,189 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class TokenVersionServiceApi:
+class TransactionLineItemVersionServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
-    def active_version(self, space_id, id, **kwargs):
-        """Active Version
+    def count(self, space_id, **kwargs):
+        """Count
 
-        Returns the token version which is currently active given by the token id. In case no token version is active the method will return null.
+        Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.active_version(space_id, id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of a token for which you want to look up the current active token version. (required)
-        :return: TokenVersion
+        :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
+        :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.active_version_with_http_info(space_id, id, **kwargs)
+            return self.count_with_http_info(space_id, **kwargs)
         else:
-            (data) = self.active_version_with_http_info(space_id, id, **kwargs)
+            (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
-    def active_version_with_http_info(self, space_id, id, **kwargs):
-        """Active Version
+    def count_with_http_info(self, space_id, **kwargs):
+        """Count
 
-        Returns the token version which is currently active given by the token id. In case no token version is active the method will return null.
+        Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.active_version_with_http_info(space_id, id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of a token for which you want to look up the current active token version. (required)
-        :return: TokenVersion
+        :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
+        :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['space_id', 'id']
+        all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method active_version" % key
+                    " to method count" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `active_version`")
-        # verify the required parameter 'id' is set
-        if ('id' not in params or
-                params['id'] is None):
-            raise ValueError("Missing the required parameter `id` when calling `active_version`")
+            raise ValueError("Missing the required parameter `space_id` when calling `count`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
             query_params.append(('spaceId', params['space_id']))
-        if 'id' in params:
-            query_params.append(('id', params['id']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+        if 'filter' in params:
+            body_params = params['filter']
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(
-            ['*/*'])
+            ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/token-version/active-version', 'GET',
+            '/transaction-line-item-version/count', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TokenVersion',
+            response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def count(self, space_id, **kwargs):
-        """Count
+    def create(self, space_id, line_item_version, **kwargs):
+        """create
 
-        Counts the number of items in the database as restricted by the given filter.
+        This operation applies a line item version on a particular transaction.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.count(space_id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.create(space_id, line_item_version, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
-        :return: int
+        :param TransactionLineItemVersionCreate line_item_version: The line item version object which should be created. (required)
+        :return: TransactionLineItemVersion
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.count_with_http_info(space_id, **kwargs)
+            return self.create_with_http_info(space_id, line_item_version, **kwargs)
         else:
-            (data) = self.count_with_http_info(space_id, **kwargs)
+            (data) = self.create_with_http_info(space_id, line_item_version, **kwargs)
             return data
 
-    def count_with_http_info(self, space_id, **kwargs):
-        """Count
+    def create_with_http_info(self, space_id, line_item_version, **kwargs):
+        """create
 
-        Counts the number of items in the database as restricted by the given filter.
+        This operation applies a line item version on a particular transaction.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.count_with_http_info(space_id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.create_with_http_info(space_id, line_item_version, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
-        :return: int
+        :param TransactionLineItemVersionCreate line_item_version: The line item version object which should be created. (required)
+        :return: TransactionLineItemVersion
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['space_id', 'filter']
+        all_params = ['space_id', 'line_item_version']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method count" % key
+                    " to method create" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `count`")
+            raise ValueError("Missing the required parameter `space_id` when calling `create`")
+        # verify the required parameter 'line_item_version' is set
+        if ('line_item_version' not in params or
+                params['line_item_version'] is None):
+            raise ValueError("Missing the required parameter `line_item_version` when calling `create`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
@@ -196,92 +192,90 @@
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'filter' in params:
-            body_params = params['filter']
+        if 'line_item_version' in params:
+            body_params = params['line_item_version']
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/token-version/count', 'POST',
+            '/transaction-line-item-version/create', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='int',
+            response_type='TransactionLineItemVersion',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the token version which should be returned. (required)
-        :return: TokenVersion
+        :param int id: The ID of the line item version which should be returned. (required)
+        :return: TransactionLineItemVersion
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The id of the token version which should be returned. (required)
-        :return: TokenVersion
+        :param int id: The ID of the line item version which should be returned. (required)
+        :return: TransactionLineItemVersion
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -321,78 +315,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/token-version/read', 'GET',
+            '/transaction-line-item-version/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TokenVersion',
+            response_type='TransactionLineItemVersion',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the token versions which are returned by the search. (required)
-        :return: list[TokenVersion]
+        :param EntityQuery query: The query restricts line item versions which are returned by the search. (required)
+        :return: list[TransactionLineItemVersion]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts the token versions which are returned by the search. (required)
-        :return: list[TokenVersion]
+        :param EntityQuery query: The query restricts line item versions which are returned by the search. (required)
+        :return: list[TransactionLineItemVersion]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -432,21 +424,21 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/token-version/search', 'POST',
+            '/transaction-line-item-version/search', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[TokenVersion]',
+            response_type='list[TransactionLineItemVersion]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/transaction_comment_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/subscription_metric_service_api.py`

 * *Files 22% similar despite different names*

```diff
@@ -2,179 +2,171 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class TransactionCommentServiceApi:
+class SubscriptionMetricServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
-    def all(self, space_id, transaction_id, **kwargs):
-        """Find by transaction
+    def count(self, space_id, **kwargs):
+        """Count
 
-        Returns all comments of the transaction.
+        Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.all(space_id, transaction_id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int transaction_id:  (required)
-        :return: list[TransactionComment]
+        :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
+        :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.all_with_http_info(space_id, transaction_id, **kwargs)
+            return self.count_with_http_info(space_id, **kwargs)
         else:
-            (data) = self.all_with_http_info(space_id, transaction_id, **kwargs)
+            (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
-    def all_with_http_info(self, space_id, transaction_id, **kwargs):
-        """Find by transaction
+    def count_with_http_info(self, space_id, **kwargs):
+        """Count
 
-        Returns all comments of the transaction.
+        Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.all_with_http_info(space_id, transaction_id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int transaction_id:  (required)
-        :return: list[TransactionComment]
+        :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
+        :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['space_id', 'transaction_id']
+        all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method all" % key
+                    " to method count" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `all`")
-        # verify the required parameter 'transaction_id' is set
-        if ('transaction_id' not in params or
-                params['transaction_id'] is None):
-            raise ValueError("Missing the required parameter `transaction_id` when calling `all`")
+            raise ValueError("Missing the required parameter `space_id` when calling `count`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
             query_params.append(('spaceId', params['space_id']))
-        if 'transaction_id' in params:
-            query_params.append(('transactionId', params['transaction_id']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+        if 'filter' in params:
+            body_params = params['filter']
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/transaction-comment/all', 'POST',
+            '/subscription-metric/count', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[TransactionComment]',
+            response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def create(self, space_id, entity, **kwargs):
         """Create
 
-        Creates the comment with the given properties.
+        Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param TransactionCommentCreate entity:  (required)
-        :return: TransactionComment
+        :param SubscriptionMetricCreate entity: The metric object with the properties which should be created. (required)
+        :return: SubscriptionMetric
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.create_with_http_info(space_id, entity, **kwargs)
         else:
             (data) = self.create_with_http_info(space_id, entity, **kwargs)
             return data
 
     def create_with_http_info(self, space_id, entity, **kwargs):
         """Create
 
-        Creates the comment with the given properties.
+        Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param TransactionCommentCreate entity:  (required)
-        :return: TransactionComment
+        :param SubscriptionMetricCreate entity: The metric object with the properties which should be created. (required)
+        :return: SubscriptionMetric
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create" % key
@@ -214,78 +206,76 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/transaction-comment/create', 'POST',
+            '/subscription-metric/create', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TransactionComment',
+            response_type='SubscriptionMetric',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def delete(self, space_id, id, **kwargs):
         """Delete
 
-        Deletes the comment with the given id.
+        Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id:  (required)
+        :param int id: The id of the metric which should be deleted. (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.delete_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.delete_with_http_info(space_id, id, **kwargs)
             return data
 
     def delete_with_http_info(self, space_id, id, **kwargs):
         """Delete
 
-        Deletes the comment with the given id.
+        Deletes the entity with the given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id:  (required)
+        :param int id: The id of the metric which should be deleted. (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete" % key
@@ -304,210 +294,97 @@
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
             query_params.append(('spaceId', params['space_id']))
-        if 'id' in params:
-            query_params.append(('id', params['id']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json;charset=utf-8'])
-
-        # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(
-            ['application/json;charset=utf-8'])
-
-        # Authentication setting
-        auth_settings = []
-
-        return self.api_client.call_api(
-            '/transaction-comment/delete', 'POST',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type=None,
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
-            collection_formats=collection_formats)
-
-    def pin(self, space_id, id, **kwargs):
-        """Pin
-
-        Pins the comment to the top.
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.pin(space_id, id, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool
-        :param int space_id:  (required)
-        :param int id:  (required)
-        :return: None
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-        kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
-        if kwargs.get('async_req'):
-            return self.pin_with_http_info(space_id, id, **kwargs)
-        else:
-            (data) = self.pin_with_http_info(space_id, id, **kwargs)
-            return data
-
-    def pin_with_http_info(self, space_id, id, **kwargs):
-        """Pin
-
-        Pins the comment to the top.
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.pin_with_http_info(space_id, id, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool
-        :param int space_id:  (required)
-        :param int id:  (required)
-        :return: None
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['space_id', 'id']
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('request_timeout')
-
-        params = locals()
-        for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method pin" % key
-                )
-            params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'space_id' is set
-        if ('space_id' not in params or
-                params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `pin`")
-        # verify the required parameter 'id' is set
-        if ('id' not in params or
-                params['id'] is None):
-            raise ValueError("Missing the required parameter `id` when calling `pin`")
-
-        collection_formats = {}
-
-        path_params = {}
-
-        query_params = []
-        if 'space_id' in params:
-            query_params.append(('spaceId', params['space_id']))
         if 'id' in params:
-            query_params.append(('id', params['id']))
-
-        header_params = {}
-
-        form_params = []
-        local_var_files = {}
-
-        body_params = None
+            body_params = params['id']
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(
-            ['*/*'])
+            ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/transaction-comment/pin', 'GET',
+            '/subscription-metric/delete', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
-        Reads the comment with the given 'id' and returns it.
+        Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id:  (required)
-        :return: TransactionComment
+        :param int id: The id of the metric which should be returned. (required)
+        :return: SubscriptionMetric
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
-        Reads the comment with the given 'id' and returns it.
+        Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id:  (required)
-        :return: TransactionComment
+        :param int id: The id of the metric which should be returned. (required)
+        :return: SubscriptionMetric
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -547,189 +424,185 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['*/*'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/transaction-comment/read', 'GET',
+            '/subscription-metric/read', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TransactionComment',
+            response_type='SubscriptionMetric',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def unpin(self, space_id, id, **kwargs):
-        """Unpin
+    def search(self, space_id, query, **kwargs):
+        """Search
 
-        Unpins the comment from the top.
+        Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.unpin(space_id, id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id:  (required)
-        :return: None
+        :param EntityQuery query: The query restricts the metric which are returned by the search. (required)
+        :return: list[SubscriptionMetric]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.unpin_with_http_info(space_id, id, **kwargs)
+            return self.search_with_http_info(space_id, query, **kwargs)
         else:
-            (data) = self.unpin_with_http_info(space_id, id, **kwargs)
+            (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
-    def unpin_with_http_info(self, space_id, id, **kwargs):
-        """Unpin
+    def search_with_http_info(self, space_id, query, **kwargs):
+        """Search
 
-        Unpins the comment from the top.
+        Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.unpin_with_http_info(space_id, id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id:  (required)
-        :return: None
+        :param EntityQuery query: The query restricts the metric which are returned by the search. (required)
+        :return: list[SubscriptionMetric]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['space_id', 'id']
+        all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method unpin" % key
+                    " to method search" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `unpin`")
-        # verify the required parameter 'id' is set
-        if ('id' not in params or
-                params['id'] is None):
-            raise ValueError("Missing the required parameter `id` when calling `unpin`")
+            raise ValueError("Missing the required parameter `space_id` when calling `search`")
+        # verify the required parameter 'query' is set
+        if ('query' not in params or
+                params['query'] is None):
+            raise ValueError("Missing the required parameter `query` when calling `search`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
             query_params.append(('spaceId', params['space_id']))
-        if 'id' in params:
-            query_params.append(('id', params['id']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+        if 'query' in params:
+            body_params = params['query']
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(
-            ['*/*'])
+            ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/transaction-comment/unpin', 'GET',
+            '/subscription-metric/search', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type=None,
+            response_type='list[SubscriptionMetric]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def update(self, space_id, entity, **kwargs):
         """Update
 
-        This updates the comment with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the comment.
+        This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param TransactionCommentActive entity:  (required)
-        :return: TransactionComment
+        :param SubscriptionMetricActive entity: The products metric with all the properties which should be updated. The id and the version are required properties. (required)
+        :return: SubscriptionMetric
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.update_with_http_info(space_id, entity, **kwargs)
         else:
             (data) = self.update_with_http_info(space_id, entity, **kwargs)
             return data
 
     def update_with_http_info(self, space_id, entity, **kwargs):
         """Update
 
-        This updates the comment with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the comment.
+        This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param TransactionCommentActive entity:  (required)
-        :return: TransactionComment
+        :param SubscriptionMetricActive entity: The products metric with all the properties which should be updated. The id and the version are required properties. (required)
+        :return: SubscriptionMetric
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update" % key
@@ -769,21 +642,21 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/transaction-comment/update', 'POST',
+            '/subscription-metric/update', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TransactionComment',
+            response_type='SubscriptionMetric',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/transaction_completion_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/transaction_completion_service_api.py`

 * *Files 8% similar despite different names*

```diff
@@ -12,42 +12,40 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def complete_offline(self, space_id, id, **kwargs):
         """completeOffline
 
         This operation completes the transaction offline. The completion is not forwarded to the processor. This implies the processor does not do anything. This method is only here to fix manually the transaction state.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.complete_offline(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the transaction which should be completed. (required)
         :return: TransactionCompletion
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.complete_offline_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.complete_offline_with_http_info(space_id, id, **kwargs)
             return data
 
     def complete_offline_with_http_info(self, space_id, id, **kwargs):
         """completeOffline
 
         This operation completes the transaction offline. The completion is not forwarded to the processor. This implies the processor does not do anything. This method is only here to fix manually the transaction state.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.complete_offline_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the transaction which should be completed. (required)
         :return: TransactionCompletion
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method complete_offline" % key
@@ -111,50 +109,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='TransactionCompletion',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def complete_online(self, space_id, id, **kwargs):
         """completeOnline
 
         This operation completes the transaction online. The completion is forwarded to the processor. This implies that the processor may take some actions based on the completion.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.complete_online(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the transaction which should be completed. (required)
         :return: TransactionCompletion
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.complete_online_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.complete_online_with_http_info(space_id, id, **kwargs)
             return data
 
     def complete_online_with_http_info(self, space_id, id, **kwargs):
         """completeOnline
 
         This operation completes the transaction online. The completion is forwarded to the processor. This implies that the processor may take some actions based on the completion.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.complete_online_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the transaction which should be completed. (required)
         :return: TransactionCompletion
@@ -162,15 +158,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method complete_online" % key
@@ -218,50 +214,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='TransactionCompletion',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def complete_partially_offline(self, space_id, completion, **kwargs):
         """completePartiallyOffline
 
         This operation can be used to partially complete the transaction offline. The completion is not forwarded to the processor. This implies the processor does not do anything. This method is only here to fix manually the transaction state.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.complete_partially_offline(space_id, completion, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param TransactionCompletionRequest completion:  (required)
         :return: TransactionCompletion
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.complete_partially_offline_with_http_info(space_id, completion, **kwargs)
         else:
             (data) = self.complete_partially_offline_with_http_info(space_id, completion, **kwargs)
             return data
 
     def complete_partially_offline_with_http_info(self, space_id, completion, **kwargs):
         """completePartiallyOffline
 
         This operation can be used to partially complete the transaction offline. The completion is not forwarded to the processor. This implies the processor does not do anything. This method is only here to fix manually the transaction state.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.complete_partially_offline_with_http_info(space_id, completion, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param TransactionCompletionRequest completion:  (required)
         :return: TransactionCompletion
@@ -269,15 +263,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'completion']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method complete_partially_offline" % key
@@ -329,50 +323,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='TransactionCompletion',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def complete_partially_online(self, space_id, completion, **kwargs):
         """completePartiallyOnline
 
         This operation can be used to partially complete the transaction online. The completion is forwarded to the processor. This implies that the processor may take some actions based on the completion.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.complete_partially_online(space_id, completion, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param TransactionCompletionRequest completion:  (required)
         :return: TransactionCompletion
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.complete_partially_online_with_http_info(space_id, completion, **kwargs)
         else:
             (data) = self.complete_partially_online_with_http_info(space_id, completion, **kwargs)
             return data
 
     def complete_partially_online_with_http_info(self, space_id, completion, **kwargs):
         """completePartiallyOnline
 
         This operation can be used to partially complete the transaction online. The completion is forwarded to the processor. This implies that the processor may take some actions based on the completion.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.complete_partially_online_with_http_info(space_id, completion, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param TransactionCompletionRequest completion:  (required)
         :return: TransactionCompletion
@@ -380,15 +372,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'completion']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method complete_partially_online" % key
@@ -440,50 +432,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='TransactionCompletion',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -491,15 +481,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -547,50 +537,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the transaction completions which should be returned. (required)
         :return: TransactionCompletion
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the transaction completions which should be returned. (required)
         :return: TransactionCompletion
@@ -598,15 +586,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -658,50 +646,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='TransactionCompletion',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the transaction completions which are returned by the search. (required)
         :return: list[TransactionCompletion]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the transaction completions which are returned by the search. (required)
         :return: list[TransactionCompletion]
@@ -709,15 +695,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -769,9 +755,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[TransactionCompletion]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/transaction_iframe_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/transaction_iframe_service_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -12,42 +12,40 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def javascript_url(self, space_id, id, **kwargs):
         """Build JavaScript URL
 
         This operation creates the URL which can be used to embed the JavaScript for handling the iFrame checkout flow.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.javascript_url(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the transaction which should be returned. (required)
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.javascript_url_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.javascript_url_with_http_info(space_id, id, **kwargs)
             return data
 
     def javascript_url_with_http_info(self, space_id, id, **kwargs):
         """Build JavaScript URL
 
         This operation creates the URL which can be used to embed the JavaScript for handling the iFrame checkout flow.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.javascript_url_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the transaction which should be returned. (required)
         :return: str
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method javascript_url" % key
@@ -111,9 +109,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='str',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/transaction_lightbox_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/transaction_lightbox_service_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -12,42 +12,40 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def javascript_url(self, space_id, id, **kwargs):
         """Build JavaScript URL
 
         This operation creates the URL which can be used to embed the JavaScript for handling the Lightbox checkout flow.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.javascript_url(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the transaction which should be returned. (required)
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.javascript_url_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.javascript_url_with_http_info(space_id, id, **kwargs)
             return data
 
     def javascript_url_with_http_info(self, space_id, id, **kwargs):
         """Build JavaScript URL
 
         This operation creates the URL which can be used to embed the JavaScript for handling the Lightbox checkout flow.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.javascript_url_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the transaction which should be returned. (required)
         :return: str
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method javascript_url" % key
@@ -111,9 +109,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='str',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/transaction_line_item_version_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/transaction_void_service_api.py`

 * *Files 21% similar despite different names*

```diff
@@ -2,52 +2,50 @@
 
 from __future__ import absolute_import
 
 import six
 
 from whitelabelmachinename.api_client import ApiClient
 
-class TransactionLineItemVersionServiceApi:
+class TransactionVoidServiceApi:
 
     def __init__(self, configuration):
         self.api_client = ApiClient(configuration=configuration)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -99,96 +97,203 @@
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/transaction-line-item-version/count', 'POST',
+            '/transaction-void/count', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
+            collection_formats=collection_formats)
+
+    def read(self, space_id, id, **kwargs):
+        """Read
+
+        Reads the entity with the given 'id' and returns it.
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.read(space_id, id, async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool
+        :param int space_id:  (required)
+        :param int id: The id of the transaction voids which should be returned. (required)
+        :return: TransactionVoid
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+        kwargs['_return_http_data_only'] = True
+
+
+        if kwargs.get('async_req'):
+            return self.read_with_http_info(space_id, id, **kwargs)
+        else:
+            (data) = self.read_with_http_info(space_id, id, **kwargs)
+            return data
+
+    def read_with_http_info(self, space_id, id, **kwargs):
+        """Read
+
+        Reads the entity with the given 'id' and returns it.
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.read_with_http_info(space_id, id, async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool
+        :param int space_id:  (required)
+        :param int id: The id of the transaction voids which should be returned. (required)
+        :return: TransactionVoid
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+
+        all_params = ['space_id', 'id']
+        all_params.append('async_req')
+        all_params.append('_return_http_data_only')
+        all_params.append('_preload_content')
+        all_params.append('_request_timeout')
+
+        params = locals()
+        for key, val in six.iteritems(params['kwargs']):
+            if key not in all_params:
+                raise TypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method read" % key
+                )
+            params[key] = val
+        del params['kwargs']
+        # verify the required parameter 'space_id' is set
+        if ('space_id' not in params or
+                params['space_id'] is None):
+            raise ValueError("Missing the required parameter `space_id` when calling `read`")
+        # verify the required parameter 'id' is set
+        if ('id' not in params or
+                params['id'] is None):
+            raise ValueError("Missing the required parameter `id` when calling `read`")
+
+        collection_formats = {}
+
+        path_params = {}
+
+        query_params = []
+        if 'space_id' in params:
+            query_params.append(('spaceId', params['space_id']))
+        if 'id' in params:
+            query_params.append(('id', params['id']))
+
+        header_params = {}
+
+        form_params = []
+        local_var_files = {}
+
+        body_params = None
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json;charset=utf-8'])
+
+        # HTTP header `Content-Type`
+        header_params['Content-Type'] = self.api_client.select_header_content_type(
+            ['*/*'])
+
+        # Authentication setting
+        auth_settings = []
+
+        return self.api_client.call_api(
+            '/transaction-void/read', 'GET',
+            path_params,
+            query_params,
+            header_params,
+            body=body_params,
+            post_params=form_params,
+            files=local_var_files,
+            response_type='TransactionVoid',
+            auth_settings=auth_settings,
+            async_req=params.get('async_req'),
+            _return_http_data_only=params.get('_return_http_data_only'),
+            _preload_content=params.get('_preload_content', True),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def create(self, space_id, line_item_version, **kwargs):
-        """create
+    def search(self, space_id, query, **kwargs):
+        """Search
 
-        This operation applies a line item version on a particular transaction.
+        Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.create(space_id, line_item_version, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param TransactionLineItemVersionCreate line_item_version: The line item version object which should be created. (required)
-        :return: TransactionLineItemVersion
+        :param EntityQuery query: The query restricts the transaction voids which are returned by the search. (required)
+        :return: list[TransactionVoid]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.create_with_http_info(space_id, line_item_version, **kwargs)
+            return self.search_with_http_info(space_id, query, **kwargs)
         else:
-            (data) = self.create_with_http_info(space_id, line_item_version, **kwargs)
+            (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
-    def create_with_http_info(self, space_id, line_item_version, **kwargs):
-        """create
+    def search_with_http_info(self, space_id, query, **kwargs):
+        """Search
 
-        This operation applies a line item version on a particular transaction.
+        Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.create_with_http_info(space_id, line_item_version, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param TransactionLineItemVersionCreate line_item_version: The line item version object which should be created. (required)
-        :return: TransactionLineItemVersion
+        :param EntityQuery query: The query restricts the transaction voids which are returned by the search. (required)
+        :return: list[TransactionVoid]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['space_id', 'line_item_version']
+        all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method create" % key
+                    " to method search" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `create`")
-        # verify the required parameter 'line_item_version' is set
-        if ('line_item_version' not in params or
-                params['line_item_version'] is None):
-            raise ValueError("Missing the required parameter `line_item_version` when calling `create`")
+            raise ValueError("Missing the required parameter `space_id` when calling `search`")
+        # verify the required parameter 'query' is set
+        if ('query' not in params or
+                params['query'] is None):
+            raise ValueError("Missing the required parameter `query` when calling `search`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
@@ -196,110 +301,108 @@
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'line_item_version' in params:
-            body_params = params['line_item_version']
+        if 'query' in params:
+            body_params = params['query']
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(
             ['application/json;charset=utf-8'])
 
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/transaction-line-item-version/create', 'POST',
+            '/transaction-void/search', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TransactionLineItemVersion',
+            response_type='list[TransactionVoid]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def read(self, space_id, id, **kwargs):
-        """Read
+    def void_offline(self, space_id, id, **kwargs):
+        """voidOffline
 
-        Reads the entity with the given 'id' and returns it.
+        This operation voids the transaction offline. The void is not forwarded to the processor. This implies the processor does not do anything. This method is only here to fix manually the transaction state.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.read(space_id, id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.void_offline(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The ID of the line item version which should be returned. (required)
-        :return: TransactionLineItemVersion
+        :param int id: The id of the transaction which should be voided. (required)
+        :return: TransactionVoid
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.read_with_http_info(space_id, id, **kwargs)
+            return self.void_offline_with_http_info(space_id, id, **kwargs)
         else:
-            (data) = self.read_with_http_info(space_id, id, **kwargs)
+            (data) = self.void_offline_with_http_info(space_id, id, **kwargs)
             return data
 
-    def read_with_http_info(self, space_id, id, **kwargs):
-        """Read
+    def void_offline_with_http_info(self, space_id, id, **kwargs):
+        """voidOffline
 
-        Reads the entity with the given 'id' and returns it.
+        This operation voids the transaction offline. The void is not forwarded to the processor. This implies the processor does not do anything. This method is only here to fix manually the transaction state.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.read_with_http_info(space_id, id, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.void_offline_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param int id: The ID of the line item version which should be returned. (required)
-        :return: TransactionLineItemVersion
+        :param int id: The id of the transaction which should be voided. (required)
+        :return: TransactionVoid
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method read" % key
+                    " to method void_offline" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `read`")
+            raise ValueError("Missing the required parameter `space_id` when calling `void_offline`")
         # verify the required parameter 'id' is set
         if ('id' not in params or
                 params['id'] is None):
-            raise ValueError("Missing the required parameter `id` when calling `read`")
+            raise ValueError("Missing the required parameter `id` when calling `void_offline`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
@@ -313,140 +416,130 @@
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
-        # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(
-            ['*/*'])
-
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/transaction-line-item-version/read', 'GET',
+            '/transaction-void/voidOffline', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TransactionLineItemVersion',
+            response_type='TransactionVoid',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def search(self, space_id, query, **kwargs):
-        """Search
+    def void_online(self, space_id, id, **kwargs):
+        """voidOnline
 
-        Searches for the entities as specified by the given query.
+        This operation voids the transaction online. The void is forwarded to the processor. This implies that the processor may take some actions based on the void.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.search(space_id, query, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.void_online(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts line item versions which are returned by the search. (required)
-        :return: list[TransactionLineItemVersion]
+        :param int id: The id of the transaction which should be voided. (required)
+        :return: TransactionVoid
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
-            return self.search_with_http_info(space_id, query, **kwargs)
+            return self.void_online_with_http_info(space_id, id, **kwargs)
         else:
-            (data) = self.search_with_http_info(space_id, query, **kwargs)
+            (data) = self.void_online_with_http_info(space_id, id, **kwargs)
             return data
 
-    def search_with_http_info(self, space_id, query, **kwargs):
-        """Search
+    def void_online_with_http_info(self, space_id, id, **kwargs):
+        """voidOnline
 
-        Searches for the entities as specified by the given query.
+        This operation voids the transaction online. The void is forwarded to the processor. This implies that the processor may take some actions based on the void.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
-        >>> thread = api.search_with_http_info(space_id, query, async_req=True)
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.void_online_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
-        :param EntityQuery query: The query restricts line item versions which are returned by the search. (required)
-        :return: list[TransactionLineItemVersion]
+        :param int id: The id of the transaction which should be voided. (required)
+        :return: TransactionVoid
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['space_id', 'query']
+        all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method search" % key
+                    " to method void_online" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'space_id' is set
         if ('space_id' not in params or
                 params['space_id'] is None):
-            raise ValueError("Missing the required parameter `space_id` when calling `search`")
-        # verify the required parameter 'query' is set
-        if ('query' not in params or
-                params['query'] is None):
-            raise ValueError("Missing the required parameter `query` when calling `search`")
+            raise ValueError("Missing the required parameter `space_id` when calling `void_online`")
+        # verify the required parameter 'id' is set
+        if ('id' not in params or
+                params['id'] is None):
+            raise ValueError("Missing the required parameter `id` when calling `void_online`")
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'space_id' in params:
             query_params.append(('spaceId', params['space_id']))
+        if 'id' in params:
+            query_params.append(('id', params['id']))
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'query' in params:
-            body_params = params['query']
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json;charset=utf-8'])
 
-        # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(
-            ['application/json;charset=utf-8'])
-
         # Authentication setting
         auth_settings = []
 
         return self.api_client.call_api(
-            '/transaction-line-item-version/search', 'POST',
+            '/transaction-void/voidOnline', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[TransactionLineItemVersion]',
+            response_type='TransactionVoid',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/transaction_mobile_sdk_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/transaction_mobile_sdk_service_api.py`

 * *Files 5% similar despite different names*

```diff
@@ -12,56 +12,54 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def payment_form_url(self, credentials, **kwargs):
         """Build Mobile SDK URL
 
         This operation builds the URL which is used to load the payment form within a WebView on a mobile device. This operation is typically called through the mobile SDK.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.payment_form_url(credentials, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str credentials: The credentials identifies the transaction and contains the security details which grants the access this operation. (required)
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.payment_form_url_with_http_info(credentials, **kwargs)
         else:
             (data) = self.payment_form_url_with_http_info(credentials, **kwargs)
             return data
 
     def payment_form_url_with_http_info(self, credentials, **kwargs):
         """Build Mobile SDK URL
 
         This operation builds the URL which is used to load the payment form within a WebView on a mobile device. This operation is typically called through the mobile SDK.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.payment_form_url_with_http_info(credentials, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str credentials: The credentials identifies the transaction and contains the security details which grants the access this operation. (required)
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['credentials']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method payment_form_url" % key
@@ -103,9 +101,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='str',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/transaction_payment_page_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/transaction_payment_page_service_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -12,42 +12,40 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def payment_page_url(self, space_id, id, **kwargs):
         """Build Payment Page URL
 
         This operation creates the URL to which the user should be redirected to when the payment page should be used.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.payment_page_url(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the transaction which should be returned. (required)
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.payment_page_url_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.payment_page_url_with_http_info(space_id, id, **kwargs)
             return data
 
     def payment_page_url_with_http_info(self, space_id, id, **kwargs):
         """Build Payment Page URL
 
         This operation creates the URL to which the user should be redirected to when the payment page should be used.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.payment_page_url_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the transaction which should be returned. (required)
         :return: str
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method payment_page_url" % key
@@ -111,9 +109,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='str',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/transaction_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/transaction_service_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -12,42 +12,40 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def confirm(self, space_id, transaction_model, **kwargs):
         """Confirm
 
         The confirm operation marks the transaction as confirmed. Once the transaction is confirmed no more changes can be applied.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.confirm(space_id, transaction_model, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param TransactionPending transaction_model: The transaction JSON object to update and confirm. (required)
         :return: Transaction
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.confirm_with_http_info(space_id, transaction_model, **kwargs)
         else:
             (data) = self.confirm_with_http_info(space_id, transaction_model, **kwargs)
             return data
 
     def confirm_with_http_info(self, space_id, transaction_model, **kwargs):
         """Confirm
 
         The confirm operation marks the transaction as confirmed. Once the transaction is confirmed no more changes can be applied.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.confirm_with_http_info(space_id, transaction_model, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param TransactionPending transaction_model: The transaction JSON object to update and confirm. (required)
         :return: Transaction
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'transaction_model']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method confirm" % key
@@ -115,50 +113,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='Transaction',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def count(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.count_with_http_info(space_id, **kwargs)
         else:
             (data) = self.count_with_http_info(space_id, **kwargs)
             return data
 
     def count_with_http_info(self, space_id, **kwargs):
         """Count
 
         Counts the number of items in the database as restricted by the given filter.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.count_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQueryFilter filter: The filter which restricts the entities which are used to calculate the count.
         :return: int
@@ -166,15 +162,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'filter']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method count" % key
@@ -222,50 +218,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='int',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def create(self, space_id, transaction, **kwargs):
         """Create
 
         Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create(space_id, transaction, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param TransactionCreate transaction: The transaction object which should be created. (required)
         :return: Transaction
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.create_with_http_info(space_id, transaction, **kwargs)
         else:
             (data) = self.create_with_http_info(space_id, transaction, **kwargs)
             return data
 
     def create_with_http_info(self, space_id, transaction, **kwargs):
         """Create
 
         Creates the entity with the given properties.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_with_http_info(space_id, transaction, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param TransactionCreate transaction: The transaction object which should be created. (required)
         :return: Transaction
@@ -273,15 +267,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'transaction']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create" % key
@@ -333,50 +327,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='Transaction',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def create_transaction_credentials(self, space_id, id, **kwargs):
         """Create Transaction Credentials
 
         This operation allows to create transaction credentials to delegate temporarily the access to the web service API for this particular transaction.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_transaction_credentials(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the transaction which should be returned. (required)
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.create_transaction_credentials_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.create_transaction_credentials_with_http_info(space_id, id, **kwargs)
             return data
 
     def create_transaction_credentials_with_http_info(self, space_id, id, **kwargs):
         """Create Transaction Credentials
 
         This operation allows to create transaction credentials to delegate temporarily the access to the web service API for this particular transaction.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_transaction_credentials_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the transaction which should be returned. (required)
         :return: str
@@ -384,15 +376,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create_transaction_credentials" % key
@@ -436,50 +428,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='str',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def delete_one_click_token_with_credentials(self, credentials, token_id, **kwargs):
         """Delete One-Click Token with Credentials
 
         This operation removes the given token.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_one_click_token_with_credentials(credentials, token_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str credentials: The credentials identifies the transaction and contains the security details which grants the access this operation. (required)
         :param int token_id: The token ID will be used to find the token which should be removed. (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.delete_one_click_token_with_credentials_with_http_info(credentials, token_id, **kwargs)
         else:
             (data) = self.delete_one_click_token_with_credentials_with_http_info(credentials, token_id, **kwargs)
             return data
 
     def delete_one_click_token_with_credentials_with_http_info(self, credentials, token_id, **kwargs):
         """Delete One-Click Token with Credentials
 
         This operation removes the given token.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_one_click_token_with_credentials_with_http_info(credentials, token_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str credentials: The credentials identifies the transaction and contains the security details which grants the access this operation. (required)
         :param int token_id: The token ID will be used to find the token which should be removed. (required)
         :return: None
@@ -487,15 +477,15 @@
                  returns the request thread.
         """
 
         all_params = ['credentials', 'token_id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete_one_click_token_with_credentials" % key
@@ -539,50 +529,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def export(self, space_id, request, **kwargs):
         """Export
 
         Exports the transactions into a CSV file. The file will contain the properties defined in the request.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.export(space_id, request, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityExportRequest request: The request controls the entries which are exported. (required)
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.export_with_http_info(space_id, request, **kwargs)
         else:
             (data) = self.export_with_http_info(space_id, request, **kwargs)
             return data
 
     def export_with_http_info(self, space_id, request, **kwargs):
         """Export
 
         Exports the transactions into a CSV file. The file will contain the properties defined in the request.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.export_with_http_info(space_id, request, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityExportRequest request: The request controls the entries which are exported. (required)
         :return: str
@@ -590,15 +578,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'request']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method export" % key
@@ -650,64 +638,62 @@
             post_params=form_params,
             files=local_var_files,
             response_type='str',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def fetch_one_click_tokens_with_credentials(self, credentials, **kwargs):
         """Fetch One Click Tokens with Credentials
 
         This operation returns the token version objects which references the tokens usable as one-click payment tokens for the provided transaction.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.fetch_one_click_tokens_with_credentials(credentials, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str credentials: The credentials identifies the transaction and contains the security details which grants the access this operation. (required)
         :return: list[TokenVersion]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.fetch_one_click_tokens_with_credentials_with_http_info(credentials, **kwargs)
         else:
             (data) = self.fetch_one_click_tokens_with_credentials_with_http_info(credentials, **kwargs)
             return data
 
     def fetch_one_click_tokens_with_credentials_with_http_info(self, credentials, **kwargs):
         """Fetch One Click Tokens with Credentials
 
         This operation returns the token version objects which references the tokens usable as one-click payment tokens for the provided transaction.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.fetch_one_click_tokens_with_credentials_with_http_info(credentials, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str credentials: The credentials identifies the transaction and contains the security details which grants the access this operation. (required)
         :return: list[TokenVersion]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['credentials']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method fetch_one_click_tokens_with_credentials" % key
@@ -745,51 +731,49 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[TokenVersion]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def fetch_payment_methods(self, space_id, id, integration_mode, **kwargs):
         """Fetch Possible Payment Methods
 
         This operation allows to get the payment method configurations which can be used with the provided transaction.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.fetch_payment_methods(space_id, id, integration_mode, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the transaction which should be returned. (required)
         :param str integration_mode: The integration mode defines the type of integration that is applied on the transaction. (required)
         :return: list[PaymentMethodConfiguration]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.fetch_payment_methods_with_http_info(space_id, id, integration_mode, **kwargs)
         else:
             (data) = self.fetch_payment_methods_with_http_info(space_id, id, integration_mode, **kwargs)
             return data
 
     def fetch_payment_methods_with_http_info(self, space_id, id, integration_mode, **kwargs):
         """Fetch Possible Payment Methods
 
         This operation allows to get the payment method configurations which can be used with the provided transaction.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.fetch_payment_methods_with_http_info(space_id, id, integration_mode, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the transaction which should be returned. (required)
         :param str integration_mode: The integration mode defines the type of integration that is applied on the transaction. (required)
@@ -798,15 +782,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id', 'integration_mode']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method fetch_payment_methods" % key
@@ -860,50 +844,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[PaymentMethodConfiguration]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def fetch_payment_methods_with_credentials(self, credentials, integration_mode, **kwargs):
         """Fetch Possible Payment Methods with Credentials
 
         This operation allows to get the payment method configurations which can be used with the provided transaction.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.fetch_payment_methods_with_credentials(credentials, integration_mode, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str credentials: The credentials identifies the transaction and contains the security details which grants the access this operation. (required)
         :param str integration_mode: The integration mode defines the type of integration that is applied on the transaction. (required)
         :return: list[PaymentMethodConfiguration]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.fetch_payment_methods_with_credentials_with_http_info(credentials, integration_mode, **kwargs)
         else:
             (data) = self.fetch_payment_methods_with_credentials_with_http_info(credentials, integration_mode, **kwargs)
             return data
 
     def fetch_payment_methods_with_credentials_with_http_info(self, credentials, integration_mode, **kwargs):
         """Fetch Possible Payment Methods with Credentials
 
         This operation allows to get the payment method configurations which can be used with the provided transaction.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.fetch_payment_methods_with_credentials_with_http_info(credentials, integration_mode, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str credentials: The credentials identifies the transaction and contains the security details which grants the access this operation. (required)
         :param str integration_mode: The integration mode defines the type of integration that is applied on the transaction. (required)
         :return: list[PaymentMethodConfiguration]
@@ -911,15 +893,15 @@
                  returns the request thread.
         """
 
         all_params = ['credentials', 'integration_mode']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method fetch_payment_methods_with_credentials" % key
@@ -967,50 +949,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[PaymentMethodConfiguration]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def get_invoice_document(self, space_id, id, **kwargs):
         """getInvoiceDocument
 
         Returns the PDF document for the transaction invoice with given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_invoice_document(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the transaction to get the invoice document for. (required)
         :return: RenderedDocument
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.get_invoice_document_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.get_invoice_document_with_http_info(space_id, id, **kwargs)
             return data
 
     def get_invoice_document_with_http_info(self, space_id, id, **kwargs):
         """getInvoiceDocument
 
         Returns the PDF document for the transaction invoice with given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_invoice_document_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the transaction to get the invoice document for. (required)
         :return: RenderedDocument
@@ -1018,15 +998,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_invoice_document" % key
@@ -1078,50 +1058,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='RenderedDocument',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def get_latest_transaction_line_item_version(self, space_id, id, **kwargs):
         """getLatestSuccessfulTransactionLineItemVersion
 
         
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_latest_transaction_line_item_version(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the transaction to get the latest line item version for. (required)
         :return: TransactionLineItemVersion
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.get_latest_transaction_line_item_version_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.get_latest_transaction_line_item_version_with_http_info(space_id, id, **kwargs)
             return data
 
     def get_latest_transaction_line_item_version_with_http_info(self, space_id, id, **kwargs):
         """getLatestSuccessfulTransactionLineItemVersion
 
         
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_latest_transaction_line_item_version_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the transaction to get the latest line item version for. (required)
         :return: TransactionLineItemVersion
@@ -1129,15 +1107,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_latest_transaction_line_item_version" % key
@@ -1185,50 +1163,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='TransactionLineItemVersion',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def get_packing_slip(self, space_id, id, **kwargs):
         """getPackingSlip
 
         Returns the packing slip for the transaction with given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_packing_slip(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the transaction to get the packing slip for. (required)
         :return: RenderedDocument
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.get_packing_slip_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.get_packing_slip_with_http_info(space_id, id, **kwargs)
             return data
 
     def get_packing_slip_with_http_info(self, space_id, id, **kwargs):
         """getPackingSlip
 
         Returns the packing slip for the transaction with given id.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_packing_slip_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the transaction to get the packing slip for. (required)
         :return: RenderedDocument
@@ -1236,15 +1212,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_packing_slip" % key
@@ -1296,50 +1272,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='RenderedDocument',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def process_one_click_token_and_redirect_with_credentials(self, credentials, token_id, **kwargs):
         """Process One-Click Token with Credentials
 
         This operation assigns the given token to the transaction and process it. This method will return an URL where the customer has to be redirect to complete the transaction.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.process_one_click_token_and_redirect_with_credentials(credentials, token_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str credentials: The credentials identifies the transaction and contains the security details which grants the access this operation. (required)
         :param int token_id: The token ID is used to load the corresponding token and to process the transaction with it. (required)
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.process_one_click_token_and_redirect_with_credentials_with_http_info(credentials, token_id, **kwargs)
         else:
             (data) = self.process_one_click_token_and_redirect_with_credentials_with_http_info(credentials, token_id, **kwargs)
             return data
 
     def process_one_click_token_and_redirect_with_credentials_with_http_info(self, credentials, token_id, **kwargs):
         """Process One-Click Token with Credentials
 
         This operation assigns the given token to the transaction and process it. This method will return an URL where the customer has to be redirect to complete the transaction.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.process_one_click_token_and_redirect_with_credentials_with_http_info(credentials, token_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str credentials: The credentials identifies the transaction and contains the security details which grants the access this operation. (required)
         :param int token_id: The token ID is used to load the corresponding token and to process the transaction with it. (required)
         :return: str
@@ -1347,15 +1321,15 @@
                  returns the request thread.
         """
 
         all_params = ['credentials', 'token_id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method process_one_click_token_and_redirect_with_credentials" % key
@@ -1399,50 +1373,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='str',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def process_without_user_interaction(self, space_id, id, **kwargs):
         """Process Without User Interaction
 
         This operation processes the transaction without requiring that the customer is present. Means this operation applies strategies to process the transaction without a direct interaction with the buyer. This operation is suitable for recurring transactions.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.process_without_user_interaction(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the transaction which should be processed. (required)
         :return: Transaction
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.process_without_user_interaction_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.process_without_user_interaction_with_http_info(space_id, id, **kwargs)
             return data
 
     def process_without_user_interaction_with_http_info(self, space_id, id, **kwargs):
         """Process Without User Interaction
 
         This operation processes the transaction without requiring that the customer is present. Means this operation applies strategies to process the transaction without a direct interaction with the buyer. This operation is suitable for recurring transactions.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.process_without_user_interaction_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the transaction which should be processed. (required)
         :return: Transaction
@@ -1450,15 +1422,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method process_without_user_interaction" % key
@@ -1502,50 +1474,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='Transaction',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the transaction which should be returned. (required)
         :return: Transaction
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_http_info(space_id, id, **kwargs)
         else:
             (data) = self.read_with_http_info(space_id, id, **kwargs)
             return data
 
     def read_with_http_info(self, space_id, id, **kwargs):
         """Read
 
         Reads the entity with the given 'id' and returns it.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_http_info(space_id, id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int id: The id of the transaction which should be returned. (required)
         :return: Transaction
@@ -1553,15 +1523,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read" % key
@@ -1613,64 +1583,62 @@
             post_params=form_params,
             files=local_var_files,
             response_type='Transaction',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def read_with_credentials(self, credentials, **kwargs):
         """Read With Credentials
 
         Reads the transaction with the given 'id' and returns it. This method uses the credentials to authenticate and identify the transaction.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_credentials(credentials, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str credentials: The credentials identifies the transaction and contains the security details which grants the access this operation. (required)
         :return: Transaction
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.read_with_credentials_with_http_info(credentials, **kwargs)
         else:
             (data) = self.read_with_credentials_with_http_info(credentials, **kwargs)
             return data
 
     def read_with_credentials_with_http_info(self, credentials, **kwargs):
         """Read With Credentials
 
         Reads the transaction with the given 'id' and returns it. This method uses the credentials to authenticate and identify the transaction.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.read_with_credentials_with_http_info(credentials, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str credentials: The credentials identifies the transaction and contains the security details which grants the access this operation. (required)
         :return: Transaction
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['credentials']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method read_with_credentials" % key
@@ -1716,50 +1684,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='Transaction',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def search(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the transactions which are returned by the search. (required)
         :return: list[Transaction]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.search_with_http_info(space_id, query, **kwargs)
         else:
             (data) = self.search_with_http_info(space_id, query, **kwargs)
             return data
 
     def search_with_http_info(self, space_id, query, **kwargs):
         """Search
 
         Searches for the entities as specified by the given query.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_with_http_info(space_id, query, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param EntityQuery query: The query restricts the transactions which are returned by the search. (required)
         :return: list[Transaction]
@@ -1767,15 +1733,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'query']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search" % key
@@ -1827,50 +1793,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[Transaction]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def update(self, space_id, entity, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param TransactionPending entity: The transaction object with the properties which should be updated. (required)
         :return: Transaction
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.update_with_http_info(space_id, entity, **kwargs)
         else:
             (data) = self.update_with_http_info(space_id, entity, **kwargs)
             return data
 
     def update_with_http_info(self, space_id, entity, **kwargs):
         """Update
 
         This updates the entity with the given properties. Only those properties which should be updated can be provided. The 'id' and 'version' are required to identify the entity.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_with_http_info(space_id, entity, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param TransactionPending entity: The transaction object with the properties which should be updated. (required)
         :return: Transaction
@@ -1878,15 +1842,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'entity']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update" % key
@@ -1938,9 +1902,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='Transaction',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/transaction_terminal_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/transaction_terminal_service_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -12,42 +12,40 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def fetch_receipts(self, space_id, request, **kwargs):
         """Fetch Receipts
 
         Returns all receipts for the requested terminal transaction.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.fetch_receipts(space_id, request, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param TerminalReceiptFetchRequest request:  (required)
         :return: list[RenderedTerminalReceipt]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.fetch_receipts_with_http_info(space_id, request, **kwargs)
         else:
             (data) = self.fetch_receipts_with_http_info(space_id, request, **kwargs)
             return data
 
     def fetch_receipts_with_http_info(self, space_id, request, **kwargs):
         """Fetch Receipts
 
         Returns all receipts for the requested terminal transaction.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.fetch_receipts_with_http_info(space_id, request, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param TerminalReceiptFetchRequest request:  (required)
         :return: list[RenderedTerminalReceipt]
@@ -55,15 +53,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'request']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method fetch_receipts" % key
@@ -115,52 +113,50 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[RenderedTerminalReceipt]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def till_connection_credentials(self, space_id, transaction_id, terminal_id, **kwargs):
         """Create Till Connection Credentials
 
         This operation creates a set of credentials to use within the WebSocket.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.till_connection_credentials(space_id, transaction_id, terminal_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int transaction_id: The ID of the transaction which is used to process with the terminal. (required)
         :param int terminal_id: The ID of the terminal which should be used to process the transaction. (required)
         :param str language: The language in which the messages should be rendered in.
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.till_connection_credentials_with_http_info(space_id, transaction_id, terminal_id, **kwargs)
         else:
             (data) = self.till_connection_credentials_with_http_info(space_id, transaction_id, terminal_id, **kwargs)
             return data
 
     def till_connection_credentials_with_http_info(self, space_id, transaction_id, terminal_id, **kwargs):
         """Create Till Connection Credentials
 
         This operation creates a set of credentials to use within the WebSocket.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.till_connection_credentials_with_http_info(space_id, transaction_id, terminal_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id:  (required)
         :param int transaction_id: The ID of the transaction which is used to process with the terminal. (required)
         :param int terminal_id: The ID of the terminal which should be used to process the transaction. (required)
@@ -170,15 +166,15 @@
                  returns the request thread.
         """
 
         all_params = ['space_id', 'transaction_id', 'terminal_id', 'language']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method till_connection_credentials" % key
@@ -230,9 +226,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type='str',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/user_account_role_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/user_account_role_service_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -12,44 +12,42 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def add_role(self, user_id, account_id, role_id, **kwargs):
         """Add Role
 
         This operation grants the role to the given user with in the given account.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.add_role(user_id, account_id, role_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int user_id: The id of the user to whom the role is assigned. (required)
         :param int account_id: The account to which the role is mapped. (required)
         :param int role_id: The role which is mapped to the user and account. (required)
         :param bool applies_on_subaccount: Whether the role applies only on subaccount.
         :return: UserAccountRole
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.add_role_with_http_info(user_id, account_id, role_id, **kwargs)
         else:
             (data) = self.add_role_with_http_info(user_id, account_id, role_id, **kwargs)
             return data
 
     def add_role_with_http_info(self, user_id, account_id, role_id, **kwargs):
         """Add Role
 
         This operation grants the role to the given user with in the given account.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.add_role_with_http_info(user_id, account_id, role_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int user_id: The id of the user to whom the role is assigned. (required)
         :param int account_id: The account to which the role is mapped. (required)
         :param int role_id: The role which is mapped to the user and account. (required)
@@ -59,15 +57,15 @@
                  returns the request thread.
         """
 
         all_params = ['user_id', 'account_id', 'role_id', 'applies_on_subaccount']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method add_role" % key
@@ -123,50 +121,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='UserAccountRole',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def list(self, user_id, account_id, **kwargs):
         """List Roles
 
         List all the roles that are assigned to the given user in the given account.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.list(user_id, account_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int user_id: The id of the user to whom the role is assigned. (required)
         :param int account_id: The account to which the role is mapped. (required)
         :return: list[UserAccountRole]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.list_with_http_info(user_id, account_id, **kwargs)
         else:
             (data) = self.list_with_http_info(user_id, account_id, **kwargs)
             return data
 
     def list_with_http_info(self, user_id, account_id, **kwargs):
         """List Roles
 
         List all the roles that are assigned to the given user in the given account.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.list_with_http_info(user_id, account_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int user_id: The id of the user to whom the role is assigned. (required)
         :param int account_id: The account to which the role is mapped. (required)
         :return: list[UserAccountRole]
@@ -174,15 +170,15 @@
                  returns the request thread.
         """
 
         all_params = ['user_id', 'account_id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method list" % key
@@ -230,64 +226,62 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[UserAccountRole]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def remove_role(self, id, **kwargs):
         """Remove Role
 
         This operation removes the specified user account role.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.remove_role(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int id: The id of user account role which should be removed (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.remove_role_with_http_info(id, **kwargs)
         else:
             (data) = self.remove_role_with_http_info(id, **kwargs)
             return data
 
     def remove_role_with_http_info(self, id, **kwargs):
         """Remove Role
 
         This operation removes the specified user account role.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.remove_role_with_http_info(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int id: The id of user account role which should be removed (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method remove_role" % key
@@ -329,9 +323,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/user_space_role_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/user_space_role_service_api.py`

 * *Files 5% similar despite different names*

```diff
@@ -12,43 +12,41 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def add_role(self, user_id, space_id, role_id, **kwargs):
         """Add Role
 
         This operation grants the given role to the user in the given space.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.add_role(user_id, space_id, role_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int user_id: The id of the user to whom the role is assigned. (required)
         :param int space_id: The space to which the role is mapped. (required)
         :param int role_id: The role which is mapped to the user and space. (required)
         :return: UserSpaceRole
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.add_role_with_http_info(user_id, space_id, role_id, **kwargs)
         else:
             (data) = self.add_role_with_http_info(user_id, space_id, role_id, **kwargs)
             return data
 
     def add_role_with_http_info(self, user_id, space_id, role_id, **kwargs):
         """Add Role
 
         This operation grants the given role to the user in the given space.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.add_role_with_http_info(user_id, space_id, role_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int user_id: The id of the user to whom the role is assigned. (required)
         :param int space_id: The space to which the role is mapped. (required)
         :param int role_id: The role which is mapped to the user and space. (required)
@@ -57,15 +55,15 @@
                  returns the request thread.
         """
 
         all_params = ['user_id', 'space_id', 'role_id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method add_role" % key
@@ -119,50 +117,48 @@
             post_params=form_params,
             files=local_var_files,
             response_type='UserSpaceRole',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def list(self, user_id, space_id, **kwargs):
         """List Roles
 
         List all the roles that are assigned to the given user in the given space.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.list(user_id, space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int user_id: The id of the user to whom the role is assigned. (required)
         :param int space_id: The space to which the role is mapped. (required)
         :return: list[UserSpaceRole]
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.list_with_http_info(user_id, space_id, **kwargs)
         else:
             (data) = self.list_with_http_info(user_id, space_id, **kwargs)
             return data
 
     def list_with_http_info(self, user_id, space_id, **kwargs):
         """List Roles
 
         List all the roles that are assigned to the given user in the given space.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.list_with_http_info(user_id, space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int user_id: The id of the user to whom the role is assigned. (required)
         :param int space_id: The space to which the role is mapped. (required)
         :return: list[UserSpaceRole]
@@ -170,15 +166,15 @@
                  returns the request thread.
         """
 
         all_params = ['user_id', 'space_id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method list" % key
@@ -226,64 +222,62 @@
             post_params=form_params,
             files=local_var_files,
             response_type='list[UserSpaceRole]',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def remove_role(self, id, **kwargs):
         """Remove Role
 
         This operation removes the specified user space role.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.remove_role(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int id: The id of user space role which should be removed (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.remove_role_with_http_info(id, **kwargs)
         else:
             (data) = self.remove_role_with_http_info(id, **kwargs)
             return data
 
     def remove_role_with_http_info(self, id, **kwargs):
         """Remove Role
 
         This operation removes the specified user space role.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.remove_role_with_http_info(id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int id: The id of user space role which should be removed (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method remove_role" % key
@@ -325,9 +319,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api/web_app_service_api.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api/web_app_service_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -12,56 +12,54 @@
         self.api_client = ApiClient(configuration=configuration)
 
     def check_installation(self, space_id, **kwargs):
         """Check Installation
 
         This operation returns true when the app is installed in given space. The web app is implied by the client ID resp. user ID that is been used to invoke this operation.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.check_installation(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id: This parameter identifies the space which should be checked if the web app is installed. (required)
         :return: bool
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.check_installation_with_http_info(space_id, **kwargs)
         else:
             (data) = self.check_installation_with_http_info(space_id, **kwargs)
             return data
 
     def check_installation_with_http_info(self, space_id, **kwargs):
         """Check Installation
 
         This operation returns true when the app is installed in given space. The web app is implied by the client ID resp. user ID that is been used to invoke this operation.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.check_installation_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id: This parameter identifies the space which should be checked if the web app is installed. (required)
         :return: bool
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method check_installation" % key
@@ -103,64 +101,62 @@
             post_params=form_params,
             files=local_var_files,
             response_type='bool',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def confirm(self, request, **kwargs):
         """Confirm
 
         This operation confirms the app installation. This method has to be invoked after the user returns to the web app. The request of the user will contain the code as a request parameter. The web app is implied by the client ID resp. user ID that is been used to invoke this operation.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.confirm(request, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param WebAppConfirmationRequest request:  (required)
         :return: WebAppConfirmationResponse
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.confirm_with_http_info(request, **kwargs)
         else:
             (data) = self.confirm_with_http_info(request, **kwargs)
             return data
 
     def confirm_with_http_info(self, request, **kwargs):
         """Confirm
 
         This operation confirms the app installation. This method has to be invoked after the user returns to the web app. The request of the user will contain the code as a request parameter. The web app is implied by the client ID resp. user ID that is been used to invoke this operation.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.confirm_with_http_info(request, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param WebAppConfirmationRequest request:  (required)
         :return: WebAppConfirmationResponse
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['request']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method confirm" % key
@@ -202,64 +198,62 @@
             post_params=form_params,
             files=local_var_files,
             response_type='WebAppConfirmationResponse',
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
     def uninstall(self, space_id, **kwargs):
         """Uninstall
 
         This operation uninstalls the web app from the provided space. The web app is implied by the client ID resp. user ID that is been used to invoke this operation.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.uninstall(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id: This parameter identifies the space within which the web app should be uninstalled. (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        
-        kwargs['request_timeout'] = self.api_client.configuration.request_timeout
+
+
         if kwargs.get('async_req'):
             return self.uninstall_with_http_info(space_id, **kwargs)
         else:
             (data) = self.uninstall_with_http_info(space_id, **kwargs)
             return data
 
     def uninstall_with_http_info(self, space_id, **kwargs):
         """Uninstall
 
         This operation uninstalls the web app from the provided space. The web app is implied by the client ID resp. user ID that is been used to invoke this operation.
         This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True.
-        
+        asynchronous HTTP request, please pass async_req=True
         >>> thread = api.uninstall_with_http_info(space_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param int space_id: This parameter identifies the space within which the web app should be uninstalled. (required)
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         all_params = ['space_id']
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
-        all_params.append('request_timeout')
+        all_params.append('_request_timeout')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method uninstall" % key
@@ -297,9 +291,9 @@
             post_params=form_params,
             files=local_var_files,
             response_type=None,
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('request_timeout'),
+            _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/api_client.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/api_client.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 # coding: utf-8
 """
     whitelabelmachinename
 
     Python SDK
 
-    OpenAPI spec version: 4.0.0
+    OpenAPI spec version: 3.0.3
     
 """
 
 from __future__ import absolute_import
 
 import time
 import hashlib
@@ -20,15 +20,14 @@
 import mimetypes
 from multiprocessing.pool import ThreadPool
 import os
 import re
 import tempfile
 from enum import Enum
 import six
-import platform
 from six.moves.urllib.parse import quote
 
 from whitelabelmachinename.configuration import Configuration
 import whitelabelmachinename.models
 from whitelabelmachinename import rest
 
 
@@ -52,23 +51,19 @@
             configuration = Configuration()
         self.configuration = configuration
 
         # Use the pool property to lazily initialize the ThreadPool.
         self._pool = None
         self.rest_client = rest.RESTClientObject(configuration)
         self.default_headers = {}
-
-        for name, value in configuration.default_headers.items():
-            self.default_headers[name] = value
-
         if header_name is not None:
             self.default_headers[header_name] = header_value
         self.cookie = cookie
         # Set default User-Agent.
-        self.user_agent = 'whitelabelmachinename/4.0.0/python'
+        self.user_agent = 'whitelabelmachinename/3.0.3/python'
 
     def __del__(self):
         if self._pool is not None:
             self._pool.close()
             self._pool.join()
 
     @property
@@ -96,27 +91,16 @@
             _return_http_data_only=None, collection_formats=None,
             _preload_content=True, _request_timeout=None):
 
         config = self.configuration
 
         # header parameters
         header_params = header_params or {}
-
-        # predefined default headers
-        default_headers = {
-            'x-meta-sdk-version': '4.0.0',
-            'x-meta-sdk-language': 'python',
-            'x-meta-sdk-provider': 'WhiteLabelName',
-            'x-meta-sdk-language-version': platform.python_version()
-        }
-
         header_params.update(self.default_headers)
-        header_params.update(default_headers)
         header_params.update(self.get_auth_headers(resource_path=resource_path, query_params=query_params, method=method))
-
         if self.cookie:
             header_params['Cookie'] = self.cookie
         if header_params:
             header_params = self.sanitize_for_serialization(header_params)
             header_params = dict(self.parameters_to_tuples(header_params,
                                                            collection_formats))
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/configuration.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/configuration.py`

 * *Files 2% similar despite different names*

```diff
@@ -12,15 +12,15 @@
 from six.moves import http_client as httplib
 
 
 class Configuration:
 
     _default = None
 
-    def __init__(self, user_id='', api_secret='', mac_version=1, default_headers={}, request_timeout=25):
+    def __init__(self, user_id='', api_secret='', mac_version=1):
         if self._default:
             for key in self._default.__dict__.keys():
                 self.__dict__[key] = copy.copy(self._default.__dict__[key])
             return
 
         # Default Base url
         self.host = "https://app-wallee.com:443/api"
@@ -42,15 +42,17 @@
         self._user_id=user_id
         # version for MAC authentication
         self._mac_version=mac_version
         # Password for HTTP basic authentication
         self.password = ""
 
         # Logging Settings
-        self.logger = {"package_logger": logging.getLogger("whitelabelmachinename"), "urllib3_logger": logging.getLogger("urllib3")}
+        self.logger = {}
+        self.logger["package_logger"] = logging.getLogger("whitelabelmachinename")
+        self.logger["urllib3_logger"] = logging.getLogger("urllib3")
         # Log format
         self.logger_format = '%(asctime)s %(levelname)s %(message)s'
         # Log stream handler
         self.logger_stream_handler = None
         # Log file handler
         self.logger_file_handler = None
         # Debug file location
@@ -78,18 +80,14 @@
         # cpu_count * 5 is used as default value to increase performance.
         self.connection_pool_maxsize = multiprocessing.cpu_count() * 5
 
         # Proxy URL
         self.proxy = None
         # Safe chars for path_param
         self.safe_chars_for_path_param = ''
-        # Default headers
-        self.default_headers=default_headers
-        # The time limit for HTTP request in seconds. (Default value is: 25)
-        self.request_timeout = request_timeout
 
     @property
     def api_secret(self):
         return self._api_secret
 
     @api_secret.setter
     def api_secret(self, value):
@@ -185,22 +183,14 @@
             # setting log level to default `logging.WARNING`
             for _, logger in six.iteritems(self.logger):
                 logger.setLevel(logging.WARNING)
             # turn off httplib debug
             httplib.HTTPConnection.debuglevel = 0
 
     @property
-    def request_timeout(self):
-        return self._request_timeout
-
-    @request_timeout.setter
-    def request_timeout(self, value):
-        self._request_timeout = value
-
-    @property
     def logger_format(self):
         """The logger format.
 
         The logger_formatter will be updated when sets logger_format.
 
         :param value: The format string.
         :type: str
@@ -258,10 +248,10 @@
         """Gets the essential information for debugging.
 
         :return: The report for debugging.
         """
         return "Python SDK Debug Report:\n"\
                "OS: {env}\n"\
                "Python Version: {pyversion}\n"\
-               "Version of the API: 4.0.0\n"\
-               "SDK Package Version: 4.0.0".\
+               "Version of the API: 3.0.3\n"\
+               "SDK Package Version: 3.0.3".\
                format(env=sys.platform, pyversion=sys.version)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/__init__.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/__init__.py`

 * *Files 3% similar despite different names*

```diff
@@ -23,20 +23,14 @@
 from .abstract_webhook_listener_update import AbstractWebhookListenerUpdate
 from .abstract_webhook_url_update import AbstractWebhookUrlUpdate
 from .account import Account
 from .account_state import AccountState
 from .account_type import AccountType
 from .address import Address
 from .address_create import AddressCreate
-from .analytics_query import AnalyticsQuery
-from .analytics_query_execution import AnalyticsQueryExecution
-from .analytics_query_execution_state import AnalyticsQueryExecutionState
-from .analytics_query_result_batch import AnalyticsQueryResultBatch
-from .analytics_schema_column import AnalyticsSchemaColumn
-from .analytics_schema_table import AnalyticsSchemaTable
 from .authenticated_card_data_create import AuthenticatedCardDataCreate
 from .bank_account import BankAccount
 from .bank_account_environment import BankAccountEnvironment
 from .bank_account_state import BankAccountState
 from .bank_account_type import BankAccountType
 from .bank_transaction import BankTransaction
 from .bank_transaction_flow_direction import BankTransactionFlowDirection
@@ -72,14 +66,18 @@
 from .customer_address import CustomerAddress
 from .customer_address_type import CustomerAddressType
 from .customer_comment import CustomerComment
 from .customer_postal_address import CustomerPostalAddress
 from .customer_postal_address_create import CustomerPostalAddressCreate
 from .customers_presence import CustomersPresence
 from .data_collection_type import DataCollectionType
+from .database_translated_string import DatabaseTranslatedString
+from .database_translated_string_create import DatabaseTranslatedStringCreate
+from .database_translated_string_item import DatabaseTranslatedStringItem
+from .database_translated_string_item_create import DatabaseTranslatedStringItemCreate
 from .debt_collection_case import DebtCollectionCase
 from .debt_collection_case_document import DebtCollectionCaseDocument
 from .debt_collection_case_source import DebtCollectionCaseSource
 from .debt_collection_case_state import DebtCollectionCaseState
 from .debt_collection_environment import DebtCollectionEnvironment
 from .debt_collection_receipt import DebtCollectionReceipt
 from .debt_collection_receipt_source import DebtCollectionReceiptSource
@@ -110,20 +108,14 @@
 from .installment_calculated_slice import InstallmentCalculatedSlice
 from .installment_payment import InstallmentPayment
 from .installment_payment_slice_state import InstallmentPaymentSliceState
 from .installment_payment_state import InstallmentPaymentState
 from .installment_plan_configuration import InstallmentPlanConfiguration
 from .installment_plan_slice_configuration import InstallmentPlanSliceConfiguration
 from .internal_transfer_bank_transaction import InternalTransferBankTransaction
-from .invoice_reconciliation_record_invoice_link import InvoiceReconciliationRecordInvoiceLink
-from .invoice_reconciliation_record_rejection_status import InvoiceReconciliationRecordRejectionStatus
-from .invoice_reconciliation_record_state import InvoiceReconciliationRecordState
-from .invoice_reconciliation_record_type import InvoiceReconciliationRecordType
-from .invoice_reimbursement import InvoiceReimbursement
-from .invoice_reimbursement_state import InvoiceReimbursementState
 from .label import Label
 from .label_descriptor import LabelDescriptor
 from .label_descriptor_category import LabelDescriptorCategory
 from .label_descriptor_group import LabelDescriptorGroup
 from .label_descriptor_type import LabelDescriptorType
 from .legal_organization_form import LegalOrganizationForm
 from .line_item import LineItem
@@ -165,16 +157,14 @@
 from .payment_connector_configuration import PaymentConnectorConfiguration
 from .payment_connector_feature import PaymentConnectorFeature
 from .payment_contract import PaymentContract
 from .payment_contract_state import PaymentContractState
 from .payment_contract_type import PaymentContractType
 from .payment_information_hash import PaymentInformationHash
 from .payment_information_hash_type import PaymentInformationHashType
-from .payment_initiation_advice_file import PaymentInitiationAdviceFile
-from .payment_initiation_advice_file_state import PaymentInitiationAdviceFileState
 from .payment_link import PaymentLink
 from .payment_link_address_handling_mode import PaymentLinkAddressHandlingMode
 from .payment_link_protection_mode import PaymentLinkProtectionMode
 from .payment_link_update import PaymentLinkUpdate
 from .payment_method import PaymentMethod
 from .payment_method_brand import PaymentMethodBrand
 from .payment_method_configuration import PaymentMethodConfiguration
@@ -183,24 +173,20 @@
 from .payment_processor_configuration import PaymentProcessorConfiguration
 from .payment_terminal import PaymentTerminal
 from .payment_terminal_address import PaymentTerminalAddress
 from .payment_terminal_configuration import PaymentTerminalConfiguration
 from .payment_terminal_configuration_state import PaymentTerminalConfigurationState
 from .payment_terminal_configuration_version import PaymentTerminalConfigurationVersion
 from .payment_terminal_configuration_version_state import PaymentTerminalConfigurationVersionState
-from .payment_terminal_dcc_transaction_sum import PaymentTerminalDccTransactionSum
 from .payment_terminal_location import PaymentTerminalLocation
 from .payment_terminal_location_state import PaymentTerminalLocationState
 from .payment_terminal_location_version import PaymentTerminalLocationVersion
 from .payment_terminal_location_version_state import PaymentTerminalLocationVersionState
 from .payment_terminal_receipt_type import PaymentTerminalReceiptType
 from .payment_terminal_state import PaymentTerminalState
-from .payment_terminal_transaction_sum import PaymentTerminalTransactionSum
-from .payment_terminal_transaction_summary import PaymentTerminalTransactionSummary
-from .payment_terminal_transaction_summary_fetch_request import PaymentTerminalTransactionSummaryFetchRequest
 from .payment_terminal_type import PaymentTerminalType
 from .permission import Permission
 from .persistable_currency_amount import PersistableCurrencyAmount
 from .persistable_currency_amount_update import PersistableCurrencyAmountUpdate
 from .product_fee_type import ProductFeeType
 from .product_metered_fee import ProductMeteredFee
 from .product_metered_fee_update import ProductMeteredFeeUpdate
@@ -215,15 +201,14 @@
 from .refund import Refund
 from .refund_comment import RefundComment
 from .refund_create import RefundCreate
 from .refund_state import RefundState
 from .refund_type import RefundType
 from .rendered_document import RenderedDocument
 from .rendered_terminal_receipt import RenderedTerminalReceipt
-from .rendered_terminal_transaction_summary import RenderedTerminalTransactionSummary
 from .resource_path import ResourcePath
 from .resource_state import ResourceState
 from .rest_address_format import RestAddressFormat
 from .rest_address_format_field import RestAddressFormatField
 from .rest_country import RestCountry
 from .rest_country_state import RestCountryState
 from .rest_currency import RestCurrency
@@ -347,26 +332,26 @@
 from .transaction_completion_state import TransactionCompletionState
 from .transaction_environment_selection_strategy import TransactionEnvironmentSelectionStrategy
 from .transaction_group import TransactionGroup
 from .transaction_group_state import TransactionGroupState
 from .transaction_invoice_comment import TransactionInvoiceComment
 from .transaction_invoice_replacement import TransactionInvoiceReplacement
 from .transaction_invoice_state import TransactionInvoiceState
+from .transaction_line_item_update_request import TransactionLineItemUpdateRequest
 from .transaction_line_item_version_create import TransactionLineItemVersionCreate
 from .transaction_line_item_version_state import TransactionLineItemVersionState
 from .transaction_state import TransactionState
 from .transaction_user_interface_type import TransactionUserInterfaceType
 from .transaction_void_mode import TransactionVoidMode
 from .transaction_void_state import TransactionVoidState
 from .two_factor_authentication_type import TwoFactorAuthenticationType
 from .user import User
 from .user_account_role import UserAccountRole
 from .user_space_role import UserSpaceRole
 from .user_type import UserType
-from .wallet_type import WalletType
 from .web_app_confirmation_request import WebAppConfirmationRequest
 from .web_app_confirmation_response import WebAppConfirmationResponse
 from .webhook_identity import WebhookIdentity
 from .webhook_listener import WebhookListener
 from .webhook_listener_entity import WebhookListenerEntity
 from .webhook_url import WebhookUrl
 from .account_create import AccountCreate
@@ -389,16 +374,14 @@
 from .customer_create import CustomerCreate
 from .debt_collection_case_create import DebtCollectionCaseCreate
 from .debt_collection_case_update import DebtCollectionCaseUpdate
 from .delivery_indication import DeliveryIndication
 from .human_user_create import HumanUserCreate
 from .human_user_update import HumanUserUpdate
 from .installment_payment_slice import InstallmentPaymentSlice
-from .invoice_reconciliation_record import InvoiceReconciliationRecord
-from .invoice_reimbursement_with_refund_reference import InvoiceReimbursementWithRefundReference
 from .payment_link_active import PaymentLinkActive
 from .payment_link_create import PaymentLinkCreate
 from .refund_bank_transaction import RefundBankTransaction
 from .refund_comment_active import RefundCommentActive
 from .refund_comment_create import RefundCommentCreate
 from .refund_recovery_bank_transaction import RefundRecoveryBankTransaction
 from .shopify_recurring_order import ShopifyRecurringOrder
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_account_update.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_account_update.py`

 * *Files 4% similar despite different names*

```diff
@@ -32,49 +32,49 @@
         
 
     
     @property
     def last_modified_date(self):
         """Gets the last_modified_date of this AbstractAccountUpdate.
 
-            The date and time when the object was last modified.
+            
 
         :return: The last_modified_date of this AbstractAccountUpdate.
         :rtype: datetime
         """
         return self._last_modified_date
 
     @last_modified_date.setter
     def last_modified_date(self, last_modified_date):
         """Sets the last_modified_date of this AbstractAccountUpdate.
 
-            The date and time when the object was last modified.
+            
 
         :param last_modified_date: The last_modified_date of this AbstractAccountUpdate.
         :type: datetime
         """
 
         self._last_modified_date = last_modified_date
     
     @property
     def name(self):
         """Gets the name of this AbstractAccountUpdate.
 
-            The name used to identify the account.
+            The name of the account identifies the account within the administrative interface.
 
         :return: The name of this AbstractAccountUpdate.
         :rtype: str
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this AbstractAccountUpdate.
 
-            The name used to identify the account.
+            The name of the account identifies the account within the administrative interface.
 
         :param name: The name of this AbstractAccountUpdate.
         :type: str
         """
         if name is not None and len(name) > 200:
             raise ValueError("Invalid value for `name`, length must be less than or equal to `200`")
         if name is not None and len(name) < 3:
@@ -82,26 +82,26 @@
 
         self._name = name
     
     @property
     def subaccount_limit(self):
         """Gets the subaccount_limit of this AbstractAccountUpdate.
 
-            The number of sub-accounts that can be created within this account.
+            This property restricts the number of subaccounts which can be created within this account.
 
         :return: The subaccount_limit of this AbstractAccountUpdate.
         :rtype: int
         """
         return self._subaccount_limit
 
     @subaccount_limit.setter
     def subaccount_limit(self, subaccount_limit):
         """Sets the subaccount_limit of this AbstractAccountUpdate.
 
-            The number of sub-accounts that can be created within this account.
+            This property restricts the number of subaccounts which can be created within this account.
 
         :param subaccount_limit: The subaccount_limit of this AbstractAccountUpdate.
         :type: int
         """
 
         self._subaccount_limit = subaccount_limit
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_application_user_update.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_application_user_update.py`

 * *Files 5% similar despite different names*

```diff
@@ -32,74 +32,74 @@
         
 
     
     @property
     def name(self):
         """Gets the name of this AbstractApplicationUserUpdate.
 
-            The name used to identify the application user.
+            The user name is used to identify the application user in administrative interfaces.
 
         :return: The name of this AbstractApplicationUserUpdate.
         :rtype: str
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this AbstractApplicationUserUpdate.
 
-            The name used to identify the application user.
+            The user name is used to identify the application user in administrative interfaces.
 
         :param name: The name of this AbstractApplicationUserUpdate.
         :type: str
         """
         if name is not None and len(name) > 256:
             raise ValueError("Invalid value for `name`, length must be less than or equal to `256`")
 
         self._name = name
     
     @property
     def request_limit(self):
         """Gets the request_limit of this AbstractApplicationUserUpdate.
 
-            The maximum number of API requests that are accepted every 2 minutes.
+            The request limit defines the maximum number of API request accepted within 2 minutes. This limit can only be changed with special privileges.
 
         :return: The request_limit of this AbstractApplicationUserUpdate.
         :rtype: int
         """
         return self._request_limit
 
     @request_limit.setter
     def request_limit(self, request_limit):
         """Sets the request_limit of this AbstractApplicationUserUpdate.
 
-            The maximum number of API requests that are accepted every 2 minutes.
+            The request limit defines the maximum number of API request accepted within 2 minutes. This limit can only be changed with special privileges.
 
         :param request_limit: The request_limit of this AbstractApplicationUserUpdate.
         :type: int
         """
 
         self._request_limit = request_limit
     
     @property
     def state(self):
         """Gets the state of this AbstractApplicationUserUpdate.
 
-            The object's current state.
+            
 
         :return: The state of this AbstractApplicationUserUpdate.
         :rtype: CreationEntityState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this AbstractApplicationUserUpdate.
 
-            The object's current state.
+            
 
         :param state: The state of this AbstractApplicationUserUpdate.
         :type: CreationEntityState
         """
 
         self._state = state
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_customer_active.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_customer_active.py`

 * *Files 10% similar despite different names*

```diff
@@ -44,172 +44,172 @@
         
 
     
     @property
     def customer_id(self):
         """Gets the customer_id of this AbstractCustomerActive.
 
-            The customer's ID in the merchant's system.
+            
 
         :return: The customer_id of this AbstractCustomerActive.
         :rtype: str
         """
         return self._customer_id
 
     @customer_id.setter
     def customer_id(self, customer_id):
         """Sets the customer_id of this AbstractCustomerActive.
 
-            The customer's ID in the merchant's system.
+            
 
         :param customer_id: The customer_id of this AbstractCustomerActive.
         :type: str
         """
         if customer_id is not None and len(customer_id) > 100:
             raise ValueError("Invalid value for `customer_id`, length must be less than or equal to `100`")
 
         self._customer_id = customer_id
     
     @property
     def email_address(self):
         """Gets the email_address of this AbstractCustomerActive.
 
-            The customer's email address.
+            
 
         :return: The email_address of this AbstractCustomerActive.
         :rtype: str
         """
         return self._email_address
 
     @email_address.setter
     def email_address(self, email_address):
         """Sets the email_address of this AbstractCustomerActive.
 
-            The customer's email address.
+            
 
         :param email_address: The email_address of this AbstractCustomerActive.
         :type: str
         """
         if email_address is not None and len(email_address) > 254:
             raise ValueError("Invalid value for `email_address`, length must be less than or equal to `254`")
 
         self._email_address = email_address
     
     @property
     def family_name(self):
         """Gets the family_name of this AbstractCustomerActive.
 
-            The customer's family or last name.
+            
 
         :return: The family_name of this AbstractCustomerActive.
         :rtype: str
         """
         return self._family_name
 
     @family_name.setter
     def family_name(self, family_name):
         """Sets the family_name of this AbstractCustomerActive.
 
-            The customer's family or last name.
+            
 
         :param family_name: The family_name of this AbstractCustomerActive.
         :type: str
         """
         if family_name is not None and len(family_name) > 100:
             raise ValueError("Invalid value for `family_name`, length must be less than or equal to `100`")
 
         self._family_name = family_name
     
     @property
     def given_name(self):
         """Gets the given_name of this AbstractCustomerActive.
 
-            The customer's given or first name.
+            
 
         :return: The given_name of this AbstractCustomerActive.
         :rtype: str
         """
         return self._given_name
 
     @given_name.setter
     def given_name(self, given_name):
         """Sets the given_name of this AbstractCustomerActive.
 
-            The customer's given or first name.
+            
 
         :param given_name: The given_name of this AbstractCustomerActive.
         :type: str
         """
         if given_name is not None and len(given_name) > 100:
             raise ValueError("Invalid value for `given_name`, length must be less than or equal to `100`")
 
         self._given_name = given_name
     
     @property
     def language(self):
         """Gets the language of this AbstractCustomerActive.
 
-            The language that is linked to the object.
+            
 
         :return: The language of this AbstractCustomerActive.
         :rtype: str
         """
         return self._language
 
     @language.setter
     def language(self, language):
         """Sets the language of this AbstractCustomerActive.
 
-            The language that is linked to the object.
+            
 
         :param language: The language of this AbstractCustomerActive.
         :type: str
         """
 
         self._language = language
     
     @property
     def meta_data(self):
         """Gets the meta_data of this AbstractCustomerActive.
 
-            Allow to store additional information about the object.
+            Meta data allow to store additional data along the object.
 
         :return: The meta_data of this AbstractCustomerActive.
         :rtype: dict(str, str)
         """
         return self._meta_data
 
     @meta_data.setter
     def meta_data(self, meta_data):
         """Sets the meta_data of this AbstractCustomerActive.
 
-            Allow to store additional information about the object.
+            Meta data allow to store additional data along the object.
 
         :param meta_data: The meta_data of this AbstractCustomerActive.
         :type: dict(str, str)
         """
 
         self._meta_data = meta_data
     
     @property
     def preferred_currency(self):
         """Gets the preferred_currency of this AbstractCustomerActive.
 
-            The customer's preferred currency.
+            
 
         :return: The preferred_currency of this AbstractCustomerActive.
         :rtype: str
         """
         return self._preferred_currency
 
     @preferred_currency.setter
     def preferred_currency(self, preferred_currency):
         """Sets the preferred_currency of this AbstractCustomerActive.
 
-            The customer's preferred currency.
+            
 
         :param preferred_currency: The preferred_currency of this AbstractCustomerActive.
         :type: str
         """
 
         self._preferred_currency = preferred_currency
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_customer_address_active.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_customer_address_active.py`

 * *Files 18% similar despite different names*

```diff
@@ -29,49 +29,49 @@
         
 
     
     @property
     def address(self):
         """Gets the address of this AbstractCustomerAddressActive.
 
-            The actual postal address.
+            
 
         :return: The address of this AbstractCustomerAddressActive.
         :rtype: CustomerPostalAddressCreate
         """
         return self._address
 
     @address.setter
     def address(self, address):
         """Sets the address of this AbstractCustomerAddressActive.
 
-            The actual postal address.
+            
 
         :param address: The address of this AbstractCustomerAddressActive.
         :type: CustomerPostalAddressCreate
         """
 
         self._address = address
     
     @property
     def address_type(self):
         """Gets the address_type of this AbstractCustomerAddressActive.
 
-            Whether the address is for billing or shipping or both.
+            
 
         :return: The address_type of this AbstractCustomerAddressActive.
         :rtype: CustomerAddressType
         """
         return self._address_type
 
     @address_type.setter
     def address_type(self, address_type):
         """Sets the address_type of this AbstractCustomerAddressActive.
 
-            Whether the address is for billing or shipping or both.
+            
 
         :param address_type: The address_type of this AbstractCustomerAddressActive.
         :type: CustomerAddressType
         """
 
         self._address_type = address_type
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_customer_comment_active.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_customer_comment_active.py`

 * *Files 15% similar despite different names*

```diff
@@ -26,26 +26,26 @@
         
 
     
     @property
     def content(self):
         """Gets the content of this AbstractCustomerCommentActive.
 
-            The comment's actual content.
+            
 
         :return: The content of this AbstractCustomerCommentActive.
         :rtype: str
         """
         return self._content
 
     @content.setter
     def content(self, content):
         """Sets the content of this AbstractCustomerCommentActive.
 
-            The comment's actual content.
+            
 
         :param content: The content of this AbstractCustomerCommentActive.
         :type: str
         """
         if content is not None and len(content) > 262144:
             raise ValueError("Invalid value for `content`, length must be less than or equal to `262144`")
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_debt_collection_case_update.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_debt_collection_case_update.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_human_user_update.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_human_user_update.py`

 * *Files 6% similar despite different names*

```diff
@@ -47,195 +47,195 @@
         
 
     
     @property
     def email_address(self):
         """Gets the email_address of this AbstractHumanUserUpdate.
 
-            The user's email address.
+            The email address of the user.
 
         :return: The email_address of this AbstractHumanUserUpdate.
         :rtype: str
         """
         return self._email_address
 
     @email_address.setter
     def email_address(self, email_address):
         """Sets the email_address of this AbstractHumanUserUpdate.
 
-            The user's email address.
+            The email address of the user.
 
         :param email_address: The email_address of this AbstractHumanUserUpdate.
         :type: str
         """
         if email_address is not None and len(email_address) > 128:
             raise ValueError("Invalid value for `email_address`, length must be less than or equal to `128`")
 
         self._email_address = email_address
     
     @property
     def firstname(self):
         """Gets the firstname of this AbstractHumanUserUpdate.
 
-            The user's first name.
+            The first name of the user.
 
         :return: The firstname of this AbstractHumanUserUpdate.
         :rtype: str
         """
         return self._firstname
 
     @firstname.setter
     def firstname(self, firstname):
         """Sets the firstname of this AbstractHumanUserUpdate.
 
-            The user's first name.
+            The first name of the user.
 
         :param firstname: The firstname of this AbstractHumanUserUpdate.
         :type: str
         """
         if firstname is not None and len(firstname) > 100:
             raise ValueError("Invalid value for `firstname`, length must be less than or equal to `100`")
 
         self._firstname = firstname
     
     @property
     def language(self):
         """Gets the language of this AbstractHumanUserUpdate.
 
-            The user's preferred language.
+            The preferred language of the user.
 
         :return: The language of this AbstractHumanUserUpdate.
         :rtype: str
         """
         return self._language
 
     @language.setter
     def language(self, language):
         """Sets the language of this AbstractHumanUserUpdate.
 
-            The user's preferred language.
+            The preferred language of the user.
 
         :param language: The language of this AbstractHumanUserUpdate.
         :type: str
         """
 
         self._language = language
     
     @property
     def lastname(self):
         """Gets the lastname of this AbstractHumanUserUpdate.
 
-            The user's last name.
+            The last name of the user.
 
         :return: The lastname of this AbstractHumanUserUpdate.
         :rtype: str
         """
         return self._lastname
 
     @lastname.setter
     def lastname(self, lastname):
         """Sets the lastname of this AbstractHumanUserUpdate.
 
-            The user's last name.
+            The last name of the user.
 
         :param lastname: The lastname of this AbstractHumanUserUpdate.
         :type: str
         """
         if lastname is not None and len(lastname) > 100:
             raise ValueError("Invalid value for `lastname`, length must be less than or equal to `100`")
 
         self._lastname = lastname
     
     @property
     def mobile_phone_number(self):
         """Gets the mobile_phone_number of this AbstractHumanUserUpdate.
 
-            The user's mobile phone number.
+            
 
         :return: The mobile_phone_number of this AbstractHumanUserUpdate.
         :rtype: str
         """
         return self._mobile_phone_number
 
     @mobile_phone_number.setter
     def mobile_phone_number(self, mobile_phone_number):
         """Sets the mobile_phone_number of this AbstractHumanUserUpdate.
 
-            The user's mobile phone number.
+            
 
         :param mobile_phone_number: The mobile_phone_number of this AbstractHumanUserUpdate.
         :type: str
         """
         if mobile_phone_number is not None and len(mobile_phone_number) > 30:
             raise ValueError("Invalid value for `mobile_phone_number`, length must be less than or equal to `30`")
 
         self._mobile_phone_number = mobile_phone_number
     
     @property
     def state(self):
         """Gets the state of this AbstractHumanUserUpdate.
 
-            The object's current state.
+            
 
         :return: The state of this AbstractHumanUserUpdate.
         :rtype: CreationEntityState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this AbstractHumanUserUpdate.
 
-            The object's current state.
+            
 
         :param state: The state of this AbstractHumanUserUpdate.
         :type: CreationEntityState
         """
 
         self._state = state
     
     @property
     def time_zone(self):
         """Gets the time_zone of this AbstractHumanUserUpdate.
 
-            The user's time zone. If none is specified, the one provided by the browser will be used.
+            The time zone which is applied for the user. If no timezone is specified the browser is used to determine an appropriate time zone.
 
         :return: The time_zone of this AbstractHumanUserUpdate.
         :rtype: str
         """
         return self._time_zone
 
     @time_zone.setter
     def time_zone(self, time_zone):
         """Sets the time_zone of this AbstractHumanUserUpdate.
 
-            The user's time zone. If none is specified, the one provided by the browser will be used.
+            The time zone which is applied for the user. If no timezone is specified the browser is used to determine an appropriate time zone.
 
         :param time_zone: The time_zone of this AbstractHumanUserUpdate.
         :type: str
         """
 
         self._time_zone = time_zone
     
     @property
     def two_factor_enabled(self):
         """Gets the two_factor_enabled of this AbstractHumanUserUpdate.
 
-            Whether two-factor authentication is enabled for this user.
+            Defines whether two-factor authentication is enabled for this user.
 
         :return: The two_factor_enabled of this AbstractHumanUserUpdate.
         :rtype: bool
         """
         return self._two_factor_enabled
 
     @two_factor_enabled.setter
     def two_factor_enabled(self, two_factor_enabled):
         """Sets the two_factor_enabled of this AbstractHumanUserUpdate.
 
-            Whether two-factor authentication is enabled for this user.
+            Defines whether two-factor authentication is enabled for this user.
 
         :param two_factor_enabled: The two_factor_enabled of this AbstractHumanUserUpdate.
         :type: bool
         """
 
         self._two_factor_enabled = two_factor_enabled
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_payment_link_update.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_payment_link_update.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_refund_comment_active.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_refund_comment_active.py`

 * *Files 6% similar despite different names*

```diff
@@ -26,26 +26,26 @@
         
 
     
     @property
     def content(self):
         """Gets the content of this AbstractRefundCommentActive.
 
-            The comment's actual content.
+            
 
         :return: The content of this AbstractRefundCommentActive.
         :rtype: str
         """
         return self._content
 
     @content.setter
     def content(self, content):
         """Sets the content of this AbstractRefundCommentActive.
 
-            The comment's actual content.
+            
 
         :param content: The content of this AbstractRefundCommentActive.
         :type: str
         """
         if content is not None and len(content) > 262144:
             raise ValueError("Invalid value for `content`, length must be less than or equal to `262144`")
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_shopify_subscription_product_update.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_shopify_subscription_product_update.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_space_update.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_space_update.py`

 * *Files 4% similar despite different names*

```diff
@@ -47,49 +47,49 @@
         
 
     
     @property
     def last_modified_date(self):
         """Gets the last_modified_date of this AbstractSpaceUpdate.
 
-            The date and time when the object was last modified.
+            
 
         :return: The last_modified_date of this AbstractSpaceUpdate.
         :rtype: datetime
         """
         return self._last_modified_date
 
     @last_modified_date.setter
     def last_modified_date(self, last_modified_date):
         """Sets the last_modified_date of this AbstractSpaceUpdate.
 
-            The date and time when the object was last modified.
+            
 
         :param last_modified_date: The last_modified_date of this AbstractSpaceUpdate.
         :type: datetime
         """
 
         self._last_modified_date = last_modified_date
     
     @property
     def name(self):
         """Gets the name of this AbstractSpaceUpdate.
 
-            The name used to identify the space.
+            The space name is used internally to identify the space in administrative interfaces. For example it is used within search fields and hence it should be distinct and descriptive.
 
         :return: The name of this AbstractSpaceUpdate.
         :rtype: str
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this AbstractSpaceUpdate.
 
-            The name used to identify the space.
+            The space name is used internally to identify the space in administrative interfaces. For example it is used within search fields and hence it should be distinct and descriptive.
 
         :param name: The name of this AbstractSpaceUpdate.
         :type: str
         """
         if name is not None and len(name) > 200:
             raise ValueError("Invalid value for `name`, length must be less than or equal to `200`")
         if name is not None and len(name) < 3:
@@ -97,141 +97,141 @@
 
         self._name = name
     
     @property
     def postal_address(self):
         """Gets the postal_address of this AbstractSpaceUpdate.
 
-            The address that is used in communication with clients for example in emails, documents, etc.
+            The address to use in communication with clients for example in email, documents etc.
 
         :return: The postal_address of this AbstractSpaceUpdate.
         :rtype: SpaceAddressCreate
         """
         return self._postal_address
 
     @postal_address.setter
     def postal_address(self, postal_address):
         """Sets the postal_address of this AbstractSpaceUpdate.
 
-            The address that is used in communication with clients for example in emails, documents, etc.
+            The address to use in communication with clients for example in email, documents etc.
 
         :param postal_address: The postal_address of this AbstractSpaceUpdate.
         :type: SpaceAddressCreate
         """
 
         self._postal_address = postal_address
     
     @property
     def primary_currency(self):
         """Gets the primary_currency of this AbstractSpaceUpdate.
 
-            The currency that is used to display aggregated amounts in the space.
+            This is the currency that is used to display aggregated amounts in the space.
 
         :return: The primary_currency of this AbstractSpaceUpdate.
         :rtype: str
         """
         return self._primary_currency
 
     @primary_currency.setter
     def primary_currency(self, primary_currency):
         """Sets the primary_currency of this AbstractSpaceUpdate.
 
-            The currency that is used to display aggregated amounts in the space.
+            This is the currency that is used to display aggregated amounts in the space.
 
         :param primary_currency: The primary_currency of this AbstractSpaceUpdate.
         :type: str
         """
 
         self._primary_currency = primary_currency
     
     @property
     def request_limit(self):
         """Gets the request_limit of this AbstractSpaceUpdate.
 
-            The maximum number of API requests that are accepted within two minutes. This limit can only be changed with special privileges.
+            The request limit defines the maximum number of API request accepted within 2 minutes for this space. This limit can only be changed with special privileges.
 
         :return: The request_limit of this AbstractSpaceUpdate.
         :rtype: int
         """
         return self._request_limit
 
     @request_limit.setter
     def request_limit(self, request_limit):
         """Sets the request_limit of this AbstractSpaceUpdate.
 
-            The maximum number of API requests that are accepted within two minutes. This limit can only be changed with special privileges.
+            The request limit defines the maximum number of API request accepted within 2 minutes for this space. This limit can only be changed with special privileges.
 
         :param request_limit: The request_limit of this AbstractSpaceUpdate.
         :type: int
         """
 
         self._request_limit = request_limit
     
     @property
     def state(self):
         """Gets the state of this AbstractSpaceUpdate.
 
-            The object's current state.
+            
 
         :return: The state of this AbstractSpaceUpdate.
         :rtype: CreationEntityState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this AbstractSpaceUpdate.
 
-            The object's current state.
+            
 
         :param state: The state of this AbstractSpaceUpdate.
         :type: CreationEntityState
         """
 
         self._state = state
     
     @property
     def technical_contact_addresses(self):
         """Gets the technical_contact_addresses of this AbstractSpaceUpdate.
 
-            The email address that will receive messages about technical issues and errors that occur in the space.
+            The email address provided as contact addresses will be informed about technical issues or errors triggered by the space.
 
         :return: The technical_contact_addresses of this AbstractSpaceUpdate.
         :rtype: list[str]
         """
         return self._technical_contact_addresses
 
     @technical_contact_addresses.setter
     def technical_contact_addresses(self, technical_contact_addresses):
         """Sets the technical_contact_addresses of this AbstractSpaceUpdate.
 
-            The email address that will receive messages about technical issues and errors that occur in the space.
+            The email address provided as contact addresses will be informed about technical issues or errors triggered by the space.
 
         :param technical_contact_addresses: The technical_contact_addresses of this AbstractSpaceUpdate.
         :type: list[str]
         """
 
         self._technical_contact_addresses = technical_contact_addresses
     
     @property
     def time_zone(self):
         """Gets the time_zone of this AbstractSpaceUpdate.
 
-            The time zone that is used to schedule and run background processes. This does not affect the formatting of dates in the user interface.
+            The time zone assigned to the space determines the time offset for calculating dates within the space. This is typically used for background processed which needs to be triggered on a specific hour within the day. Changing the space time zone will not change the display of dates.
 
         :return: The time_zone of this AbstractSpaceUpdate.
         :rtype: str
         """
         return self._time_zone
 
     @time_zone.setter
     def time_zone(self, time_zone):
         """Sets the time_zone of this AbstractSpaceUpdate.
 
-            The time zone that is used to schedule and run background processes. This does not affect the formatting of dates in the user interface.
+            The time zone assigned to the space determines the time offset for calculating dates within the space. This is typically used for background processed which needs to be triggered on a specific hour within the day. Changing the space time zone will not change the display of dates.
 
         :param time_zone: The time_zone of this AbstractSpaceUpdate.
         :type: str
         """
 
         self._time_zone = time_zone
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_subscriber_update.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_subscriber_update.py`

 * *Files 2% similar despite different names*

```diff
@@ -192,26 +192,26 @@
 
         self._language = language
     
     @property
     def meta_data(self):
         """Gets the meta_data of this AbstractSubscriberUpdate.
 
-            Allow to store additional information about the object.
+            Meta data allow to store additional data along the object.
 
         :return: The meta_data of this AbstractSubscriberUpdate.
         :rtype: dict(str, str)
         """
         return self._meta_data
 
     @meta_data.setter
     def meta_data(self, meta_data):
         """Sets the meta_data of this AbstractSubscriberUpdate.
 
-            Allow to store additional information about the object.
+            Meta data allow to store additional data along the object.
 
         :param meta_data: The meta_data of this AbstractSubscriberUpdate.
         :type: dict(str, str)
         """
 
         self._meta_data = meta_data
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_subscription_affiliate_update.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_subscription_affiliate_update.py`

 * *Files 4% similar despite different names*

```diff
@@ -35,49 +35,49 @@
         
 
     
     @property
     def language(self):
         """Gets the language of this AbstractSubscriptionAffiliateUpdate.
 
-            The language that is linked to the object.
+            
 
         :return: The language of this AbstractSubscriptionAffiliateUpdate.
         :rtype: str
         """
         return self._language
 
     @language.setter
     def language(self, language):
         """Sets the language of this AbstractSubscriptionAffiliateUpdate.
 
-            The language that is linked to the object.
+            
 
         :param language: The language of this AbstractSubscriptionAffiliateUpdate.
         :type: str
         """
 
         self._language = language
     
     @property
     def meta_data(self):
         """Gets the meta_data of this AbstractSubscriptionAffiliateUpdate.
 
-            Allow to store additional information about the object.
+            Meta data allow to store additional data along the object.
 
         :return: The meta_data of this AbstractSubscriptionAffiliateUpdate.
         :rtype: dict(str, str)
         """
         return self._meta_data
 
     @meta_data.setter
     def meta_data(self, meta_data):
         """Sets the meta_data of this AbstractSubscriptionAffiliateUpdate.
 
-            Allow to store additional information about the object.
+            Meta data allow to store additional data along the object.
 
         :param meta_data: The meta_data of this AbstractSubscriptionAffiliateUpdate.
         :type: dict(str, str)
         """
 
         self._meta_data = meta_data
     
@@ -108,26 +108,26 @@
 
         self._name = name
     
     @property
     def state(self):
         """Gets the state of this AbstractSubscriptionAffiliateUpdate.
 
-            The object's current state.
+            
 
         :return: The state of this AbstractSubscriptionAffiliateUpdate.
         :rtype: CreationEntityState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this AbstractSubscriptionAffiliateUpdate.
 
-            The object's current state.
+            
 
         :param state: The state of this AbstractSubscriptionAffiliateUpdate.
         :type: CreationEntityState
         """
 
         self._state = state
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_subscription_metric_update.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/debt_collector.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,79 +1,105 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
 
 
 
-class AbstractSubscriptionMetricUpdate:
+class DebtCollector:
 
     swagger_types = {
     
         'description': 'dict(str, str)',
+        'id': 'int',
         'name': 'dict(str, str)',
     }
 
     attribute_map = {
-        'description': 'description','name': 'name',
+        'description': 'description','id': 'id','name': 'name',
     }
 
     
     _description = None
+    _id = None
     _name = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
         self.description = kwargs.get('description', None)
+        self.id = kwargs.get('id', None)
         self.name = kwargs.get('name', None)
         
 
     
     @property
     def description(self):
-        """Gets the description of this AbstractSubscriptionMetricUpdate.
+        """Gets the description of this DebtCollector.
 
             
 
-        :return: The description of this AbstractSubscriptionMetricUpdate.
+        :return: The description of this DebtCollector.
         :rtype: dict(str, str)
         """
         return self._description
 
     @description.setter
     def description(self, description):
-        """Sets the description of this AbstractSubscriptionMetricUpdate.
+        """Sets the description of this DebtCollector.
 
             
 
-        :param description: The description of this AbstractSubscriptionMetricUpdate.
+        :param description: The description of this DebtCollector.
         :type: dict(str, str)
         """
 
         self._description = description
     
     @property
+    def id(self):
+        """Gets the id of this DebtCollector.
+
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
+
+        :return: The id of this DebtCollector.
+        :rtype: int
+        """
+        return self._id
+
+    @id.setter
+    def id(self, id):
+        """Sets the id of this DebtCollector.
+
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
+
+        :param id: The id of this DebtCollector.
+        :type: int
+        """
+
+        self._id = id
+    
+    @property
     def name(self):
-        """Gets the name of this AbstractSubscriptionMetricUpdate.
+        """Gets the name of this DebtCollector.
 
             
 
-        :return: The name of this AbstractSubscriptionMetricUpdate.
+        :return: The name of this DebtCollector.
         :rtype: dict(str, str)
         """
         return self._name
 
     @name.setter
     def name(self, name):
-        """Sets the name of this AbstractSubscriptionMetricUpdate.
+        """Sets the name of this DebtCollector.
 
             
 
-        :param name: The name of this AbstractSubscriptionMetricUpdate.
+        :param name: The name of this DebtCollector.
         :type: dict(str, str)
         """
 
         self._name = name
     
 
     def to_dict(self):
@@ -94,27 +120,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(AbstractSubscriptionMetricUpdate, dict):
+        if issubclass(DebtCollector, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, AbstractSubscriptionMetricUpdate):
+        if not isinstance(other, DebtCollector):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_subscription_product_active.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_subscription_product_active.py`

 * *Files 1% similar despite different names*

```diff
@@ -158,26 +158,26 @@
 
         self._sort_order = sort_order
     
     @property
     def state(self):
         """Gets the state of this AbstractSubscriptionProductActive.
 
-            The object's current state.
+            
 
         :return: The state of this AbstractSubscriptionProductActive.
         :rtype: SubscriptionProductState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this AbstractSubscriptionProductActive.
 
-            The object's current state.
+            
 
         :param state: The state of this AbstractSubscriptionProductActive.
         :type: SubscriptionProductState
         """
 
         self._state = state
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_token_update.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_token_update.py`

 * *Files 1% similar despite different names*

```diff
@@ -112,26 +112,26 @@
 
         self._enabled_for_one_click_payment = enabled_for_one_click_payment
     
     @property
     def language(self):
         """Gets the language of this AbstractTokenUpdate.
 
-            The language that is linked to the object.
+            
 
         :return: The language of this AbstractTokenUpdate.
         :rtype: str
         """
         return self._language
 
     @language.setter
     def language(self, language):
         """Sets the language of this AbstractTokenUpdate.
 
-            The language that is linked to the object.
+            
 
         :param language: The language of this AbstractTokenUpdate.
         :type: str
         """
 
         self._language = language
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_transaction_comment_active.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_transaction_invoice_comment_active.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
 
 
 
-class AbstractTransactionCommentActive:
+class AbstractTransactionInvoiceCommentActive:
 
     swagger_types = {
     
         'content': 'str',
     }
 
     attribute_map = {
@@ -24,30 +24,30 @@
         
         self.content = kwargs.get('content', None)
         
 
     
     @property
     def content(self):
-        """Gets the content of this AbstractTransactionCommentActive.
+        """Gets the content of this AbstractTransactionInvoiceCommentActive.
 
-            The comment's actual content.
+            
 
-        :return: The content of this AbstractTransactionCommentActive.
+        :return: The content of this AbstractTransactionInvoiceCommentActive.
         :rtype: str
         """
         return self._content
 
     @content.setter
     def content(self, content):
-        """Sets the content of this AbstractTransactionCommentActive.
+        """Sets the content of this AbstractTransactionInvoiceCommentActive.
 
-            The comment's actual content.
+            
 
-        :param content: The content of this AbstractTransactionCommentActive.
+        :param content: The content of this AbstractTransactionInvoiceCommentActive.
         :type: str
         """
         if content is not None and len(content) > 262144:
             raise ValueError("Invalid value for `content`, length must be less than or equal to `262144`")
 
         self._content = content
     
@@ -70,27 +70,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(AbstractTransactionCommentActive, dict):
+        if issubclass(AbstractTransactionInvoiceCommentActive, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, AbstractTransactionCommentActive):
+        if not isinstance(other, AbstractTransactionInvoiceCommentActive):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_transaction_invoice_comment_active.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_transaction_comment_active.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
 
 
 
-class AbstractTransactionInvoiceCommentActive:
+class AbstractTransactionCommentActive:
 
     swagger_types = {
     
         'content': 'str',
     }
 
     attribute_map = {
@@ -24,30 +24,30 @@
         
         self.content = kwargs.get('content', None)
         
 
     
     @property
     def content(self):
-        """Gets the content of this AbstractTransactionInvoiceCommentActive.
+        """Gets the content of this AbstractTransactionCommentActive.
 
-            The comment's actual content.
+            
 
-        :return: The content of this AbstractTransactionInvoiceCommentActive.
+        :return: The content of this AbstractTransactionCommentActive.
         :rtype: str
         """
         return self._content
 
     @content.setter
     def content(self, content):
-        """Sets the content of this AbstractTransactionInvoiceCommentActive.
+        """Sets the content of this AbstractTransactionCommentActive.
 
-            The comment's actual content.
+            
 
-        :param content: The content of this AbstractTransactionInvoiceCommentActive.
+        :param content: The content of this AbstractTransactionCommentActive.
         :type: str
         """
         if content is not None and len(content) > 262144:
             raise ValueError("Invalid value for `content`, length must be less than or equal to `262144`")
 
         self._content = content
     
@@ -70,27 +70,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(AbstractTransactionInvoiceCommentActive, dict):
+        if issubclass(AbstractTransactionCommentActive, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, AbstractTransactionInvoiceCommentActive):
+        if not isinstance(other, AbstractTransactionCommentActive):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_transaction_pending.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_transaction_pending.py`

 * *Files 2% similar despite different names*

```diff
@@ -5,15 +5,15 @@
 
 
 
 class AbstractTransactionPending:
 
     swagger_types = {
     
-        'allowed_payment_method_brands': 'list[int]',
+        'allowed_payment_method_brands': 'list[PaymentMethodBrand]',
         'allowed_payment_method_configurations': 'list[int]',
         'billing_address': 'AddressCreate',
         'completion_behavior': 'TransactionCompletionBehavior',
         'currency': 'str',
         'customer_email_address': 'str',
         'customer_id': 'str',
         'failed_url': 'str',
@@ -83,26 +83,26 @@
     @property
     def allowed_payment_method_brands(self):
         """Gets the allowed_payment_method_brands of this AbstractTransactionPending.
 
             
 
         :return: The allowed_payment_method_brands of this AbstractTransactionPending.
-        :rtype: list[int]
+        :rtype: list[PaymentMethodBrand]
         """
         return self._allowed_payment_method_brands
 
     @allowed_payment_method_brands.setter
     def allowed_payment_method_brands(self, allowed_payment_method_brands):
         """Sets the allowed_payment_method_brands of this AbstractTransactionPending.
 
             
 
         :param allowed_payment_method_brands: The allowed_payment_method_brands of this AbstractTransactionPending.
-        :type: list[int]
+        :type: list[PaymentMethodBrand]
         """
 
         self._allowed_payment_method_brands = allowed_payment_method_brands
     
     @property
     def allowed_payment_method_configurations(self):
         """Gets the allowed_payment_method_configurations of this AbstractTransactionPending.
@@ -295,26 +295,26 @@
 
         self._invoice_merchant_reference = invoice_merchant_reference
     
     @property
     def language(self):
         """Gets the language of this AbstractTransactionPending.
 
-            The language that is linked to the object.
+            
 
         :return: The language of this AbstractTransactionPending.
         :rtype: str
         """
         return self._language
 
     @language.setter
     def language(self, language):
         """Sets the language of this AbstractTransactionPending.
 
-            The language that is linked to the object.
+            
 
         :param language: The language of this AbstractTransactionPending.
         :type: str
         """
 
         self._language = language
     
@@ -366,26 +366,26 @@
 
         self._merchant_reference = merchant_reference
     
     @property
     def meta_data(self):
         """Gets the meta_data of this AbstractTransactionPending.
 
-            Allow to store additional information about the object.
+            Meta data allow to store additional data along the object.
 
         :return: The meta_data of this AbstractTransactionPending.
         :rtype: dict(str, str)
         """
         return self._meta_data
 
     @meta_data.setter
     def meta_data(self, meta_data):
         """Sets the meta_data of this AbstractTransactionPending.
 
-            Allow to store additional information about the object.
+            Meta data allow to store additional data along the object.
 
         :param meta_data: The meta_data of this AbstractTransactionPending.
         :type: dict(str, str)
         """
 
         self._meta_data = meta_data
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_webhook_listener_update.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_webhook_listener_update.py`

 * *Files 18% similar despite different names*

```diff
@@ -35,97 +35,97 @@
         
 
     
     @property
     def entity_states(self):
         """Gets the entity_states of this AbstractWebhookListenerUpdate.
 
-            The entity's target states that are to be monitored.
+            The target state identifies the state into which entities need to move into to trigger the webhook listener.
 
         :return: The entity_states of this AbstractWebhookListenerUpdate.
         :rtype: list[str]
         """
         return self._entity_states
 
     @entity_states.setter
     def entity_states(self, entity_states):
         """Sets the entity_states of this AbstractWebhookListenerUpdate.
 
-            The entity's target states that are to be monitored.
+            The target state identifies the state into which entities need to move into to trigger the webhook listener.
 
         :param entity_states: The entity_states of this AbstractWebhookListenerUpdate.
         :type: list[str]
         """
 
         self._entity_states = entity_states
     
     @property
     def name(self):
         """Gets the name of this AbstractWebhookListenerUpdate.
 
-            The name used to identify the webhook listener.
+            The webhook listener name is used internally to identify the webhook listener in administrative interfaces.For example it is used within search fields and hence it should be distinct and descriptive.
 
         :return: The name of this AbstractWebhookListenerUpdate.
         :rtype: str
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this AbstractWebhookListenerUpdate.
 
-            The name used to identify the webhook listener.
+            The webhook listener name is used internally to identify the webhook listener in administrative interfaces.For example it is used within search fields and hence it should be distinct and descriptive.
 
         :param name: The name of this AbstractWebhookListenerUpdate.
         :type: str
         """
         if name is not None and len(name) > 50:
             raise ValueError("Invalid value for `name`, length must be less than or equal to `50`")
 
         self._name = name
     
     @property
     def notify_every_change(self):
         """Gets the notify_every_change of this AbstractWebhookListenerUpdate.
 
-            Whether every update of the entity or only state changes are to be monitored.
+            Defines whether the webhook listener is to be informed about every change made to the entity in contrast to state transitions only.
 
         :return: The notify_every_change of this AbstractWebhookListenerUpdate.
         :rtype: bool
         """
         return self._notify_every_change
 
     @notify_every_change.setter
     def notify_every_change(self, notify_every_change):
         """Sets the notify_every_change of this AbstractWebhookListenerUpdate.
 
-            Whether every update of the entity or only state changes are to be monitored.
+            Defines whether the webhook listener is to be informed about every change made to the entity in contrast to state transitions only.
 
         :param notify_every_change: The notify_every_change of this AbstractWebhookListenerUpdate.
         :type: bool
         """
 
         self._notify_every_change = notify_every_change
     
     @property
     def state(self):
         """Gets the state of this AbstractWebhookListenerUpdate.
 
-            The object's current state.
+            
 
         :return: The state of this AbstractWebhookListenerUpdate.
         :rtype: CreationEntityState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this AbstractWebhookListenerUpdate.
 
-            The object's current state.
+            
 
         :param state: The state of this AbstractWebhookListenerUpdate.
         :type: CreationEntityState
         """
 
         self._state = state
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/abstract_webhook_url_update.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/abstract_webhook_url_update.py`

 * *Files 8% similar despite different names*

```diff
@@ -32,74 +32,74 @@
         
 
     
     @property
     def name(self):
         """Gets the name of this AbstractWebhookUrlUpdate.
 
-            The name used to identify the webhook URL.
+            The URL name is used internally to identify the URL in administrative interfaces. For example it is used within search fields and hence it should be distinct and descriptive.
 
         :return: The name of this AbstractWebhookUrlUpdate.
         :rtype: str
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this AbstractWebhookUrlUpdate.
 
-            The name used to identify the webhook URL.
+            The URL name is used internally to identify the URL in administrative interfaces. For example it is used within search fields and hence it should be distinct and descriptive.
 
         :param name: The name of this AbstractWebhookUrlUpdate.
         :type: str
         """
         if name is not None and len(name) > 50:
             raise ValueError("Invalid value for `name`, length must be less than or equal to `50`")
 
         self._name = name
     
     @property
     def state(self):
         """Gets the state of this AbstractWebhookUrlUpdate.
 
-            The object's current state.
+            
 
         :return: The state of this AbstractWebhookUrlUpdate.
         :rtype: CreationEntityState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this AbstractWebhookUrlUpdate.
 
-            The object's current state.
+            
 
         :param state: The state of this AbstractWebhookUrlUpdate.
         :type: CreationEntityState
         """
 
         self._state = state
     
     @property
     def url(self):
         """Gets the url of this AbstractWebhookUrlUpdate.
 
-            The actual URL where notifications about entity changes are sent to.
+            The URL to which the HTTP requests are sent to. An example URL could look like https://www.example.com/some/path?some-query-parameter=value.
 
         :return: The url of this AbstractWebhookUrlUpdate.
         :rtype: str
         """
         return self._url
 
     @url.setter
     def url(self, url):
         """Sets the url of this AbstractWebhookUrlUpdate.
 
-            The actual URL where notifications about entity changes are sent to.
+            The URL to which the HTTP requests are sent to. An example URL could look like https://www.example.com/some/path?some-query-parameter=value.
 
         :param url: The url of this AbstractWebhookUrlUpdate.
         :type: str
         """
         if url is not None and len(url) > 500:
             raise ValueError("Invalid value for `url`, length must be less than or equal to `500`")
         if url is not None and len(url) < 9:
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/account.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/account.py`

 * *Files 6% similar despite different names*

```diff
@@ -74,210 +74,210 @@
         
 
     
     @property
     def active(self):
         """Gets the active of this Account.
 
-            Whether this account and all its parent accounts are active.
+            Active means that this account and all accounts in the hierarchy are active.
 
         :return: The active of this Account.
         :rtype: bool
         """
         return self._active
 
     @active.setter
     def active(self, active):
         """Sets the active of this Account.
 
-            Whether this account and all its parent accounts are active.
+            Active means that this account and all accounts in the hierarchy are active.
 
         :param active: The active of this Account.
         :type: bool
         """
 
         self._active = active
     
     @property
     def active_or_restricted_active(self):
         """Gets the active_or_restricted_active of this Account.
 
-            Whether this account and all its parent accounts are active or restricted active.
+            This property is true when all accounts in the hierarchy are active or restricted active.
 
         :return: The active_or_restricted_active of this Account.
         :rtype: bool
         """
         return self._active_or_restricted_active
 
     @active_or_restricted_active.setter
     def active_or_restricted_active(self, active_or_restricted_active):
         """Sets the active_or_restricted_active of this Account.
 
-            Whether this account and all its parent accounts are active or restricted active.
+            This property is true when all accounts in the hierarchy are active or restricted active.
 
         :param active_or_restricted_active: The active_or_restricted_active of this Account.
         :type: bool
         """
 
         self._active_or_restricted_active = active_or_restricted_active
     
     @property
     def created_by(self):
         """Gets the created_by of this Account.
 
-            The ID of the user the account was created by.
+            The ID of the user who created this entity.
 
         :return: The created_by of this Account.
         :rtype: int
         """
         return self._created_by
 
     @created_by.setter
     def created_by(self, created_by):
         """Sets the created_by of this Account.
 
-            The ID of the user the account was created by.
+            The ID of the user who created this entity.
 
         :param created_by: The created_by of this Account.
         :type: int
         """
 
         self._created_by = created_by
     
     @property
     def created_on(self):
         """Gets the created_on of this Account.
 
-            The date and time when the account was created.
+            The date and time when this entity was created.
 
         :return: The created_on of this Account.
         :rtype: datetime
         """
         return self._created_on
 
     @created_on.setter
     def created_on(self, created_on):
         """Sets the created_on of this Account.
 
-            The date and time when the account was created.
+            The date and time when this entity was created.
 
         :param created_on: The created_on of this Account.
         :type: datetime
         """
 
         self._created_on = created_on
     
     @property
     def deleted_by(self):
         """Gets the deleted_by of this Account.
 
-            The ID of a user the account was deleted by.
+            The ID of a user that deleted this entity.
 
         :return: The deleted_by of this Account.
         :rtype: int
         """
         return self._deleted_by
 
     @deleted_by.setter
     def deleted_by(self, deleted_by):
         """Sets the deleted_by of this Account.
 
-            The ID of a user the account was deleted by.
+            The ID of a user that deleted this entity.
 
         :param deleted_by: The deleted_by of this Account.
         :type: int
         """
 
         self._deleted_by = deleted_by
     
     @property
     def deleted_on(self):
         """Gets the deleted_on of this Account.
 
-            The date and time when the account was deleted.
+            The date and time when this entity was deleted.
 
         :return: The deleted_on of this Account.
         :rtype: datetime
         """
         return self._deleted_on
 
     @deleted_on.setter
     def deleted_on(self, deleted_on):
         """Sets the deleted_on of this Account.
 
-            The date and time when the account was deleted.
+            The date and time when this entity was deleted.
 
         :param deleted_on: The deleted_on of this Account.
         :type: datetime
         """
 
         self._deleted_on = deleted_on
     
     @property
     def id(self):
         """Gets the id of this Account.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this Account.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this Account.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this Account.
         :type: int
         """
 
         self._id = id
     
     @property
     def last_modified_date(self):
         """Gets the last_modified_date of this Account.
 
-            The date and time when the object was last modified.
+            
 
         :return: The last_modified_date of this Account.
         :rtype: datetime
         """
         return self._last_modified_date
 
     @last_modified_date.setter
     def last_modified_date(self, last_modified_date):
         """Sets the last_modified_date of this Account.
 
-            The date and time when the object was last modified.
+            
 
         :param last_modified_date: The last_modified_date of this Account.
         :type: datetime
         """
 
         self._last_modified_date = last_modified_date
     
     @property
     def name(self):
         """Gets the name of this Account.
 
-            The name used to identify the account.
+            The name of the account identifies the account within the administrative interface.
 
         :return: The name of this Account.
         :rtype: str
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this Account.
 
-            The name used to identify the account.
+            The name of the account identifies the account within the administrative interface.
 
         :param name: The name of this Account.
         :type: str
         """
         if name is not None and len(name) > 200:
             raise ValueError("Invalid value for `name`, length must be less than or equal to `200`")
         if name is not None and len(name) < 3:
@@ -285,187 +285,187 @@
 
         self._name = name
     
     @property
     def parent_account(self):
         """Gets the parent_account of this Account.
 
-            The parent account responsible for administering this account.
+            The account which is responsible for administering the account.
 
         :return: The parent_account of this Account.
         :rtype: Account
         """
         return self._parent_account
 
     @parent_account.setter
     def parent_account(self, parent_account):
         """Sets the parent_account of this Account.
 
-            The parent account responsible for administering this account.
+            The account which is responsible for administering the account.
 
         :param parent_account: The parent_account of this Account.
         :type: Account
         """
 
         self._parent_account = parent_account
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this Account.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this Account.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this Account.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this Account.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
     @property
     def restricted_active(self):
         """Gets the restricted_active of this Account.
 
-            Whether this account and all its parent accounts are active or restricted active. There is at least one account that is restricted active.
+            Restricted active means that at least one account in the hierarchy is only restricted active, but all are either restricted active or active.
 
         :return: The restricted_active of this Account.
         :rtype: bool
         """
         return self._restricted_active
 
     @restricted_active.setter
     def restricted_active(self, restricted_active):
         """Sets the restricted_active of this Account.
 
-            Whether this account and all its parent accounts are active or restricted active. There is at least one account that is restricted active.
+            Restricted active means that at least one account in the hierarchy is only restricted active, but all are either restricted active or active.
 
         :param restricted_active: The restricted_active of this Account.
         :type: bool
         """
 
         self._restricted_active = restricted_active
     
     @property
     def scope(self):
         """Gets the scope of this Account.
 
-            The scope that the account belongs to.
+            This is the scope to which the account belongs to.
 
         :return: The scope of this Account.
         :rtype: int
         """
         return self._scope
 
     @scope.setter
     def scope(self, scope):
         """Sets the scope of this Account.
 
-            The scope that the account belongs to.
+            This is the scope to which the account belongs to.
 
         :param scope: The scope of this Account.
         :type: int
         """
 
         self._scope = scope
     
     @property
     def state(self):
         """Gets the state of this Account.
 
-            The object's current state.
+            
 
         :return: The state of this Account.
         :rtype: AccountState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this Account.
 
-            The object's current state.
+            
 
         :param state: The state of this Account.
         :type: AccountState
         """
 
         self._state = state
     
     @property
     def subaccount_limit(self):
         """Gets the subaccount_limit of this Account.
 
-            The number of sub-accounts that can be created within this account.
+            This property restricts the number of subaccounts which can be created within this account.
 
         :return: The subaccount_limit of this Account.
         :rtype: int
         """
         return self._subaccount_limit
 
     @subaccount_limit.setter
     def subaccount_limit(self, subaccount_limit):
         """Sets the subaccount_limit of this Account.
 
-            The number of sub-accounts that can be created within this account.
+            This property restricts the number of subaccounts which can be created within this account.
 
         :param subaccount_limit: The subaccount_limit of this Account.
         :type: int
         """
 
         self._subaccount_limit = subaccount_limit
     
     @property
     def type(self):
         """Gets the type of this Account.
 
-            The account's type which defines its role and capabilities.
+            The account type defines which role and capabilities it has.
 
         :return: The type of this Account.
         :rtype: AccountType
         """
         return self._type
 
     @type.setter
     def type(self, type):
         """Sets the type of this Account.
 
-            The account's type which defines its role and capabilities.
+            The account type defines which role and capabilities it has.
 
         :param type: The type of this Account.
         :type: AccountType
         """
 
         self._type = type
     
     @property
     def version(self):
         """Gets the version of this Account.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this Account.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this Account.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this Account.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/account_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/account_create.py`

 * *Files 16% similar despite different names*

```diff
@@ -32,49 +32,49 @@
         self.attribute_map.update(super().attribute_map)
 
     
     @property
     def parent_account(self):
         """Gets the parent_account of this AccountCreate.
 
-            The parent account responsible for administering this account.
+            The account which is responsible for administering the account.
 
         :return: The parent_account of this AccountCreate.
         :rtype: int
         """
         return self._parent_account
 
     @parent_account.setter
     def parent_account(self, parent_account):
         """Sets the parent_account of this AccountCreate.
 
-            The parent account responsible for administering this account.
+            The account which is responsible for administering the account.
 
         :param parent_account: The parent_account of this AccountCreate.
         :type: int
         """
 
         self._parent_account = parent_account
     
     @property
     def scope(self):
         """Gets the scope of this AccountCreate.
 
-            The scope that the account belongs to.
+            This is the scope to which the account belongs to.
 
         :return: The scope of this AccountCreate.
         :rtype: int
         """
         return self._scope
 
     @scope.setter
     def scope(self, scope):
         """Sets the scope of this AccountCreate.
 
-            The scope that the account belongs to.
+            This is the scope to which the account belongs to.
 
         :param scope: The scope of this AccountCreate.
         :type: int
         """
         if scope is None:
             raise ValueError("Invalid value for `scope`, must not be `None`")
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/account_update.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/account_update.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/address.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/address.py`

 * *Files 14% similar despite different names*

```diff
@@ -83,491 +83,491 @@
         
 
     
     @property
     def city(self):
         """Gets the city of this Address.
 
-            The city, town or village.
+            
 
         :return: The city of this Address.
         :rtype: str
         """
         return self._city
 
     @city.setter
     def city(self, city):
         """Sets the city of this Address.
 
-            The city, town or village.
+            
 
         :param city: The city of this Address.
         :type: str
         """
         if city is not None and len(city) > 100:
             raise ValueError("Invalid value for `city`, length must be less than or equal to `100`")
 
         self._city = city
     
     @property
     def commercial_register_number(self):
         """Gets the commercial_register_number of this Address.
 
-            The commercial registration number of the organization.
+            
 
         :return: The commercial_register_number of this Address.
         :rtype: str
         """
         return self._commercial_register_number
 
     @commercial_register_number.setter
     def commercial_register_number(self, commercial_register_number):
         """Sets the commercial_register_number of this Address.
 
-            The commercial registration number of the organization.
+            
 
         :param commercial_register_number: The commercial_register_number of this Address.
         :type: str
         """
         if commercial_register_number is not None and len(commercial_register_number) > 100:
             raise ValueError("Invalid value for `commercial_register_number`, length must be less than or equal to `100`")
 
         self._commercial_register_number = commercial_register_number
     
     @property
     def country(self):
         """Gets the country of this Address.
 
-            The two-letter country code (ISO 3166 format).
+            
 
         :return: The country of this Address.
         :rtype: str
         """
         return self._country
 
     @country.setter
     def country(self, country):
         """Sets the country of this Address.
 
-            The two-letter country code (ISO 3166 format).
+            
 
         :param country: The country of this Address.
         :type: str
         """
 
         self._country = country
     
     @property
     def date_of_birth(self):
         """Gets the date_of_birth of this Address.
 
-            The date of birth.
+            
 
         :return: The date_of_birth of this Address.
         :rtype: date
         """
         return self._date_of_birth
 
     @date_of_birth.setter
     def date_of_birth(self, date_of_birth):
         """Sets the date_of_birth of this Address.
 
-            The date of birth.
+            
 
         :param date_of_birth: The date_of_birth of this Address.
         :type: date
         """
 
         self._date_of_birth = date_of_birth
     
     @property
     def dependent_locality(self):
         """Gets the dependent_locality of this Address.
 
-            The dependent locality which is a sub-division of the state.
+            
 
         :return: The dependent_locality of this Address.
         :rtype: str
         """
         return self._dependent_locality
 
     @dependent_locality.setter
     def dependent_locality(self, dependent_locality):
         """Sets the dependent_locality of this Address.
 
-            The dependent locality which is a sub-division of the state.
+            
 
         :param dependent_locality: The dependent_locality of this Address.
         :type: str
         """
         if dependent_locality is not None and len(dependent_locality) > 100:
             raise ValueError("Invalid value for `dependent_locality`, length must be less than or equal to `100`")
 
         self._dependent_locality = dependent_locality
     
     @property
     def email_address(self):
         """Gets the email_address of this Address.
 
-            The email address.
+            
 
         :return: The email_address of this Address.
         :rtype: str
         """
         return self._email_address
 
     @email_address.setter
     def email_address(self, email_address):
         """Sets the email_address of this Address.
 
-            The email address.
+            
 
         :param email_address: The email_address of this Address.
         :type: str
         """
         if email_address is not None and len(email_address) > 254:
             raise ValueError("Invalid value for `email_address`, length must be less than or equal to `254`")
 
         self._email_address = email_address
     
     @property
     def family_name(self):
         """Gets the family_name of this Address.
 
-            The family or last name.
+            
 
         :return: The family_name of this Address.
         :rtype: str
         """
         return self._family_name
 
     @family_name.setter
     def family_name(self, family_name):
         """Sets the family_name of this Address.
 
-            The family or last name.
+            
 
         :param family_name: The family_name of this Address.
         :type: str
         """
         if family_name is not None and len(family_name) > 100:
             raise ValueError("Invalid value for `family_name`, length must be less than or equal to `100`")
 
         self._family_name = family_name
     
     @property
     def gender(self):
         """Gets the gender of this Address.
 
-            The gender.
+            
 
         :return: The gender of this Address.
         :rtype: Gender
         """
         return self._gender
 
     @gender.setter
     def gender(self, gender):
         """Sets the gender of this Address.
 
-            The gender.
+            
 
         :param gender: The gender of this Address.
         :type: Gender
         """
 
         self._gender = gender
     
     @property
     def given_name(self):
         """Gets the given_name of this Address.
 
-            The given or first name.
+            
 
         :return: The given_name of this Address.
         :rtype: str
         """
         return self._given_name
 
     @given_name.setter
     def given_name(self, given_name):
         """Sets the given_name of this Address.
 
-            The given or first name.
+            
 
         :param given_name: The given_name of this Address.
         :type: str
         """
         if given_name is not None and len(given_name) > 100:
             raise ValueError("Invalid value for `given_name`, length must be less than or equal to `100`")
 
         self._given_name = given_name
     
     @property
     def legal_organization_form(self):
         """Gets the legal_organization_form of this Address.
 
-            The legal form of the organization.
+            
 
         :return: The legal_organization_form of this Address.
         :rtype: LegalOrganizationForm
         """
         return self._legal_organization_form
 
     @legal_organization_form.setter
     def legal_organization_form(self, legal_organization_form):
         """Sets the legal_organization_form of this Address.
 
-            The legal form of the organization.
+            
 
         :param legal_organization_form: The legal_organization_form of this Address.
         :type: LegalOrganizationForm
         """
 
         self._legal_organization_form = legal_organization_form
     
     @property
     def mobile_phone_number(self):
         """Gets the mobile_phone_number of this Address.
 
-            The phone number of a mobile phone.
+            
 
         :return: The mobile_phone_number of this Address.
         :rtype: str
         """
         return self._mobile_phone_number
 
     @mobile_phone_number.setter
     def mobile_phone_number(self, mobile_phone_number):
         """Sets the mobile_phone_number of this Address.
 
-            The phone number of a mobile phone.
+            
 
         :param mobile_phone_number: The mobile_phone_number of this Address.
         :type: str
         """
         if mobile_phone_number is not None and len(mobile_phone_number) > 100:
             raise ValueError("Invalid value for `mobile_phone_number`, length must be less than or equal to `100`")
 
         self._mobile_phone_number = mobile_phone_number
     
     @property
     def organization_name(self):
         """Gets the organization_name of this Address.
 
-            The organization's name.
+            
 
         :return: The organization_name of this Address.
         :rtype: str
         """
         return self._organization_name
 
     @organization_name.setter
     def organization_name(self, organization_name):
         """Sets the organization_name of this Address.
 
-            The organization's name.
+            
 
         :param organization_name: The organization_name of this Address.
         :type: str
         """
         if organization_name is not None and len(organization_name) > 100:
             raise ValueError("Invalid value for `organization_name`, length must be less than or equal to `100`")
 
         self._organization_name = organization_name
     
     @property
     def phone_number(self):
         """Gets the phone_number of this Address.
 
-            The phone number.
+            
 
         :return: The phone_number of this Address.
         :rtype: str
         """
         return self._phone_number
 
     @phone_number.setter
     def phone_number(self, phone_number):
         """Sets the phone_number of this Address.
 
-            The phone number.
+            
 
         :param phone_number: The phone_number of this Address.
         :type: str
         """
         if phone_number is not None and len(phone_number) > 100:
             raise ValueError("Invalid value for `phone_number`, length must be less than or equal to `100`")
 
         self._phone_number = phone_number
     
     @property
     def postal_state(self):
         """Gets the postal_state of this Address.
 
-            The name of the region, typically a state, county, province or prefecture.
+            
 
         :return: The postal_state of this Address.
         :rtype: str
         """
         return self._postal_state
 
     @postal_state.setter
     def postal_state(self, postal_state):
         """Sets the postal_state of this Address.
 
-            The name of the region, typically a state, county, province or prefecture.
+            
 
         :param postal_state: The postal_state of this Address.
         :type: str
         """
 
         self._postal_state = postal_state
     
     @property
     def postcode(self):
         """Gets the postcode of this Address.
 
-            The postal code, also known as ZIP, postcode, etc.
+            
 
         :return: The postcode of this Address.
         :rtype: str
         """
         return self._postcode
 
     @postcode.setter
     def postcode(self, postcode):
         """Sets the postcode of this Address.
 
-            The postal code, also known as ZIP, postcode, etc.
+            
 
         :param postcode: The postcode of this Address.
         :type: str
         """
         if postcode is not None and len(postcode) > 40:
             raise ValueError("Invalid value for `postcode`, length must be less than or equal to `40`")
 
         self._postcode = postcode
     
     @property
     def sales_tax_number(self):
         """Gets the sales_tax_number of this Address.
 
-            The sales tax number of the organization.
+            
 
         :return: The sales_tax_number of this Address.
         :rtype: str
         """
         return self._sales_tax_number
 
     @sales_tax_number.setter
     def sales_tax_number(self, sales_tax_number):
         """Sets the sales_tax_number of this Address.
 
-            The sales tax number of the organization.
+            
 
         :param sales_tax_number: The sales_tax_number of this Address.
         :type: str
         """
         if sales_tax_number is not None and len(sales_tax_number) > 100:
             raise ValueError("Invalid value for `sales_tax_number`, length must be less than or equal to `100`")
 
         self._sales_tax_number = sales_tax_number
     
     @property
     def salutation(self):
         """Gets the salutation of this Address.
 
-            The salutation e.g. Mrs, Mr, Dr.
+            
 
         :return: The salutation of this Address.
         :rtype: str
         """
         return self._salutation
 
     @salutation.setter
     def salutation(self, salutation):
         """Sets the salutation of this Address.
 
-            The salutation e.g. Mrs, Mr, Dr.
+            
 
         :param salutation: The salutation of this Address.
         :type: str
         """
         if salutation is not None and len(salutation) > 20:
             raise ValueError("Invalid value for `salutation`, length must be less than or equal to `20`")
 
         self._salutation = salutation
     
     @property
     def social_security_number(self):
         """Gets the social_security_number of this Address.
 
-            The social security number.
+            
 
         :return: The social_security_number of this Address.
         :rtype: str
         """
         return self._social_security_number
 
     @social_security_number.setter
     def social_security_number(self, social_security_number):
         """Sets the social_security_number of this Address.
 
-            The social security number.
+            
 
         :param social_security_number: The social_security_number of this Address.
         :type: str
         """
         if social_security_number is not None and len(social_security_number) > 100:
             raise ValueError("Invalid value for `social_security_number`, length must be less than or equal to `100`")
 
         self._social_security_number = social_security_number
     
     @property
     def sorting_code(self):
         """Gets the sorting_code of this Address.
 
-            The sorting code identifying the post office where the PO Box is located.
+            The sorting code identifies the post office at which the post box is located in.
 
         :return: The sorting_code of this Address.
         :rtype: str
         """
         return self._sorting_code
 
     @sorting_code.setter
     def sorting_code(self, sorting_code):
         """Sets the sorting_code of this Address.
 
-            The sorting code identifying the post office where the PO Box is located.
+            The sorting code identifies the post office at which the post box is located in.
 
         :param sorting_code: The sorting_code of this Address.
         :type: str
         """
         if sorting_code is not None and len(sorting_code) > 100:
             raise ValueError("Invalid value for `sorting_code`, length must be less than or equal to `100`")
 
         self._sorting_code = sorting_code
     
     @property
     def street(self):
         """Gets the street of this Address.
 
-            The street or PO Box.
+            
 
         :return: The street of this Address.
         :rtype: str
         """
         return self._street
 
     @street.setter
     def street(self, street):
         """Sets the street of this Address.
 
-            The street or PO Box.
+            
 
         :param street: The street of this Address.
         :type: str
         """
         if street is not None and len(street) > 300:
             raise ValueError("Invalid value for `street`, length must be less than or equal to `300`")
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/address_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/address_create.py`

 * *Files 4% similar despite different names*

```diff
@@ -83,491 +83,491 @@
         
 
     
     @property
     def city(self):
         """Gets the city of this AddressCreate.
 
-            The city, town or village.
+            
 
         :return: The city of this AddressCreate.
         :rtype: str
         """
         return self._city
 
     @city.setter
     def city(self, city):
         """Sets the city of this AddressCreate.
 
-            The city, town or village.
+            
 
         :param city: The city of this AddressCreate.
         :type: str
         """
         if city is not None and len(city) > 100:
             raise ValueError("Invalid value for `city`, length must be less than or equal to `100`")
 
         self._city = city
     
     @property
     def commercial_register_number(self):
         """Gets the commercial_register_number of this AddressCreate.
 
-            The commercial registration number of the organization.
+            
 
         :return: The commercial_register_number of this AddressCreate.
         :rtype: str
         """
         return self._commercial_register_number
 
     @commercial_register_number.setter
     def commercial_register_number(self, commercial_register_number):
         """Sets the commercial_register_number of this AddressCreate.
 
-            The commercial registration number of the organization.
+            
 
         :param commercial_register_number: The commercial_register_number of this AddressCreate.
         :type: str
         """
         if commercial_register_number is not None and len(commercial_register_number) > 100:
             raise ValueError("Invalid value for `commercial_register_number`, length must be less than or equal to `100`")
 
         self._commercial_register_number = commercial_register_number
     
     @property
     def country(self):
         """Gets the country of this AddressCreate.
 
-            The country is represented with a two-letter code (ISO 3166-1 alpha-2 standard) - for example, CH for Switzerland.
+            
 
         :return: The country of this AddressCreate.
         :rtype: str
         """
         return self._country
 
     @country.setter
     def country(self, country):
         """Sets the country of this AddressCreate.
 
-            The country is represented with a two-letter code (ISO 3166-1 alpha-2 standard) - for example, CH for Switzerland.
+            
 
         :param country: The country of this AddressCreate.
         :type: str
         """
 
         self._country = country
     
     @property
     def date_of_birth(self):
         """Gets the date_of_birth of this AddressCreate.
 
-            The date of birth.
+            
 
         :return: The date_of_birth of this AddressCreate.
         :rtype: date
         """
         return self._date_of_birth
 
     @date_of_birth.setter
     def date_of_birth(self, date_of_birth):
         """Sets the date_of_birth of this AddressCreate.
 
-            The date of birth.
+            
 
         :param date_of_birth: The date_of_birth of this AddressCreate.
         :type: date
         """
 
         self._date_of_birth = date_of_birth
     
     @property
     def dependent_locality(self):
         """Gets the dependent_locality of this AddressCreate.
 
-            The dependent locality which is a sub-division of the state.
+            
 
         :return: The dependent_locality of this AddressCreate.
         :rtype: str
         """
         return self._dependent_locality
 
     @dependent_locality.setter
     def dependent_locality(self, dependent_locality):
         """Sets the dependent_locality of this AddressCreate.
 
-            The dependent locality which is a sub-division of the state.
+            
 
         :param dependent_locality: The dependent_locality of this AddressCreate.
         :type: str
         """
         if dependent_locality is not None and len(dependent_locality) > 100:
             raise ValueError("Invalid value for `dependent_locality`, length must be less than or equal to `100`")
 
         self._dependent_locality = dependent_locality
     
     @property
     def email_address(self):
         """Gets the email_address of this AddressCreate.
 
-            The email address.
+            
 
         :return: The email_address of this AddressCreate.
         :rtype: str
         """
         return self._email_address
 
     @email_address.setter
     def email_address(self, email_address):
         """Sets the email_address of this AddressCreate.
 
-            The email address.
+            
 
         :param email_address: The email_address of this AddressCreate.
         :type: str
         """
         if email_address is not None and len(email_address) > 254:
             raise ValueError("Invalid value for `email_address`, length must be less than or equal to `254`")
 
         self._email_address = email_address
     
     @property
     def family_name(self):
         """Gets the family_name of this AddressCreate.
 
-            The family or last name.
+            
 
         :return: The family_name of this AddressCreate.
         :rtype: str
         """
         return self._family_name
 
     @family_name.setter
     def family_name(self, family_name):
         """Sets the family_name of this AddressCreate.
 
-            The family or last name.
+            
 
         :param family_name: The family_name of this AddressCreate.
         :type: str
         """
         if family_name is not None and len(family_name) > 100:
             raise ValueError("Invalid value for `family_name`, length must be less than or equal to `100`")
 
         self._family_name = family_name
     
     @property
     def gender(self):
         """Gets the gender of this AddressCreate.
 
-            The gender.
+            
 
         :return: The gender of this AddressCreate.
         :rtype: Gender
         """
         return self._gender
 
     @gender.setter
     def gender(self, gender):
         """Sets the gender of this AddressCreate.
 
-            The gender.
+            
 
         :param gender: The gender of this AddressCreate.
         :type: Gender
         """
 
         self._gender = gender
     
     @property
     def given_name(self):
         """Gets the given_name of this AddressCreate.
 
-            The given or first name.
+            
 
         :return: The given_name of this AddressCreate.
         :rtype: str
         """
         return self._given_name
 
     @given_name.setter
     def given_name(self, given_name):
         """Sets the given_name of this AddressCreate.
 
-            The given or first name.
+            
 
         :param given_name: The given_name of this AddressCreate.
         :type: str
         """
         if given_name is not None and len(given_name) > 100:
             raise ValueError("Invalid value for `given_name`, length must be less than or equal to `100`")
 
         self._given_name = given_name
     
     @property
     def legal_organization_form(self):
         """Gets the legal_organization_form of this AddressCreate.
 
-            The legal form of the organization.
+            
 
         :return: The legal_organization_form of this AddressCreate.
         :rtype: int
         """
         return self._legal_organization_form
 
     @legal_organization_form.setter
     def legal_organization_form(self, legal_organization_form):
         """Sets the legal_organization_form of this AddressCreate.
 
-            The legal form of the organization.
+            
 
         :param legal_organization_form: The legal_organization_form of this AddressCreate.
         :type: int
         """
 
         self._legal_organization_form = legal_organization_form
     
     @property
     def mobile_phone_number(self):
         """Gets the mobile_phone_number of this AddressCreate.
 
-            The phone number of a mobile phone.
+            
 
         :return: The mobile_phone_number of this AddressCreate.
         :rtype: str
         """
         return self._mobile_phone_number
 
     @mobile_phone_number.setter
     def mobile_phone_number(self, mobile_phone_number):
         """Sets the mobile_phone_number of this AddressCreate.
 
-            The phone number of a mobile phone.
+            
 
         :param mobile_phone_number: The mobile_phone_number of this AddressCreate.
         :type: str
         """
         if mobile_phone_number is not None and len(mobile_phone_number) > 100:
             raise ValueError("Invalid value for `mobile_phone_number`, length must be less than or equal to `100`")
 
         self._mobile_phone_number = mobile_phone_number
     
     @property
     def organization_name(self):
         """Gets the organization_name of this AddressCreate.
 
-            The organization's name.
+            
 
         :return: The organization_name of this AddressCreate.
         :rtype: str
         """
         return self._organization_name
 
     @organization_name.setter
     def organization_name(self, organization_name):
         """Sets the organization_name of this AddressCreate.
 
-            The organization's name.
+            
 
         :param organization_name: The organization_name of this AddressCreate.
         :type: str
         """
         if organization_name is not None and len(organization_name) > 100:
             raise ValueError("Invalid value for `organization_name`, length must be less than or equal to `100`")
 
         self._organization_name = organization_name
     
     @property
     def phone_number(self):
         """Gets the phone_number of this AddressCreate.
 
-            The phone number.
+            
 
         :return: The phone_number of this AddressCreate.
         :rtype: str
         """
         return self._phone_number
 
     @phone_number.setter
     def phone_number(self, phone_number):
         """Sets the phone_number of this AddressCreate.
 
-            The phone number.
+            
 
         :param phone_number: The phone_number of this AddressCreate.
         :type: str
         """
         if phone_number is not None and len(phone_number) > 100:
             raise ValueError("Invalid value for `phone_number`, length must be less than or equal to `100`")
 
         self._phone_number = phone_number
     
     @property
     def postal_state(self):
         """Gets the postal_state of this AddressCreate.
 
-            The name of the region, typically a state, county, province or prefecture.
+            
 
         :return: The postal_state of this AddressCreate.
         :rtype: str
         """
         return self._postal_state
 
     @postal_state.setter
     def postal_state(self, postal_state):
         """Sets the postal_state of this AddressCreate.
 
-            The name of the region, typically a state, county, province or prefecture.
+            
 
         :param postal_state: The postal_state of this AddressCreate.
         :type: str
         """
 
         self._postal_state = postal_state
     
     @property
     def postcode(self):
         """Gets the postcode of this AddressCreate.
 
-            The postal code, also known as ZIP, postcode, etc.
+            
 
         :return: The postcode of this AddressCreate.
         :rtype: str
         """
         return self._postcode
 
     @postcode.setter
     def postcode(self, postcode):
         """Sets the postcode of this AddressCreate.
 
-            The postal code, also known as ZIP, postcode, etc.
+            
 
         :param postcode: The postcode of this AddressCreate.
         :type: str
         """
         if postcode is not None and len(postcode) > 40:
             raise ValueError("Invalid value for `postcode`, length must be less than or equal to `40`")
 
         self._postcode = postcode
     
     @property
     def sales_tax_number(self):
         """Gets the sales_tax_number of this AddressCreate.
 
-            The sales tax number of the organization.
+            
 
         :return: The sales_tax_number of this AddressCreate.
         :rtype: str
         """
         return self._sales_tax_number
 
     @sales_tax_number.setter
     def sales_tax_number(self, sales_tax_number):
         """Sets the sales_tax_number of this AddressCreate.
 
-            The sales tax number of the organization.
+            
 
         :param sales_tax_number: The sales_tax_number of this AddressCreate.
         :type: str
         """
         if sales_tax_number is not None and len(sales_tax_number) > 100:
             raise ValueError("Invalid value for `sales_tax_number`, length must be less than or equal to `100`")
 
         self._sales_tax_number = sales_tax_number
     
     @property
     def salutation(self):
         """Gets the salutation of this AddressCreate.
 
-            The salutation e.g. Mrs, Mr, Dr.
+            
 
         :return: The salutation of this AddressCreate.
         :rtype: str
         """
         return self._salutation
 
     @salutation.setter
     def salutation(self, salutation):
         """Sets the salutation of this AddressCreate.
 
-            The salutation e.g. Mrs, Mr, Dr.
+            
 
         :param salutation: The salutation of this AddressCreate.
         :type: str
         """
         if salutation is not None and len(salutation) > 20:
             raise ValueError("Invalid value for `salutation`, length must be less than or equal to `20`")
 
         self._salutation = salutation
     
     @property
     def social_security_number(self):
         """Gets the social_security_number of this AddressCreate.
 
-            The social security number.
+            
 
         :return: The social_security_number of this AddressCreate.
         :rtype: str
         """
         return self._social_security_number
 
     @social_security_number.setter
     def social_security_number(self, social_security_number):
         """Sets the social_security_number of this AddressCreate.
 
-            The social security number.
+            
 
         :param social_security_number: The social_security_number of this AddressCreate.
         :type: str
         """
         if social_security_number is not None and len(social_security_number) > 100:
             raise ValueError("Invalid value for `social_security_number`, length must be less than or equal to `100`")
 
         self._social_security_number = social_security_number
     
     @property
     def sorting_code(self):
         """Gets the sorting_code of this AddressCreate.
 
-            The sorting code identifying the post office where the PO Box is located.
+            The sorting code identifies the post office at which the post box is located in.
 
         :return: The sorting_code of this AddressCreate.
         :rtype: str
         """
         return self._sorting_code
 
     @sorting_code.setter
     def sorting_code(self, sorting_code):
         """Sets the sorting_code of this AddressCreate.
 
-            The sorting code identifying the post office where the PO Box is located.
+            The sorting code identifies the post office at which the post box is located in.
 
         :param sorting_code: The sorting_code of this AddressCreate.
         :type: str
         """
         if sorting_code is not None and len(sorting_code) > 100:
             raise ValueError("Invalid value for `sorting_code`, length must be less than or equal to `100`")
 
         self._sorting_code = sorting_code
     
     @property
     def street(self):
         """Gets the street of this AddressCreate.
 
-            The street or PO Box.
+            
 
         :return: The street of this AddressCreate.
         :rtype: str
         """
         return self._street
 
     @street.setter
     def street(self, street):
         """Sets the street of this AddressCreate.
 
-            The street or PO Box.
+            
 
         :param street: The street of this AddressCreate.
         :type: str
         """
         if street is not None and len(street) > 300:
             raise ValueError("Invalid value for `street`, length must be less than or equal to `300`")
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/analytics_query_execution.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_terminal.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,343 +1,345 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
 
 
 
-class AnalyticsQueryExecution:
+class PaymentTerminal:
 
     swagger_types = {
     
-        'account': 'int',
-        'error_message': 'str',
+        'configuration_version': 'PaymentTerminalConfigurationVersion',
+        'default_currency': 'str',
         'external_id': 'str',
-        'failure_reason': 'FailureReason',
         'id': 'int',
-        'processing_end_time': 'datetime',
-        'processing_start_time': 'datetime',
-        'query_string': 'str',
-        'scanned_data_in_gb': 'float',
-        'scanned_data_limit': 'float',
-        'spaces': 'list[int]',
-        'state': 'AnalyticsQueryExecutionState',
+        'identifier': 'str',
+        'linked_space_id': 'int',
+        'location_version': 'PaymentTerminalLocationVersion',
+        'name': 'str',
+        'planned_purge_date': 'datetime',
+        'state': 'PaymentTerminalState',
+        'type': 'PaymentTerminalType',
+        'version': 'int',
     }
 
     attribute_map = {
-        'account': 'account','error_message': 'errorMessage','external_id': 'externalId','failure_reason': 'failureReason','id': 'id','processing_end_time': 'processingEndTime','processing_start_time': 'processingStartTime','query_string': 'queryString','scanned_data_in_gb': 'scannedDataInGb','scanned_data_limit': 'scannedDataLimit','spaces': 'spaces','state': 'state',
+        'configuration_version': 'configurationVersion','default_currency': 'defaultCurrency','external_id': 'externalId','id': 'id','identifier': 'identifier','linked_space_id': 'linkedSpaceId','location_version': 'locationVersion','name': 'name','planned_purge_date': 'plannedPurgeDate','state': 'state','type': 'type','version': 'version',
     }
 
     
-    _account = None
-    _error_message = None
+    _configuration_version = None
+    _default_currency = None
     _external_id = None
-    _failure_reason = None
     _id = None
-    _processing_end_time = None
-    _processing_start_time = None
-    _query_string = None
-    _scanned_data_in_gb = None
-    _scanned_data_limit = None
-    _spaces = None
+    _identifier = None
+    _linked_space_id = None
+    _location_version = None
+    _name = None
+    _planned_purge_date = None
     _state = None
+    _type = None
+    _version = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
-        self.account = kwargs.get('account', None)
-        self.error_message = kwargs.get('error_message', None)
+        self.configuration_version = kwargs.get('configuration_version', None)
+        self.default_currency = kwargs.get('default_currency', None)
         self.external_id = kwargs.get('external_id', None)
-        self.failure_reason = kwargs.get('failure_reason', None)
         self.id = kwargs.get('id', None)
-        self.processing_end_time = kwargs.get('processing_end_time', None)
-        self.processing_start_time = kwargs.get('processing_start_time', None)
-        self.query_string = kwargs.get('query_string', None)
-        self.scanned_data_in_gb = kwargs.get('scanned_data_in_gb', None)
-        self.scanned_data_limit = kwargs.get('scanned_data_limit', None)
-        self.spaces = kwargs.get('spaces', None)
+        self.identifier = kwargs.get('identifier', None)
+        self.linked_space_id = kwargs.get('linked_space_id', None)
+        self.location_version = kwargs.get('location_version', None)
+        self.name = kwargs.get('name', None)
+        self.planned_purge_date = kwargs.get('planned_purge_date', None)
         self.state = kwargs.get('state', None)
+        self.type = kwargs.get('type', None)
+        self.version = kwargs.get('version', None)
         
 
     
     @property
-    def account(self):
-        """Gets the account of this AnalyticsQueryExecution.
+    def configuration_version(self):
+        """Gets the configuration_version of this PaymentTerminal.
 
-            The account in which the query has been executed.
+            
 
-        :return: The account of this AnalyticsQueryExecution.
-        :rtype: int
+        :return: The configuration_version of this PaymentTerminal.
+        :rtype: PaymentTerminalConfigurationVersion
         """
-        return self._account
+        return self._configuration_version
 
-    @account.setter
-    def account(self, account):
-        """Sets the account of this AnalyticsQueryExecution.
+    @configuration_version.setter
+    def configuration_version(self, configuration_version):
+        """Sets the configuration_version of this PaymentTerminal.
 
-            The account in which the query has been executed.
+            
 
-        :param account: The account of this AnalyticsQueryExecution.
-        :type: int
+        :param configuration_version: The configuration_version of this PaymentTerminal.
+        :type: PaymentTerminalConfigurationVersion
         """
 
-        self._account = account
+        self._configuration_version = configuration_version
     
     @property
-    def error_message(self):
-        """Gets the error_message of this AnalyticsQueryExecution.
+    def default_currency(self):
+        """Gets the default_currency of this PaymentTerminal.
 
-            The error message if and only if the query has failed, otherwise null.
+            
 
-        :return: The error_message of this AnalyticsQueryExecution.
+        :return: The default_currency of this PaymentTerminal.
         :rtype: str
         """
-        return self._error_message
+        return self._default_currency
 
-    @error_message.setter
-    def error_message(self, error_message):
-        """Sets the error_message of this AnalyticsQueryExecution.
+    @default_currency.setter
+    def default_currency(self, default_currency):
+        """Sets the default_currency of this PaymentTerminal.
 
-            The error message if and only if the query has failed, otherwise null.
+            
 
-        :param error_message: The error_message of this AnalyticsQueryExecution.
+        :param default_currency: The default_currency of this PaymentTerminal.
         :type: str
         """
 
-        self._error_message = error_message
+        self._default_currency = default_currency
     
     @property
     def external_id(self):
-        """Gets the external_id of this AnalyticsQueryExecution.
+        """Gets the external_id of this PaymentTerminal.
 
-            The External ID of the query if one had been specified; otherwise null.
+            A client generated nonce which identifies the entity to be created. Subsequent creation requests with the same external ID will not create new entities but return the initially created entity instead.
 
-        :return: The external_id of this AnalyticsQueryExecution.
+        :return: The external_id of this PaymentTerminal.
         :rtype: str
         """
         return self._external_id
 
     @external_id.setter
     def external_id(self, external_id):
-        """Sets the external_id of this AnalyticsQueryExecution.
+        """Sets the external_id of this PaymentTerminal.
 
-            The External ID of the query if one had been specified; otherwise null.
+            A client generated nonce which identifies the entity to be created. Subsequent creation requests with the same external ID will not create new entities but return the initially created entity instead.
 
-        :param external_id: The external_id of this AnalyticsQueryExecution.
+        :param external_id: The external_id of this PaymentTerminal.
         :type: str
         """
 
         self._external_id = external_id
     
     @property
-    def failure_reason(self):
-        """Gets the failure_reason of this AnalyticsQueryExecution.
+    def id(self):
+        """Gets the id of this PaymentTerminal.
 
-            The reason of the failure if and only if the query has failed, otherwise null.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
-        :return: The failure_reason of this AnalyticsQueryExecution.
-        :rtype: FailureReason
+        :return: The id of this PaymentTerminal.
+        :rtype: int
         """
-        return self._failure_reason
+        return self._id
 
-    @failure_reason.setter
-    def failure_reason(self, failure_reason):
-        """Sets the failure_reason of this AnalyticsQueryExecution.
+    @id.setter
+    def id(self, id):
+        """Sets the id of this PaymentTerminal.
 
-            The reason of the failure if and only if the query has failed, otherwise null.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
-        :param failure_reason: The failure_reason of this AnalyticsQueryExecution.
-        :type: FailureReason
+        :param id: The id of this PaymentTerminal.
+        :type: int
         """
 
-        self._failure_reason = failure_reason
+        self._id = id
     
     @property
-    def id(self):
-        """Gets the id of this AnalyticsQueryExecution.
+    def identifier(self):
+        """Gets the identifier of this PaymentTerminal.
 
-            A unique identifier for the object.
+            The identifier uniquely identifies the terminal. Normally it is visible on the device or in the display of the device.
 
-        :return: The id of this AnalyticsQueryExecution.
-        :rtype: int
+        :return: The identifier of this PaymentTerminal.
+        :rtype: str
         """
-        return self._id
+        return self._identifier
 
-    @id.setter
-    def id(self, id):
-        """Sets the id of this AnalyticsQueryExecution.
+    @identifier.setter
+    def identifier(self, identifier):
+        """Sets the identifier of this PaymentTerminal.
 
-            A unique identifier for the object.
+            The identifier uniquely identifies the terminal. Normally it is visible on the device or in the display of the device.
 
-        :param id: The id of this AnalyticsQueryExecution.
-        :type: int
+        :param identifier: The identifier of this PaymentTerminal.
+        :type: str
         """
 
-        self._id = id
+        self._identifier = identifier
     
     @property
-    def processing_end_time(self):
-        """Gets the processing_end_time of this AnalyticsQueryExecution.
+    def linked_space_id(self):
+        """Gets the linked_space_id of this PaymentTerminal.
 
-            The time at which processing of the query has finished (either successfully or by failure or by cancelation). Will be null if the query execution has not finished yet.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
-        :return: The processing_end_time of this AnalyticsQueryExecution.
-        :rtype: datetime
+        :return: The linked_space_id of this PaymentTerminal.
+        :rtype: int
         """
-        return self._processing_end_time
+        return self._linked_space_id
 
-    @processing_end_time.setter
-    def processing_end_time(self, processing_end_time):
-        """Sets the processing_end_time of this AnalyticsQueryExecution.
+    @linked_space_id.setter
+    def linked_space_id(self, linked_space_id):
+        """Sets the linked_space_id of this PaymentTerminal.
 
-            The time at which processing of the query has finished (either successfully or by failure or by cancelation). Will be null if the query execution has not finished yet.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
-        :param processing_end_time: The processing_end_time of this AnalyticsQueryExecution.
-        :type: datetime
+        :param linked_space_id: The linked_space_id of this PaymentTerminal.
+        :type: int
         """
 
-        self._processing_end_time = processing_end_time
+        self._linked_space_id = linked_space_id
     
     @property
-    def processing_start_time(self):
-        """Gets the processing_start_time of this AnalyticsQueryExecution.
+    def location_version(self):
+        """Gets the location_version of this PaymentTerminal.
 
-            The time at which processing of the query has started (never null).
+            
 
-        :return: The processing_start_time of this AnalyticsQueryExecution.
-        :rtype: datetime
+        :return: The location_version of this PaymentTerminal.
+        :rtype: PaymentTerminalLocationVersion
         """
-        return self._processing_start_time
+        return self._location_version
 
-    @processing_start_time.setter
-    def processing_start_time(self, processing_start_time):
-        """Sets the processing_start_time of this AnalyticsQueryExecution.
+    @location_version.setter
+    def location_version(self, location_version):
+        """Sets the location_version of this PaymentTerminal.
 
-            The time at which processing of the query has started (never null).
+            
 
-        :param processing_start_time: The processing_start_time of this AnalyticsQueryExecution.
-        :type: datetime
+        :param location_version: The location_version of this PaymentTerminal.
+        :type: PaymentTerminalLocationVersion
         """
 
-        self._processing_start_time = processing_start_time
+        self._location_version = location_version
     
     @property
-    def query_string(self):
-        """Gets the query_string of this AnalyticsQueryExecution.
+    def name(self):
+        """Gets the name of this PaymentTerminal.
 
-            The SQL statement which has been submitted for execution.
+            The terminal name is used internally to identify the terminal in administrative interfaces. For example it is used within search fields and hence it should be distinct and descriptive.
 
-        :return: The query_string of this AnalyticsQueryExecution.
+        :return: The name of this PaymentTerminal.
         :rtype: str
         """
-        return self._query_string
+        return self._name
 
-    @query_string.setter
-    def query_string(self, query_string):
-        """Sets the query_string of this AnalyticsQueryExecution.
+    @name.setter
+    def name(self, name):
+        """Sets the name of this PaymentTerminal.
 
-            The SQL statement which has been submitted for execution.
+            The terminal name is used internally to identify the terminal in administrative interfaces. For example it is used within search fields and hence it should be distinct and descriptive.
 
-        :param query_string: The query_string of this AnalyticsQueryExecution.
+        :param name: The name of this PaymentTerminal.
         :type: str
         """
+        if name is not None and len(name) > 100:
+            raise ValueError("Invalid value for `name`, length must be less than or equal to `100`")
 
-        self._query_string = query_string
+        self._name = name
     
     @property
-    def scanned_data_in_gb(self):
-        """Gets the scanned_data_in_gb of this AnalyticsQueryExecution.
+    def planned_purge_date(self):
+        """Gets the planned_purge_date of this PaymentTerminal.
 
-            The amount of data scanned while processing the query (in GB). (Note that this amount may increase over time while the query is still being processed and not finished yet.)
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
-        :return: The scanned_data_in_gb of this AnalyticsQueryExecution.
-        :rtype: float
+        :return: The planned_purge_date of this PaymentTerminal.
+        :rtype: datetime
         """
-        return self._scanned_data_in_gb
+        return self._planned_purge_date
 
-    @scanned_data_in_gb.setter
-    def scanned_data_in_gb(self, scanned_data_in_gb):
-        """Sets the scanned_data_in_gb of this AnalyticsQueryExecution.
+    @planned_purge_date.setter
+    def planned_purge_date(self, planned_purge_date):
+        """Sets the planned_purge_date of this PaymentTerminal.
 
-            The amount of data scanned while processing the query (in GB). (Note that this amount may increase over time while the query is still being processed and not finished yet.)
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
-        :param scanned_data_in_gb: The scanned_data_in_gb of this AnalyticsQueryExecution.
-        :type: float
+        :param planned_purge_date: The planned_purge_date of this PaymentTerminal.
+        :type: datetime
         """
 
-        self._scanned_data_in_gb = scanned_data_in_gb
+        self._planned_purge_date = planned_purge_date
     
     @property
-    def scanned_data_limit(self):
-        """Gets the scanned_data_limit of this AnalyticsQueryExecution.
+    def state(self):
+        """Gets the state of this PaymentTerminal.
 
-            The maximal amount of scanned data that this query is allowed to scan. After this limit is reached query will be canceled by the system. 
+            
 
-        :return: The scanned_data_limit of this AnalyticsQueryExecution.
-        :rtype: float
+        :return: The state of this PaymentTerminal.
+        :rtype: PaymentTerminalState
         """
-        return self._scanned_data_limit
+        return self._state
 
-    @scanned_data_limit.setter
-    def scanned_data_limit(self, scanned_data_limit):
-        """Sets the scanned_data_limit of this AnalyticsQueryExecution.
+    @state.setter
+    def state(self, state):
+        """Sets the state of this PaymentTerminal.
 
-            The maximal amount of scanned data that this query is allowed to scan. After this limit is reached query will be canceled by the system. 
+            
 
-        :param scanned_data_limit: The scanned_data_limit of this AnalyticsQueryExecution.
-        :type: float
+        :param state: The state of this PaymentTerminal.
+        :type: PaymentTerminalState
         """
 
-        self._scanned_data_limit = scanned_data_limit
+        self._state = state
     
     @property
-    def spaces(self):
-        """Gets the spaces of this AnalyticsQueryExecution.
+    def type(self):
+        """Gets the type of this PaymentTerminal.
 
-            The spaces in which the query has been executed. May be empty if all spaces of the specified account have been queried.
+            
 
-        :return: The spaces of this AnalyticsQueryExecution.
-        :rtype: list[int]
+        :return: The type of this PaymentTerminal.
+        :rtype: PaymentTerminalType
         """
-        return self._spaces
+        return self._type
 
-    @spaces.setter
-    def spaces(self, spaces):
-        """Sets the spaces of this AnalyticsQueryExecution.
+    @type.setter
+    def type(self, type):
+        """Sets the type of this PaymentTerminal.
 
-            The spaces in which the query has been executed. May be empty if all spaces of the specified account have been queried.
+            
 
-        :param spaces: The spaces of this AnalyticsQueryExecution.
-        :type: list[int]
+        :param type: The type of this PaymentTerminal.
+        :type: PaymentTerminalType
         """
 
-        self._spaces = spaces
+        self._type = type
     
     @property
-    def state(self):
-        """Gets the state of this AnalyticsQueryExecution.
+    def version(self):
+        """Gets the version of this PaymentTerminal.
 
-            The current state of the query execution.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
-        :return: The state of this AnalyticsQueryExecution.
-        :rtype: AnalyticsQueryExecutionState
+        :return: The version of this PaymentTerminal.
+        :rtype: int
         """
-        return self._state
+        return self._version
 
-    @state.setter
-    def state(self, state):
-        """Sets the state of this AnalyticsQueryExecution.
+    @version.setter
+    def version(self, version):
+        """Sets the version of this PaymentTerminal.
 
-            The current state of the query execution.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
-        :param state: The state of this AnalyticsQueryExecution.
-        :type: AnalyticsQueryExecutionState
+        :param version: The version of this PaymentTerminal.
+        :type: int
         """
 
-        self._state = state
+        self._version = version
     
 
     def to_dict(self):
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
@@ -354,27 +356,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(AnalyticsQueryExecution, dict):
+        if issubclass(PaymentTerminal, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, AnalyticsQueryExecution):
+        if not isinstance(other, PaymentTerminal):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/analytics_query_result_batch.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/user_space_role.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,135 +1,161 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
 
 
 
-class AnalyticsQueryResultBatch:
+class UserSpaceRole:
 
     swagger_types = {
     
-        'columns': 'list[AnalyticsSchemaColumn]',
-        'next_token': 'str',
-        'query_execution': 'AnalyticsQueryExecution',
-        'rows': 'list[list[str]]',
+        'id': 'int',
+        'role': 'int',
+        'space': 'int',
+        'user': 'int',
+        'version': 'int',
     }
 
     attribute_map = {
-        'columns': 'columns','next_token': 'nextToken','query_execution': 'queryExecution','rows': 'rows',
+        'id': 'id','role': 'role','space': 'space','user': 'user','version': 'version',
     }
 
     
-    _columns = None
-    _next_token = None
-    _query_execution = None
-    _rows = None
+    _id = None
+    _role = None
+    _space = None
+    _user = None
+    _version = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
-        self.columns = kwargs.get('columns', None)
-        self.next_token = kwargs.get('next_token', None)
-        self.query_execution = kwargs.get('query_execution', None)
-        self.rows = kwargs.get('rows', None)
+        self.id = kwargs.get('id', None)
+        self.role = kwargs.get('role', None)
+        self.space = kwargs.get('space', None)
+        self.user = kwargs.get('user', None)
+        self.version = kwargs.get('version', None)
         
 
     
     @property
-    def columns(self):
-        """Gets the columns of this AnalyticsQueryResultBatch.
+    def id(self):
+        """Gets the id of this UserSpaceRole.
 
-            The schemas of the columns returned by the query (in order). Will be null if the results of the query are not (yet) available.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
-        :return: The columns of this AnalyticsQueryResultBatch.
-        :rtype: list[AnalyticsSchemaColumn]
+        :return: The id of this UserSpaceRole.
+        :rtype: int
         """
-        return self._columns
+        return self._id
 
-    @columns.setter
-    def columns(self, columns):
-        """Sets the columns of this AnalyticsQueryResultBatch.
+    @id.setter
+    def id(self, id):
+        """Sets the id of this UserSpaceRole.
 
-            The schemas of the columns returned by the query (in order). Will be null if the results of the query are not (yet) available.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
-        :param columns: The columns of this AnalyticsQueryResultBatch.
-        :type: list[AnalyticsSchemaColumn]
+        :param id: The id of this UserSpaceRole.
+        :type: int
         """
 
-        self._columns = columns
+        self._id = id
     
     @property
-    def next_token(self):
-        """Gets the next_token of this AnalyticsQueryResultBatch.
+    def role(self):
+        """Gets the role of this UserSpaceRole.
 
-            The token to be provided to fetch the next batch of results. May be null if no more result batches are available.
+            
 
-        :return: The next_token of this AnalyticsQueryResultBatch.
-        :rtype: str
+        :return: The role of this UserSpaceRole.
+        :rtype: int
         """
-        return self._next_token
+        return self._role
 
-    @next_token.setter
-    def next_token(self, next_token):
-        """Sets the next_token of this AnalyticsQueryResultBatch.
+    @role.setter
+    def role(self, role):
+        """Sets the role of this UserSpaceRole.
 
-            The token to be provided to fetch the next batch of results. May be null if no more result batches are available.
+            
 
-        :param next_token: The next_token of this AnalyticsQueryResultBatch.
-        :type: str
+        :param role: The role of this UserSpaceRole.
+        :type: int
         """
 
-        self._next_token = next_token
+        self._role = role
     
     @property
-    def query_execution(self):
-        """Gets the query_execution of this AnalyticsQueryResultBatch.
+    def space(self):
+        """Gets the space of this UserSpaceRole.
 
-            The query execution which produced the result.
+            
 
-        :return: The query_execution of this AnalyticsQueryResultBatch.
-        :rtype: AnalyticsQueryExecution
+        :return: The space of this UserSpaceRole.
+        :rtype: int
         """
-        return self._query_execution
+        return self._space
 
-    @query_execution.setter
-    def query_execution(self, query_execution):
-        """Sets the query_execution of this AnalyticsQueryResultBatch.
+    @space.setter
+    def space(self, space):
+        """Sets the space of this UserSpaceRole.
 
-            The query execution which produced the result.
+            
 
-        :param query_execution: The query_execution of this AnalyticsQueryResultBatch.
-        :type: AnalyticsQueryExecution
+        :param space: The space of this UserSpaceRole.
+        :type: int
         """
 
-        self._query_execution = query_execution
+        self._space = space
     
     @property
-    def rows(self):
-        """Gets the rows of this AnalyticsQueryResultBatch.
+    def user(self):
+        """Gets the user of this UserSpaceRole.
 
-            The rows of the result set contained in this batch where each row is a list of column values (in order of the columns specified in the query). Will be null if the results of the query are not (yet) available.
+            
 
-        :return: The rows of this AnalyticsQueryResultBatch.
-        :rtype: list[list[str]]
+        :return: The user of this UserSpaceRole.
+        :rtype: int
         """
-        return self._rows
+        return self._user
 
-    @rows.setter
-    def rows(self, rows):
-        """Sets the rows of this AnalyticsQueryResultBatch.
+    @user.setter
+    def user(self, user):
+        """Sets the user of this UserSpaceRole.
 
-            The rows of the result set contained in this batch where each row is a list of column values (in order of the columns specified in the query). Will be null if the results of the query are not (yet) available.
+            
 
-        :param rows: The rows of this AnalyticsQueryResultBatch.
-        :type: list[list[str]]
+        :param user: The user of this UserSpaceRole.
+        :type: int
         """
 
-        self._rows = rows
+        self._user = user
+    
+    @property
+    def version(self):
+        """Gets the version of this UserSpaceRole.
+
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
+
+        :return: The version of this UserSpaceRole.
+        :rtype: int
+        """
+        return self._version
+
+    @version.setter
+    def version(self, version):
+        """Sets the version of this UserSpaceRole.
+
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
+
+        :param version: The version of this UserSpaceRole.
+        :type: int
+        """
+
+        self._version = version
     
 
     def to_dict(self):
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
@@ -146,27 +172,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(AnalyticsQueryResultBatch, dict):
+        if issubclass(UserSpaceRole, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, AnalyticsQueryResultBatch):
+        if not isinstance(other, UserSpaceRole):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/analytics_schema_column.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/product_metered_fee.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,240 +1,266 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
 
 
 
-class AnalyticsSchemaColumn:
+class ProductMeteredFee:
 
     swagger_types = {
     
-        'alias_name': 'str',
-        'column_name': 'str',
-        'description': 'dict(str, str)',
-        'precision': 'int',
-        'referenced_table': 'str',
-        'scale': 'int',
-        'table_name': 'str',
-        'type': 'str',
+        'component': 'SubscriptionProductComponent',
+        'description': 'DatabaseTranslatedString',
+        'id': 'int',
+        'linked_space_id': 'int',
+        'metric': 'SubscriptionMetric',
+        'name': 'DatabaseTranslatedString',
+        'tier_pricing': 'ProductMeteredTierPricing',
+        'type': 'ProductFeeType',
+        'version': 'int',
     }
 
     attribute_map = {
-        'alias_name': 'aliasName','column_name': 'columnName','description': 'description','precision': 'precision','referenced_table': 'referencedTable','scale': 'scale','table_name': 'tableName','type': 'type',
+        'component': 'component','description': 'description','id': 'id','linked_space_id': 'linkedSpaceId','metric': 'metric','name': 'name','tier_pricing': 'tierPricing','type': 'type','version': 'version',
     }
 
     
-    _alias_name = None
-    _column_name = None
+    _component = None
     _description = None
-    _precision = None
-    _referenced_table = None
-    _scale = None
-    _table_name = None
+    _id = None
+    _linked_space_id = None
+    _metric = None
+    _name = None
+    _tier_pricing = None
     _type = None
+    _version = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
-        self.alias_name = kwargs.get('alias_name', None)
-        self.column_name = kwargs.get('column_name', None)
+        self.component = kwargs.get('component', None)
         self.description = kwargs.get('description', None)
-        self.precision = kwargs.get('precision', None)
-        self.referenced_table = kwargs.get('referenced_table', None)
-        self.scale = kwargs.get('scale', None)
-        self.table_name = kwargs.get('table_name', None)
+        self.id = kwargs.get('id', None)
+        self.linked_space_id = kwargs.get('linked_space_id', None)
+        self.metric = kwargs.get('metric', None)
+        self.name = kwargs.get('name', None)
+        self.tier_pricing = kwargs.get('tier_pricing', None)
         self.type = kwargs.get('type', None)
+        self.version = kwargs.get('version', None)
         
 
     
     @property
-    def alias_name(self):
-        """Gets the alias_name of this AnalyticsSchemaColumn.
+    def component(self):
+        """Gets the component of this ProductMeteredFee.
 
-            The name of the alias defined for the column in the query or null if none is defined.
+            
 
-        :return: The alias_name of this AnalyticsSchemaColumn.
-        :rtype: str
+        :return: The component of this ProductMeteredFee.
+        :rtype: SubscriptionProductComponent
         """
-        return self._alias_name
+        return self._component
 
-    @alias_name.setter
-    def alias_name(self, alias_name):
-        """Sets the alias_name of this AnalyticsSchemaColumn.
+    @component.setter
+    def component(self, component):
+        """Sets the component of this ProductMeteredFee.
 
-            The name of the alias defined for the column in the query or null if none is defined.
+            
 
-        :param alias_name: The alias_name of this AnalyticsSchemaColumn.
-        :type: str
+        :param component: The component of this ProductMeteredFee.
+        :type: SubscriptionProductComponent
         """
 
-        self._alias_name = alias_name
+        self._component = component
     
     @property
-    def column_name(self):
-        """Gets the column_name of this AnalyticsSchemaColumn.
+    def description(self):
+        """Gets the description of this ProductMeteredFee.
 
-            The name of the column in the table or null if this is a synthetic column which is the result of some SQL expression.
+            The description of a component fee describes the fee to the subscriber. The description may be shown in documents or on certain user interfaces.
 
-        :return: The column_name of this AnalyticsSchemaColumn.
-        :rtype: str
+        :return: The description of this ProductMeteredFee.
+        :rtype: DatabaseTranslatedString
         """
-        return self._column_name
+        return self._description
 
-    @column_name.setter
-    def column_name(self, column_name):
-        """Sets the column_name of this AnalyticsSchemaColumn.
+    @description.setter
+    def description(self, description):
+        """Sets the description of this ProductMeteredFee.
 
-            The name of the column in the table or null if this is a synthetic column which is the result of some SQL expression.
+            The description of a component fee describes the fee to the subscriber. The description may be shown in documents or on certain user interfaces.
 
-        :param column_name: The column_name of this AnalyticsSchemaColumn.
-        :type: str
+        :param description: The description of this ProductMeteredFee.
+        :type: DatabaseTranslatedString
         """
 
-        self._column_name = column_name
+        self._description = description
     
     @property
-    def description(self):
-        """Gets the description of this AnalyticsSchemaColumn.
+    def id(self):
+        """Gets the id of this ProductMeteredFee.
 
-            A human readable description of the property contained in this column or null if this is a synthetic column which is the result of some SQL expression.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
-        :return: The description of this AnalyticsSchemaColumn.
-        :rtype: dict(str, str)
+        :return: The id of this ProductMeteredFee.
+        :rtype: int
         """
-        return self._description
+        return self._id
 
-    @description.setter
-    def description(self, description):
-        """Sets the description of this AnalyticsSchemaColumn.
+    @id.setter
+    def id(self, id):
+        """Sets the id of this ProductMeteredFee.
 
-            A human readable description of the property contained in this column or null if this is a synthetic column which is the result of some SQL expression.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
-        :param description: The description of this AnalyticsSchemaColumn.
-        :type: dict(str, str)
+        :param id: The id of this ProductMeteredFee.
+        :type: int
         """
 
-        self._description = description
+        self._id = id
     
     @property
-    def precision(self):
-        """Gets the precision of this AnalyticsSchemaColumn.
+    def linked_space_id(self):
+        """Gets the linked_space_id of this ProductMeteredFee.
 
-            The precision (maximal number of digits) for decimal data types, otherwise 0.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
-        :return: The precision of this AnalyticsSchemaColumn.
+        :return: The linked_space_id of this ProductMeteredFee.
         :rtype: int
         """
-        return self._precision
+        return self._linked_space_id
 
-    @precision.setter
-    def precision(self, precision):
-        """Sets the precision of this AnalyticsSchemaColumn.
+    @linked_space_id.setter
+    def linked_space_id(self, linked_space_id):
+        """Sets the linked_space_id of this ProductMeteredFee.
 
-            The precision (maximal number of digits) for decimal data types, otherwise 0.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
-        :param precision: The precision of this AnalyticsSchemaColumn.
+        :param linked_space_id: The linked_space_id of this ProductMeteredFee.
         :type: int
         """
 
-        self._precision = precision
+        self._linked_space_id = linked_space_id
     
     @property
-    def referenced_table(self):
-        """Gets the referenced_table of this AnalyticsSchemaColumn.
+    def metric(self):
+        """Gets the metric of this ProductMeteredFee.
 
-            The name of the referenced table if this column represents a foreign-key relation to the IDs of another table, otherwise null.
+            
 
-        :return: The referenced_table of this AnalyticsSchemaColumn.
-        :rtype: str
+        :return: The metric of this ProductMeteredFee.
+        :rtype: SubscriptionMetric
         """
-        return self._referenced_table
+        return self._metric
 
-    @referenced_table.setter
-    def referenced_table(self, referenced_table):
-        """Sets the referenced_table of this AnalyticsSchemaColumn.
+    @metric.setter
+    def metric(self, metric):
+        """Sets the metric of this ProductMeteredFee.
 
-            The name of the referenced table if this column represents a foreign-key relation to the IDs of another table, otherwise null.
+            
 
-        :param referenced_table: The referenced_table of this AnalyticsSchemaColumn.
-        :type: str
+        :param metric: The metric of this ProductMeteredFee.
+        :type: SubscriptionMetric
         """
 
-        self._referenced_table = referenced_table
+        self._metric = metric
     
     @property
-    def scale(self):
-        """Gets the scale of this AnalyticsSchemaColumn.
+    def name(self):
+        """Gets the name of this ProductMeteredFee.
 
-            The scale (maximal number number of digits in the fractional part) in case of a decimal data type, otherwise 0.
+            The name of the fee should describe for the subscriber in few words for what the fee is for.
 
-        :return: The scale of this AnalyticsSchemaColumn.
-        :rtype: int
+        :return: The name of this ProductMeteredFee.
+        :rtype: DatabaseTranslatedString
         """
-        return self._scale
+        return self._name
 
-    @scale.setter
-    def scale(self, scale):
-        """Sets the scale of this AnalyticsSchemaColumn.
+    @name.setter
+    def name(self, name):
+        """Sets the name of this ProductMeteredFee.
 
-            The scale (maximal number number of digits in the fractional part) in case of a decimal data type, otherwise 0.
+            The name of the fee should describe for the subscriber in few words for what the fee is for.
 
-        :param scale: The scale of this AnalyticsSchemaColumn.
-        :type: int
+        :param name: The name of this ProductMeteredFee.
+        :type: DatabaseTranslatedString
         """
 
-        self._scale = scale
+        self._name = name
     
     @property
-    def table_name(self):
-        """Gets the table_name of this AnalyticsSchemaColumn.
+    def tier_pricing(self):
+        """Gets the tier_pricing of this ProductMeteredFee.
 
-            The name of the table which defines this column.
+            The tier pricing determines the calculation method of the tiers. The prices of the different tiers can be applied in different ways. The tier pricing controls this calculation.
 
-        :return: The table_name of this AnalyticsSchemaColumn.
-        :rtype: str
+        :return: The tier_pricing of this ProductMeteredFee.
+        :rtype: ProductMeteredTierPricing
         """
-        return self._table_name
+        return self._tier_pricing
 
-    @table_name.setter
-    def table_name(self, table_name):
-        """Sets the table_name of this AnalyticsSchemaColumn.
+    @tier_pricing.setter
+    def tier_pricing(self, tier_pricing):
+        """Sets the tier_pricing of this ProductMeteredFee.
 
-            The name of the table which defines this column.
+            The tier pricing determines the calculation method of the tiers. The prices of the different tiers can be applied in different ways. The tier pricing controls this calculation.
 
-        :param table_name: The table_name of this AnalyticsSchemaColumn.
-        :type: str
+        :param tier_pricing: The tier_pricing of this ProductMeteredFee.
+        :type: ProductMeteredTierPricing
         """
 
-        self._table_name = table_name
+        self._tier_pricing = tier_pricing
     
     @property
     def type(self):
-        """Gets the type of this AnalyticsSchemaColumn.
+        """Gets the type of this ProductMeteredFee.
 
-            The ORC data type of the column value.
+            
 
-        :return: The type of this AnalyticsSchemaColumn.
-        :rtype: str
+        :return: The type of this ProductMeteredFee.
+        :rtype: ProductFeeType
         """
         return self._type
 
     @type.setter
     def type(self, type):
-        """Sets the type of this AnalyticsSchemaColumn.
+        """Sets the type of this ProductMeteredFee.
 
-            The ORC data type of the column value.
+            
 
-        :param type: The type of this AnalyticsSchemaColumn.
-        :type: str
+        :param type: The type of this ProductMeteredFee.
+        :type: ProductFeeType
         """
 
         self._type = type
     
+    @property
+    def version(self):
+        """Gets the version of this ProductMeteredFee.
+
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
+
+        :return: The version of this ProductMeteredFee.
+        :rtype: int
+        """
+        return self._version
+
+    @version.setter
+    def version(self, version):
+        """Sets the version of this ProductMeteredFee.
+
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
+
+        :param version: The version of this ProductMeteredFee.
+        :type: int
+        """
+
+        self._version = version
+    
 
     def to_dict(self):
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
@@ -250,27 +276,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(AnalyticsSchemaColumn, dict):
+        if issubclass(ProductMeteredFee, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, AnalyticsSchemaColumn):
+        if not isinstance(other, ProductMeteredFee):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/analytics_schema_table.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/debt_collection_receipt_source.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,109 +1,109 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
 
 
 
-class AnalyticsSchemaTable:
+class DebtCollectionReceiptSource:
 
     swagger_types = {
     
-        'columns': 'list[AnalyticsSchemaColumn]',
         'description': 'dict(str, str)',
-        'table_name': 'str',
+        'id': 'int',
+        'name': 'dict(str, str)',
     }
 
     attribute_map = {
-        'columns': 'columns','description': 'description','table_name': 'tableName',
+        'description': 'description','id': 'id','name': 'name',
     }
 
     
-    _columns = None
     _description = None
-    _table_name = None
+    _id = None
+    _name = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
-        self.columns = kwargs.get('columns', None)
         self.description = kwargs.get('description', None)
-        self.table_name = kwargs.get('table_name', None)
+        self.id = kwargs.get('id', None)
+        self.name = kwargs.get('name', None)
         
 
     
     @property
-    def columns(self):
-        """Gets the columns of this AnalyticsSchemaTable.
+    def description(self):
+        """Gets the description of this DebtCollectionReceiptSource.
 
-            The schemas of all columns of this table.
+            
 
-        :return: The columns of this AnalyticsSchemaTable.
-        :rtype: list[AnalyticsSchemaColumn]
+        :return: The description of this DebtCollectionReceiptSource.
+        :rtype: dict(str, str)
         """
-        return self._columns
+        return self._description
 
-    @columns.setter
-    def columns(self, columns):
-        """Sets the columns of this AnalyticsSchemaTable.
+    @description.setter
+    def description(self, description):
+        """Sets the description of this DebtCollectionReceiptSource.
 
-            The schemas of all columns of this table.
+            
 
-        :param columns: The columns of this AnalyticsSchemaTable.
-        :type: list[AnalyticsSchemaColumn]
+        :param description: The description of this DebtCollectionReceiptSource.
+        :type: dict(str, str)
         """
 
-        self._columns = columns
+        self._description = description
     
     @property
-    def description(self):
-        """Gets the description of this AnalyticsSchemaTable.
+    def id(self):
+        """Gets the id of this DebtCollectionReceiptSource.
 
-            A human readable description of the entity type contained in this table.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
-        :return: The description of this AnalyticsSchemaTable.
-        :rtype: dict(str, str)
+        :return: The id of this DebtCollectionReceiptSource.
+        :rtype: int
         """
-        return self._description
+        return self._id
 
-    @description.setter
-    def description(self, description):
-        """Sets the description of this AnalyticsSchemaTable.
+    @id.setter
+    def id(self, id):
+        """Sets the id of this DebtCollectionReceiptSource.
 
-            A human readable description of the entity type contained in this table.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
-        :param description: The description of this AnalyticsSchemaTable.
-        :type: dict(str, str)
+        :param id: The id of this DebtCollectionReceiptSource.
+        :type: int
         """
 
-        self._description = description
+        self._id = id
     
     @property
-    def table_name(self):
-        """Gets the table_name of this AnalyticsSchemaTable.
+    def name(self):
+        """Gets the name of this DebtCollectionReceiptSource.
 
-            The name of this table.
+            
 
-        :return: The table_name of this AnalyticsSchemaTable.
-        :rtype: str
+        :return: The name of this DebtCollectionReceiptSource.
+        :rtype: dict(str, str)
         """
-        return self._table_name
+        return self._name
 
-    @table_name.setter
-    def table_name(self, table_name):
-        """Sets the table_name of this AnalyticsSchemaTable.
+    @name.setter
+    def name(self, name):
+        """Sets the name of this DebtCollectionReceiptSource.
 
-            The name of this table.
+            
 
-        :param table_name: The table_name of this AnalyticsSchemaTable.
-        :type: str
+        :param name: The name of this DebtCollectionReceiptSource.
+        :type: dict(str, str)
         """
 
-        self._table_name = table_name
+        self._name = name
     
 
     def to_dict(self):
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
@@ -120,27 +120,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(AnalyticsSchemaTable, dict):
+        if issubclass(DebtCollectionReceiptSource, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, AnalyticsSchemaTable):
+        if not isinstance(other, DebtCollectionReceiptSource):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/application_user.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/application_user.py`

 * *Files 19% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 
 
 class ApplicationUser(User):
 
     swagger_types = {
     
         'name': 'str',
-        'primary_account': 'int',
+        'primary_account': 'Account',
         'request_limit': 'int',
     }
 
     attribute_map = {
         'name': 'name','primary_account': 'primaryAccount','request_limit': 'requestLimit',
     }
 
@@ -34,74 +34,74 @@
         self.attribute_map.update(super().attribute_map)
 
     
     @property
     def name(self):
         """Gets the name of this ApplicationUser.
 
-            The name used to identify the application user.
+            The user name is used to identify the application user in administrative interfaces.
 
         :return: The name of this ApplicationUser.
         :rtype: str
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this ApplicationUser.
 
-            The name used to identify the application user.
+            The user name is used to identify the application user in administrative interfaces.
 
         :param name: The name of this ApplicationUser.
         :type: str
         """
         if name is not None and len(name) > 256:
             raise ValueError("Invalid value for `name`, length must be less than or equal to `256`")
 
         self._name = name
     
     @property
     def primary_account(self):
         """Gets the primary_account of this ApplicationUser.
 
-            The primary account that the user belongs to.
+            The account that this user is associated with. The account owner will be able to manage this user.
 
         :return: The primary_account of this ApplicationUser.
-        :rtype: int
+        :rtype: Account
         """
         return self._primary_account
 
     @primary_account.setter
     def primary_account(self, primary_account):
         """Sets the primary_account of this ApplicationUser.
 
-            The primary account that the user belongs to.
+            The account that this user is associated with. The account owner will be able to manage this user.
 
         :param primary_account: The primary_account of this ApplicationUser.
-        :type: int
+        :type: Account
         """
 
         self._primary_account = primary_account
     
     @property
     def request_limit(self):
         """Gets the request_limit of this ApplicationUser.
 
-            The maximum number of API requests that are accepted every 2 minutes.
+            The request limit defines the maximum number of API request accepted within 2 minutes. This limit can only be changed with special privileges.
 
         :return: The request_limit of this ApplicationUser.
         :rtype: int
         """
         return self._request_limit
 
     @request_limit.setter
     def request_limit(self, request_limit):
         """Sets the request_limit of this ApplicationUser.
 
-            The maximum number of API requests that are accepted every 2 minutes.
+            The request limit defines the maximum number of API request accepted within 2 minutes. This limit can only be changed with special privileges.
 
         :param request_limit: The request_limit of this ApplicationUser.
         :type: int
         """
 
         self._request_limit = request_limit
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/application_user_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/human_user_create.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
-from . import AbstractApplicationUserUpdate
+from . import AbstractHumanUserUpdate
 
 
-class ApplicationUserCreate(AbstractApplicationUserUpdate):
+class HumanUserCreate(AbstractHumanUserUpdate):
 
     swagger_types = {
     
         'primary_account': 'int',
     }
 
     attribute_map = {
@@ -18,43 +18,40 @@
 
     
     _primary_account = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
-        self.primary_account = kwargs.get('primary_account')
-
+        self.primary_account = kwargs.get('primary_account', None)
         super().__init__(**kwargs)
         self.swagger_types.update(super().swagger_types)
         self.attribute_map.update(super().attribute_map)
 
     
     @property
     def primary_account(self):
-        """Gets the primary_account of this ApplicationUserCreate.
+        """Gets the primary_account of this HumanUserCreate.
 
-            The primary account that the user belongs to.
+            The primary account links the user to a specific account.
 
-        :return: The primary_account of this ApplicationUserCreate.
+        :return: The primary_account of this HumanUserCreate.
         :rtype: int
         """
         return self._primary_account
 
     @primary_account.setter
     def primary_account(self, primary_account):
-        """Sets the primary_account of this ApplicationUserCreate.
+        """Sets the primary_account of this HumanUserCreate.
 
-            The primary account that the user belongs to.
+            The primary account links the user to a specific account.
 
-        :param primary_account: The primary_account of this ApplicationUserCreate.
+        :param primary_account: The primary_account of this HumanUserCreate.
         :type: int
         """
-        if primary_account is None:
-            raise ValueError("Invalid value for `primary_account`, must not be `None`")
 
         self._primary_account = primary_account
     
 
     def to_dict(self):
         result = {}
 
@@ -73,27 +70,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(ApplicationUserCreate, dict):
+        if issubclass(HumanUserCreate, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, ApplicationUserCreate):
+        if not isinstance(other, HumanUserCreate):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/application_user_create_with_mac_key.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/application_user_create_with_mac_key.py`

 * *Files 16% similar despite different names*

```diff
@@ -28,26 +28,26 @@
         self.attribute_map.update(super().attribute_map)
 
     
     @property
     def mac_key(self):
         """Gets the mac_key of this ApplicationUserCreateWithMacKey.
 
-            The user's authentication key securing requests. Only displayed a single time after the user has been created.
+            
 
         :return: The mac_key of this ApplicationUserCreateWithMacKey.
         :rtype: str
         """
         return self._mac_key
 
     @mac_key.setter
     def mac_key(self, mac_key):
         """Sets the mac_key of this ApplicationUserCreateWithMacKey.
 
-            The user's authentication key securing requests. Only displayed a single time after the user has been created.
+            
 
         :param mac_key: The mac_key of this ApplicationUserCreateWithMacKey.
         :type: str
         """
 
         self._mac_key = mac_key
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/application_user_update.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/application_user_update.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/authenticated_card_data.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/authenticated_card_data.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/authenticated_card_data_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/authenticated_card_data_create.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/bank_account.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/bank_account.py`

 * *Files 15% similar despite different names*

```diff
@@ -72,26 +72,26 @@
 
         self._description = description
     
     @property
     def id(self):
         """Gets the id of this BankAccount.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this BankAccount.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this BankAccount.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this BankAccount.
         :type: int
         """
 
         self._id = id
     
@@ -120,72 +120,72 @@
 
         self._identifier = identifier
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this BankAccount.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this BankAccount.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this BankAccount.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this BankAccount.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this BankAccount.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this BankAccount.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this BankAccount.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this BankAccount.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
     @property
     def state(self):
         """Gets the state of this BankAccount.
 
-            The object's current state.
+            
 
         :return: The state of this BankAccount.
         :rtype: BankAccountState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this BankAccount.
 
-            The object's current state.
+            
 
         :param state: The state of this BankAccount.
         :type: BankAccountState
         """
 
         self._state = state
     
@@ -212,26 +212,26 @@
 
         self._type = type
     
     @property
     def version(self):
         """Gets the version of this BankAccount.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this BankAccount.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this BankAccount.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this BankAccount.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/bank_account_type.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/bank_account_type.py`

 * *Files 8% similar despite different names*

```diff
@@ -35,49 +35,49 @@
         
 
     
     @property
     def description(self):
         """Gets the description of this BankAccountType.
 
-            The localized description of the object.
+            
 
         :return: The description of this BankAccountType.
         :rtype: dict(str, str)
         """
         return self._description
 
     @description.setter
     def description(self, description):
         """Sets the description of this BankAccountType.
 
-            The localized description of the object.
+            
 
         :param description: The description of this BankAccountType.
         :type: dict(str, str)
         """
 
         self._description = description
     
     @property
     def id(self):
         """Gets the id of this BankAccountType.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this BankAccountType.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this BankAccountType.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this BankAccountType.
         :type: int
         """
 
         self._id = id
     
@@ -104,26 +104,26 @@
 
         self._identifier_name = identifier_name
     
     @property
     def name(self):
         """Gets the name of this BankAccountType.
 
-            The localized name of the object.
+            
 
         :return: The name of this BankAccountType.
         :rtype: dict(str, str)
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this BankAccountType.
 
-            The localized name of the object.
+            
 
         :param name: The name of this BankAccountType.
         :type: dict(str, str)
         """
 
         self._name = name
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/bank_transaction.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/bank_transaction.py`

 * *Files 5% similar despite different names*

```diff
@@ -123,26 +123,26 @@
 
         self._created_by = created_by
     
     @property
     def created_on(self):
         """Gets the created_on of this BankTransaction.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :return: The created_on of this BankTransaction.
         :rtype: datetime
         """
         return self._created_on
 
     @created_on.setter
     def created_on(self, created_on):
         """Sets the created_on of this BankTransaction.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :param created_on: The created_on of this BankTransaction.
         :type: datetime
         """
 
         self._created_on = created_on
     
@@ -219,72 +219,72 @@
 
         self._flow_direction = flow_direction
     
     @property
     def id(self):
         """Gets the id of this BankTransaction.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this BankTransaction.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this BankTransaction.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this BankTransaction.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this BankTransaction.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this BankTransaction.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this BankTransaction.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this BankTransaction.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this BankTransaction.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this BankTransaction.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this BankTransaction.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this BankTransaction.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -357,26 +357,26 @@
 
         self._source = source
     
     @property
     def state(self):
         """Gets the state of this BankTransaction.
 
-            The object's current state.
+            
 
         :return: The state of this BankTransaction.
         :rtype: BankTransactionState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this BankTransaction.
 
-            The object's current state.
+            
 
         :param state: The state of this BankTransaction.
         :type: BankTransactionState
         """
 
         self._state = state
     
@@ -472,26 +472,26 @@
 
         self._value_date = value_date
     
     @property
     def version(self):
         """Gets the version of this BankTransaction.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this BankTransaction.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this BankTransaction.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this BankTransaction.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/bank_transaction_source.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/bank_transaction_source.py`

 * *Files 11% similar despite different names*

```diff
@@ -32,72 +32,72 @@
         
 
     
     @property
     def description(self):
         """Gets the description of this BankTransactionSource.
 
-            The localized description of the object.
+            
 
         :return: The description of this BankTransactionSource.
         :rtype: dict(str, str)
         """
         return self._description
 
     @description.setter
     def description(self, description):
         """Sets the description of this BankTransactionSource.
 
-            The localized description of the object.
+            
 
         :param description: The description of this BankTransactionSource.
         :type: dict(str, str)
         """
 
         self._description = description
     
     @property
     def id(self):
         """Gets the id of this BankTransactionSource.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this BankTransactionSource.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this BankTransactionSource.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this BankTransactionSource.
         :type: int
         """
 
         self._id = id
     
     @property
     def name(self):
         """Gets the name of this BankTransactionSource.
 
-            The localized name of the object.
+            
 
         :return: The name of this BankTransactionSource.
         :rtype: dict(str, str)
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this BankTransactionSource.
 
-            The localized name of the object.
+            
 
         :param name: The name of this BankTransactionSource.
         :type: dict(str, str)
         """
 
         self._name = name
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/bank_transaction_type.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_terminal_type.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
 
 
 
-class BankTransactionType:
+class PaymentTerminalType:
 
     swagger_types = {
     
         'description': 'dict(str, str)',
         'id': 'int',
         'name': 'dict(str, str)',
     }
@@ -30,76 +30,76 @@
         self.id = kwargs.get('id', None)
         self.name = kwargs.get('name', None)
         
 
     
     @property
     def description(self):
-        """Gets the description of this BankTransactionType.
+        """Gets the description of this PaymentTerminalType.
 
-            The localized description of the object.
+            
 
-        :return: The description of this BankTransactionType.
+        :return: The description of this PaymentTerminalType.
         :rtype: dict(str, str)
         """
         return self._description
 
     @description.setter
     def description(self, description):
-        """Sets the description of this BankTransactionType.
+        """Sets the description of this PaymentTerminalType.
 
-            The localized description of the object.
+            
 
-        :param description: The description of this BankTransactionType.
+        :param description: The description of this PaymentTerminalType.
         :type: dict(str, str)
         """
 
         self._description = description
     
     @property
     def id(self):
-        """Gets the id of this BankTransactionType.
+        """Gets the id of this PaymentTerminalType.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
-        :return: The id of this BankTransactionType.
+        :return: The id of this PaymentTerminalType.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
-        """Sets the id of this BankTransactionType.
+        """Sets the id of this PaymentTerminalType.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
-        :param id: The id of this BankTransactionType.
+        :param id: The id of this PaymentTerminalType.
         :type: int
         """
 
         self._id = id
     
     @property
     def name(self):
-        """Gets the name of this BankTransactionType.
+        """Gets the name of this PaymentTerminalType.
 
-            The localized name of the object.
+            
 
-        :return: The name of this BankTransactionType.
+        :return: The name of this PaymentTerminalType.
         :rtype: dict(str, str)
         """
         return self._name
 
     @name.setter
     def name(self, name):
-        """Sets the name of this BankTransactionType.
+        """Sets the name of this PaymentTerminalType.
 
-            The localized name of the object.
+            
 
-        :param name: The name of this BankTransactionType.
+        :param name: The name of this PaymentTerminalType.
         :type: dict(str, str)
         """
 
         self._name = name
     
 
     def to_dict(self):
@@ -120,27 +120,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(BankTransactionType, dict):
+        if issubclass(PaymentTerminalType, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, BankTransactionType):
+        if not isinstance(other, PaymentTerminalType):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/card_cryptogram.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/card_cryptogram.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/card_cryptogram_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/card_cryptogram_create.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/cardholder_authentication.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/cardholder_authentication.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/cardholder_authentication_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/cardholder_authentication_create.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/charge.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/charge.py`

 * *Files 6% similar despite different names*

```diff
@@ -107,49 +107,49 @@
 
         self._failure_reason = failure_reason
     
     @property
     def language(self):
         """Gets the language of this Charge.
 
-            The language that is linked to the object.
+            
 
         :return: The language of this Charge.
         :rtype: str
         """
         return self._language
 
     @language.setter
     def language(self, language):
         """Sets the language of this Charge.
 
-            The language that is linked to the object.
+            
 
         :param language: The language of this Charge.
         :type: str
         """
 
         self._language = language
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this Charge.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this Charge.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this Charge.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this Charge.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -176,26 +176,26 @@
 
         self._space_view_id = space_view_id
     
     @property
     def state(self):
         """Gets the state of this Charge.
 
-            The object's current state.
+            
 
         :return: The state of this Charge.
         :rtype: ChargeState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this Charge.
 
-            The object's current state.
+            
 
         :param state: The state of this Charge.
         :type: ChargeState
         """
 
         self._state = state
     
@@ -314,26 +314,26 @@
 
         self._user_failure_message = user_failure_message
     
     @property
     def version(self):
         """Gets the version of this Charge.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this Charge.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this Charge.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this Charge.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/charge_attempt.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/charge_attempt.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,15 +9,14 @@
 
     swagger_types = {
     
         'charge': 'Charge',
         'completion_behavior': 'TransactionCompletionBehavior',
         'connector_configuration': 'PaymentConnectorConfiguration',
         'created_on': 'datetime',
-        'customers_presence': 'CustomersPresence',
         'environment': 'ChargeAttemptEnvironment',
         'failed_on': 'datetime',
         'failure_reason': 'FailureReason',
         'initializing_token_version': 'bool',
         'invocation': 'ConnectorInvocation',
         'labels': 'list[Label]',
         'language': 'str',
@@ -30,27 +29,25 @@
         'succeeded_on': 'datetime',
         'terminal': 'PaymentTerminal',
         'time_zone': 'str',
         'timeout_on': 'datetime',
         'token_version': 'TokenVersion',
         'user_failure_message': 'str',
         'version': 'int',
-        'wallet_type': 'WalletType',
     }
 
     attribute_map = {
-        'charge': 'charge','completion_behavior': 'completionBehavior','connector_configuration': 'connectorConfiguration','created_on': 'createdOn','customers_presence': 'customersPresence','environment': 'environment','failed_on': 'failedOn','failure_reason': 'failureReason','initializing_token_version': 'initializingTokenVersion','invocation': 'invocation','labels': 'labels','language': 'language','next_update_on': 'nextUpdateOn','planned_purge_date': 'plannedPurgeDate','redirection_url': 'redirectionUrl','sales_channel': 'salesChannel','space_view_id': 'spaceViewId','state': 'state','succeeded_on': 'succeededOn','terminal': 'terminal','time_zone': 'timeZone','timeout_on': 'timeoutOn','token_version': 'tokenVersion','user_failure_message': 'userFailureMessage','version': 'version','wallet_type': 'walletType',
+        'charge': 'charge','completion_behavior': 'completionBehavior','connector_configuration': 'connectorConfiguration','created_on': 'createdOn','environment': 'environment','failed_on': 'failedOn','failure_reason': 'failureReason','initializing_token_version': 'initializingTokenVersion','invocation': 'invocation','labels': 'labels','language': 'language','next_update_on': 'nextUpdateOn','planned_purge_date': 'plannedPurgeDate','redirection_url': 'redirectionUrl','sales_channel': 'salesChannel','space_view_id': 'spaceViewId','state': 'state','succeeded_on': 'succeededOn','terminal': 'terminal','time_zone': 'timeZone','timeout_on': 'timeoutOn','token_version': 'tokenVersion','user_failure_message': 'userFailureMessage','version': 'version',
     }
 
     
     _charge = None
     _completion_behavior = None
     _connector_configuration = None
     _created_on = None
-    _customers_presence = None
     _environment = None
     _failed_on = None
     _failure_reason = None
     _initializing_token_version = None
     _invocation = None
     _labels = None
     _language = None
@@ -63,24 +60,22 @@
     _succeeded_on = None
     _terminal = None
     _time_zone = None
     _timeout_on = None
     _token_version = None
     _user_failure_message = None
     _version = None
-    _wallet_type = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
         self.charge = kwargs.get('charge', None)
         self.completion_behavior = kwargs.get('completion_behavior', None)
         self.connector_configuration = kwargs.get('connector_configuration', None)
         self.created_on = kwargs.get('created_on', None)
-        self.customers_presence = kwargs.get('customers_presence', None)
         self.environment = kwargs.get('environment', None)
         self.failed_on = kwargs.get('failed_on', None)
         self.failure_reason = kwargs.get('failure_reason', None)
         self.initializing_token_version = kwargs.get('initializing_token_version', None)
         self.invocation = kwargs.get('invocation', None)
         self.labels = kwargs.get('labels', None)
         self.language = kwargs.get('language', None)
@@ -93,15 +88,14 @@
         self.succeeded_on = kwargs.get('succeeded_on', None)
         self.terminal = kwargs.get('terminal', None)
         self.time_zone = kwargs.get('time_zone', None)
         self.timeout_on = kwargs.get('timeout_on', None)
         self.token_version = kwargs.get('token_version', None)
         self.user_failure_message = kwargs.get('user_failure_message', None)
         self.version = kwargs.get('version', None)
-        self.wallet_type = kwargs.get('wallet_type', None)
         super().__init__(**kwargs)
         self.swagger_types.update(super().swagger_types)
         self.attribute_map.update(super().attribute_map)
 
     
     @property
     def charge(self):
@@ -172,57 +166,34 @@
 
         self._connector_configuration = connector_configuration
     
     @property
     def created_on(self):
         """Gets the created_on of this ChargeAttempt.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :return: The created_on of this ChargeAttempt.
         :rtype: datetime
         """
         return self._created_on
 
     @created_on.setter
     def created_on(self, created_on):
         """Sets the created_on of this ChargeAttempt.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :param created_on: The created_on of this ChargeAttempt.
         :type: datetime
         """
 
         self._created_on = created_on
     
     @property
-    def customers_presence(self):
-        """Gets the customers_presence of this ChargeAttempt.
-
-            The customers presence indicates which kind of customer interaction was used during the charge attempt.
-
-        :return: The customers_presence of this ChargeAttempt.
-        :rtype: CustomersPresence
-        """
-        return self._customers_presence
-
-    @customers_presence.setter
-    def customers_presence(self, customers_presence):
-        """Sets the customers_presence of this ChargeAttempt.
-
-            The customers presence indicates which kind of customer interaction was used during the charge attempt.
-
-        :param customers_presence: The customers_presence of this ChargeAttempt.
-        :type: CustomersPresence
-        """
-
-        self._customers_presence = customers_presence
-    
-    @property
     def environment(self):
         """Gets the environment of this ChargeAttempt.
 
             
 
         :return: The environment of this ChargeAttempt.
         :rtype: ChargeAttemptEnvironment
@@ -356,26 +327,26 @@
 
         self._labels = labels
     
     @property
     def language(self):
         """Gets the language of this ChargeAttempt.
 
-            The language that is linked to the object.
+            
 
         :return: The language of this ChargeAttempt.
         :rtype: str
         """
         return self._language
 
     @language.setter
     def language(self, language):
         """Sets the language of this ChargeAttempt.
 
-            The language that is linked to the object.
+            
 
         :param language: The language of this ChargeAttempt.
         :type: str
         """
 
         self._language = language
     
@@ -402,26 +373,26 @@
 
         self._next_update_on = next_update_on
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this ChargeAttempt.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this ChargeAttempt.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this ChargeAttempt.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this ChargeAttempt.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -494,26 +465,26 @@
 
         self._space_view_id = space_view_id
     
     @property
     def state(self):
         """Gets the state of this ChargeAttempt.
 
-            The object's current state.
+            
 
         :return: The state of this ChargeAttempt.
         :rtype: ChargeAttemptState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this ChargeAttempt.
 
-            The object's current state.
+            
 
         :param state: The state of this ChargeAttempt.
         :type: ChargeAttemptState
         """
 
         self._state = state
     
@@ -657,56 +628,33 @@
 
         self._user_failure_message = user_failure_message
     
     @property
     def version(self):
         """Gets the version of this ChargeAttempt.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this ChargeAttempt.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this ChargeAttempt.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this ChargeAttempt.
         :type: int
         """
 
         self._version = version
     
-    @property
-    def wallet_type(self):
-        """Gets the wallet_type of this ChargeAttempt.
-
-            
-
-        :return: The wallet_type of this ChargeAttempt.
-        :rtype: WalletType
-        """
-        return self._wallet_type
-
-    @wallet_type.setter
-    def wallet_type(self, wallet_type):
-        """Sets the wallet_type of this ChargeAttempt.
-
-            
-
-        :param wallet_type: The wallet_type of this ChargeAttempt.
-        :type: WalletType
-        """
-
-        self._wallet_type = wallet_type
-    
 
     def to_dict(self):
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/charge_bank_transaction.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/charge_bank_transaction.py`

 * *Files 4% similar despite different names*

```diff
@@ -95,26 +95,26 @@
 
         self._completion = completion
     
     @property
     def language(self):
         """Gets the language of this ChargeBankTransaction.
 
-            The language that is linked to the object.
+            
 
         :return: The language of this ChargeBankTransaction.
         :rtype: str
         """
         return self._language
 
     @language.setter
     def language(self, language):
         """Sets the language of this ChargeBankTransaction.
 
-            The language that is linked to the object.
+            
 
         :param language: The language of this ChargeBankTransaction.
         :type: str
         """
 
         self._language = language
     
@@ -210,26 +210,26 @@
 
         self._transaction_currency_value_amount = transaction_currency_value_amount
     
     @property
     def version(self):
         """Gets the version of this ChargeBankTransaction.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this ChargeBankTransaction.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this ChargeBankTransaction.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this ChargeBankTransaction.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/charge_flow.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/charge_flow.py`

 * *Files 8% similar despite different names*

```diff
@@ -70,49 +70,49 @@
 
         self._conditions = conditions
     
     @property
     def id(self):
         """Gets the id of this ChargeFlow.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this ChargeFlow.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this ChargeFlow.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this ChargeFlow.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this ChargeFlow.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this ChargeFlow.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this ChargeFlow.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this ChargeFlow.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -139,26 +139,26 @@
 
         self._name = name
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this ChargeFlow.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this ChargeFlow.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this ChargeFlow.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this ChargeFlow.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -185,49 +185,49 @@
 
         self._priority = priority
     
     @property
     def state(self):
         """Gets the state of this ChargeFlow.
 
-            The object's current state.
+            
 
         :return: The state of this ChargeFlow.
         :rtype: CreationEntityState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this ChargeFlow.
 
-            The object's current state.
+            
 
         :param state: The state of this ChargeFlow.
         :type: CreationEntityState
         """
 
         self._state = state
     
     @property
     def version(self):
         """Gets the version of this ChargeFlow.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this ChargeFlow.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this ChargeFlow.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this ChargeFlow.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/charge_flow_level.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/charge_flow_level.py`

 * *Files 5% similar despite different names*

```diff
@@ -101,72 +101,72 @@
 
         self._configuration = configuration
     
     @property
     def created_on(self):
         """Gets the created_on of this ChargeFlowLevel.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :return: The created_on of this ChargeFlowLevel.
         :rtype: datetime
         """
         return self._created_on
 
     @created_on.setter
     def created_on(self, created_on):
         """Sets the created_on of this ChargeFlowLevel.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :param created_on: The created_on of this ChargeFlowLevel.
         :type: datetime
         """
 
         self._created_on = created_on
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this ChargeFlowLevel.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this ChargeFlowLevel.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this ChargeFlowLevel.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this ChargeFlowLevel.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
     @property
     def state(self):
         """Gets the state of this ChargeFlowLevel.
 
-            The object's current state.
+            
 
         :return: The state of this ChargeFlowLevel.
         :rtype: ChargeFlowLevelState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this ChargeFlowLevel.
 
-            The object's current state.
+            
 
         :param state: The state of this ChargeFlowLevel.
         :type: ChargeFlowLevelState
         """
 
         self._state = state
     
@@ -262,26 +262,26 @@
 
         self._transaction = transaction
     
     @property
     def version(self):
         """Gets the version of this ChargeFlowLevel.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this ChargeFlowLevel.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this ChargeFlowLevel.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this ChargeFlowLevel.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/charge_flow_level_configuration.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/charge_flow_level_configuration.py`

 * *Files 7% similar despite different names*

```diff
@@ -76,49 +76,49 @@
 
         self._flow = flow
     
     @property
     def id(self):
         """Gets the id of this ChargeFlowLevelConfiguration.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this ChargeFlowLevelConfiguration.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this ChargeFlowLevelConfiguration.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this ChargeFlowLevelConfiguration.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this ChargeFlowLevelConfiguration.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this ChargeFlowLevelConfiguration.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this ChargeFlowLevelConfiguration.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this ChargeFlowLevelConfiguration.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -170,26 +170,26 @@
 
         self._period = period
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this ChargeFlowLevelConfiguration.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this ChargeFlowLevelConfiguration.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this ChargeFlowLevelConfiguration.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this ChargeFlowLevelConfiguration.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -216,26 +216,26 @@
 
         self._priority = priority
     
     @property
     def state(self):
         """Gets the state of this ChargeFlowLevelConfiguration.
 
-            The object's current state.
+            
 
         :return: The state of this ChargeFlowLevelConfiguration.
         :rtype: CreationEntityState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this ChargeFlowLevelConfiguration.
 
-            The object's current state.
+            
 
         :param state: The state of this ChargeFlowLevelConfiguration.
         :type: CreationEntityState
         """
 
         self._state = state
     
@@ -262,26 +262,26 @@
 
         self._type = type
     
     @property
     def version(self):
         """Gets the version of this ChargeFlowLevelConfiguration.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this ChargeFlowLevelConfiguration.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this ChargeFlowLevelConfiguration.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this ChargeFlowLevelConfiguration.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/charge_flow_level_configuration_type.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/charge_flow_level_configuration_type.py`

 * *Files 6% similar despite different names*

```diff
@@ -35,49 +35,49 @@
         
 
     
     @property
     def description(self):
         """Gets the description of this ChargeFlowLevelConfigurationType.
 
-            The localized description of the object.
+            
 
         :return: The description of this ChargeFlowLevelConfigurationType.
         :rtype: dict(str, str)
         """
         return self._description
 
     @description.setter
     def description(self, description):
         """Sets the description of this ChargeFlowLevelConfigurationType.
 
-            The localized description of the object.
+            
 
         :param description: The description of this ChargeFlowLevelConfigurationType.
         :type: dict(str, str)
         """
 
         self._description = description
     
     @property
     def id(self):
         """Gets the id of this ChargeFlowLevelConfigurationType.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this ChargeFlowLevelConfigurationType.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this ChargeFlowLevelConfigurationType.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this ChargeFlowLevelConfigurationType.
         :type: int
         """
 
         self._id = id
     
@@ -104,26 +104,26 @@
 
         self._label = label
     
     @property
     def name(self):
         """Gets the name of this ChargeFlowLevelConfigurationType.
 
-            The localized name of the object.
+            
 
         :return: The name of this ChargeFlowLevelConfigurationType.
         :rtype: dict(str, str)
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this ChargeFlowLevelConfigurationType.
 
-            The localized name of the object.
+            
 
         :param name: The name of this ChargeFlowLevelConfigurationType.
         :type: dict(str, str)
         """
 
         self._name = name
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/charge_flow_level_payment_link.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/charge_flow_level_payment_link.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/client_error.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/client_error.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/completion_line_item.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/completion_line_item.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/completion_line_item_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/completion_line_item_create.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/condition.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/condition.py`

 * *Files 9% similar despite different names*

```diff
@@ -67,49 +67,49 @@
 
         self._condition_type = condition_type
     
     @property
     def id(self):
         """Gets the id of this Condition.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this Condition.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this Condition.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this Condition.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this Condition.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this Condition.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this Condition.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this Condition.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -138,72 +138,72 @@
 
         self._name = name
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this Condition.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this Condition.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this Condition.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this Condition.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
     @property
     def state(self):
         """Gets the state of this Condition.
 
-            The object's current state.
+            
 
         :return: The state of this Condition.
         :rtype: CreationEntityState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this Condition.
 
-            The object's current state.
+            
 
         :param state: The state of this Condition.
         :type: CreationEntityState
         """
 
         self._state = state
     
     @property
     def version(self):
         """Gets the version of this Condition.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this Condition.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this Condition.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this Condition.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/condition_type.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/condition_type.py`

 * *Files 8% similar despite different names*

```diff
@@ -32,72 +32,72 @@
         
 
     
     @property
     def description(self):
         """Gets the description of this ConditionType.
 
-            The localized description of the object.
+            
 
         :return: The description of this ConditionType.
         :rtype: dict(str, str)
         """
         return self._description
 
     @description.setter
     def description(self, description):
         """Sets the description of this ConditionType.
 
-            The localized description of the object.
+            
 
         :param description: The description of this ConditionType.
         :type: dict(str, str)
         """
 
         self._description = description
     
     @property
     def id(self):
         """Gets the id of this ConditionType.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this ConditionType.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this ConditionType.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this ConditionType.
         :type: int
         """
 
         self._id = id
     
     @property
     def name(self):
         """Gets the name of this ConditionType.
 
-            The localized name of the object.
+            
 
         :return: The name of this ConditionType.
         :rtype: dict(str, str)
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this ConditionType.
 
-            The localized name of the object.
+            
 
         :param name: The name of this ConditionType.
         :type: dict(str, str)
         """
 
         self._name = name
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/connector_invocation.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/connector_invocation.py`

 * *Files 9% similar despite different names*

```diff
@@ -43,49 +43,49 @@
         self.attribute_map.update(super().attribute_map)
 
     
     @property
     def created_on(self):
         """Gets the created_on of this ConnectorInvocation.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :return: The created_on of this ConnectorInvocation.
         :rtype: datetime
         """
         return self._created_on
 
     @created_on.setter
     def created_on(self, created_on):
         """Sets the created_on of this ConnectorInvocation.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :param created_on: The created_on of this ConnectorInvocation.
         :type: datetime
         """
 
         self._created_on = created_on
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this ConnectorInvocation.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this ConnectorInvocation.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this ConnectorInvocation.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this ConnectorInvocation.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -158,26 +158,26 @@
 
         self._transaction = transaction
     
     @property
     def version(self):
         """Gets the version of this ConnectorInvocation.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this ConnectorInvocation.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this ConnectorInvocation.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this ConnectorInvocation.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/criteria_operator.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/criteria_operator.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/currency_bank_account.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/currency_bank_account.py`

 * *Files 11% similar despite different names*

```diff
@@ -110,72 +110,72 @@
 
         self._environment = environment
     
     @property
     def id(self):
         """Gets the id of this CurrencyBankAccount.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this CurrencyBankAccount.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this CurrencyBankAccount.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this CurrencyBankAccount.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this CurrencyBankAccount.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this CurrencyBankAccount.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this CurrencyBankAccount.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this CurrencyBankAccount.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
     @property
     def version(self):
         """Gets the version of this CurrencyBankAccount.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this CurrencyBankAccount.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this CurrencyBankAccount.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this CurrencyBankAccount.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/customer.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/customer.py`

 * *Files 21% similar despite different names*

```diff
@@ -56,264 +56,264 @@
         
 
     
     @property
     def created_on(self):
         """Gets the created_on of this Customer.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :return: The created_on of this Customer.
         :rtype: datetime
         """
         return self._created_on
 
     @created_on.setter
     def created_on(self, created_on):
         """Sets the created_on of this Customer.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :param created_on: The created_on of this Customer.
         :type: datetime
         """
 
         self._created_on = created_on
     
     @property
     def customer_id(self):
         """Gets the customer_id of this Customer.
 
-            The customer's ID in the merchant's system.
+            
 
         :return: The customer_id of this Customer.
         :rtype: str
         """
         return self._customer_id
 
     @customer_id.setter
     def customer_id(self, customer_id):
         """Sets the customer_id of this Customer.
 
-            The customer's ID in the merchant's system.
+            
 
         :param customer_id: The customer_id of this Customer.
         :type: str
         """
         if customer_id is not None and len(customer_id) > 100:
             raise ValueError("Invalid value for `customer_id`, length must be less than or equal to `100`")
 
         self._customer_id = customer_id
     
     @property
     def email_address(self):
         """Gets the email_address of this Customer.
 
-            The customer's email address.
+            
 
         :return: The email_address of this Customer.
         :rtype: str
         """
         return self._email_address
 
     @email_address.setter
     def email_address(self, email_address):
         """Sets the email_address of this Customer.
 
-            The customer's email address.
+            
 
         :param email_address: The email_address of this Customer.
         :type: str
         """
         if email_address is not None and len(email_address) > 254:
             raise ValueError("Invalid value for `email_address`, length must be less than or equal to `254`")
 
         self._email_address = email_address
     
     @property
     def family_name(self):
         """Gets the family_name of this Customer.
 
-            The customer's family or last name.
+            
 
         :return: The family_name of this Customer.
         :rtype: str
         """
         return self._family_name
 
     @family_name.setter
     def family_name(self, family_name):
         """Sets the family_name of this Customer.
 
-            The customer's family or last name.
+            
 
         :param family_name: The family_name of this Customer.
         :type: str
         """
         if family_name is not None and len(family_name) > 100:
             raise ValueError("Invalid value for `family_name`, length must be less than or equal to `100`")
 
         self._family_name = family_name
     
     @property
     def given_name(self):
         """Gets the given_name of this Customer.
 
-            The customer's given or first name.
+            
 
         :return: The given_name of this Customer.
         :rtype: str
         """
         return self._given_name
 
     @given_name.setter
     def given_name(self, given_name):
         """Sets the given_name of this Customer.
 
-            The customer's given or first name.
+            
 
         :param given_name: The given_name of this Customer.
         :type: str
         """
         if given_name is not None and len(given_name) > 100:
             raise ValueError("Invalid value for `given_name`, length must be less than or equal to `100`")
 
         self._given_name = given_name
     
     @property
     def id(self):
         """Gets the id of this Customer.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this Customer.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this Customer.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this Customer.
         :type: int
         """
 
         self._id = id
     
     @property
     def language(self):
         """Gets the language of this Customer.
 
-            The language that is linked to the object.
+            
 
         :return: The language of this Customer.
         :rtype: str
         """
         return self._language
 
     @language.setter
     def language(self, language):
         """Sets the language of this Customer.
 
-            The language that is linked to the object.
+            
 
         :param language: The language of this Customer.
         :type: str
         """
 
         self._language = language
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this Customer.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this Customer.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this Customer.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this Customer.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
     @property
     def meta_data(self):
         """Gets the meta_data of this Customer.
 
-            Allow to store additional information about the object.
+            Meta data allow to store additional data along the object.
 
         :return: The meta_data of this Customer.
         :rtype: dict(str, str)
         """
         return self._meta_data
 
     @meta_data.setter
     def meta_data(self, meta_data):
         """Sets the meta_data of this Customer.
 
-            Allow to store additional information about the object.
+            Meta data allow to store additional data along the object.
 
         :param meta_data: The meta_data of this Customer.
         :type: dict(str, str)
         """
 
         self._meta_data = meta_data
     
     @property
     def preferred_currency(self):
         """Gets the preferred_currency of this Customer.
 
-            The customer's preferred currency.
+            
 
         :return: The preferred_currency of this Customer.
         :rtype: str
         """
         return self._preferred_currency
 
     @preferred_currency.setter
     def preferred_currency(self, preferred_currency):
         """Sets the preferred_currency of this Customer.
 
-            The customer's preferred currency.
+            
 
         :param preferred_currency: The preferred_currency of this Customer.
         :type: str
         """
 
         self._preferred_currency = preferred_currency
     
     @property
     def version(self):
         """Gets the version of this Customer.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this Customer.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this Customer.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this Customer.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/customer_active.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/customer_active.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/customer_address.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/customer_address.py`

 * *Files 7% similar despite different names*

```diff
@@ -47,187 +47,187 @@
         
 
     
     @property
     def address(self):
         """Gets the address of this CustomerAddress.
 
-            The actual postal address.
+            
 
         :return: The address of this CustomerAddress.
         :rtype: CustomerPostalAddress
         """
         return self._address
 
     @address.setter
     def address(self, address):
         """Sets the address of this CustomerAddress.
 
-            The actual postal address.
+            
 
         :param address: The address of this CustomerAddress.
         :type: CustomerPostalAddress
         """
 
         self._address = address
     
     @property
     def address_type(self):
         """Gets the address_type of this CustomerAddress.
 
-            Whether the address is for billing or shipping or both.
+            
 
         :return: The address_type of this CustomerAddress.
         :rtype: CustomerAddressType
         """
         return self._address_type
 
     @address_type.setter
     def address_type(self, address_type):
         """Sets the address_type of this CustomerAddress.
 
-            Whether the address is for billing or shipping or both.
+            
 
         :param address_type: The address_type of this CustomerAddress.
         :type: CustomerAddressType
         """
 
         self._address_type = address_type
     
     @property
     def created_on(self):
         """Gets the created_on of this CustomerAddress.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :return: The created_on of this CustomerAddress.
         :rtype: datetime
         """
         return self._created_on
 
     @created_on.setter
     def created_on(self, created_on):
         """Sets the created_on of this CustomerAddress.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :param created_on: The created_on of this CustomerAddress.
         :type: datetime
         """
 
         self._created_on = created_on
     
     @property
     def customer(self):
         """Gets the customer of this CustomerAddress.
 
-            The customer that the object belongs to.
+            
 
         :return: The customer of this CustomerAddress.
         :rtype: Customer
         """
         return self._customer
 
     @customer.setter
     def customer(self, customer):
         """Sets the customer of this CustomerAddress.
 
-            The customer that the object belongs to.
+            
 
         :param customer: The customer of this CustomerAddress.
         :type: Customer
         """
 
         self._customer = customer
     
     @property
     def default_address(self):
         """Gets the default_address of this CustomerAddress.
 
-            Whether this is the customer's default address.
+            
 
         :return: The default_address of this CustomerAddress.
         :rtype: bool
         """
         return self._default_address
 
     @default_address.setter
     def default_address(self, default_address):
         """Sets the default_address of this CustomerAddress.
 
-            Whether this is the customer's default address.
+            
 
         :param default_address: The default_address of this CustomerAddress.
         :type: bool
         """
 
         self._default_address = default_address
     
     @property
     def id(self):
         """Gets the id of this CustomerAddress.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this CustomerAddress.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this CustomerAddress.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this CustomerAddress.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this CustomerAddress.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this CustomerAddress.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this CustomerAddress.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this CustomerAddress.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
     @property
     def version(self):
         """Gets the version of this CustomerAddress.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this CustomerAddress.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this CustomerAddress.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this CustomerAddress.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/customer_address_active.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/customer_address_active.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/customer_address_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/customer_comment_create.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
-from . import AbstractCustomerAddressActive
+from . import AbstractCustomerCommentActive
 
 
-class CustomerAddressCreate(AbstractCustomerAddressActive):
+class CustomerCommentCreate(AbstractCustomerCommentActive):
 
     swagger_types = {
     
         'customer': 'int',
     }
 
     attribute_map = {
@@ -27,30 +27,30 @@
         super().__init__(**kwargs)
         self.swagger_types.update(super().swagger_types)
         self.attribute_map.update(super().attribute_map)
 
     
     @property
     def customer(self):
-        """Gets the customer of this CustomerAddressCreate.
+        """Gets the customer of this CustomerCommentCreate.
 
-            The customer that the object belongs to.
+            
 
-        :return: The customer of this CustomerAddressCreate.
+        :return: The customer of this CustomerCommentCreate.
         :rtype: int
         """
         return self._customer
 
     @customer.setter
     def customer(self, customer):
-        """Sets the customer of this CustomerAddressCreate.
+        """Sets the customer of this CustomerCommentCreate.
 
-            The customer that the object belongs to.
+            
 
-        :param customer: The customer of this CustomerAddressCreate.
+        :param customer: The customer of this CustomerCommentCreate.
         :type: int
         """
         if customer is None:
             raise ValueError("Invalid value for `customer`, must not be `None`")
 
         self._customer = customer
     
@@ -73,27 +73,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(CustomerAddressCreate, dict):
+        if issubclass(CustomerCommentCreate, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, CustomerAddressCreate):
+        if not isinstance(other, CustomerCommentCreate):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/customer_comment.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/customer_comment.py`

 * *Files 8% similar despite different names*

```diff
@@ -53,235 +53,235 @@
         
 
     
     @property
     def content(self):
         """Gets the content of this CustomerComment.
 
-            The comment's actual content.
+            
 
         :return: The content of this CustomerComment.
         :rtype: str
         """
         return self._content
 
     @content.setter
     def content(self, content):
         """Sets the content of this CustomerComment.
 
-            The comment's actual content.
+            
 
         :param content: The content of this CustomerComment.
         :type: str
         """
         if content is not None and len(content) > 262144:
             raise ValueError("Invalid value for `content`, length must be less than or equal to `262144`")
 
         self._content = content
     
     @property
     def created_by(self):
         """Gets the created_by of this CustomerComment.
 
-            The ID of the user the comment was created by.
+            
 
         :return: The created_by of this CustomerComment.
         :rtype: int
         """
         return self._created_by
 
     @created_by.setter
     def created_by(self, created_by):
         """Sets the created_by of this CustomerComment.
 
-            The ID of the user the comment was created by.
+            
 
         :param created_by: The created_by of this CustomerComment.
         :type: int
         """
 
         self._created_by = created_by
     
     @property
     def created_on(self):
         """Gets the created_on of this CustomerComment.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :return: The created_on of this CustomerComment.
         :rtype: datetime
         """
         return self._created_on
 
     @created_on.setter
     def created_on(self, created_on):
         """Sets the created_on of this CustomerComment.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :param created_on: The created_on of this CustomerComment.
         :type: datetime
         """
 
         self._created_on = created_on
     
     @property
     def customer(self):
         """Gets the customer of this CustomerComment.
 
-            The customer that the object belongs to.
+            
 
         :return: The customer of this CustomerComment.
         :rtype: int
         """
         return self._customer
 
     @customer.setter
     def customer(self, customer):
         """Sets the customer of this CustomerComment.
 
-            The customer that the object belongs to.
+            
 
         :param customer: The customer of this CustomerComment.
         :type: int
         """
 
         self._customer = customer
     
     @property
     def edited_by(self):
         """Gets the edited_by of this CustomerComment.
 
-            The ID of the user the comment was last updated by.
+            
 
         :return: The edited_by of this CustomerComment.
         :rtype: int
         """
         return self._edited_by
 
     @edited_by.setter
     def edited_by(self, edited_by):
         """Sets the edited_by of this CustomerComment.
 
-            The ID of the user the comment was last updated by.
+            
 
         :param edited_by: The edited_by of this CustomerComment.
         :type: int
         """
 
         self._edited_by = edited_by
     
     @property
     def edited_on(self):
         """Gets the edited_on of this CustomerComment.
 
-            The date and time when the comment was last updated.
+            The date on which the comment was last edited.
 
         :return: The edited_on of this CustomerComment.
         :rtype: datetime
         """
         return self._edited_on
 
     @edited_on.setter
     def edited_on(self, edited_on):
         """Sets the edited_on of this CustomerComment.
 
-            The date and time when the comment was last updated.
+            The date on which the comment was last edited.
 
         :param edited_on: The edited_on of this CustomerComment.
         :type: datetime
         """
 
         self._edited_on = edited_on
     
     @property
     def id(self):
         """Gets the id of this CustomerComment.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this CustomerComment.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this CustomerComment.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this CustomerComment.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this CustomerComment.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this CustomerComment.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this CustomerComment.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this CustomerComment.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
     @property
     def pinned(self):
         """Gets the pinned of this CustomerComment.
 
-            Whether the comment is pinned to the top.
+            
 
         :return: The pinned of this CustomerComment.
         :rtype: bool
         """
         return self._pinned
 
     @pinned.setter
     def pinned(self, pinned):
         """Sets the pinned of this CustomerComment.
 
-            Whether the comment is pinned to the top.
+            
 
         :param pinned: The pinned of this CustomerComment.
         :type: bool
         """
 
         self._pinned = pinned
     
     @property
     def version(self):
         """Gets the version of this CustomerComment.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this CustomerComment.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this CustomerComment.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this CustomerComment.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/customer_comment_active.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/customer_comment_active.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/customer_comment_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/customer_address_create.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
-from . import AbstractCustomerCommentActive
+from . import AbstractCustomerAddressActive
 
 
-class CustomerCommentCreate(AbstractCustomerCommentActive):
+class CustomerAddressCreate(AbstractCustomerAddressActive):
 
     swagger_types = {
     
         'customer': 'int',
     }
 
     attribute_map = {
@@ -27,30 +27,30 @@
         super().__init__(**kwargs)
         self.swagger_types.update(super().swagger_types)
         self.attribute_map.update(super().attribute_map)
 
     
     @property
     def customer(self):
-        """Gets the customer of this CustomerCommentCreate.
+        """Gets the customer of this CustomerAddressCreate.
 
-            The customer that the object belongs to.
+            
 
-        :return: The customer of this CustomerCommentCreate.
+        :return: The customer of this CustomerAddressCreate.
         :rtype: int
         """
         return self._customer
 
     @customer.setter
     def customer(self, customer):
-        """Sets the customer of this CustomerCommentCreate.
+        """Sets the customer of this CustomerAddressCreate.
 
-            The customer that the object belongs to.
+            
 
-        :param customer: The customer of this CustomerCommentCreate.
+        :param customer: The customer of this CustomerAddressCreate.
         :type: int
         """
         if customer is None:
             raise ValueError("Invalid value for `customer`, must not be `None`")
 
         self._customer = customer
     
@@ -73,27 +73,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(CustomerCommentCreate, dict):
+        if issubclass(CustomerAddressCreate, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, CustomerCommentCreate):
+        if not isinstance(other, CustomerAddressCreate):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/customer_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/customer_create.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/customer_postal_address.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/customer_postal_address.py`

 * *Files 4% similar despite different names*

```diff
@@ -83,491 +83,491 @@
         
 
     
     @property
     def city(self):
         """Gets the city of this CustomerPostalAddress.
 
-            The city, town or village.
+            
 
         :return: The city of this CustomerPostalAddress.
         :rtype: str
         """
         return self._city
 
     @city.setter
     def city(self, city):
         """Sets the city of this CustomerPostalAddress.
 
-            The city, town or village.
+            
 
         :param city: The city of this CustomerPostalAddress.
         :type: str
         """
         if city is not None and len(city) > 100:
             raise ValueError("Invalid value for `city`, length must be less than or equal to `100`")
 
         self._city = city
     
     @property
     def commercial_register_number(self):
         """Gets the commercial_register_number of this CustomerPostalAddress.
 
-            The commercial registration number of the organization.
+            
 
         :return: The commercial_register_number of this CustomerPostalAddress.
         :rtype: str
         """
         return self._commercial_register_number
 
     @commercial_register_number.setter
     def commercial_register_number(self, commercial_register_number):
         """Sets the commercial_register_number of this CustomerPostalAddress.
 
-            The commercial registration number of the organization.
+            
 
         :param commercial_register_number: The commercial_register_number of this CustomerPostalAddress.
         :type: str
         """
         if commercial_register_number is not None and len(commercial_register_number) > 100:
             raise ValueError("Invalid value for `commercial_register_number`, length must be less than or equal to `100`")
 
         self._commercial_register_number = commercial_register_number
     
     @property
     def country(self):
         """Gets the country of this CustomerPostalAddress.
 
-            The two-letter country code (ISO 3166 format).
+            
 
         :return: The country of this CustomerPostalAddress.
         :rtype: str
         """
         return self._country
 
     @country.setter
     def country(self, country):
         """Sets the country of this CustomerPostalAddress.
 
-            The two-letter country code (ISO 3166 format).
+            
 
         :param country: The country of this CustomerPostalAddress.
         :type: str
         """
 
         self._country = country
     
     @property
     def date_of_birth(self):
         """Gets the date_of_birth of this CustomerPostalAddress.
 
-            The date of birth.
+            
 
         :return: The date_of_birth of this CustomerPostalAddress.
         :rtype: date
         """
         return self._date_of_birth
 
     @date_of_birth.setter
     def date_of_birth(self, date_of_birth):
         """Sets the date_of_birth of this CustomerPostalAddress.
 
-            The date of birth.
+            
 
         :param date_of_birth: The date_of_birth of this CustomerPostalAddress.
         :type: date
         """
 
         self._date_of_birth = date_of_birth
     
     @property
     def dependent_locality(self):
         """Gets the dependent_locality of this CustomerPostalAddress.
 
-            The dependent locality which is a sub-division of the state.
+            
 
         :return: The dependent_locality of this CustomerPostalAddress.
         :rtype: str
         """
         return self._dependent_locality
 
     @dependent_locality.setter
     def dependent_locality(self, dependent_locality):
         """Sets the dependent_locality of this CustomerPostalAddress.
 
-            The dependent locality which is a sub-division of the state.
+            
 
         :param dependent_locality: The dependent_locality of this CustomerPostalAddress.
         :type: str
         """
         if dependent_locality is not None and len(dependent_locality) > 100:
             raise ValueError("Invalid value for `dependent_locality`, length must be less than or equal to `100`")
 
         self._dependent_locality = dependent_locality
     
     @property
     def email_address(self):
         """Gets the email_address of this CustomerPostalAddress.
 
-            The email address.
+            
 
         :return: The email_address of this CustomerPostalAddress.
         :rtype: str
         """
         return self._email_address
 
     @email_address.setter
     def email_address(self, email_address):
         """Sets the email_address of this CustomerPostalAddress.
 
-            The email address.
+            
 
         :param email_address: The email_address of this CustomerPostalAddress.
         :type: str
         """
         if email_address is not None and len(email_address) > 254:
             raise ValueError("Invalid value for `email_address`, length must be less than or equal to `254`")
 
         self._email_address = email_address
     
     @property
     def family_name(self):
         """Gets the family_name of this CustomerPostalAddress.
 
-            The family or last name.
+            
 
         :return: The family_name of this CustomerPostalAddress.
         :rtype: str
         """
         return self._family_name
 
     @family_name.setter
     def family_name(self, family_name):
         """Sets the family_name of this CustomerPostalAddress.
 
-            The family or last name.
+            
 
         :param family_name: The family_name of this CustomerPostalAddress.
         :type: str
         """
         if family_name is not None and len(family_name) > 100:
             raise ValueError("Invalid value for `family_name`, length must be less than or equal to `100`")
 
         self._family_name = family_name
     
     @property
     def gender(self):
         """Gets the gender of this CustomerPostalAddress.
 
-            The gender.
+            
 
         :return: The gender of this CustomerPostalAddress.
         :rtype: Gender
         """
         return self._gender
 
     @gender.setter
     def gender(self, gender):
         """Sets the gender of this CustomerPostalAddress.
 
-            The gender.
+            
 
         :param gender: The gender of this CustomerPostalAddress.
         :type: Gender
         """
 
         self._gender = gender
     
     @property
     def given_name(self):
         """Gets the given_name of this CustomerPostalAddress.
 
-            The given or first name.
+            
 
         :return: The given_name of this CustomerPostalAddress.
         :rtype: str
         """
         return self._given_name
 
     @given_name.setter
     def given_name(self, given_name):
         """Sets the given_name of this CustomerPostalAddress.
 
-            The given or first name.
+            
 
         :param given_name: The given_name of this CustomerPostalAddress.
         :type: str
         """
         if given_name is not None and len(given_name) > 100:
             raise ValueError("Invalid value for `given_name`, length must be less than or equal to `100`")
 
         self._given_name = given_name
     
     @property
     def legal_organization_form(self):
         """Gets the legal_organization_form of this CustomerPostalAddress.
 
-            The legal form of the organization.
+            
 
         :return: The legal_organization_form of this CustomerPostalAddress.
         :rtype: LegalOrganizationForm
         """
         return self._legal_organization_form
 
     @legal_organization_form.setter
     def legal_organization_form(self, legal_organization_form):
         """Sets the legal_organization_form of this CustomerPostalAddress.
 
-            The legal form of the organization.
+            
 
         :param legal_organization_form: The legal_organization_form of this CustomerPostalAddress.
         :type: LegalOrganizationForm
         """
 
         self._legal_organization_form = legal_organization_form
     
     @property
     def mobile_phone_number(self):
         """Gets the mobile_phone_number of this CustomerPostalAddress.
 
-            The phone number of a mobile phone.
+            
 
         :return: The mobile_phone_number of this CustomerPostalAddress.
         :rtype: str
         """
         return self._mobile_phone_number
 
     @mobile_phone_number.setter
     def mobile_phone_number(self, mobile_phone_number):
         """Sets the mobile_phone_number of this CustomerPostalAddress.
 
-            The phone number of a mobile phone.
+            
 
         :param mobile_phone_number: The mobile_phone_number of this CustomerPostalAddress.
         :type: str
         """
         if mobile_phone_number is not None and len(mobile_phone_number) > 100:
             raise ValueError("Invalid value for `mobile_phone_number`, length must be less than or equal to `100`")
 
         self._mobile_phone_number = mobile_phone_number
     
     @property
     def organization_name(self):
         """Gets the organization_name of this CustomerPostalAddress.
 
-            The organization's name.
+            
 
         :return: The organization_name of this CustomerPostalAddress.
         :rtype: str
         """
         return self._organization_name
 
     @organization_name.setter
     def organization_name(self, organization_name):
         """Sets the organization_name of this CustomerPostalAddress.
 
-            The organization's name.
+            
 
         :param organization_name: The organization_name of this CustomerPostalAddress.
         :type: str
         """
         if organization_name is not None and len(organization_name) > 100:
             raise ValueError("Invalid value for `organization_name`, length must be less than or equal to `100`")
 
         self._organization_name = organization_name
     
     @property
     def phone_number(self):
         """Gets the phone_number of this CustomerPostalAddress.
 
-            The phone number.
+            
 
         :return: The phone_number of this CustomerPostalAddress.
         :rtype: str
         """
         return self._phone_number
 
     @phone_number.setter
     def phone_number(self, phone_number):
         """Sets the phone_number of this CustomerPostalAddress.
 
-            The phone number.
+            
 
         :param phone_number: The phone_number of this CustomerPostalAddress.
         :type: str
         """
         if phone_number is not None and len(phone_number) > 100:
             raise ValueError("Invalid value for `phone_number`, length must be less than or equal to `100`")
 
         self._phone_number = phone_number
     
     @property
     def postal_state(self):
         """Gets the postal_state of this CustomerPostalAddress.
 
-            The name of the region, typically a state, county, province or prefecture.
+            
 
         :return: The postal_state of this CustomerPostalAddress.
         :rtype: str
         """
         return self._postal_state
 
     @postal_state.setter
     def postal_state(self, postal_state):
         """Sets the postal_state of this CustomerPostalAddress.
 
-            The name of the region, typically a state, county, province or prefecture.
+            
 
         :param postal_state: The postal_state of this CustomerPostalAddress.
         :type: str
         """
 
         self._postal_state = postal_state
     
     @property
     def postcode(self):
         """Gets the postcode of this CustomerPostalAddress.
 
-            The postal code, also known as ZIP, postcode, etc.
+            
 
         :return: The postcode of this CustomerPostalAddress.
         :rtype: str
         """
         return self._postcode
 
     @postcode.setter
     def postcode(self, postcode):
         """Sets the postcode of this CustomerPostalAddress.
 
-            The postal code, also known as ZIP, postcode, etc.
+            
 
         :param postcode: The postcode of this CustomerPostalAddress.
         :type: str
         """
         if postcode is not None and len(postcode) > 40:
             raise ValueError("Invalid value for `postcode`, length must be less than or equal to `40`")
 
         self._postcode = postcode
     
     @property
     def sales_tax_number(self):
         """Gets the sales_tax_number of this CustomerPostalAddress.
 
-            The sales tax number of the organization.
+            
 
         :return: The sales_tax_number of this CustomerPostalAddress.
         :rtype: str
         """
         return self._sales_tax_number
 
     @sales_tax_number.setter
     def sales_tax_number(self, sales_tax_number):
         """Sets the sales_tax_number of this CustomerPostalAddress.
 
-            The sales tax number of the organization.
+            
 
         :param sales_tax_number: The sales_tax_number of this CustomerPostalAddress.
         :type: str
         """
         if sales_tax_number is not None and len(sales_tax_number) > 100:
             raise ValueError("Invalid value for `sales_tax_number`, length must be less than or equal to `100`")
 
         self._sales_tax_number = sales_tax_number
     
     @property
     def salutation(self):
         """Gets the salutation of this CustomerPostalAddress.
 
-            The salutation e.g. Mrs, Mr, Dr.
+            
 
         :return: The salutation of this CustomerPostalAddress.
         :rtype: str
         """
         return self._salutation
 
     @salutation.setter
     def salutation(self, salutation):
         """Sets the salutation of this CustomerPostalAddress.
 
-            The salutation e.g. Mrs, Mr, Dr.
+            
 
         :param salutation: The salutation of this CustomerPostalAddress.
         :type: str
         """
         if salutation is not None and len(salutation) > 20:
             raise ValueError("Invalid value for `salutation`, length must be less than or equal to `20`")
 
         self._salutation = salutation
     
     @property
     def social_security_number(self):
         """Gets the social_security_number of this CustomerPostalAddress.
 
-            The social security number.
+            
 
         :return: The social_security_number of this CustomerPostalAddress.
         :rtype: str
         """
         return self._social_security_number
 
     @social_security_number.setter
     def social_security_number(self, social_security_number):
         """Sets the social_security_number of this CustomerPostalAddress.
 
-            The social security number.
+            
 
         :param social_security_number: The social_security_number of this CustomerPostalAddress.
         :type: str
         """
         if social_security_number is not None and len(social_security_number) > 100:
             raise ValueError("Invalid value for `social_security_number`, length must be less than or equal to `100`")
 
         self._social_security_number = social_security_number
     
     @property
     def sorting_code(self):
         """Gets the sorting_code of this CustomerPostalAddress.
 
-            The sorting code identifying the post office where the PO Box is located.
+            The sorting code identifies the post office at which the post box is located in.
 
         :return: The sorting_code of this CustomerPostalAddress.
         :rtype: str
         """
         return self._sorting_code
 
     @sorting_code.setter
     def sorting_code(self, sorting_code):
         """Sets the sorting_code of this CustomerPostalAddress.
 
-            The sorting code identifying the post office where the PO Box is located.
+            The sorting code identifies the post office at which the post box is located in.
 
         :param sorting_code: The sorting_code of this CustomerPostalAddress.
         :type: str
         """
         if sorting_code is not None and len(sorting_code) > 100:
             raise ValueError("Invalid value for `sorting_code`, length must be less than or equal to `100`")
 
         self._sorting_code = sorting_code
     
     @property
     def street(self):
         """Gets the street of this CustomerPostalAddress.
 
-            The street or PO Box.
+            
 
         :return: The street of this CustomerPostalAddress.
         :rtype: str
         """
         return self._street
 
     @street.setter
     def street(self, street):
         """Sets the street of this CustomerPostalAddress.
 
-            The street or PO Box.
+            
 
         :param street: The street of this CustomerPostalAddress.
         :type: str
         """
         if street is not None and len(street) > 300:
             raise ValueError("Invalid value for `street`, length must be less than or equal to `300`")
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/customer_postal_address_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/customer_postal_address_create.py`

 * *Files 3% similar despite different names*

```diff
@@ -83,491 +83,491 @@
         
 
     
     @property
     def city(self):
         """Gets the city of this CustomerPostalAddressCreate.
 
-            The city, town or village.
+            
 
         :return: The city of this CustomerPostalAddressCreate.
         :rtype: str
         """
         return self._city
 
     @city.setter
     def city(self, city):
         """Sets the city of this CustomerPostalAddressCreate.
 
-            The city, town or village.
+            
 
         :param city: The city of this CustomerPostalAddressCreate.
         :type: str
         """
         if city is not None and len(city) > 100:
             raise ValueError("Invalid value for `city`, length must be less than or equal to `100`")
 
         self._city = city
     
     @property
     def commercial_register_number(self):
         """Gets the commercial_register_number of this CustomerPostalAddressCreate.
 
-            The commercial registration number of the organization.
+            
 
         :return: The commercial_register_number of this CustomerPostalAddressCreate.
         :rtype: str
         """
         return self._commercial_register_number
 
     @commercial_register_number.setter
     def commercial_register_number(self, commercial_register_number):
         """Sets the commercial_register_number of this CustomerPostalAddressCreate.
 
-            The commercial registration number of the organization.
+            
 
         :param commercial_register_number: The commercial_register_number of this CustomerPostalAddressCreate.
         :type: str
         """
         if commercial_register_number is not None and len(commercial_register_number) > 100:
             raise ValueError("Invalid value for `commercial_register_number`, length must be less than or equal to `100`")
 
         self._commercial_register_number = commercial_register_number
     
     @property
     def country(self):
         """Gets the country of this CustomerPostalAddressCreate.
 
-            The two-letter country code (ISO 3166 format).
+            
 
         :return: The country of this CustomerPostalAddressCreate.
         :rtype: str
         """
         return self._country
 
     @country.setter
     def country(self, country):
         """Sets the country of this CustomerPostalAddressCreate.
 
-            The two-letter country code (ISO 3166 format).
+            
 
         :param country: The country of this CustomerPostalAddressCreate.
         :type: str
         """
 
         self._country = country
     
     @property
     def date_of_birth(self):
         """Gets the date_of_birth of this CustomerPostalAddressCreate.
 
-            The date of birth.
+            
 
         :return: The date_of_birth of this CustomerPostalAddressCreate.
         :rtype: date
         """
         return self._date_of_birth
 
     @date_of_birth.setter
     def date_of_birth(self, date_of_birth):
         """Sets the date_of_birth of this CustomerPostalAddressCreate.
 
-            The date of birth.
+            
 
         :param date_of_birth: The date_of_birth of this CustomerPostalAddressCreate.
         :type: date
         """
 
         self._date_of_birth = date_of_birth
     
     @property
     def dependent_locality(self):
         """Gets the dependent_locality of this CustomerPostalAddressCreate.
 
-            The dependent locality which is a sub-division of the state.
+            
 
         :return: The dependent_locality of this CustomerPostalAddressCreate.
         :rtype: str
         """
         return self._dependent_locality
 
     @dependent_locality.setter
     def dependent_locality(self, dependent_locality):
         """Sets the dependent_locality of this CustomerPostalAddressCreate.
 
-            The dependent locality which is a sub-division of the state.
+            
 
         :param dependent_locality: The dependent_locality of this CustomerPostalAddressCreate.
         :type: str
         """
         if dependent_locality is not None and len(dependent_locality) > 100:
             raise ValueError("Invalid value for `dependent_locality`, length must be less than or equal to `100`")
 
         self._dependent_locality = dependent_locality
     
     @property
     def email_address(self):
         """Gets the email_address of this CustomerPostalAddressCreate.
 
-            The email address.
+            
 
         :return: The email_address of this CustomerPostalAddressCreate.
         :rtype: str
         """
         return self._email_address
 
     @email_address.setter
     def email_address(self, email_address):
         """Sets the email_address of this CustomerPostalAddressCreate.
 
-            The email address.
+            
 
         :param email_address: The email_address of this CustomerPostalAddressCreate.
         :type: str
         """
         if email_address is not None and len(email_address) > 254:
             raise ValueError("Invalid value for `email_address`, length must be less than or equal to `254`")
 
         self._email_address = email_address
     
     @property
     def family_name(self):
         """Gets the family_name of this CustomerPostalAddressCreate.
 
-            The family or last name.
+            
 
         :return: The family_name of this CustomerPostalAddressCreate.
         :rtype: str
         """
         return self._family_name
 
     @family_name.setter
     def family_name(self, family_name):
         """Sets the family_name of this CustomerPostalAddressCreate.
 
-            The family or last name.
+            
 
         :param family_name: The family_name of this CustomerPostalAddressCreate.
         :type: str
         """
         if family_name is not None and len(family_name) > 100:
             raise ValueError("Invalid value for `family_name`, length must be less than or equal to `100`")
 
         self._family_name = family_name
     
     @property
     def gender(self):
         """Gets the gender of this CustomerPostalAddressCreate.
 
-            The gender.
+            
 
         :return: The gender of this CustomerPostalAddressCreate.
         :rtype: Gender
         """
         return self._gender
 
     @gender.setter
     def gender(self, gender):
         """Sets the gender of this CustomerPostalAddressCreate.
 
-            The gender.
+            
 
         :param gender: The gender of this CustomerPostalAddressCreate.
         :type: Gender
         """
 
         self._gender = gender
     
     @property
     def given_name(self):
         """Gets the given_name of this CustomerPostalAddressCreate.
 
-            The given or first name.
+            
 
         :return: The given_name of this CustomerPostalAddressCreate.
         :rtype: str
         """
         return self._given_name
 
     @given_name.setter
     def given_name(self, given_name):
         """Sets the given_name of this CustomerPostalAddressCreate.
 
-            The given or first name.
+            
 
         :param given_name: The given_name of this CustomerPostalAddressCreate.
         :type: str
         """
         if given_name is not None and len(given_name) > 100:
             raise ValueError("Invalid value for `given_name`, length must be less than or equal to `100`")
 
         self._given_name = given_name
     
     @property
     def legal_organization_form(self):
         """Gets the legal_organization_form of this CustomerPostalAddressCreate.
 
-            The legal form of the organization.
+            
 
         :return: The legal_organization_form of this CustomerPostalAddressCreate.
         :rtype: int
         """
         return self._legal_organization_form
 
     @legal_organization_form.setter
     def legal_organization_form(self, legal_organization_form):
         """Sets the legal_organization_form of this CustomerPostalAddressCreate.
 
-            The legal form of the organization.
+            
 
         :param legal_organization_form: The legal_organization_form of this CustomerPostalAddressCreate.
         :type: int
         """
 
         self._legal_organization_form = legal_organization_form
     
     @property
     def mobile_phone_number(self):
         """Gets the mobile_phone_number of this CustomerPostalAddressCreate.
 
-            The phone number of a mobile phone.
+            
 
         :return: The mobile_phone_number of this CustomerPostalAddressCreate.
         :rtype: str
         """
         return self._mobile_phone_number
 
     @mobile_phone_number.setter
     def mobile_phone_number(self, mobile_phone_number):
         """Sets the mobile_phone_number of this CustomerPostalAddressCreate.
 
-            The phone number of a mobile phone.
+            
 
         :param mobile_phone_number: The mobile_phone_number of this CustomerPostalAddressCreate.
         :type: str
         """
         if mobile_phone_number is not None and len(mobile_phone_number) > 100:
             raise ValueError("Invalid value for `mobile_phone_number`, length must be less than or equal to `100`")
 
         self._mobile_phone_number = mobile_phone_number
     
     @property
     def organization_name(self):
         """Gets the organization_name of this CustomerPostalAddressCreate.
 
-            The organization's name.
+            
 
         :return: The organization_name of this CustomerPostalAddressCreate.
         :rtype: str
         """
         return self._organization_name
 
     @organization_name.setter
     def organization_name(self, organization_name):
         """Sets the organization_name of this CustomerPostalAddressCreate.
 
-            The organization's name.
+            
 
         :param organization_name: The organization_name of this CustomerPostalAddressCreate.
         :type: str
         """
         if organization_name is not None and len(organization_name) > 100:
             raise ValueError("Invalid value for `organization_name`, length must be less than or equal to `100`")
 
         self._organization_name = organization_name
     
     @property
     def phone_number(self):
         """Gets the phone_number of this CustomerPostalAddressCreate.
 
-            The phone number.
+            
 
         :return: The phone_number of this CustomerPostalAddressCreate.
         :rtype: str
         """
         return self._phone_number
 
     @phone_number.setter
     def phone_number(self, phone_number):
         """Sets the phone_number of this CustomerPostalAddressCreate.
 
-            The phone number.
+            
 
         :param phone_number: The phone_number of this CustomerPostalAddressCreate.
         :type: str
         """
         if phone_number is not None and len(phone_number) > 100:
             raise ValueError("Invalid value for `phone_number`, length must be less than or equal to `100`")
 
         self._phone_number = phone_number
     
     @property
     def postal_state(self):
         """Gets the postal_state of this CustomerPostalAddressCreate.
 
-            The name of the region, typically a state, county, province or prefecture.
+            
 
         :return: The postal_state of this CustomerPostalAddressCreate.
         :rtype: str
         """
         return self._postal_state
 
     @postal_state.setter
     def postal_state(self, postal_state):
         """Sets the postal_state of this CustomerPostalAddressCreate.
 
-            The name of the region, typically a state, county, province or prefecture.
+            
 
         :param postal_state: The postal_state of this CustomerPostalAddressCreate.
         :type: str
         """
 
         self._postal_state = postal_state
     
     @property
     def postcode(self):
         """Gets the postcode of this CustomerPostalAddressCreate.
 
-            The postal code, also known as ZIP, postcode, etc.
+            
 
         :return: The postcode of this CustomerPostalAddressCreate.
         :rtype: str
         """
         return self._postcode
 
     @postcode.setter
     def postcode(self, postcode):
         """Sets the postcode of this CustomerPostalAddressCreate.
 
-            The postal code, also known as ZIP, postcode, etc.
+            
 
         :param postcode: The postcode of this CustomerPostalAddressCreate.
         :type: str
         """
         if postcode is not None and len(postcode) > 40:
             raise ValueError("Invalid value for `postcode`, length must be less than or equal to `40`")
 
         self._postcode = postcode
     
     @property
     def sales_tax_number(self):
         """Gets the sales_tax_number of this CustomerPostalAddressCreate.
 
-            The sales tax number of the organization.
+            
 
         :return: The sales_tax_number of this CustomerPostalAddressCreate.
         :rtype: str
         """
         return self._sales_tax_number
 
     @sales_tax_number.setter
     def sales_tax_number(self, sales_tax_number):
         """Sets the sales_tax_number of this CustomerPostalAddressCreate.
 
-            The sales tax number of the organization.
+            
 
         :param sales_tax_number: The sales_tax_number of this CustomerPostalAddressCreate.
         :type: str
         """
         if sales_tax_number is not None and len(sales_tax_number) > 100:
             raise ValueError("Invalid value for `sales_tax_number`, length must be less than or equal to `100`")
 
         self._sales_tax_number = sales_tax_number
     
     @property
     def salutation(self):
         """Gets the salutation of this CustomerPostalAddressCreate.
 
-            The salutation e.g. Mrs, Mr, Dr.
+            
 
         :return: The salutation of this CustomerPostalAddressCreate.
         :rtype: str
         """
         return self._salutation
 
     @salutation.setter
     def salutation(self, salutation):
         """Sets the salutation of this CustomerPostalAddressCreate.
 
-            The salutation e.g. Mrs, Mr, Dr.
+            
 
         :param salutation: The salutation of this CustomerPostalAddressCreate.
         :type: str
         """
         if salutation is not None and len(salutation) > 20:
             raise ValueError("Invalid value for `salutation`, length must be less than or equal to `20`")
 
         self._salutation = salutation
     
     @property
     def social_security_number(self):
         """Gets the social_security_number of this CustomerPostalAddressCreate.
 
-            The social security number.
+            
 
         :return: The social_security_number of this CustomerPostalAddressCreate.
         :rtype: str
         """
         return self._social_security_number
 
     @social_security_number.setter
     def social_security_number(self, social_security_number):
         """Sets the social_security_number of this CustomerPostalAddressCreate.
 
-            The social security number.
+            
 
         :param social_security_number: The social_security_number of this CustomerPostalAddressCreate.
         :type: str
         """
         if social_security_number is not None and len(social_security_number) > 100:
             raise ValueError("Invalid value for `social_security_number`, length must be less than or equal to `100`")
 
         self._social_security_number = social_security_number
     
     @property
     def sorting_code(self):
         """Gets the sorting_code of this CustomerPostalAddressCreate.
 
-            The sorting code identifying the post office where the PO Box is located.
+            The sorting code identifies the post office at which the post box is located in.
 
         :return: The sorting_code of this CustomerPostalAddressCreate.
         :rtype: str
         """
         return self._sorting_code
 
     @sorting_code.setter
     def sorting_code(self, sorting_code):
         """Sets the sorting_code of this CustomerPostalAddressCreate.
 
-            The sorting code identifying the post office where the PO Box is located.
+            The sorting code identifies the post office at which the post box is located in.
 
         :param sorting_code: The sorting_code of this CustomerPostalAddressCreate.
         :type: str
         """
         if sorting_code is not None and len(sorting_code) > 100:
             raise ValueError("Invalid value for `sorting_code`, length must be less than or equal to `100`")
 
         self._sorting_code = sorting_code
     
     @property
     def street(self):
         """Gets the street of this CustomerPostalAddressCreate.
 
-            The street or PO Box.
+            
 
         :return: The street of this CustomerPostalAddressCreate.
         :rtype: str
         """
         return self._street
 
     @street.setter
     def street(self, street):
         """Sets the street of this CustomerPostalAddressCreate.
 
-            The street or PO Box.
+            
 
         :param street: The street of this CustomerPostalAddressCreate.
         :type: str
         """
         if street is not None and len(street) > 300:
             raise ValueError("Invalid value for `street`, length must be less than or equal to `300`")
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/debt_collection_case.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/debt_collection_case.py`

 * *Files 4% similar despite different names*

```diff
@@ -231,26 +231,26 @@
 
         self._contract_date = contract_date
     
     @property
     def created_on(self):
         """Gets the created_on of this DebtCollectionCase.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :return: The created_on of this DebtCollectionCase.
         :rtype: datetime
         """
         return self._created_on
 
     @created_on.setter
     def created_on(self, created_on):
         """Sets the created_on of this DebtCollectionCase.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :param created_on: The created_on of this DebtCollectionCase.
         :type: datetime
         """
 
         self._created_on = created_on
     
@@ -415,26 +415,26 @@
 
         self._failure_reason = failure_reason
     
     @property
     def id(self):
         """Gets the id of this DebtCollectionCase.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this DebtCollectionCase.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this DebtCollectionCase.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this DebtCollectionCase.
         :type: int
         """
 
         self._id = id
     
@@ -507,26 +507,26 @@
 
         self._line_items = line_items
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this DebtCollectionCase.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this DebtCollectionCase.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this DebtCollectionCase.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this DebtCollectionCase.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -553,26 +553,26 @@
 
         self._next_attempt_on = next_attempt_on
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this DebtCollectionCase.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this DebtCollectionCase.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this DebtCollectionCase.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this DebtCollectionCase.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -783,49 +783,49 @@
 
         self._space_view_id = space_view_id
     
     @property
     def state(self):
         """Gets the state of this DebtCollectionCase.
 
-            The object's current state.
+            
 
         :return: The state of this DebtCollectionCase.
         :rtype: DebtCollectionCaseState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this DebtCollectionCase.
 
-            The object's current state.
+            
 
         :param state: The state of this DebtCollectionCase.
         :type: DebtCollectionCaseState
         """
 
         self._state = state
     
     @property
     def version(self):
         """Gets the version of this DebtCollectionCase.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this DebtCollectionCase.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this DebtCollectionCase.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this DebtCollectionCase.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/debt_collection_case_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/debt_collection_case_create.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/debt_collection_case_document.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/debt_collection_case_document.py`

 * *Files 9% similar despite different names*

```diff
@@ -56,26 +56,26 @@
         
 
     
     @property
     def created_on(self):
         """Gets the created_on of this DebtCollectionCaseDocument.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :return: The created_on of this DebtCollectionCaseDocument.
         :rtype: datetime
         """
         return self._created_on
 
     @created_on.setter
     def created_on(self, created_on):
         """Sets the created_on of this DebtCollectionCaseDocument.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :param created_on: The created_on of this DebtCollectionCaseDocument.
         :type: datetime
         """
 
         self._created_on = created_on
     
@@ -127,26 +127,26 @@
 
         self._file_name = file_name
     
     @property
     def id(self):
         """Gets the id of this DebtCollectionCaseDocument.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this DebtCollectionCaseDocument.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this DebtCollectionCaseDocument.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this DebtCollectionCaseDocument.
         :type: int
         """
 
         self._id = id
     
@@ -173,26 +173,26 @@
 
         self._labels = labels
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this DebtCollectionCaseDocument.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this DebtCollectionCaseDocument.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this DebtCollectionCaseDocument.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this DebtCollectionCaseDocument.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -219,26 +219,26 @@
 
         self._mime_type = mime_type
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this DebtCollectionCaseDocument.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this DebtCollectionCaseDocument.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this DebtCollectionCaseDocument.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this DebtCollectionCaseDocument.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -292,26 +292,26 @@
 
         self._unique_id = unique_id
     
     @property
     def version(self):
         """Gets the version of this DebtCollectionCaseDocument.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this DebtCollectionCaseDocument.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this DebtCollectionCaseDocument.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this DebtCollectionCaseDocument.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/debt_collection_case_source.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/debt_collection_case_source.py`

 * *Files 10% similar despite different names*

```diff
@@ -35,26 +35,26 @@
         
 
     
     @property
     def description(self):
         """Gets the description of this DebtCollectionCaseSource.
 
-            The localized description of the object.
+            
 
         :return: The description of this DebtCollectionCaseSource.
         :rtype: dict(str, str)
         """
         return self._description
 
     @description.setter
     def description(self, description):
         """Sets the description of this DebtCollectionCaseSource.
 
-            The localized description of the object.
+            
 
         :param description: The description of this DebtCollectionCaseSource.
         :type: dict(str, str)
         """
 
         self._description = description
     
@@ -81,49 +81,49 @@
 
         self._forced_preparing_state = forced_preparing_state
     
     @property
     def id(self):
         """Gets the id of this DebtCollectionCaseSource.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this DebtCollectionCaseSource.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this DebtCollectionCaseSource.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this DebtCollectionCaseSource.
         :type: int
         """
 
         self._id = id
     
     @property
     def name(self):
         """Gets the name of this DebtCollectionCaseSource.
 
-            The localized name of the object.
+            
 
         :return: The name of this DebtCollectionCaseSource.
         :rtype: dict(str, str)
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this DebtCollectionCaseSource.
 
-            The localized name of the object.
+            
 
         :param name: The name of this DebtCollectionCaseSource.
         :type: dict(str, str)
         """
 
         self._name = name
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/debt_collection_case_update.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/debt_collection_case_update.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/debt_collection_receipt.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/debt_collection_receipt.py`

 * *Files 8% similar despite different names*

```diff
@@ -99,26 +99,26 @@
 
         self._created_by = created_by
     
     @property
     def created_on(self):
         """Gets the created_on of this DebtCollectionReceipt.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :return: The created_on of this DebtCollectionReceipt.
         :rtype: datetime
         """
         return self._created_on
 
     @created_on.setter
     def created_on(self, created_on):
         """Sets the created_on of this DebtCollectionReceipt.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :param created_on: The created_on of this DebtCollectionReceipt.
         :type: datetime
         """
 
         self._created_on = created_on
     
@@ -172,72 +172,72 @@
 
         self._external_id = external_id
     
     @property
     def id(self):
         """Gets the id of this DebtCollectionReceipt.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this DebtCollectionReceipt.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this DebtCollectionReceipt.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this DebtCollectionReceipt.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this DebtCollectionReceipt.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this DebtCollectionReceipt.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this DebtCollectionReceipt.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this DebtCollectionReceipt.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this DebtCollectionReceipt.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this DebtCollectionReceipt.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this DebtCollectionReceipt.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this DebtCollectionReceipt.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -264,26 +264,26 @@
 
         self._source = source
     
     @property
     def version(self):
         """Gets the version of this DebtCollectionReceipt.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this DebtCollectionReceipt.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this DebtCollectionReceipt.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this DebtCollectionReceipt.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/debt_collection_receipt_source.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/static_value.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,105 +1,131 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
 
 
 
-class DebtCollectionReceiptSource:
+class StaticValue:
 
     swagger_types = {
     
         'description': 'dict(str, str)',
+        'features': 'list[int]',
         'id': 'int',
         'name': 'dict(str, str)',
     }
 
     attribute_map = {
-        'description': 'description','id': 'id','name': 'name',
+        'description': 'description','features': 'features','id': 'id','name': 'name',
     }
 
     
     _description = None
+    _features = None
     _id = None
     _name = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
         self.description = kwargs.get('description', None)
+        self.features = kwargs.get('features', None)
         self.id = kwargs.get('id', None)
         self.name = kwargs.get('name', None)
         
 
     
     @property
     def description(self):
-        """Gets the description of this DebtCollectionReceiptSource.
+        """Gets the description of this StaticValue.
 
-            The localized description of the object.
+            
 
-        :return: The description of this DebtCollectionReceiptSource.
+        :return: The description of this StaticValue.
         :rtype: dict(str, str)
         """
         return self._description
 
     @description.setter
     def description(self, description):
-        """Sets the description of this DebtCollectionReceiptSource.
+        """Sets the description of this StaticValue.
 
-            The localized description of the object.
+            
 
-        :param description: The description of this DebtCollectionReceiptSource.
+        :param description: The description of this StaticValue.
         :type: dict(str, str)
         """
 
         self._description = description
     
     @property
+    def features(self):
+        """Gets the features of this StaticValue.
+
+            
+
+        :return: The features of this StaticValue.
+        :rtype: list[int]
+        """
+        return self._features
+
+    @features.setter
+    def features(self, features):
+        """Sets the features of this StaticValue.
+
+            
+
+        :param features: The features of this StaticValue.
+        :type: list[int]
+        """
+
+        self._features = features
+    
+    @property
     def id(self):
-        """Gets the id of this DebtCollectionReceiptSource.
+        """Gets the id of this StaticValue.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
-        :return: The id of this DebtCollectionReceiptSource.
+        :return: The id of this StaticValue.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
-        """Sets the id of this DebtCollectionReceiptSource.
+        """Sets the id of this StaticValue.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
-        :param id: The id of this DebtCollectionReceiptSource.
+        :param id: The id of this StaticValue.
         :type: int
         """
 
         self._id = id
     
     @property
     def name(self):
-        """Gets the name of this DebtCollectionReceiptSource.
+        """Gets the name of this StaticValue.
 
-            The localized name of the object.
+            
 
-        :return: The name of this DebtCollectionReceiptSource.
+        :return: The name of this StaticValue.
         :rtype: dict(str, str)
         """
         return self._name
 
     @name.setter
     def name(self, name):
-        """Sets the name of this DebtCollectionReceiptSource.
+        """Sets the name of this StaticValue.
 
-            The localized name of the object.
+            
 
-        :param name: The name of this DebtCollectionReceiptSource.
+        :param name: The name of this StaticValue.
         :type: dict(str, str)
         """
 
         self._name = name
     
 
     def to_dict(self):
@@ -120,27 +146,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(DebtCollectionReceiptSource, dict):
+        if issubclass(StaticValue, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, DebtCollectionReceiptSource):
+        if not isinstance(other, StaticValue):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/debt_collector.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_terminal_receipt_type.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
 
 
 
-class DebtCollector:
+class PaymentTerminalReceiptType:
 
     swagger_types = {
     
         'description': 'dict(str, str)',
         'id': 'int',
         'name': 'dict(str, str)',
     }
@@ -30,76 +30,76 @@
         self.id = kwargs.get('id', None)
         self.name = kwargs.get('name', None)
         
 
     
     @property
     def description(self):
-        """Gets the description of this DebtCollector.
+        """Gets the description of this PaymentTerminalReceiptType.
 
-            The localized description of the object.
+            
 
-        :return: The description of this DebtCollector.
+        :return: The description of this PaymentTerminalReceiptType.
         :rtype: dict(str, str)
         """
         return self._description
 
     @description.setter
     def description(self, description):
-        """Sets the description of this DebtCollector.
+        """Sets the description of this PaymentTerminalReceiptType.
 
-            The localized description of the object.
+            
 
-        :param description: The description of this DebtCollector.
+        :param description: The description of this PaymentTerminalReceiptType.
         :type: dict(str, str)
         """
 
         self._description = description
     
     @property
     def id(self):
-        """Gets the id of this DebtCollector.
+        """Gets the id of this PaymentTerminalReceiptType.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
-        :return: The id of this DebtCollector.
+        :return: The id of this PaymentTerminalReceiptType.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
-        """Sets the id of this DebtCollector.
+        """Sets the id of this PaymentTerminalReceiptType.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
-        :param id: The id of this DebtCollector.
+        :param id: The id of this PaymentTerminalReceiptType.
         :type: int
         """
 
         self._id = id
     
     @property
     def name(self):
-        """Gets the name of this DebtCollector.
+        """Gets the name of this PaymentTerminalReceiptType.
 
-            The localized name of the object.
+            
 
-        :return: The name of this DebtCollector.
+        :return: The name of this PaymentTerminalReceiptType.
         :rtype: dict(str, str)
         """
         return self._name
 
     @name.setter
     def name(self, name):
-        """Sets the name of this DebtCollector.
+        """Sets the name of this PaymentTerminalReceiptType.
 
-            The localized name of the object.
+            
 
-        :param name: The name of this DebtCollector.
+        :param name: The name of this PaymentTerminalReceiptType.
         :type: dict(str, str)
         """
 
         self._name = name
     
 
     def to_dict(self):
@@ -120,27 +120,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(DebtCollector, dict):
+        if issubclass(PaymentTerminalReceiptType, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, DebtCollector):
+        if not isinstance(other, PaymentTerminalReceiptType):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/debt_collector_condition.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/debt_collector_condition.py`

 * *Files 14% similar despite different names*

```diff
@@ -44,49 +44,49 @@
         
 
     
     @property
     def id(self):
         """Gets the id of this DebtCollectorCondition.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this DebtCollectorCondition.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this DebtCollectorCondition.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this DebtCollectorCondition.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this DebtCollectorCondition.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this DebtCollectorCondition.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this DebtCollectorCondition.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this DebtCollectorCondition.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -115,49 +115,49 @@
 
         self._name = name
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this DebtCollectorCondition.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this DebtCollectorCondition.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this DebtCollectorCondition.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this DebtCollectorCondition.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
     @property
     def state(self):
         """Gets the state of this DebtCollectorCondition.
 
-            The object's current state.
+            
 
         :return: The state of this DebtCollectorCondition.
         :rtype: CreationEntityState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this DebtCollectorCondition.
 
-            The object's current state.
+            
 
         :param state: The state of this DebtCollectorCondition.
         :type: CreationEntityState
         """
 
         self._state = state
     
@@ -184,26 +184,26 @@
 
         self._type = type
     
     @property
     def version(self):
         """Gets the version of this DebtCollectorCondition.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this DebtCollectorCondition.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this DebtCollectorCondition.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this DebtCollectorCondition.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/debt_collector_condition_type.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/debt_collector_condition_type.py`

 * *Files 11% similar despite different names*

```diff
@@ -32,72 +32,72 @@
         
 
     
     @property
     def description(self):
         """Gets the description of this DebtCollectorConditionType.
 
-            The localized description of the object.
+            
 
         :return: The description of this DebtCollectorConditionType.
         :rtype: dict(str, str)
         """
         return self._description
 
     @description.setter
     def description(self, description):
         """Sets the description of this DebtCollectorConditionType.
 
-            The localized description of the object.
+            
 
         :param description: The description of this DebtCollectorConditionType.
         :type: dict(str, str)
         """
 
         self._description = description
     
     @property
     def id(self):
         """Gets the id of this DebtCollectorConditionType.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this DebtCollectorConditionType.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this DebtCollectorConditionType.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this DebtCollectorConditionType.
         :type: int
         """
 
         self._id = id
     
     @property
     def name(self):
         """Gets the name of this DebtCollectorConditionType.
 
-            The localized name of the object.
+            
 
         :return: The name of this DebtCollectorConditionType.
         :rtype: dict(str, str)
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this DebtCollectorConditionType.
 
-            The localized name of the object.
+            
 
         :param name: The name of this DebtCollectorConditionType.
         :type: dict(str, str)
         """
 
         self._name = name
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/debt_collector_configuration.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/debt_collector_configuration.py`

 * *Files 11% similar despite different names*

```diff
@@ -125,49 +125,49 @@
 
         self._enabled_space_views = enabled_space_views
     
     @property
     def id(self):
         """Gets the id of this DebtCollectorConfiguration.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this DebtCollectorConfiguration.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this DebtCollectorConfiguration.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this DebtCollectorConfiguration.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this DebtCollectorConfiguration.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this DebtCollectorConfiguration.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this DebtCollectorConfiguration.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this DebtCollectorConfiguration.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -196,26 +196,26 @@
 
         self._name = name
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this DebtCollectorConfiguration.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this DebtCollectorConfiguration.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this DebtCollectorConfiguration.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this DebtCollectorConfiguration.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -265,49 +265,49 @@
 
         self._skip_review_enabled = skip_review_enabled
     
     @property
     def state(self):
         """Gets the state of this DebtCollectorConfiguration.
 
-            The object's current state.
+            
 
         :return: The state of this DebtCollectorConfiguration.
         :rtype: CreationEntityState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this DebtCollectorConfiguration.
 
-            The object's current state.
+            
 
         :param state: The state of this DebtCollectorConfiguration.
         :type: CreationEntityState
         """
 
         self._state = state
     
     @property
     def version(self):
         """Gets the version of this DebtCollectorConfiguration.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this DebtCollectorConfiguration.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this DebtCollectorConfiguration.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this DebtCollectorConfiguration.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/delivery_indication.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/delivery_indication.py`

 * *Files 4% similar despite different names*

```diff
@@ -127,26 +127,26 @@
 
         self._completion = completion
     
     @property
     def created_on(self):
         """Gets the created_on of this DeliveryIndication.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :return: The created_on of this DeliveryIndication.
         :rtype: datetime
         """
         return self._created_on
 
     @created_on.setter
     def created_on(self, created_on):
         """Sets the created_on of this DeliveryIndication.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :param created_on: The created_on of this DeliveryIndication.
         :type: datetime
         """
 
         self._created_on = created_on
     
@@ -219,49 +219,49 @@
 
         self._manually_decided_on = manually_decided_on
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this DeliveryIndication.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this DeliveryIndication.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this DeliveryIndication.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this DeliveryIndication.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
     @property
     def state(self):
         """Gets the state of this DeliveryIndication.
 
-            The object's current state.
+            
 
         :return: The state of this DeliveryIndication.
         :rtype: DeliveryIndicationState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this DeliveryIndication.
 
-            The object's current state.
+            
 
         :param state: The state of this DeliveryIndication.
         :type: DeliveryIndicationState
         """
 
         self._state = state
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/delivery_indication_decision_reason.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/delivery_indication_decision_reason.py`

 * *Files 15% similar despite different names*

```diff
@@ -32,72 +32,72 @@
         
 
     
     @property
     def description(self):
         """Gets the description of this DeliveryIndicationDecisionReason.
 
-            The localized description of the object.
+            
 
         :return: The description of this DeliveryIndicationDecisionReason.
         :rtype: dict(str, str)
         """
         return self._description
 
     @description.setter
     def description(self, description):
         """Sets the description of this DeliveryIndicationDecisionReason.
 
-            The localized description of the object.
+            
 
         :param description: The description of this DeliveryIndicationDecisionReason.
         :type: dict(str, str)
         """
 
         self._description = description
     
     @property
     def id(self):
         """Gets the id of this DeliveryIndicationDecisionReason.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this DeliveryIndicationDecisionReason.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this DeliveryIndicationDecisionReason.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this DeliveryIndicationDecisionReason.
         :type: int
         """
 
         self._id = id
     
     @property
     def name(self):
         """Gets the name of this DeliveryIndicationDecisionReason.
 
-            The localized name of the object.
+            
 
         :return: The name of this DeliveryIndicationDecisionReason.
         :rtype: dict(str, str)
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this DeliveryIndicationDecisionReason.
 
-            The localized name of the object.
+            
 
         :param name: The name of this DeliveryIndicationDecisionReason.
         :type: dict(str, str)
         """
 
         self._name = name
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/document_template.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/document_template.py`

 * *Files 8% similar despite different names*

```diff
@@ -102,49 +102,49 @@
 
         self._delivery_enabled = delivery_enabled
     
     @property
     def id(self):
         """Gets the id of this DocumentTemplate.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this DocumentTemplate.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this DocumentTemplate.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this DocumentTemplate.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this DocumentTemplate.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this DocumentTemplate.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this DocumentTemplate.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this DocumentTemplate.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -173,26 +173,26 @@
 
         self._name = name
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this DocumentTemplate.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this DocumentTemplate.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this DocumentTemplate.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this DocumentTemplate.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -219,26 +219,26 @@
 
         self._space_id = space_id
     
     @property
     def state(self):
         """Gets the state of this DocumentTemplate.
 
-            The object's current state.
+            
 
         :return: The state of this DocumentTemplate.
         :rtype: CreationEntityState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this DocumentTemplate.
 
-            The object's current state.
+            
 
         :param state: The state of this DocumentTemplate.
         :type: CreationEntityState
         """
 
         self._state = state
     
@@ -288,26 +288,26 @@
 
         self._type = type
     
     @property
     def version(self):
         """Gets the version of this DocumentTemplate.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this DocumentTemplate.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this DocumentTemplate.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this DocumentTemplate.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/document_template_type.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/document_template_type.py`

 * *Files 4% similar despite different names*

```diff
@@ -107,26 +107,26 @@
 
         self._group = group
     
     @property
     def id(self):
         """Gets the id of this DocumentTemplateType.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this DocumentTemplateType.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this DocumentTemplateType.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this DocumentTemplateType.
         :type: int
         """
 
         self._id = id
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/document_template_type_group.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/document_template_type_group.py`

 * *Files 10% similar despite different names*

```diff
@@ -29,26 +29,26 @@
         
 
     
     @property
     def id(self):
         """Gets the id of this DocumentTemplateTypeGroup.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this DocumentTemplateTypeGroup.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this DocumentTemplateTypeGroup.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this DocumentTemplateTypeGroup.
         :type: int
         """
 
         self._id = id
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/entity_export_request.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/entity_export_request.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/entity_query.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/entity_query.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/entity_query_filter.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/entity_query_filter.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/entity_query_order_by.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/entity_query_order_by.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/external_transfer_bank_transaction.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/external_transfer_bank_transaction.py`

 * *Files 9% similar despite different names*

```diff
@@ -136,72 +136,72 @@
 
         self._external_bank_name = external_bank_name
     
     @property
     def id(self):
         """Gets the id of this ExternalTransferBankTransaction.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this ExternalTransferBankTransaction.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this ExternalTransferBankTransaction.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this ExternalTransferBankTransaction.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this ExternalTransferBankTransaction.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this ExternalTransferBankTransaction.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this ExternalTransferBankTransaction.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this ExternalTransferBankTransaction.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
     @property
     def version(self):
         """Gets the version of this ExternalTransferBankTransaction.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this ExternalTransferBankTransaction.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this ExternalTransferBankTransaction.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this ExternalTransferBankTransaction.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/failure_reason.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/failure_reason.py`

 * *Files 4% similar despite different names*

```diff
@@ -61,26 +61,26 @@
 
         self._category = category
     
     @property
     def description(self):
         """Gets the description of this FailureReason.
 
-            The localized description of the object.
+            
 
         :return: The description of this FailureReason.
         :rtype: dict(str, str)
         """
         return self._description
 
     @description.setter
     def description(self, description):
         """Sets the description of this FailureReason.
 
-            The localized description of the object.
+            
 
         :param description: The description of this FailureReason.
         :type: dict(str, str)
         """
 
         self._description = description
     
@@ -107,49 +107,49 @@
 
         self._features = features
     
     @property
     def id(self):
         """Gets the id of this FailureReason.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this FailureReason.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this FailureReason.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this FailureReason.
         :type: int
         """
 
         self._id = id
     
     @property
     def name(self):
         """Gets the name of this FailureReason.
 
-            The localized name of the object.
+            
 
         :return: The name of this FailureReason.
         :rtype: dict(str, str)
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this FailureReason.
 
-            The localized name of the object.
+            
 
         :param name: The name of this FailureReason.
         :type: dict(str, str)
         """
 
         self._name = name
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/feature.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/feature.py`

 * *Files 6% similar despite different names*

```diff
@@ -50,187 +50,187 @@
         
 
     
     @property
     def beta(self):
         """Gets the beta of this Feature.
 
-            Whether the feature is in beta stage and there may still be some issues.
+            
 
         :return: The beta of this Feature.
         :rtype: bool
         """
         return self._beta
 
     @beta.setter
     def beta(self, beta):
         """Sets the beta of this Feature.
 
-            Whether the feature is in beta stage and there may still be some issues.
+            
 
         :param beta: The beta of this Feature.
         :type: bool
         """
 
         self._beta = beta
     
     @property
     def category(self):
         """Gets the category of this Feature.
 
-            The category that the feature belongs to.
+            
 
         :return: The category of this Feature.
         :rtype: FeatureCategory
         """
         return self._category
 
     @category.setter
     def category(self, category):
         """Sets the category of this Feature.
 
-            The category that the feature belongs to.
+            
 
         :param category: The category of this Feature.
         :type: FeatureCategory
         """
 
         self._category = category
     
     @property
     def description(self):
         """Gets the description of this Feature.
 
-            The localized description of the object.
+            
 
         :return: The description of this Feature.
         :rtype: dict(str, str)
         """
         return self._description
 
     @description.setter
     def description(self, description):
         """Sets the description of this Feature.
 
-            The localized description of the object.
+            
 
         :param description: The description of this Feature.
         :type: dict(str, str)
         """
 
         self._description = description
     
     @property
     def id(self):
         """Gets the id of this Feature.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this Feature.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this Feature.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this Feature.
         :type: int
         """
 
         self._id = id
     
     @property
     def logo_path(self):
         """Gets the logo_path of this Feature.
 
-            The path to the feature's logo image.
+            
 
         :return: The logo_path of this Feature.
         :rtype: str
         """
         return self._logo_path
 
     @logo_path.setter
     def logo_path(self, logo_path):
         """Sets the logo_path of this Feature.
 
-            The path to the feature's logo image.
+            
 
         :param logo_path: The logo_path of this Feature.
         :type: str
         """
 
         self._logo_path = logo_path
     
     @property
     def name(self):
         """Gets the name of this Feature.
 
-            The localized name of the object.
+            
 
         :return: The name of this Feature.
         :rtype: dict(str, str)
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this Feature.
 
-            The localized name of the object.
+            
 
         :param name: The name of this Feature.
         :type: dict(str, str)
         """
 
         self._name = name
     
     @property
     def required_features(self):
         """Gets the required_features of this Feature.
 
-            The features that must be enabled for this feature to work properly.
+            
 
         :return: The required_features of this Feature.
         :rtype: list[int]
         """
         return self._required_features
 
     @required_features.setter
     def required_features(self, required_features):
         """Sets the required_features of this Feature.
 
-            The features that must be enabled for this feature to work properly.
+            
 
         :param required_features: The required_features of this Feature.
         :type: list[int]
         """
 
         self._required_features = required_features
     
     @property
     def sort_order(self):
         """Gets the sort_order of this Feature.
 
-            When listing features, they can be sorted by this number.
+            
 
         :return: The sort_order of this Feature.
         :rtype: int
         """
         return self._sort_order
 
     @sort_order.setter
     def sort_order(self, sort_order):
         """Sets the sort_order of this Feature.
 
-            When listing features, they can be sorted by this number.
+            
 
         :param sort_order: The sort_order of this Feature.
         :type: int
         """
 
         self._sort_order = sort_order
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/feature_category.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/feature_category.py`

 * *Files 16% similar despite different names*

```diff
@@ -35,95 +35,95 @@
         
 
     
     @property
     def description(self):
         """Gets the description of this FeatureCategory.
 
-            The localized description of the object.
+            
 
         :return: The description of this FeatureCategory.
         :rtype: dict(str, str)
         """
         return self._description
 
     @description.setter
     def description(self, description):
         """Sets the description of this FeatureCategory.
 
-            The localized description of the object.
+            
 
         :param description: The description of this FeatureCategory.
         :type: dict(str, str)
         """
 
         self._description = description
     
     @property
     def id(self):
         """Gets the id of this FeatureCategory.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this FeatureCategory.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this FeatureCategory.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this FeatureCategory.
         :type: int
         """
 
         self._id = id
     
     @property
     def name(self):
         """Gets the name of this FeatureCategory.
 
-            The localized name of the object.
+            
 
         :return: The name of this FeatureCategory.
         :rtype: dict(str, str)
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this FeatureCategory.
 
-            The localized name of the object.
+            
 
         :param name: The name of this FeatureCategory.
         :type: dict(str, str)
         """
 
         self._name = name
     
     @property
     def order_weight(self):
         """Gets the order_weight of this FeatureCategory.
 
-            When listing feature categories, they can be sorted by this number.
+            
 
         :return: The order_weight of this FeatureCategory.
         :rtype: int
         """
         return self._order_weight
 
     @order_weight.setter
     def order_weight(self, order_weight):
         """Sets the order_weight of this FeatureCategory.
 
-            When listing feature categories, they can be sorted by this number.
+            
 
         :param order_weight: The order_weight of this FeatureCategory.
         :type: int
         """
 
         self._order_weight = order_weight
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/human_user.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/human_user.py`

 * *Files 24% similar despite different names*

```diff
@@ -12,16 +12,16 @@
         'email_address': 'str',
         'email_address_verified': 'bool',
         'firstname': 'str',
         'language': 'str',
         'lastname': 'str',
         'mobile_phone_number': 'str',
         'mobile_phone_verified': 'bool',
-        'primary_account': 'int',
-        'scope': 'int',
+        'primary_account': 'Account',
+        'scope': 'Scope',
         'time_zone': 'str',
         'two_factor_enabled': 'bool',
         'two_factor_type': 'TwoFactorAuthenticationType',
     }
 
     attribute_map = {
         'email_address': 'emailAddress','email_address_verified': 'emailAddressVerified','firstname': 'firstname','language': 'language','lastname': 'lastname','mobile_phone_number': 'mobilePhoneNumber','mobile_phone_verified': 'mobilePhoneVerified','primary_account': 'primaryAccount','scope': 'scope','time_zone': 'timeZone','two_factor_enabled': 'twoFactorEnabled','two_factor_type': 'twoFactorType',
@@ -59,287 +59,287 @@
         
 
     
     @property
     def email_address(self):
         """Gets the email_address of this HumanUser.
 
-            The user's email address.
+            The email address of the user.
 
         :return: The email_address of this HumanUser.
         :rtype: str
         """
         return self._email_address
 
     @email_address.setter
     def email_address(self, email_address):
         """Sets the email_address of this HumanUser.
 
-            The user's email address.
+            The email address of the user.
 
         :param email_address: The email_address of this HumanUser.
         :type: str
         """
         if email_address is not None and len(email_address) > 128:
             raise ValueError("Invalid value for `email_address`, length must be less than or equal to `128`")
 
         self._email_address = email_address
     
     @property
     def email_address_verified(self):
         """Gets the email_address_verified of this HumanUser.
 
-            Whether the user's email address has been verified.
+            Defines whether a user is verified or not.
 
         :return: The email_address_verified of this HumanUser.
         :rtype: bool
         """
         return self._email_address_verified
 
     @email_address_verified.setter
     def email_address_verified(self, email_address_verified):
         """Sets the email_address_verified of this HumanUser.
 
-            Whether the user's email address has been verified.
+            Defines whether a user is verified or not.
 
         :param email_address_verified: The email_address_verified of this HumanUser.
         :type: bool
         """
 
         self._email_address_verified = email_address_verified
     
     @property
     def firstname(self):
         """Gets the firstname of this HumanUser.
 
-            The user's first name.
+            The first name of the user.
 
         :return: The firstname of this HumanUser.
         :rtype: str
         """
         return self._firstname
 
     @firstname.setter
     def firstname(self, firstname):
         """Sets the firstname of this HumanUser.
 
-            The user's first name.
+            The first name of the user.
 
         :param firstname: The firstname of this HumanUser.
         :type: str
         """
         if firstname is not None and len(firstname) > 100:
             raise ValueError("Invalid value for `firstname`, length must be less than or equal to `100`")
 
         self._firstname = firstname
     
     @property
     def language(self):
         """Gets the language of this HumanUser.
 
-            The user's preferred language.
+            The preferred language of the user.
 
         :return: The language of this HumanUser.
         :rtype: str
         """
         return self._language
 
     @language.setter
     def language(self, language):
         """Sets the language of this HumanUser.
 
-            The user's preferred language.
+            The preferred language of the user.
 
         :param language: The language of this HumanUser.
         :type: str
         """
 
         self._language = language
     
     @property
     def lastname(self):
         """Gets the lastname of this HumanUser.
 
-            The user's last name.
+            The last name of the user.
 
         :return: The lastname of this HumanUser.
         :rtype: str
         """
         return self._lastname
 
     @lastname.setter
     def lastname(self, lastname):
         """Sets the lastname of this HumanUser.
 
-            The user's last name.
+            The last name of the user.
 
         :param lastname: The lastname of this HumanUser.
         :type: str
         """
         if lastname is not None and len(lastname) > 100:
             raise ValueError("Invalid value for `lastname`, length must be less than or equal to `100`")
 
         self._lastname = lastname
     
     @property
     def mobile_phone_number(self):
         """Gets the mobile_phone_number of this HumanUser.
 
-            The user's mobile phone number.
+            
 
         :return: The mobile_phone_number of this HumanUser.
         :rtype: str
         """
         return self._mobile_phone_number
 
     @mobile_phone_number.setter
     def mobile_phone_number(self, mobile_phone_number):
         """Sets the mobile_phone_number of this HumanUser.
 
-            The user's mobile phone number.
+            
 
         :param mobile_phone_number: The mobile_phone_number of this HumanUser.
         :type: str
         """
         if mobile_phone_number is not None and len(mobile_phone_number) > 30:
             raise ValueError("Invalid value for `mobile_phone_number`, length must be less than or equal to `30`")
 
         self._mobile_phone_number = mobile_phone_number
     
     @property
     def mobile_phone_verified(self):
         """Gets the mobile_phone_verified of this HumanUser.
 
-            Whether the user's mobile phone number has been verified.
+            Defines whether a users mobile phone number is verified or not.
 
         :return: The mobile_phone_verified of this HumanUser.
         :rtype: bool
         """
         return self._mobile_phone_verified
 
     @mobile_phone_verified.setter
     def mobile_phone_verified(self, mobile_phone_verified):
         """Sets the mobile_phone_verified of this HumanUser.
 
-            Whether the user's mobile phone number has been verified.
+            Defines whether a users mobile phone number is verified or not.
 
         :param mobile_phone_verified: The mobile_phone_verified of this HumanUser.
         :type: bool
         """
 
         self._mobile_phone_verified = mobile_phone_verified
     
     @property
     def primary_account(self):
         """Gets the primary_account of this HumanUser.
 
-            The primary account that the user belongs to.
+            The primary account links the user to a specific account.
 
         :return: The primary_account of this HumanUser.
-        :rtype: int
+        :rtype: Account
         """
         return self._primary_account
 
     @primary_account.setter
     def primary_account(self, primary_account):
         """Sets the primary_account of this HumanUser.
 
-            The primary account that the user belongs to.
+            The primary account links the user to a specific account.
 
         :param primary_account: The primary_account of this HumanUser.
-        :type: int
+        :type: Account
         """
 
         self._primary_account = primary_account
     
     @property
     def scope(self):
         """Gets the scope of this HumanUser.
 
-            The scope that the user belongs to.
+            The scope to which the user belongs to.
 
         :return: The scope of this HumanUser.
-        :rtype: int
+        :rtype: Scope
         """
         return self._scope
 
     @scope.setter
     def scope(self, scope):
         """Sets the scope of this HumanUser.
 
-            The scope that the user belongs to.
+            The scope to which the user belongs to.
 
         :param scope: The scope of this HumanUser.
-        :type: int
+        :type: Scope
         """
 
         self._scope = scope
     
     @property
     def time_zone(self):
         """Gets the time_zone of this HumanUser.
 
-            The user's time zone. If none is specified, the one provided by the browser will be used.
+            The time zone which is applied for the user. If no timezone is specified the browser is used to determine an appropriate time zone.
 
         :return: The time_zone of this HumanUser.
         :rtype: str
         """
         return self._time_zone
 
     @time_zone.setter
     def time_zone(self, time_zone):
         """Sets the time_zone of this HumanUser.
 
-            The user's time zone. If none is specified, the one provided by the browser will be used.
+            The time zone which is applied for the user. If no timezone is specified the browser is used to determine an appropriate time zone.
 
         :param time_zone: The time_zone of this HumanUser.
         :type: str
         """
 
         self._time_zone = time_zone
     
     @property
     def two_factor_enabled(self):
         """Gets the two_factor_enabled of this HumanUser.
 
-            Whether two-factor authentication is enabled for this user.
+            Defines whether two-factor authentication is enabled for this user.
 
         :return: The two_factor_enabled of this HumanUser.
         :rtype: bool
         """
         return self._two_factor_enabled
 
     @two_factor_enabled.setter
     def two_factor_enabled(self, two_factor_enabled):
         """Sets the two_factor_enabled of this HumanUser.
 
-            Whether two-factor authentication is enabled for this user.
+            Defines whether two-factor authentication is enabled for this user.
 
         :param two_factor_enabled: The two_factor_enabled of this HumanUser.
         :type: bool
         """
 
         self._two_factor_enabled = two_factor_enabled
     
     @property
     def two_factor_type(self):
         """Gets the two_factor_type of this HumanUser.
 
-            The type of two-factor authentication that is enabled for the user.
+            
 
         :return: The two_factor_type of this HumanUser.
         :rtype: TwoFactorAuthenticationType
         """
         return self._two_factor_type
 
     @two_factor_type.setter
     def two_factor_type(self, two_factor_type):
         """Sets the two_factor_type of this HumanUser.
 
-            The type of two-factor authentication that is enabled for the user.
+            
 
         :param two_factor_type: The two_factor_type of this HumanUser.
         :type: TwoFactorAuthenticationType
         """
 
         self._two_factor_type = two_factor_type
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/human_user_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/line_item_attribute_create.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,59 +1,93 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
-from . import AbstractHumanUserUpdate
 
 
-class HumanUserCreate(AbstractHumanUserUpdate):
+
+class LineItemAttributeCreate:
 
     swagger_types = {
     
-        'primary_account': 'int',
+        'label': 'str',
+        'value': 'str',
     }
 
     attribute_map = {
-        'primary_account': 'primaryAccount',
+        'label': 'label','value': 'value',
     }
 
     
-    _primary_account = None
+    _label = None
+    _value = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
-        self.primary_account = kwargs.get('primary_account', None)
-        super().__init__(**kwargs)
-        self.swagger_types.update(super().swagger_types)
-        self.attribute_map.update(super().attribute_map)
+        self.label = kwargs.get('label')
+
+        self.value = kwargs.get('value')
+
+        
+
+    
+    @property
+    def label(self):
+        """Gets the label of this LineItemAttributeCreate.
+
+            
+
+        :return: The label of this LineItemAttributeCreate.
+        :rtype: str
+        """
+        return self._label
+
+    @label.setter
+    def label(self, label):
+        """Sets the label of this LineItemAttributeCreate.
+
+            
+
+        :param label: The label of this LineItemAttributeCreate.
+        :type: str
+        """
+        if label is None:
+            raise ValueError("Invalid value for `label`, must not be `None`")
+        if label is not None and len(label) > 512:
+            raise ValueError("Invalid value for `label`, length must be less than or equal to `512`")
 
+        self._label = label
     
     @property
-    def primary_account(self):
-        """Gets the primary_account of this HumanUserCreate.
+    def value(self):
+        """Gets the value of this LineItemAttributeCreate.
 
-            The primary account that the user belongs to.
+            
 
-        :return: The primary_account of this HumanUserCreate.
-        :rtype: int
+        :return: The value of this LineItemAttributeCreate.
+        :rtype: str
         """
-        return self._primary_account
+        return self._value
 
-    @primary_account.setter
-    def primary_account(self, primary_account):
-        """Sets the primary_account of this HumanUserCreate.
+    @value.setter
+    def value(self, value):
+        """Sets the value of this LineItemAttributeCreate.
 
-            The primary account that the user belongs to.
+            
 
-        :param primary_account: The primary_account of this HumanUserCreate.
-        :type: int
+        :param value: The value of this LineItemAttributeCreate.
+        :type: str
         """
+        if value is None:
+            raise ValueError("Invalid value for `value`, must not be `None`")
+        if value is not None and len(value) > 512:
+            raise ValueError("Invalid value for `value`, length must be less than or equal to `512`")
 
-        self._primary_account = primary_account
+        self._value = value
     
 
     def to_dict(self):
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
@@ -70,27 +104,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(HumanUserCreate, dict):
+        if issubclass(LineItemAttributeCreate, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, HumanUserCreate):
+        if not isinstance(other, LineItemAttributeCreate):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/human_user_update.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/human_user_update.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/installment_calculated_plan.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/installment_calculated_plan.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/installment_calculated_slice.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/installment_calculated_slice.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/installment_payment.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/installment_payment.py`

 * *Files 10% similar despite different names*

```diff
@@ -50,49 +50,49 @@
         
 
     
     @property
     def created_on(self):
         """Gets the created_on of this InstallmentPayment.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :return: The created_on of this InstallmentPayment.
         :rtype: datetime
         """
         return self._created_on
 
     @created_on.setter
     def created_on(self, created_on):
         """Sets the created_on of this InstallmentPayment.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :param created_on: The created_on of this InstallmentPayment.
         :type: datetime
         """
 
         self._created_on = created_on
     
     @property
     def id(self):
         """Gets the id of this InstallmentPayment.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this InstallmentPayment.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this InstallmentPayment.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this InstallmentPayment.
         :type: int
         """
 
         self._id = id
     
@@ -142,26 +142,26 @@
 
         self._line_items = line_items
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this InstallmentPayment.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this InstallmentPayment.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this InstallmentPayment.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this InstallmentPayment.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -188,72 +188,72 @@
 
         self._plan_configuration = plan_configuration
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this InstallmentPayment.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this InstallmentPayment.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this InstallmentPayment.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this InstallmentPayment.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
     @property
     def state(self):
         """Gets the state of this InstallmentPayment.
 
-            The object's current state.
+            
 
         :return: The state of this InstallmentPayment.
         :rtype: InstallmentPaymentState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this InstallmentPayment.
 
-            The object's current state.
+            
 
         :param state: The state of this InstallmentPayment.
         :type: InstallmentPaymentState
         """
 
         self._state = state
     
     @property
     def version(self):
         """Gets the version of this InstallmentPayment.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this InstallmentPayment.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this InstallmentPayment.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this InstallmentPayment.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/installment_payment_slice.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/installment_payment_slice.py`

 * *Files 6% similar despite different names*

```diff
@@ -72,26 +72,26 @@
 
         self._charge_on = charge_on
     
     @property
     def created_on(self):
         """Gets the created_on of this InstallmentPaymentSlice.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :return: The created_on of this InstallmentPaymentSlice.
         :rtype: datetime
         """
         return self._created_on
 
     @created_on.setter
     def created_on(self, created_on):
         """Sets the created_on of this InstallmentPaymentSlice.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :param created_on: The created_on of this InstallmentPaymentSlice.
         :type: datetime
         """
 
         self._created_on = created_on
     
@@ -141,49 +141,49 @@
 
         self._line_items = line_items
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this InstallmentPaymentSlice.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this InstallmentPaymentSlice.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this InstallmentPaymentSlice.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this InstallmentPaymentSlice.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
     @property
     def state(self):
         """Gets the state of this InstallmentPaymentSlice.
 
-            The object's current state.
+            
 
         :return: The state of this InstallmentPaymentSlice.
         :rtype: InstallmentPaymentSliceState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this InstallmentPaymentSlice.
 
-            The object's current state.
+            
 
         :param state: The state of this InstallmentPaymentSlice.
         :type: InstallmentPaymentSliceState
         """
 
         self._state = state
     
@@ -210,26 +210,26 @@
 
         self._transaction = transaction
     
     @property
     def version(self):
         """Gets the version of this InstallmentPaymentSlice.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this InstallmentPaymentSlice.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this InstallmentPaymentSlice.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this InstallmentPaymentSlice.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/installment_plan_configuration.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/installment_plan_configuration.py`

 * *Files 3% similar despite different names*

```diff
@@ -20,15 +20,15 @@
         'payment_method_configurations': 'list[int]',
         'planned_purge_date': 'datetime',
         'sort_order': 'int',
         'space_reference': 'SpaceReference',
         'state': 'CreationEntityState',
         'tax_class': 'TaxClass',
         'terms_and_conditions': 'ResourcePath',
-        'title': 'dict(str, str)',
+        'title': 'DatabaseTranslatedString',
         'version': 'int',
     }
 
     attribute_map = {
         'base_currency': 'baseCurrency','conditions': 'conditions','id': 'id','installment_fee': 'installmentFee','interest_rate': 'interestRate','linked_space_id': 'linkedSpaceId','minimal_amount': 'minimalAmount','name': 'name','payment_method_configurations': 'paymentMethodConfigurations','planned_purge_date': 'plannedPurgeDate','sort_order': 'sortOrder','space_reference': 'spaceReference','state': 'state','tax_class': 'taxClass','terms_and_conditions': 'termsAndConditions','title': 'title','version': 'version',
     }
 
@@ -120,26 +120,26 @@
 
         self._conditions = conditions
     
     @property
     def id(self):
         """Gets the id of this InstallmentPlanConfiguration.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this InstallmentPlanConfiguration.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this InstallmentPlanConfiguration.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this InstallmentPlanConfiguration.
         :type: int
         """
 
         self._id = id
     
@@ -189,26 +189,26 @@
 
         self._interest_rate = interest_rate
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this InstallmentPlanConfiguration.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this InstallmentPlanConfiguration.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this InstallmentPlanConfiguration.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this InstallmentPlanConfiguration.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -283,26 +283,26 @@
 
         self._payment_method_configurations = payment_method_configurations
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this InstallmentPlanConfiguration.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this InstallmentPlanConfiguration.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this InstallmentPlanConfiguration.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this InstallmentPlanConfiguration.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -352,26 +352,26 @@
 
         self._space_reference = space_reference
     
     @property
     def state(self):
         """Gets the state of this InstallmentPlanConfiguration.
 
-            The object's current state.
+            
 
         :return: The state of this InstallmentPlanConfiguration.
         :rtype: CreationEntityState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this InstallmentPlanConfiguration.
 
-            The object's current state.
+            
 
         :param state: The state of this InstallmentPlanConfiguration.
         :type: CreationEntityState
         """
 
         self._state = state
     
@@ -424,46 +424,46 @@
     @property
     def title(self):
         """Gets the title of this InstallmentPlanConfiguration.
 
             The title of the installment plan is used within the payment process. The title is visible to the buyer.
 
         :return: The title of this InstallmentPlanConfiguration.
-        :rtype: dict(str, str)
+        :rtype: DatabaseTranslatedString
         """
         return self._title
 
     @title.setter
     def title(self, title):
         """Sets the title of this InstallmentPlanConfiguration.
 
             The title of the installment plan is used within the payment process. The title is visible to the buyer.
 
         :param title: The title of this InstallmentPlanConfiguration.
-        :type: dict(str, str)
+        :type: DatabaseTranslatedString
         """
 
         self._title = title
     
     @property
     def version(self):
         """Gets the version of this InstallmentPlanConfiguration.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this InstallmentPlanConfiguration.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this InstallmentPlanConfiguration.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this InstallmentPlanConfiguration.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/installment_plan_slice_configuration.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/installment_plan_slice_configuration.py`

 * *Files 18% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 
 
 class InstallmentPlanSliceConfiguration:
 
     swagger_types = {
     
         'id': 'int',
-        'line_item_title': 'dict(str, str)',
+        'line_item_title': 'DatabaseTranslatedString',
         'linked_space_id': 'int',
         'period': 'str',
         'plan': 'InstallmentPlanConfiguration',
         'planned_purge_date': 'datetime',
         'priority': 'int',
         'proportion': 'float',
         'state': 'CreationEntityState',
@@ -53,72 +53,72 @@
         
 
     
     @property
     def id(self):
         """Gets the id of this InstallmentPlanSliceConfiguration.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this InstallmentPlanSliceConfiguration.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this InstallmentPlanSliceConfiguration.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this InstallmentPlanSliceConfiguration.
         :type: int
         """
 
         self._id = id
     
     @property
     def line_item_title(self):
         """Gets the line_item_title of this InstallmentPlanSliceConfiguration.
 
             The title of this slices line items. The title is visible to the buyer.
 
         :return: The line_item_title of this InstallmentPlanSliceConfiguration.
-        :rtype: dict(str, str)
+        :rtype: DatabaseTranslatedString
         """
         return self._line_item_title
 
     @line_item_title.setter
     def line_item_title(self, line_item_title):
         """Sets the line_item_title of this InstallmentPlanSliceConfiguration.
 
             The title of this slices line items. The title is visible to the buyer.
 
         :param line_item_title: The line_item_title of this InstallmentPlanSliceConfiguration.
-        :type: dict(str, str)
+        :type: DatabaseTranslatedString
         """
 
         self._line_item_title = line_item_title
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this InstallmentPlanSliceConfiguration.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this InstallmentPlanSliceConfiguration.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this InstallmentPlanSliceConfiguration.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this InstallmentPlanSliceConfiguration.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -168,26 +168,26 @@
 
         self._plan = plan
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this InstallmentPlanSliceConfiguration.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this InstallmentPlanSliceConfiguration.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this InstallmentPlanSliceConfiguration.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this InstallmentPlanSliceConfiguration.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -237,49 +237,49 @@
 
         self._proportion = proportion
     
     @property
     def state(self):
         """Gets the state of this InstallmentPlanSliceConfiguration.
 
-            The object's current state.
+            
 
         :return: The state of this InstallmentPlanSliceConfiguration.
         :rtype: CreationEntityState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this InstallmentPlanSliceConfiguration.
 
-            The object's current state.
+            
 
         :param state: The state of this InstallmentPlanSliceConfiguration.
         :type: CreationEntityState
         """
 
         self._state = state
     
     @property
     def version(self):
         """Gets the version of this InstallmentPlanSliceConfiguration.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this InstallmentPlanSliceConfiguration.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this InstallmentPlanSliceConfiguration.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this InstallmentPlanSliceConfiguration.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/internal_transfer_bank_transaction.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/internal_transfer_bank_transaction.py`

 * *Files 8% similar despite different names*

```diff
@@ -38,49 +38,49 @@
         
 
     
     @property
     def id(self):
         """Gets the id of this InternalTransferBankTransaction.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this InternalTransferBankTransaction.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this InternalTransferBankTransaction.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this InternalTransferBankTransaction.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this InternalTransferBankTransaction.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this InternalTransferBankTransaction.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this InternalTransferBankTransaction.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this InternalTransferBankTransaction.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -130,26 +130,26 @@
 
         self._target_bank_transaction = target_bank_transaction
     
     @property
     def version(self):
         """Gets the version of this InternalTransferBankTransaction.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this InternalTransferBankTransaction.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this InternalTransferBankTransaction.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this InternalTransferBankTransaction.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/invoice_reconciliation_record.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_completion.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,817 +1,737 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
 from . import TransactionAwareEntity
 
 
-class InvoiceReconciliationRecord(TransactionAwareEntity):
+class TransactionCompletion(TransactionAwareEntity):
 
     swagger_types = {
     
-        'address': 'str',
         'amount': 'float',
-        'city': 'str',
-        'country': 'str',
+        'base_line_items': 'list[LineItem]',
+        'created_by': 'int',
         'created_on': 'datetime',
-        'currency': 'str',
-        'discarded_by': 'int',
-        'discarded_on': 'datetime',
-        'environment': 'ChargeAttemptEnvironment',
-        'family_name': 'str',
-        'given_name': 'str',
-        'iban': 'str',
-        'last_resolution_failure': 'FailureReason',
-        'participant_number': 'str',
-        'payment_fee_amount': 'float',
-        'payment_fee_currency': 'str',
-        'payment_reason': 'str',
+        'external_id': 'str',
+        'failed_on': 'datetime',
+        'failure_reason': 'FailureReason',
+        'invoice_merchant_reference': 'str',
+        'labels': 'list[Label]',
+        'language': 'str',
+        'last_completion': 'bool',
+        'line_item_version': 'TransactionLineItemVersion',
+        'line_items': 'list[LineItem]',
+        'mode': 'TransactionCompletionMode',
+        'next_update_on': 'datetime',
+        'payment_information': 'str',
         'planned_purge_date': 'datetime',
-        'post_code': 'str',
-        'reference_number': 'str',
-        'rejection_status': 'InvoiceReconciliationRecordRejectionStatus',
-        'resolved_by': 'int',
-        'resolved_on': 'datetime',
-        'sender_bank_account': 'str',
-        'state': 'InvoiceReconciliationRecordState',
-        'street': 'str',
-        'type': 'InvoiceReconciliationRecordType',
-        'unique_id': 'str',
-        'value_date': 'datetime',
+        'processing_on': 'datetime',
+        'processor_reference': 'str',
+        'remaining_line_items': 'list[LineItem]',
+        'space_view_id': 'int',
+        'state': 'TransactionCompletionState',
+        'succeeded_on': 'datetime',
+        'tax_amount': 'float',
+        'time_zone': 'str',
+        'timeout_on': 'datetime',
         'version': 'int',
     }
 
     attribute_map = {
-        'address': 'address','amount': 'amount','city': 'city','country': 'country','created_on': 'createdOn','currency': 'currency','discarded_by': 'discardedBy','discarded_on': 'discardedOn','environment': 'environment','family_name': 'familyName','given_name': 'givenName','iban': 'iban','last_resolution_failure': 'lastResolutionFailure','participant_number': 'participantNumber','payment_fee_amount': 'paymentFeeAmount','payment_fee_currency': 'paymentFeeCurrency','payment_reason': 'paymentReason','planned_purge_date': 'plannedPurgeDate','post_code': 'postCode','reference_number': 'referenceNumber','rejection_status': 'rejectionStatus','resolved_by': 'resolvedBy','resolved_on': 'resolvedOn','sender_bank_account': 'senderBankAccount','state': 'state','street': 'street','type': 'type','unique_id': 'uniqueId','value_date': 'valueDate','version': 'version',
+        'amount': 'amount','base_line_items': 'baseLineItems','created_by': 'createdBy','created_on': 'createdOn','external_id': 'externalId','failed_on': 'failedOn','failure_reason': 'failureReason','invoice_merchant_reference': 'invoiceMerchantReference','labels': 'labels','language': 'language','last_completion': 'lastCompletion','line_item_version': 'lineItemVersion','line_items': 'lineItems','mode': 'mode','next_update_on': 'nextUpdateOn','payment_information': 'paymentInformation','planned_purge_date': 'plannedPurgeDate','processing_on': 'processingOn','processor_reference': 'processorReference','remaining_line_items': 'remainingLineItems','space_view_id': 'spaceViewId','state': 'state','succeeded_on': 'succeededOn','tax_amount': 'taxAmount','time_zone': 'timeZone','timeout_on': 'timeoutOn','version': 'version',
     }
 
     
-    _address = None
     _amount = None
-    _city = None
-    _country = None
+    _base_line_items = None
+    _created_by = None
     _created_on = None
-    _currency = None
-    _discarded_by = None
-    _discarded_on = None
-    _environment = None
-    _family_name = None
-    _given_name = None
-    _iban = None
-    _last_resolution_failure = None
-    _participant_number = None
-    _payment_fee_amount = None
-    _payment_fee_currency = None
-    _payment_reason = None
+    _external_id = None
+    _failed_on = None
+    _failure_reason = None
+    _invoice_merchant_reference = None
+    _labels = None
+    _language = None
+    _last_completion = None
+    _line_item_version = None
+    _line_items = None
+    _mode = None
+    _next_update_on = None
+    _payment_information = None
     _planned_purge_date = None
-    _post_code = None
-    _reference_number = None
-    _rejection_status = None
-    _resolved_by = None
-    _resolved_on = None
-    _sender_bank_account = None
+    _processing_on = None
+    _processor_reference = None
+    _remaining_line_items = None
+    _space_view_id = None
     _state = None
-    _street = None
-    _type = None
-    _unique_id = None
-    _value_date = None
+    _succeeded_on = None
+    _tax_amount = None
+    _time_zone = None
+    _timeout_on = None
     _version = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
-        self.address = kwargs.get('address', None)
         self.amount = kwargs.get('amount', None)
-        self.city = kwargs.get('city', None)
-        self.country = kwargs.get('country', None)
+        self.base_line_items = kwargs.get('base_line_items', None)
+        self.created_by = kwargs.get('created_by', None)
         self.created_on = kwargs.get('created_on', None)
-        self.currency = kwargs.get('currency', None)
-        self.discarded_by = kwargs.get('discarded_by', None)
-        self.discarded_on = kwargs.get('discarded_on', None)
-        self.environment = kwargs.get('environment', None)
-        self.family_name = kwargs.get('family_name', None)
-        self.given_name = kwargs.get('given_name', None)
-        self.iban = kwargs.get('iban', None)
-        self.last_resolution_failure = kwargs.get('last_resolution_failure', None)
-        self.participant_number = kwargs.get('participant_number', None)
-        self.payment_fee_amount = kwargs.get('payment_fee_amount', None)
-        self.payment_fee_currency = kwargs.get('payment_fee_currency', None)
-        self.payment_reason = kwargs.get('payment_reason', None)
+        self.external_id = kwargs.get('external_id', None)
+        self.failed_on = kwargs.get('failed_on', None)
+        self.failure_reason = kwargs.get('failure_reason', None)
+        self.invoice_merchant_reference = kwargs.get('invoice_merchant_reference', None)
+        self.labels = kwargs.get('labels', None)
+        self.language = kwargs.get('language', None)
+        self.last_completion = kwargs.get('last_completion', None)
+        self.line_item_version = kwargs.get('line_item_version', None)
+        self.line_items = kwargs.get('line_items', None)
+        self.mode = kwargs.get('mode', None)
+        self.next_update_on = kwargs.get('next_update_on', None)
+        self.payment_information = kwargs.get('payment_information', None)
         self.planned_purge_date = kwargs.get('planned_purge_date', None)
-        self.post_code = kwargs.get('post_code', None)
-        self.reference_number = kwargs.get('reference_number', None)
-        self.rejection_status = kwargs.get('rejection_status', None)
-        self.resolved_by = kwargs.get('resolved_by', None)
-        self.resolved_on = kwargs.get('resolved_on', None)
-        self.sender_bank_account = kwargs.get('sender_bank_account', None)
+        self.processing_on = kwargs.get('processing_on', None)
+        self.processor_reference = kwargs.get('processor_reference', None)
+        self.remaining_line_items = kwargs.get('remaining_line_items', None)
+        self.space_view_id = kwargs.get('space_view_id', None)
         self.state = kwargs.get('state', None)
-        self.street = kwargs.get('street', None)
-        self.type = kwargs.get('type', None)
-        self.unique_id = kwargs.get('unique_id', None)
-        self.value_date = kwargs.get('value_date', None)
+        self.succeeded_on = kwargs.get('succeeded_on', None)
+        self.tax_amount = kwargs.get('tax_amount', None)
+        self.time_zone = kwargs.get('time_zone', None)
+        self.timeout_on = kwargs.get('timeout_on', None)
         self.version = kwargs.get('version', None)
         super().__init__(**kwargs)
         self.swagger_types.update(super().swagger_types)
         self.attribute_map.update(super().attribute_map)
 
     
     @property
-    def address(self):
-        """Gets the address of this InvoiceReconciliationRecord.
-
-            
-
-        :return: The address of this InvoiceReconciliationRecord.
-        :rtype: str
-        """
-        return self._address
-
-    @address.setter
-    def address(self, address):
-        """Sets the address of this InvoiceReconciliationRecord.
-
-            
-
-        :param address: The address of this InvoiceReconciliationRecord.
-        :type: str
-        """
-
-        self._address = address
-    
-    @property
     def amount(self):
-        """Gets the amount of this InvoiceReconciliationRecord.
+        """Gets the amount of this TransactionCompletion.
 
-            
+            The amount which is captured. The amount represents sum of line items including taxes.
 
-        :return: The amount of this InvoiceReconciliationRecord.
+        :return: The amount of this TransactionCompletion.
         :rtype: float
         """
         return self._amount
 
     @amount.setter
     def amount(self, amount):
-        """Sets the amount of this InvoiceReconciliationRecord.
+        """Sets the amount of this TransactionCompletion.
 
-            
+            The amount which is captured. The amount represents sum of line items including taxes.
 
-        :param amount: The amount of this InvoiceReconciliationRecord.
+        :param amount: The amount of this TransactionCompletion.
         :type: float
         """
 
         self._amount = amount
     
     @property
-    def city(self):
-        """Gets the city of this InvoiceReconciliationRecord.
+    def base_line_items(self):
+        """Gets the base_line_items of this TransactionCompletion.
 
-            
+            The base line items on which the completion is applied on.
 
-        :return: The city of this InvoiceReconciliationRecord.
-        :rtype: str
+        :return: The base_line_items of this TransactionCompletion.
+        :rtype: list[LineItem]
         """
-        return self._city
+        return self._base_line_items
 
-    @city.setter
-    def city(self, city):
-        """Sets the city of this InvoiceReconciliationRecord.
+    @base_line_items.setter
+    def base_line_items(self, base_line_items):
+        """Sets the base_line_items of this TransactionCompletion.
 
-            
+            The base line items on which the completion is applied on.
 
-        :param city: The city of this InvoiceReconciliationRecord.
-        :type: str
+        :param base_line_items: The base_line_items of this TransactionCompletion.
+        :type: list[LineItem]
         """
 
-        self._city = city
+        self._base_line_items = base_line_items
     
     @property
-    def country(self):
-        """Gets the country of this InvoiceReconciliationRecord.
+    def created_by(self):
+        """Gets the created_by of this TransactionCompletion.
 
             
 
-        :return: The country of this InvoiceReconciliationRecord.
-        :rtype: str
+        :return: The created_by of this TransactionCompletion.
+        :rtype: int
         """
-        return self._country
+        return self._created_by
 
-    @country.setter
-    def country(self, country):
-        """Sets the country of this InvoiceReconciliationRecord.
+    @created_by.setter
+    def created_by(self, created_by):
+        """Sets the created_by of this TransactionCompletion.
 
             
 
-        :param country: The country of this InvoiceReconciliationRecord.
-        :type: str
+        :param created_by: The created_by of this TransactionCompletion.
+        :type: int
         """
 
-        self._country = country
+        self._created_by = created_by
     
     @property
     def created_on(self):
-        """Gets the created_on of this InvoiceReconciliationRecord.
+        """Gets the created_on of this TransactionCompletion.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
-        :return: The created_on of this InvoiceReconciliationRecord.
+        :return: The created_on of this TransactionCompletion.
         :rtype: datetime
         """
         return self._created_on
 
     @created_on.setter
     def created_on(self, created_on):
-        """Sets the created_on of this InvoiceReconciliationRecord.
+        """Sets the created_on of this TransactionCompletion.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
-        :param created_on: The created_on of this InvoiceReconciliationRecord.
+        :param created_on: The created_on of this TransactionCompletion.
         :type: datetime
         """
 
         self._created_on = created_on
     
     @property
-    def currency(self):
-        """Gets the currency of this InvoiceReconciliationRecord.
+    def external_id(self):
+        """Gets the external_id of this TransactionCompletion.
 
-            
+            The external ID helps to identify the entity and a subsequent creation of an entity with the same ID will not create a new entity.
 
-        :return: The currency of this InvoiceReconciliationRecord.
+        :return: The external_id of this TransactionCompletion.
         :rtype: str
         """
-        return self._currency
+        return self._external_id
 
-    @currency.setter
-    def currency(self, currency):
-        """Sets the currency of this InvoiceReconciliationRecord.
+    @external_id.setter
+    def external_id(self, external_id):
+        """Sets the external_id of this TransactionCompletion.
 
-            
+            The external ID helps to identify the entity and a subsequent creation of an entity with the same ID will not create a new entity.
 
-        :param currency: The currency of this InvoiceReconciliationRecord.
+        :param external_id: The external_id of this TransactionCompletion.
         :type: str
         """
+        if external_id is not None and len(external_id) > 100:
+            raise ValueError("Invalid value for `external_id`, length must be less than or equal to `100`")
+        if external_id is not None and len(external_id) < 1:
+            raise ValueError("Invalid value for `external_id`, length must be greater than or equal to `1`")
 
-        self._currency = currency
+        self._external_id = external_id
     
     @property
-    def discarded_by(self):
-        """Gets the discarded_by of this InvoiceReconciliationRecord.
+    def failed_on(self):
+        """Gets the failed_on of this TransactionCompletion.
 
             
 
-        :return: The discarded_by of this InvoiceReconciliationRecord.
-        :rtype: int
+        :return: The failed_on of this TransactionCompletion.
+        :rtype: datetime
         """
-        return self._discarded_by
+        return self._failed_on
 
-    @discarded_by.setter
-    def discarded_by(self, discarded_by):
-        """Sets the discarded_by of this InvoiceReconciliationRecord.
+    @failed_on.setter
+    def failed_on(self, failed_on):
+        """Sets the failed_on of this TransactionCompletion.
 
             
 
-        :param discarded_by: The discarded_by of this InvoiceReconciliationRecord.
-        :type: int
+        :param failed_on: The failed_on of this TransactionCompletion.
+        :type: datetime
         """
 
-        self._discarded_by = discarded_by
+        self._failed_on = failed_on
     
     @property
-    def discarded_on(self):
-        """Gets the discarded_on of this InvoiceReconciliationRecord.
+    def failure_reason(self):
+        """Gets the failure_reason of this TransactionCompletion.
 
-            The discarded on date indicates when the bank transaction has been discarded.
+            
 
-        :return: The discarded_on of this InvoiceReconciliationRecord.
-        :rtype: datetime
+        :return: The failure_reason of this TransactionCompletion.
+        :rtype: FailureReason
         """
-        return self._discarded_on
+        return self._failure_reason
 
-    @discarded_on.setter
-    def discarded_on(self, discarded_on):
-        """Sets the discarded_on of this InvoiceReconciliationRecord.
+    @failure_reason.setter
+    def failure_reason(self, failure_reason):
+        """Sets the failure_reason of this TransactionCompletion.
 
-            The discarded on date indicates when the bank transaction has been discarded.
+            
 
-        :param discarded_on: The discarded_on of this InvoiceReconciliationRecord.
-        :type: datetime
+        :param failure_reason: The failure_reason of this TransactionCompletion.
+        :type: FailureReason
         """
 
-        self._discarded_on = discarded_on
+        self._failure_reason = failure_reason
     
     @property
-    def environment(self):
-        """Gets the environment of this InvoiceReconciliationRecord.
+    def invoice_merchant_reference(self):
+        """Gets the invoice_merchant_reference of this TransactionCompletion.
 
             
 
-        :return: The environment of this InvoiceReconciliationRecord.
-        :rtype: ChargeAttemptEnvironment
+        :return: The invoice_merchant_reference of this TransactionCompletion.
+        :rtype: str
         """
-        return self._environment
+        return self._invoice_merchant_reference
 
-    @environment.setter
-    def environment(self, environment):
-        """Sets the environment of this InvoiceReconciliationRecord.
+    @invoice_merchant_reference.setter
+    def invoice_merchant_reference(self, invoice_merchant_reference):
+        """Sets the invoice_merchant_reference of this TransactionCompletion.
 
             
 
-        :param environment: The environment of this InvoiceReconciliationRecord.
-        :type: ChargeAttemptEnvironment
+        :param invoice_merchant_reference: The invoice_merchant_reference of this TransactionCompletion.
+        :type: str
         """
+        if invoice_merchant_reference is not None and len(invoice_merchant_reference) > 100:
+            raise ValueError("Invalid value for `invoice_merchant_reference`, length must be less than or equal to `100`")
 
-        self._environment = environment
+        self._invoice_merchant_reference = invoice_merchant_reference
     
     @property
-    def family_name(self):
-        """Gets the family_name of this InvoiceReconciliationRecord.
+    def labels(self):
+        """Gets the labels of this TransactionCompletion.
 
             
 
-        :return: The family_name of this InvoiceReconciliationRecord.
-        :rtype: str
+        :return: The labels of this TransactionCompletion.
+        :rtype: list[Label]
         """
-        return self._family_name
+        return self._labels
 
-    @family_name.setter
-    def family_name(self, family_name):
-        """Sets the family_name of this InvoiceReconciliationRecord.
+    @labels.setter
+    def labels(self, labels):
+        """Sets the labels of this TransactionCompletion.
 
             
 
-        :param family_name: The family_name of this InvoiceReconciliationRecord.
-        :type: str
+        :param labels: The labels of this TransactionCompletion.
+        :type: list[Label]
         """
 
-        self._family_name = family_name
+        self._labels = labels
     
     @property
-    def given_name(self):
-        """Gets the given_name of this InvoiceReconciliationRecord.
+    def language(self):
+        """Gets the language of this TransactionCompletion.
 
             
 
-        :return: The given_name of this InvoiceReconciliationRecord.
+        :return: The language of this TransactionCompletion.
         :rtype: str
         """
-        return self._given_name
+        return self._language
 
-    @given_name.setter
-    def given_name(self, given_name):
-        """Sets the given_name of this InvoiceReconciliationRecord.
+    @language.setter
+    def language(self, language):
+        """Sets the language of this TransactionCompletion.
 
             
 
-        :param given_name: The given_name of this InvoiceReconciliationRecord.
+        :param language: The language of this TransactionCompletion.
         :type: str
         """
 
-        self._given_name = given_name
+        self._language = language
     
     @property
-    def iban(self):
-        """Gets the iban of this InvoiceReconciliationRecord.
+    def last_completion(self):
+        """Gets the last_completion of this TransactionCompletion.
 
-            
+            Indicates if this is the last completion. After the last completion is created the transaction cannot be completed anymore.
 
-        :return: The iban of this InvoiceReconciliationRecord.
-        :rtype: str
+        :return: The last_completion of this TransactionCompletion.
+        :rtype: bool
         """
-        return self._iban
+        return self._last_completion
 
-    @iban.setter
-    def iban(self, iban):
-        """Sets the iban of this InvoiceReconciliationRecord.
+    @last_completion.setter
+    def last_completion(self, last_completion):
+        """Sets the last_completion of this TransactionCompletion.
 
-            
+            Indicates if this is the last completion. After the last completion is created the transaction cannot be completed anymore.
 
-        :param iban: The iban of this InvoiceReconciliationRecord.
-        :type: str
+        :param last_completion: The last_completion of this TransactionCompletion.
+        :type: bool
         """
-        if iban is not None and len(iban) > 100:
-            raise ValueError("Invalid value for `iban`, length must be less than or equal to `100`")
 
-        self._iban = iban
+        self._last_completion = last_completion
     
     @property
-    def last_resolution_failure(self):
-        """Gets the last_resolution_failure of this InvoiceReconciliationRecord.
+    def line_item_version(self):
+        """Gets the line_item_version of this TransactionCompletion.
 
             
 
-        :return: The last_resolution_failure of this InvoiceReconciliationRecord.
-        :rtype: FailureReason
+        :return: The line_item_version of this TransactionCompletion.
+        :rtype: TransactionLineItemVersion
         """
-        return self._last_resolution_failure
+        return self._line_item_version
 
-    @last_resolution_failure.setter
-    def last_resolution_failure(self, last_resolution_failure):
-        """Sets the last_resolution_failure of this InvoiceReconciliationRecord.
+    @line_item_version.setter
+    def line_item_version(self, line_item_version):
+        """Sets the line_item_version of this TransactionCompletion.
 
             
 
-        :param last_resolution_failure: The last_resolution_failure of this InvoiceReconciliationRecord.
-        :type: FailureReason
+        :param line_item_version: The line_item_version of this TransactionCompletion.
+        :type: TransactionLineItemVersion
         """
 
-        self._last_resolution_failure = last_resolution_failure
+        self._line_item_version = line_item_version
     
     @property
-    def participant_number(self):
-        """Gets the participant_number of this InvoiceReconciliationRecord.
+    def line_items(self):
+        """Gets the line_items of this TransactionCompletion.
 
-            
+            The line items which are captured.
 
-        :return: The participant_number of this InvoiceReconciliationRecord.
-        :rtype: str
+        :return: The line_items of this TransactionCompletion.
+        :rtype: list[LineItem]
         """
-        return self._participant_number
+        return self._line_items
 
-    @participant_number.setter
-    def participant_number(self, participant_number):
-        """Sets the participant_number of this InvoiceReconciliationRecord.
+    @line_items.setter
+    def line_items(self, line_items):
+        """Sets the line_items of this TransactionCompletion.
 
-            
+            The line items which are captured.
 
-        :param participant_number: The participant_number of this InvoiceReconciliationRecord.
-        :type: str
+        :param line_items: The line_items of this TransactionCompletion.
+        :type: list[LineItem]
         """
-        if participant_number is not None and len(participant_number) > 100:
-            raise ValueError("Invalid value for `participant_number`, length must be less than or equal to `100`")
 
-        self._participant_number = participant_number
+        self._line_items = line_items
     
     @property
-    def payment_fee_amount(self):
-        """Gets the payment_fee_amount of this InvoiceReconciliationRecord.
+    def mode(self):
+        """Gets the mode of this TransactionCompletion.
 
             
 
-        :return: The payment_fee_amount of this InvoiceReconciliationRecord.
-        :rtype: float
+        :return: The mode of this TransactionCompletion.
+        :rtype: TransactionCompletionMode
         """
-        return self._payment_fee_amount
+        return self._mode
 
-    @payment_fee_amount.setter
-    def payment_fee_amount(self, payment_fee_amount):
-        """Sets the payment_fee_amount of this InvoiceReconciliationRecord.
+    @mode.setter
+    def mode(self, mode):
+        """Sets the mode of this TransactionCompletion.
 
             
 
-        :param payment_fee_amount: The payment_fee_amount of this InvoiceReconciliationRecord.
-        :type: float
+        :param mode: The mode of this TransactionCompletion.
+        :type: TransactionCompletionMode
         """
 
-        self._payment_fee_amount = payment_fee_amount
+        self._mode = mode
     
     @property
-    def payment_fee_currency(self):
-        """Gets the payment_fee_currency of this InvoiceReconciliationRecord.
+    def next_update_on(self):
+        """Gets the next_update_on of this TransactionCompletion.
 
             
 
-        :return: The payment_fee_currency of this InvoiceReconciliationRecord.
-        :rtype: str
+        :return: The next_update_on of this TransactionCompletion.
+        :rtype: datetime
         """
-        return self._payment_fee_currency
+        return self._next_update_on
 
-    @payment_fee_currency.setter
-    def payment_fee_currency(self, payment_fee_currency):
-        """Sets the payment_fee_currency of this InvoiceReconciliationRecord.
+    @next_update_on.setter
+    def next_update_on(self, next_update_on):
+        """Sets the next_update_on of this TransactionCompletion.
 
             
 
-        :param payment_fee_currency: The payment_fee_currency of this InvoiceReconciliationRecord.
-        :type: str
+        :param next_update_on: The next_update_on of this TransactionCompletion.
+        :type: datetime
         """
 
-        self._payment_fee_currency = payment_fee_currency
+        self._next_update_on = next_update_on
     
     @property
-    def payment_reason(self):
-        """Gets the payment_reason of this InvoiceReconciliationRecord.
+    def payment_information(self):
+        """Gets the payment_information of this TransactionCompletion.
 
             
 
-        :return: The payment_reason of this InvoiceReconciliationRecord.
+        :return: The payment_information of this TransactionCompletion.
         :rtype: str
         """
-        return self._payment_reason
+        return self._payment_information
 
-    @payment_reason.setter
-    def payment_reason(self, payment_reason):
-        """Sets the payment_reason of this InvoiceReconciliationRecord.
+    @payment_information.setter
+    def payment_information(self, payment_information):
+        """Sets the payment_information of this TransactionCompletion.
 
             
 
-        :param payment_reason: The payment_reason of this InvoiceReconciliationRecord.
+        :param payment_information: The payment_information of this TransactionCompletion.
         :type: str
         """
 
-        self._payment_reason = payment_reason
+        self._payment_information = payment_information
     
     @property
     def planned_purge_date(self):
-        """Gets the planned_purge_date of this InvoiceReconciliationRecord.
+        """Gets the planned_purge_date of this TransactionCompletion.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
-        :return: The planned_purge_date of this InvoiceReconciliationRecord.
+        :return: The planned_purge_date of this TransactionCompletion.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
-        """Sets the planned_purge_date of this InvoiceReconciliationRecord.
+        """Sets the planned_purge_date of this TransactionCompletion.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
-        :param planned_purge_date: The planned_purge_date of this InvoiceReconciliationRecord.
+        :param planned_purge_date: The planned_purge_date of this TransactionCompletion.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
     @property
-    def post_code(self):
-        """Gets the post_code of this InvoiceReconciliationRecord.
+    def processing_on(self):
+        """Gets the processing_on of this TransactionCompletion.
 
             
 
-        :return: The post_code of this InvoiceReconciliationRecord.
-        :rtype: str
+        :return: The processing_on of this TransactionCompletion.
+        :rtype: datetime
         """
-        return self._post_code
+        return self._processing_on
 
-    @post_code.setter
-    def post_code(self, post_code):
-        """Sets the post_code of this InvoiceReconciliationRecord.
+    @processing_on.setter
+    def processing_on(self, processing_on):
+        """Sets the processing_on of this TransactionCompletion.
 
             
 
-        :param post_code: The post_code of this InvoiceReconciliationRecord.
-        :type: str
+        :param processing_on: The processing_on of this TransactionCompletion.
+        :type: datetime
         """
 
-        self._post_code = post_code
+        self._processing_on = processing_on
     
     @property
-    def reference_number(self):
-        """Gets the reference_number of this InvoiceReconciliationRecord.
+    def processor_reference(self):
+        """Gets the processor_reference of this TransactionCompletion.
 
             
 
-        :return: The reference_number of this InvoiceReconciliationRecord.
+        :return: The processor_reference of this TransactionCompletion.
         :rtype: str
         """
-        return self._reference_number
+        return self._processor_reference
 
-    @reference_number.setter
-    def reference_number(self, reference_number):
-        """Sets the reference_number of this InvoiceReconciliationRecord.
+    @processor_reference.setter
+    def processor_reference(self, processor_reference):
+        """Sets the processor_reference of this TransactionCompletion.
 
             
 
-        :param reference_number: The reference_number of this InvoiceReconciliationRecord.
+        :param processor_reference: The processor_reference of this TransactionCompletion.
         :type: str
         """
-        if reference_number is not None and len(reference_number) > 255:
-            raise ValueError("Invalid value for `reference_number`, length must be less than or equal to `255`")
 
-        self._reference_number = reference_number
+        self._processor_reference = processor_reference
     
     @property
-    def rejection_status(self):
-        """Gets the rejection_status of this InvoiceReconciliationRecord.
+    def remaining_line_items(self):
+        """Gets the remaining_line_items of this TransactionCompletion.
 
             
 
-        :return: The rejection_status of this InvoiceReconciliationRecord.
-        :rtype: InvoiceReconciliationRecordRejectionStatus
+        :return: The remaining_line_items of this TransactionCompletion.
+        :rtype: list[LineItem]
         """
-        return self._rejection_status
+        return self._remaining_line_items
 
-    @rejection_status.setter
-    def rejection_status(self, rejection_status):
-        """Sets the rejection_status of this InvoiceReconciliationRecord.
+    @remaining_line_items.setter
+    def remaining_line_items(self, remaining_line_items):
+        """Sets the remaining_line_items of this TransactionCompletion.
 
             
 
-        :param rejection_status: The rejection_status of this InvoiceReconciliationRecord.
-        :type: InvoiceReconciliationRecordRejectionStatus
+        :param remaining_line_items: The remaining_line_items of this TransactionCompletion.
+        :type: list[LineItem]
         """
 
-        self._rejection_status = rejection_status
+        self._remaining_line_items = remaining_line_items
     
     @property
-    def resolved_by(self):
-        """Gets the resolved_by of this InvoiceReconciliationRecord.
+    def space_view_id(self):
+        """Gets the space_view_id of this TransactionCompletion.
 
             
 
-        :return: The resolved_by of this InvoiceReconciliationRecord.
+        :return: The space_view_id of this TransactionCompletion.
         :rtype: int
         """
-        return self._resolved_by
+        return self._space_view_id
 
-    @resolved_by.setter
-    def resolved_by(self, resolved_by):
-        """Sets the resolved_by of this InvoiceReconciliationRecord.
+    @space_view_id.setter
+    def space_view_id(self, space_view_id):
+        """Sets the space_view_id of this TransactionCompletion.
 
             
 
-        :param resolved_by: The resolved_by of this InvoiceReconciliationRecord.
+        :param space_view_id: The space_view_id of this TransactionCompletion.
         :type: int
         """
 
-        self._resolved_by = resolved_by
-    
-    @property
-    def resolved_on(self):
-        """Gets the resolved_on of this InvoiceReconciliationRecord.
-
-            The resolved on date indicates when the bank transaction has been resolved.
-
-        :return: The resolved_on of this InvoiceReconciliationRecord.
-        :rtype: datetime
-        """
-        return self._resolved_on
-
-    @resolved_on.setter
-    def resolved_on(self, resolved_on):
-        """Sets the resolved_on of this InvoiceReconciliationRecord.
-
-            The resolved on date indicates when the bank transaction has been resolved.
-
-        :param resolved_on: The resolved_on of this InvoiceReconciliationRecord.
-        :type: datetime
-        """
-
-        self._resolved_on = resolved_on
-    
-    @property
-    def sender_bank_account(self):
-        """Gets the sender_bank_account of this InvoiceReconciliationRecord.
-
-            
-
-        :return: The sender_bank_account of this InvoiceReconciliationRecord.
-        :rtype: str
-        """
-        return self._sender_bank_account
-
-    @sender_bank_account.setter
-    def sender_bank_account(self, sender_bank_account):
-        """Sets the sender_bank_account of this InvoiceReconciliationRecord.
-
-            
-
-        :param sender_bank_account: The sender_bank_account of this InvoiceReconciliationRecord.
-        :type: str
-        """
-
-        self._sender_bank_account = sender_bank_account
+        self._space_view_id = space_view_id
     
     @property
     def state(self):
-        """Gets the state of this InvoiceReconciliationRecord.
+        """Gets the state of this TransactionCompletion.
 
-            The object's current state.
+            
 
-        :return: The state of this InvoiceReconciliationRecord.
-        :rtype: InvoiceReconciliationRecordState
+        :return: The state of this TransactionCompletion.
+        :rtype: TransactionCompletionState
         """
         return self._state
 
     @state.setter
     def state(self, state):
-        """Sets the state of this InvoiceReconciliationRecord.
+        """Sets the state of this TransactionCompletion.
 
-            The object's current state.
+            
 
-        :param state: The state of this InvoiceReconciliationRecord.
-        :type: InvoiceReconciliationRecordState
+        :param state: The state of this TransactionCompletion.
+        :type: TransactionCompletionState
         """
 
         self._state = state
     
     @property
-    def street(self):
-        """Gets the street of this InvoiceReconciliationRecord.
+    def succeeded_on(self):
+        """Gets the succeeded_on of this TransactionCompletion.
 
             
 
-        :return: The street of this InvoiceReconciliationRecord.
-        :rtype: str
+        :return: The succeeded_on of this TransactionCompletion.
+        :rtype: datetime
         """
-        return self._street
+        return self._succeeded_on
 
-    @street.setter
-    def street(self, street):
-        """Sets the street of this InvoiceReconciliationRecord.
+    @succeeded_on.setter
+    def succeeded_on(self, succeeded_on):
+        """Sets the succeeded_on of this TransactionCompletion.
 
             
 
-        :param street: The street of this InvoiceReconciliationRecord.
-        :type: str
+        :param succeeded_on: The succeeded_on of this TransactionCompletion.
+        :type: datetime
         """
 
-        self._street = street
+        self._succeeded_on = succeeded_on
     
     @property
-    def type(self):
-        """Gets the type of this InvoiceReconciliationRecord.
+    def tax_amount(self):
+        """Gets the tax_amount of this TransactionCompletion.
 
-            
+            The total sum of all taxes of line items.
 
-        :return: The type of this InvoiceReconciliationRecord.
-        :rtype: InvoiceReconciliationRecordType
+        :return: The tax_amount of this TransactionCompletion.
+        :rtype: float
         """
-        return self._type
+        return self._tax_amount
 
-    @type.setter
-    def type(self, type):
-        """Sets the type of this InvoiceReconciliationRecord.
+    @tax_amount.setter
+    def tax_amount(self, tax_amount):
+        """Sets the tax_amount of this TransactionCompletion.
 
-            
+            The total sum of all taxes of line items.
 
-        :param type: The type of this InvoiceReconciliationRecord.
-        :type: InvoiceReconciliationRecordType
+        :param tax_amount: The tax_amount of this TransactionCompletion.
+        :type: float
         """
 
-        self._type = type
+        self._tax_amount = tax_amount
     
     @property
-    def unique_id(self):
-        """Gets the unique_id of this InvoiceReconciliationRecord.
+    def time_zone(self):
+        """Gets the time_zone of this TransactionCompletion.
 
             
 
-        :return: The unique_id of this InvoiceReconciliationRecord.
+        :return: The time_zone of this TransactionCompletion.
         :rtype: str
         """
-        return self._unique_id
+        return self._time_zone
 
-    @unique_id.setter
-    def unique_id(self, unique_id):
-        """Sets the unique_id of this InvoiceReconciliationRecord.
+    @time_zone.setter
+    def time_zone(self, time_zone):
+        """Sets the time_zone of this TransactionCompletion.
 
             
 
-        :param unique_id: The unique_id of this InvoiceReconciliationRecord.
+        :param time_zone: The time_zone of this TransactionCompletion.
         :type: str
         """
-        if unique_id is not None and len(unique_id) > 500:
-            raise ValueError("Invalid value for `unique_id`, length must be less than or equal to `500`")
 
-        self._unique_id = unique_id
+        self._time_zone = time_zone
     
     @property
-    def value_date(self):
-        """Gets the value_date of this InvoiceReconciliationRecord.
+    def timeout_on(self):
+        """Gets the timeout_on of this TransactionCompletion.
 
             
 
-        :return: The value_date of this InvoiceReconciliationRecord.
+        :return: The timeout_on of this TransactionCompletion.
         :rtype: datetime
         """
-        return self._value_date
+        return self._timeout_on
 
-    @value_date.setter
-    def value_date(self, value_date):
-        """Sets the value_date of this InvoiceReconciliationRecord.
+    @timeout_on.setter
+    def timeout_on(self, timeout_on):
+        """Sets the timeout_on of this TransactionCompletion.
 
             
 
-        :param value_date: The value_date of this InvoiceReconciliationRecord.
+        :param timeout_on: The timeout_on of this TransactionCompletion.
         :type: datetime
         """
 
-        self._value_date = value_date
+        self._timeout_on = timeout_on
     
     @property
     def version(self):
-        """Gets the version of this InvoiceReconciliationRecord.
+        """Gets the version of this TransactionCompletion.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
-        :return: The version of this InvoiceReconciliationRecord.
+        :return: The version of this TransactionCompletion.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
-        """Sets the version of this InvoiceReconciliationRecord.
+        """Sets the version of this TransactionCompletion.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
-        :param version: The version of this InvoiceReconciliationRecord.
+        :param version: The version of this TransactionCompletion.
         :type: int
         """
 
         self._version = version
     
 
     def to_dict(self):
@@ -832,27 +752,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(InvoiceReconciliationRecord, dict):
+        if issubclass(TransactionCompletion, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, InvoiceReconciliationRecord):
+        if not isinstance(other, TransactionCompletion):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/invoice_reconciliation_record_type.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_contract_type.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,105 +1,131 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
 
 
 
-class InvoiceReconciliationRecordType:
+class PaymentContractType:
 
     swagger_types = {
     
         'description': 'dict(str, str)',
+        'feature': 'Feature',
         'id': 'int',
         'name': 'dict(str, str)',
     }
 
     attribute_map = {
-        'description': 'description','id': 'id','name': 'name',
+        'description': 'description','feature': 'feature','id': 'id','name': 'name',
     }
 
     
     _description = None
+    _feature = None
     _id = None
     _name = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
         self.description = kwargs.get('description', None)
+        self.feature = kwargs.get('feature', None)
         self.id = kwargs.get('id', None)
         self.name = kwargs.get('name', None)
         
 
     
     @property
     def description(self):
-        """Gets the description of this InvoiceReconciliationRecordType.
+        """Gets the description of this PaymentContractType.
 
-            The localized description of the object.
+            
 
-        :return: The description of this InvoiceReconciliationRecordType.
+        :return: The description of this PaymentContractType.
         :rtype: dict(str, str)
         """
         return self._description
 
     @description.setter
     def description(self, description):
-        """Sets the description of this InvoiceReconciliationRecordType.
+        """Sets the description of this PaymentContractType.
 
-            The localized description of the object.
+            
 
-        :param description: The description of this InvoiceReconciliationRecordType.
+        :param description: The description of this PaymentContractType.
         :type: dict(str, str)
         """
 
         self._description = description
     
     @property
+    def feature(self):
+        """Gets the feature of this PaymentContractType.
+
+            
+
+        :return: The feature of this PaymentContractType.
+        :rtype: Feature
+        """
+        return self._feature
+
+    @feature.setter
+    def feature(self, feature):
+        """Sets the feature of this PaymentContractType.
+
+            
+
+        :param feature: The feature of this PaymentContractType.
+        :type: Feature
+        """
+
+        self._feature = feature
+    
+    @property
     def id(self):
-        """Gets the id of this InvoiceReconciliationRecordType.
+        """Gets the id of this PaymentContractType.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
-        :return: The id of this InvoiceReconciliationRecordType.
+        :return: The id of this PaymentContractType.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
-        """Sets the id of this InvoiceReconciliationRecordType.
+        """Sets the id of this PaymentContractType.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
-        :param id: The id of this InvoiceReconciliationRecordType.
+        :param id: The id of this PaymentContractType.
         :type: int
         """
 
         self._id = id
     
     @property
     def name(self):
-        """Gets the name of this InvoiceReconciliationRecordType.
+        """Gets the name of this PaymentContractType.
 
-            The localized name of the object.
+            
 
-        :return: The name of this InvoiceReconciliationRecordType.
+        :return: The name of this PaymentContractType.
         :rtype: dict(str, str)
         """
         return self._name
 
     @name.setter
     def name(self, name):
-        """Sets the name of this InvoiceReconciliationRecordType.
+        """Sets the name of this PaymentContractType.
 
-            The localized name of the object.
+            
 
-        :param name: The name of this InvoiceReconciliationRecordType.
+        :param name: The name of this PaymentContractType.
         :type: dict(str, str)
         """
 
         self._name = name
     
 
     def to_dict(self):
@@ -120,27 +146,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(InvoiceReconciliationRecordType, dict):
+        if issubclass(PaymentContractType, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, InvoiceReconciliationRecordType):
+        if not isinstance(other, PaymentContractType):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/invoice_reimbursement.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_method_configuration.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,573 +1,471 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
 
 
 
-class InvoiceReimbursement:
+class PaymentMethodConfiguration:
 
     swagger_types = {
     
-        'amount': 'float',
-        'created_on': 'datetime',
-        'currency': 'str',
-        'discarded_by': 'int',
-        'discarded_on': 'datetime',
+        'data_collection_type': 'DataCollectionType',
+        'description': 'DatabaseTranslatedString',
         'id': 'int',
+        'image_resource_path': 'ResourcePath',
         'linked_space_id': 'int',
-        'payment_connector_configuration': 'PaymentConnectorConfiguration',
-        'payment_initiation_advice_file': 'PaymentInitiationAdviceFile',
-        'processed_by': 'int',
-        'processed_on': 'datetime',
-        'recipient_city': 'str',
-        'recipient_country': 'str',
-        'recipient_family_name': 'str',
-        'recipient_given_name': 'str',
-        'recipient_iban': 'str',
-        'recipient_postcode': 'str',
-        'recipient_street': 'str',
-        'sender_iban': 'str',
-        'state': 'InvoiceReimbursementState',
+        'name': 'str',
+        'one_click_payment_mode': 'OneClickPaymentMode',
+        'payment_method': 'int',
+        'planned_purge_date': 'datetime',
+        'resolved_description': 'dict(str, str)',
+        'resolved_image_url': 'str',
+        'resolved_title': 'dict(str, str)',
+        'sort_order': 'int',
+        'space_id': 'int',
+        'state': 'CreationEntityState',
+        'title': 'DatabaseTranslatedString',
         'version': 'int',
     }
 
     attribute_map = {
-        'amount': 'amount','created_on': 'createdOn','currency': 'currency','discarded_by': 'discardedBy','discarded_on': 'discardedOn','id': 'id','linked_space_id': 'linkedSpaceId','payment_connector_configuration': 'paymentConnectorConfiguration','payment_initiation_advice_file': 'paymentInitiationAdviceFile','processed_by': 'processedBy','processed_on': 'processedOn','recipient_city': 'recipientCity','recipient_country': 'recipientCountry','recipient_family_name': 'recipientFamilyName','recipient_given_name': 'recipientGivenName','recipient_iban': 'recipientIban','recipient_postcode': 'recipientPostcode','recipient_street': 'recipientStreet','sender_iban': 'senderIban','state': 'state','version': 'version',
+        'data_collection_type': 'dataCollectionType','description': 'description','id': 'id','image_resource_path': 'imageResourcePath','linked_space_id': 'linkedSpaceId','name': 'name','one_click_payment_mode': 'oneClickPaymentMode','payment_method': 'paymentMethod','planned_purge_date': 'plannedPurgeDate','resolved_description': 'resolvedDescription','resolved_image_url': 'resolvedImageUrl','resolved_title': 'resolvedTitle','sort_order': 'sortOrder','space_id': 'spaceId','state': 'state','title': 'title','version': 'version',
     }
 
     
-    _amount = None
-    _created_on = None
-    _currency = None
-    _discarded_by = None
-    _discarded_on = None
+    _data_collection_type = None
+    _description = None
     _id = None
+    _image_resource_path = None
     _linked_space_id = None
-    _payment_connector_configuration = None
-    _payment_initiation_advice_file = None
-    _processed_by = None
-    _processed_on = None
-    _recipient_city = None
-    _recipient_country = None
-    _recipient_family_name = None
-    _recipient_given_name = None
-    _recipient_iban = None
-    _recipient_postcode = None
-    _recipient_street = None
-    _sender_iban = None
+    _name = None
+    _one_click_payment_mode = None
+    _payment_method = None
+    _planned_purge_date = None
+    _resolved_description = None
+    _resolved_image_url = None
+    _resolved_title = None
+    _sort_order = None
+    _space_id = None
     _state = None
+    _title = None
     _version = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
-        self.amount = kwargs.get('amount', None)
-        self.created_on = kwargs.get('created_on', None)
-        self.currency = kwargs.get('currency', None)
-        self.discarded_by = kwargs.get('discarded_by', None)
-        self.discarded_on = kwargs.get('discarded_on', None)
+        self.data_collection_type = kwargs.get('data_collection_type', None)
+        self.description = kwargs.get('description', None)
         self.id = kwargs.get('id', None)
+        self.image_resource_path = kwargs.get('image_resource_path', None)
         self.linked_space_id = kwargs.get('linked_space_id', None)
-        self.payment_connector_configuration = kwargs.get('payment_connector_configuration', None)
-        self.payment_initiation_advice_file = kwargs.get('payment_initiation_advice_file', None)
-        self.processed_by = kwargs.get('processed_by', None)
-        self.processed_on = kwargs.get('processed_on', None)
-        self.recipient_city = kwargs.get('recipient_city', None)
-        self.recipient_country = kwargs.get('recipient_country', None)
-        self.recipient_family_name = kwargs.get('recipient_family_name', None)
-        self.recipient_given_name = kwargs.get('recipient_given_name', None)
-        self.recipient_iban = kwargs.get('recipient_iban', None)
-        self.recipient_postcode = kwargs.get('recipient_postcode', None)
-        self.recipient_street = kwargs.get('recipient_street', None)
-        self.sender_iban = kwargs.get('sender_iban', None)
+        self.name = kwargs.get('name', None)
+        self.one_click_payment_mode = kwargs.get('one_click_payment_mode', None)
+        self.payment_method = kwargs.get('payment_method', None)
+        self.planned_purge_date = kwargs.get('planned_purge_date', None)
+        self.resolved_description = kwargs.get('resolved_description', None)
+        self.resolved_image_url = kwargs.get('resolved_image_url', None)
+        self.resolved_title = kwargs.get('resolved_title', None)
+        self.sort_order = kwargs.get('sort_order', None)
+        self.space_id = kwargs.get('space_id', None)
         self.state = kwargs.get('state', None)
+        self.title = kwargs.get('title', None)
         self.version = kwargs.get('version', None)
         
 
     
     @property
-    def amount(self):
-        """Gets the amount of this InvoiceReimbursement.
+    def data_collection_type(self):
+        """Gets the data_collection_type of this PaymentMethodConfiguration.
 
-            
+            The data collection type determines who is collecting the payment information. This can be done either by the processor (offsite) or by our application (onsite).
 
-        :return: The amount of this InvoiceReimbursement.
-        :rtype: float
+        :return: The data_collection_type of this PaymentMethodConfiguration.
+        :rtype: DataCollectionType
         """
-        return self._amount
+        return self._data_collection_type
 
-    @amount.setter
-    def amount(self, amount):
-        """Sets the amount of this InvoiceReimbursement.
+    @data_collection_type.setter
+    def data_collection_type(self, data_collection_type):
+        """Sets the data_collection_type of this PaymentMethodConfiguration.
 
-            
+            The data collection type determines who is collecting the payment information. This can be done either by the processor (offsite) or by our application (onsite).
 
-        :param amount: The amount of this InvoiceReimbursement.
-        :type: float
+        :param data_collection_type: The data_collection_type of this PaymentMethodConfiguration.
+        :type: DataCollectionType
         """
 
-        self._amount = amount
+        self._data_collection_type = data_collection_type
     
     @property
-    def created_on(self):
-        """Gets the created_on of this InvoiceReimbursement.
+    def description(self):
+        """Gets the description of this PaymentMethodConfiguration.
 
-            The date and time when the object was created.
+            The payment method configuration description can be used to show a text during the payment process. Choose an appropriate description as it will be displayed to your customer.
 
-        :return: The created_on of this InvoiceReimbursement.
-        :rtype: datetime
+        :return: The description of this PaymentMethodConfiguration.
+        :rtype: DatabaseTranslatedString
         """
-        return self._created_on
+        return self._description
 
-    @created_on.setter
-    def created_on(self, created_on):
-        """Sets the created_on of this InvoiceReimbursement.
+    @description.setter
+    def description(self, description):
+        """Sets the description of this PaymentMethodConfiguration.
 
-            The date and time when the object was created.
+            The payment method configuration description can be used to show a text during the payment process. Choose an appropriate description as it will be displayed to your customer.
 
-        :param created_on: The created_on of this InvoiceReimbursement.
-        :type: datetime
+        :param description: The description of this PaymentMethodConfiguration.
+        :type: DatabaseTranslatedString
         """
 
-        self._created_on = created_on
+        self._description = description
     
     @property
-    def currency(self):
-        """Gets the currency of this InvoiceReimbursement.
-
-            
-
-        :return: The currency of this InvoiceReimbursement.
-        :rtype: str
-        """
-        return self._currency
-
-    @currency.setter
-    def currency(self, currency):
-        """Sets the currency of this InvoiceReimbursement.
-
-            
-
-        :param currency: The currency of this InvoiceReimbursement.
-        :type: str
-        """
+    def id(self):
+        """Gets the id of this PaymentMethodConfiguration.
 
-        self._currency = currency
-    
-    @property
-    def discarded_by(self):
-        """Gets the discarded_by of this InvoiceReimbursement.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
-            
-
-        :return: The discarded_by of this InvoiceReimbursement.
+        :return: The id of this PaymentMethodConfiguration.
         :rtype: int
         """
-        return self._discarded_by
+        return self._id
 
-    @discarded_by.setter
-    def discarded_by(self, discarded_by):
-        """Sets the discarded_by of this InvoiceReimbursement.
+    @id.setter
+    def id(self, id):
+        """Sets the id of this PaymentMethodConfiguration.
 
-            
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
-        :param discarded_by: The discarded_by of this InvoiceReimbursement.
+        :param id: The id of this PaymentMethodConfiguration.
         :type: int
         """
 
-        self._discarded_by = discarded_by
-    
-    @property
-    def discarded_on(self):
-        """Gets the discarded_on of this InvoiceReimbursement.
-
-            
-
-        :return: The discarded_on of this InvoiceReimbursement.
-        :rtype: datetime
-        """
-        return self._discarded_on
-
-    @discarded_on.setter
-    def discarded_on(self, discarded_on):
-        """Sets the discarded_on of this InvoiceReimbursement.
-
-            
-
-        :param discarded_on: The discarded_on of this InvoiceReimbursement.
-        :type: datetime
-        """
-
-        self._discarded_on = discarded_on
+        self._id = id
     
     @property
-    def id(self):
-        """Gets the id of this InvoiceReimbursement.
+    def image_resource_path(self):
+        """Gets the image_resource_path of this PaymentMethodConfiguration.
 
-            A unique identifier for the object.
+            The image of the payment method configuration overrides the default image of the payment method.
 
-        :return: The id of this InvoiceReimbursement.
-        :rtype: int
+        :return: The image_resource_path of this PaymentMethodConfiguration.
+        :rtype: ResourcePath
         """
-        return self._id
+        return self._image_resource_path
 
-    @id.setter
-    def id(self, id):
-        """Sets the id of this InvoiceReimbursement.
+    @image_resource_path.setter
+    def image_resource_path(self, image_resource_path):
+        """Sets the image_resource_path of this PaymentMethodConfiguration.
 
-            A unique identifier for the object.
+            The image of the payment method configuration overrides the default image of the payment method.
 
-        :param id: The id of this InvoiceReimbursement.
-        :type: int
+        :param image_resource_path: The image_resource_path of this PaymentMethodConfiguration.
+        :type: ResourcePath
         """
 
-        self._id = id
+        self._image_resource_path = image_resource_path
     
     @property
     def linked_space_id(self):
-        """Gets the linked_space_id of this InvoiceReimbursement.
+        """Gets the linked_space_id of this PaymentMethodConfiguration.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
-        :return: The linked_space_id of this InvoiceReimbursement.
+        :return: The linked_space_id of this PaymentMethodConfiguration.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
-        """Sets the linked_space_id of this InvoiceReimbursement.
+        """Sets the linked_space_id of this PaymentMethodConfiguration.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
-        :param linked_space_id: The linked_space_id of this InvoiceReimbursement.
+        :param linked_space_id: The linked_space_id of this PaymentMethodConfiguration.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
     @property
-    def payment_connector_configuration(self):
-        """Gets the payment_connector_configuration of this InvoiceReimbursement.
+    def name(self):
+        """Gets the name of this PaymentMethodConfiguration.
 
-            
+            The payment method configuration name is used internally to identify the payment method configuration. For example the name is used within search fields and hence it should be distinct and descriptive.
 
-        :return: The payment_connector_configuration of this InvoiceReimbursement.
-        :rtype: PaymentConnectorConfiguration
+        :return: The name of this PaymentMethodConfiguration.
+        :rtype: str
         """
-        return self._payment_connector_configuration
+        return self._name
 
-    @payment_connector_configuration.setter
-    def payment_connector_configuration(self, payment_connector_configuration):
-        """Sets the payment_connector_configuration of this InvoiceReimbursement.
+    @name.setter
+    def name(self, name):
+        """Sets the name of this PaymentMethodConfiguration.
 
-            
+            The payment method configuration name is used internally to identify the payment method configuration. For example the name is used within search fields and hence it should be distinct and descriptive.
 
-        :param payment_connector_configuration: The payment_connector_configuration of this InvoiceReimbursement.
-        :type: PaymentConnectorConfiguration
+        :param name: The name of this PaymentMethodConfiguration.
+        :type: str
         """
+        if name is not None and len(name) > 100:
+            raise ValueError("Invalid value for `name`, length must be less than or equal to `100`")
 
-        self._payment_connector_configuration = payment_connector_configuration
+        self._name = name
     
     @property
-    def payment_initiation_advice_file(self):
-        """Gets the payment_initiation_advice_file of this InvoiceReimbursement.
+    def one_click_payment_mode(self):
+        """Gets the one_click_payment_mode of this PaymentMethodConfiguration.
 
-            
+            When the buyer is present on the payment page or within the iFrame the payment details can be stored automatically. The buyer will be able to use the stored payment details for subsequent transactions. When the transaction already contains a token one-click payments are disabled anyway
 
-        :return: The payment_initiation_advice_file of this InvoiceReimbursement.
-        :rtype: PaymentInitiationAdviceFile
+        :return: The one_click_payment_mode of this PaymentMethodConfiguration.
+        :rtype: OneClickPaymentMode
         """
-        return self._payment_initiation_advice_file
+        return self._one_click_payment_mode
 
-    @payment_initiation_advice_file.setter
-    def payment_initiation_advice_file(self, payment_initiation_advice_file):
-        """Sets the payment_initiation_advice_file of this InvoiceReimbursement.
+    @one_click_payment_mode.setter
+    def one_click_payment_mode(self, one_click_payment_mode):
+        """Sets the one_click_payment_mode of this PaymentMethodConfiguration.
 
-            
+            When the buyer is present on the payment page or within the iFrame the payment details can be stored automatically. The buyer will be able to use the stored payment details for subsequent transactions. When the transaction already contains a token one-click payments are disabled anyway
 
-        :param payment_initiation_advice_file: The payment_initiation_advice_file of this InvoiceReimbursement.
-        :type: PaymentInitiationAdviceFile
+        :param one_click_payment_mode: The one_click_payment_mode of this PaymentMethodConfiguration.
+        :type: OneClickPaymentMode
         """
 
-        self._payment_initiation_advice_file = payment_initiation_advice_file
+        self._one_click_payment_mode = one_click_payment_mode
     
     @property
-    def processed_by(self):
-        """Gets the processed_by of this InvoiceReimbursement.
+    def payment_method(self):
+        """Gets the payment_method of this PaymentMethodConfiguration.
 
             
 
-        :return: The processed_by of this InvoiceReimbursement.
+        :return: The payment_method of this PaymentMethodConfiguration.
         :rtype: int
         """
-        return self._processed_by
+        return self._payment_method
 
-    @processed_by.setter
-    def processed_by(self, processed_by):
-        """Sets the processed_by of this InvoiceReimbursement.
+    @payment_method.setter
+    def payment_method(self, payment_method):
+        """Sets the payment_method of this PaymentMethodConfiguration.
 
             
 
-        :param processed_by: The processed_by of this InvoiceReimbursement.
+        :param payment_method: The payment_method of this PaymentMethodConfiguration.
         :type: int
         """
 
-        self._processed_by = processed_by
+        self._payment_method = payment_method
     
     @property
-    def processed_on(self):
-        """Gets the processed_on of this InvoiceReimbursement.
+    def planned_purge_date(self):
+        """Gets the planned_purge_date of this PaymentMethodConfiguration.
 
-            
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
-        :return: The processed_on of this InvoiceReimbursement.
+        :return: The planned_purge_date of this PaymentMethodConfiguration.
         :rtype: datetime
         """
-        return self._processed_on
+        return self._planned_purge_date
 
-    @processed_on.setter
-    def processed_on(self, processed_on):
-        """Sets the processed_on of this InvoiceReimbursement.
+    @planned_purge_date.setter
+    def planned_purge_date(self, planned_purge_date):
+        """Sets the planned_purge_date of this PaymentMethodConfiguration.
 
-            
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
-        :param processed_on: The processed_on of this InvoiceReimbursement.
+        :param planned_purge_date: The planned_purge_date of this PaymentMethodConfiguration.
         :type: datetime
         """
 
-        self._processed_on = processed_on
-    
-    @property
-    def recipient_city(self):
-        """Gets the recipient_city of this InvoiceReimbursement.
-
-            
-
-        :return: The recipient_city of this InvoiceReimbursement.
-        :rtype: str
-        """
-        return self._recipient_city
-
-    @recipient_city.setter
-    def recipient_city(self, recipient_city):
-        """Sets the recipient_city of this InvoiceReimbursement.
-
-            
-
-        :param recipient_city: The recipient_city of this InvoiceReimbursement.
-        :type: str
-        """
-
-        self._recipient_city = recipient_city
+        self._planned_purge_date = planned_purge_date
     
     @property
-    def recipient_country(self):
-        """Gets the recipient_country of this InvoiceReimbursement.
+    def resolved_description(self):
+        """Gets the resolved_description of this PaymentMethodConfiguration.
 
-            
+            The resolved description uses the specified description or the default one when it is not overridden.
 
-        :return: The recipient_country of this InvoiceReimbursement.
-        :rtype: str
+        :return: The resolved_description of this PaymentMethodConfiguration.
+        :rtype: dict(str, str)
         """
-        return self._recipient_country
+        return self._resolved_description
 
-    @recipient_country.setter
-    def recipient_country(self, recipient_country):
-        """Sets the recipient_country of this InvoiceReimbursement.
+    @resolved_description.setter
+    def resolved_description(self, resolved_description):
+        """Sets the resolved_description of this PaymentMethodConfiguration.
 
-            
+            The resolved description uses the specified description or the default one when it is not overridden.
 
-        :param recipient_country: The recipient_country of this InvoiceReimbursement.
-        :type: str
+        :param resolved_description: The resolved_description of this PaymentMethodConfiguration.
+        :type: dict(str, str)
         """
 
-        self._recipient_country = recipient_country
+        self._resolved_description = resolved_description
     
     @property
-    def recipient_family_name(self):
-        """Gets the recipient_family_name of this InvoiceReimbursement.
+    def resolved_image_url(self):
+        """Gets the resolved_image_url of this PaymentMethodConfiguration.
 
-            
+            The resolved URL of the image to use with this payment method.
 
-        :return: The recipient_family_name of this InvoiceReimbursement.
+        :return: The resolved_image_url of this PaymentMethodConfiguration.
         :rtype: str
         """
-        return self._recipient_family_name
+        return self._resolved_image_url
 
-    @recipient_family_name.setter
-    def recipient_family_name(self, recipient_family_name):
-        """Sets the recipient_family_name of this InvoiceReimbursement.
+    @resolved_image_url.setter
+    def resolved_image_url(self, resolved_image_url):
+        """Sets the resolved_image_url of this PaymentMethodConfiguration.
 
-            
+            The resolved URL of the image to use with this payment method.
 
-        :param recipient_family_name: The recipient_family_name of this InvoiceReimbursement.
+        :param resolved_image_url: The resolved_image_url of this PaymentMethodConfiguration.
         :type: str
         """
 
-        self._recipient_family_name = recipient_family_name
+        self._resolved_image_url = resolved_image_url
     
     @property
-    def recipient_given_name(self):
-        """Gets the recipient_given_name of this InvoiceReimbursement.
+    def resolved_title(self):
+        """Gets the resolved_title of this PaymentMethodConfiguration.
 
-            
+            The resolved title uses the specified title or the default one when it is not overridden.
 
-        :return: The recipient_given_name of this InvoiceReimbursement.
-        :rtype: str
+        :return: The resolved_title of this PaymentMethodConfiguration.
+        :rtype: dict(str, str)
         """
-        return self._recipient_given_name
+        return self._resolved_title
 
-    @recipient_given_name.setter
-    def recipient_given_name(self, recipient_given_name):
-        """Sets the recipient_given_name of this InvoiceReimbursement.
+    @resolved_title.setter
+    def resolved_title(self, resolved_title):
+        """Sets the resolved_title of this PaymentMethodConfiguration.
 
-            
+            The resolved title uses the specified title or the default one when it is not overridden.
 
-        :param recipient_given_name: The recipient_given_name of this InvoiceReimbursement.
-        :type: str
+        :param resolved_title: The resolved_title of this PaymentMethodConfiguration.
+        :type: dict(str, str)
         """
 
-        self._recipient_given_name = recipient_given_name
+        self._resolved_title = resolved_title
     
     @property
-    def recipient_iban(self):
-        """Gets the recipient_iban of this InvoiceReimbursement.
-
-            
-
-        :return: The recipient_iban of this InvoiceReimbursement.
-        :rtype: str
-        """
-        return self._recipient_iban
+    def sort_order(self):
+        """Gets the sort_order of this PaymentMethodConfiguration.
 
-    @recipient_iban.setter
-    def recipient_iban(self, recipient_iban):
-        """Sets the recipient_iban of this InvoiceReimbursement.
+            The sort order of the payment method determines the ordering of the methods shown to the user during the payment process.
 
-            
-
-        :param recipient_iban: The recipient_iban of this InvoiceReimbursement.
-        :type: str
-        """
-
-        self._recipient_iban = recipient_iban
-    
-    @property
-    def recipient_postcode(self):
-        """Gets the recipient_postcode of this InvoiceReimbursement.
-
-            
-
-        :return: The recipient_postcode of this InvoiceReimbursement.
-        :rtype: str
+        :return: The sort_order of this PaymentMethodConfiguration.
+        :rtype: int
         """
-        return self._recipient_postcode
+        return self._sort_order
 
-    @recipient_postcode.setter
-    def recipient_postcode(self, recipient_postcode):
-        """Sets the recipient_postcode of this InvoiceReimbursement.
+    @sort_order.setter
+    def sort_order(self, sort_order):
+        """Sets the sort_order of this PaymentMethodConfiguration.
 
-            
+            The sort order of the payment method determines the ordering of the methods shown to the user during the payment process.
 
-        :param recipient_postcode: The recipient_postcode of this InvoiceReimbursement.
-        :type: str
+        :param sort_order: The sort_order of this PaymentMethodConfiguration.
+        :type: int
         """
 
-        self._recipient_postcode = recipient_postcode
+        self._sort_order = sort_order
     
     @property
-    def recipient_street(self):
-        """Gets the recipient_street of this InvoiceReimbursement.
+    def space_id(self):
+        """Gets the space_id of this PaymentMethodConfiguration.
 
             
 
-        :return: The recipient_street of this InvoiceReimbursement.
-        :rtype: str
+        :return: The space_id of this PaymentMethodConfiguration.
+        :rtype: int
         """
-        return self._recipient_street
+        return self._space_id
 
-    @recipient_street.setter
-    def recipient_street(self, recipient_street):
-        """Sets the recipient_street of this InvoiceReimbursement.
+    @space_id.setter
+    def space_id(self, space_id):
+        """Sets the space_id of this PaymentMethodConfiguration.
 
             
 
-        :param recipient_street: The recipient_street of this InvoiceReimbursement.
-        :type: str
+        :param space_id: The space_id of this PaymentMethodConfiguration.
+        :type: int
         """
 
-        self._recipient_street = recipient_street
+        self._space_id = space_id
     
     @property
-    def sender_iban(self):
-        """Gets the sender_iban of this InvoiceReimbursement.
+    def state(self):
+        """Gets the state of this PaymentMethodConfiguration.
 
             
 
-        :return: The sender_iban of this InvoiceReimbursement.
-        :rtype: str
+        :return: The state of this PaymentMethodConfiguration.
+        :rtype: CreationEntityState
         """
-        return self._sender_iban
+        return self._state
 
-    @sender_iban.setter
-    def sender_iban(self, sender_iban):
-        """Sets the sender_iban of this InvoiceReimbursement.
+    @state.setter
+    def state(self, state):
+        """Sets the state of this PaymentMethodConfiguration.
 
             
 
-        :param sender_iban: The sender_iban of this InvoiceReimbursement.
-        :type: str
+        :param state: The state of this PaymentMethodConfiguration.
+        :type: CreationEntityState
         """
 
-        self._sender_iban = sender_iban
+        self._state = state
     
     @property
-    def state(self):
-        """Gets the state of this InvoiceReimbursement.
+    def title(self):
+        """Gets the title of this PaymentMethodConfiguration.
 
-            The object's current state.
+            The title of the payment method configuration is used within the payment process. The title is visible to the customer.
 
-        :return: The state of this InvoiceReimbursement.
-        :rtype: InvoiceReimbursementState
+        :return: The title of this PaymentMethodConfiguration.
+        :rtype: DatabaseTranslatedString
         """
-        return self._state
+        return self._title
 
-    @state.setter
-    def state(self, state):
-        """Sets the state of this InvoiceReimbursement.
+    @title.setter
+    def title(self, title):
+        """Sets the title of this PaymentMethodConfiguration.
 
-            The object's current state.
+            The title of the payment method configuration is used within the payment process. The title is visible to the customer.
 
-        :param state: The state of this InvoiceReimbursement.
-        :type: InvoiceReimbursementState
+        :param title: The title of this PaymentMethodConfiguration.
+        :type: DatabaseTranslatedString
         """
 
-        self._state = state
+        self._title = title
     
     @property
     def version(self):
-        """Gets the version of this InvoiceReimbursement.
+        """Gets the version of this PaymentMethodConfiguration.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
-        :return: The version of this InvoiceReimbursement.
+        :return: The version of this PaymentMethodConfiguration.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
-        """Sets the version of this InvoiceReimbursement.
+        """Sets the version of this PaymentMethodConfiguration.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
-        :param version: The version of this InvoiceReimbursement.
+        :param version: The version of this PaymentMethodConfiguration.
         :type: int
         """
 
         self._version = version
     
 
     def to_dict(self):
@@ -588,27 +486,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(InvoiceReimbursement, dict):
+        if issubclass(PaymentMethodConfiguration, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, InvoiceReimbursement):
+        if not isinstance(other, PaymentMethodConfiguration):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/label.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/label.py`

 * *Files 4% similar despite different names*

```diff
@@ -107,49 +107,49 @@
 
         self._descriptor = descriptor
     
     @property
     def id(self):
         """Gets the id of this Label.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this Label.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this Label.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this Label.
         :type: int
         """
 
         self._id = id
     
     @property
     def version(self):
         """Gets the version of this Label.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this Label.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this Label.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this Label.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/label_descriptor.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/label_descriptor.py`

 * *Files 11% similar despite different names*

```diff
@@ -47,187 +47,187 @@
         
 
     
     @property
     def category(self):
         """Gets the category of this LabelDescriptor.
 
-            The label's category.
+            
 
         :return: The category of this LabelDescriptor.
         :rtype: LabelDescriptorCategory
         """
         return self._category
 
     @category.setter
     def category(self, category):
         """Sets the category of this LabelDescriptor.
 
-            The label's category.
+            
 
         :param category: The category of this LabelDescriptor.
         :type: LabelDescriptorCategory
         """
 
         self._category = category
     
     @property
     def description(self):
         """Gets the description of this LabelDescriptor.
 
-            The localized description of the object.
+            
 
         :return: The description of this LabelDescriptor.
         :rtype: dict(str, str)
         """
         return self._description
 
     @description.setter
     def description(self, description):
         """Sets the description of this LabelDescriptor.
 
-            The localized description of the object.
+            
 
         :param description: The description of this LabelDescriptor.
         :type: dict(str, str)
         """
 
         self._description = description
     
     @property
     def features(self):
         """Gets the features of this LabelDescriptor.
 
-            The features that this label belongs to.
+            
 
         :return: The features of this LabelDescriptor.
         :rtype: list[int]
         """
         return self._features
 
     @features.setter
     def features(self, features):
         """Sets the features of this LabelDescriptor.
 
-            The features that this label belongs to.
+            
 
         :param features: The features of this LabelDescriptor.
         :type: list[int]
         """
 
         self._features = features
     
     @property
     def group(self):
         """Gets the group of this LabelDescriptor.
 
-            The group that this label belongs to.
+            
 
         :return: The group of this LabelDescriptor.
         :rtype: int
         """
         return self._group
 
     @group.setter
     def group(self, group):
         """Sets the group of this LabelDescriptor.
 
-            The group that this label belongs to.
+            
 
         :param group: The group of this LabelDescriptor.
         :type: int
         """
 
         self._group = group
     
     @property
     def id(self):
         """Gets the id of this LabelDescriptor.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this LabelDescriptor.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this LabelDescriptor.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this LabelDescriptor.
         :type: int
         """
 
         self._id = id
     
     @property
     def name(self):
         """Gets the name of this LabelDescriptor.
 
-            The localized name of the object.
+            
 
         :return: The name of this LabelDescriptor.
         :rtype: dict(str, str)
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this LabelDescriptor.
 
-            The localized name of the object.
+            
 
         :param name: The name of this LabelDescriptor.
         :type: dict(str, str)
         """
 
         self._name = name
     
     @property
     def type(self):
         """Gets the type of this LabelDescriptor.
 
-            The type of the label's value.
+            
 
         :return: The type of this LabelDescriptor.
         :rtype: int
         """
         return self._type
 
     @type.setter
     def type(self, type):
         """Sets the type of this LabelDescriptor.
 
-            The type of the label's value.
+            
 
         :param type: The type of this LabelDescriptor.
         :type: int
         """
 
         self._type = type
     
     @property
     def weight(self):
         """Gets the weight of this LabelDescriptor.
 
-            When listing labels, they can be sorted by this number.
+            
 
         :return: The weight of this LabelDescriptor.
         :rtype: int
         """
         return self._weight
 
     @weight.setter
     def weight(self, weight):
         """Sets the weight of this LabelDescriptor.
 
-            When listing labels, they can be sorted by this number.
+            
 
         :param weight: The weight of this LabelDescriptor.
         :type: int
         """
 
         self._weight = weight
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/label_descriptor_group.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/label_descriptor_group.py`

 * *Files 11% similar despite different names*

```diff
@@ -35,95 +35,95 @@
         
 
     
     @property
     def description(self):
         """Gets the description of this LabelDescriptorGroup.
 
-            The localized description of the object.
+            
 
         :return: The description of this LabelDescriptorGroup.
         :rtype: dict(str, str)
         """
         return self._description
 
     @description.setter
     def description(self, description):
         """Sets the description of this LabelDescriptorGroup.
 
-            The localized description of the object.
+            
 
         :param description: The description of this LabelDescriptorGroup.
         :type: dict(str, str)
         """
 
         self._description = description
     
     @property
     def id(self):
         """Gets the id of this LabelDescriptorGroup.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this LabelDescriptorGroup.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this LabelDescriptorGroup.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this LabelDescriptorGroup.
         :type: int
         """
 
         self._id = id
     
     @property
     def name(self):
         """Gets the name of this LabelDescriptorGroup.
 
-            The localized name of the object.
+            
 
         :return: The name of this LabelDescriptorGroup.
         :rtype: dict(str, str)
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this LabelDescriptorGroup.
 
-            The localized name of the object.
+            
 
         :param name: The name of this LabelDescriptorGroup.
         :type: dict(str, str)
         """
 
         self._name = name
     
     @property
     def weight(self):
         """Gets the weight of this LabelDescriptorGroup.
 
-            When listing label groups, they can be sorted by this number.
+            
 
         :return: The weight of this LabelDescriptorGroup.
         :rtype: int
         """
         return self._weight
 
     @weight.setter
     def weight(self, weight):
         """Sets the weight of this LabelDescriptorGroup.
 
-            When listing label groups, they can be sorted by this number.
+            
 
         :param weight: The weight of this LabelDescriptorGroup.
         :type: int
         """
 
         self._weight = weight
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/label_descriptor_type.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/label_descriptor_type.py`

 * *Files 8% similar despite different names*

```diff
@@ -32,72 +32,72 @@
         
 
     
     @property
     def description(self):
         """Gets the description of this LabelDescriptorType.
 
-            The localized description of the object.
+            
 
         :return: The description of this LabelDescriptorType.
         :rtype: dict(str, str)
         """
         return self._description
 
     @description.setter
     def description(self, description):
         """Sets the description of this LabelDescriptorType.
 
-            The localized description of the object.
+            
 
         :param description: The description of this LabelDescriptorType.
         :type: dict(str, str)
         """
 
         self._description = description
     
     @property
     def id(self):
         """Gets the id of this LabelDescriptorType.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this LabelDescriptorType.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this LabelDescriptorType.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this LabelDescriptorType.
         :type: int
         """
 
         self._id = id
     
     @property
     def name(self):
         """Gets the name of this LabelDescriptorType.
 
-            The localized name of the object.
+            
 
         :return: The name of this LabelDescriptorType.
         :rtype: dict(str, str)
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this LabelDescriptorType.
 
-            The localized name of the object.
+            
 
         :param name: The name of this LabelDescriptorType.
         :type: dict(str, str)
         """
 
         self._name = name
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/legal_organization_form.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/legal_organization_form.py`

 * *Files 11% similar despite different names*

```diff
@@ -38,118 +38,118 @@
         
 
     
     @property
     def country(self):
         """Gets the country of this LegalOrganizationForm.
 
-            The two-letter code of the country the legal organization form is used in (ISO 3166-1 alpha-2 format).
+            
 
         :return: The country of this LegalOrganizationForm.
         :rtype: str
         """
         return self._country
 
     @country.setter
     def country(self, country):
         """Sets the country of this LegalOrganizationForm.
 
-            The two-letter code of the country the legal organization form is used in (ISO 3166-1 alpha-2 format).
+            
 
         :param country: The country of this LegalOrganizationForm.
         :type: str
         """
 
         self._country = country
     
     @property
     def description(self):
         """Gets the description of this LegalOrganizationForm.
 
-            The localized descriptions of the legal organization form.
+            
 
         :return: The description of this LegalOrganizationForm.
         :rtype: list[LocalizedString]
         """
         return self._description
 
     @description.setter
     def description(self, description):
         """Sets the description of this LegalOrganizationForm.
 
-            The localized descriptions of the legal organization form.
+            
 
         :param description: The description of this LegalOrganizationForm.
         :type: list[LocalizedString]
         """
 
         self._description = description
     
     @property
     def english_description(self):
         """Gets the english_description of this LegalOrganizationForm.
 
-            The English name of the legal organization form.
+            
 
         :return: The english_description of this LegalOrganizationForm.
         :rtype: str
         """
         return self._english_description
 
     @english_description.setter
     def english_description(self, english_description):
         """Sets the english_description of this LegalOrganizationForm.
 
-            The English name of the legal organization form.
+            
 
         :param english_description: The english_description of this LegalOrganizationForm.
         :type: str
         """
 
         self._english_description = english_description
     
     @property
     def id(self):
         """Gets the id of this LegalOrganizationForm.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this LegalOrganizationForm.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this LegalOrganizationForm.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this LegalOrganizationForm.
         :type: int
         """
 
         self._id = id
     
     @property
     def shortcut(self):
         """Gets the shortcut of this LegalOrganizationForm.
 
-            The localized shortcuts of the legal organization form.
+            
 
         :return: The shortcut of this LegalOrganizationForm.
         :rtype: list[LocalizedString]
         """
         return self._shortcut
 
     @shortcut.setter
     def shortcut(self, shortcut):
         """Sets the shortcut of this LegalOrganizationForm.
 
-            The localized shortcuts of the legal organization form.
+            
 
         :param shortcut: The shortcut of this LegalOrganizationForm.
         :type: list[LocalizedString]
         """
 
         self._shortcut = shortcut
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/line_item.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/line_item.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/line_item_attribute.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/line_item_attribute.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/line_item_attribute_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/refund_comment_create.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,93 +1,62 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
+from . import AbstractRefundCommentActive
 
 
-
-class LineItemAttributeCreate:
+class RefundCommentCreate(AbstractRefundCommentActive):
 
     swagger_types = {
     
-        'label': 'str',
-        'value': 'str',
+        'refund': 'int',
     }
 
     attribute_map = {
-        'label': 'label','value': 'value',
+        'refund': 'refund',
     }
 
     
-    _label = None
-    _value = None
+    _refund = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
-        self.label = kwargs.get('label')
-
-        self.value = kwargs.get('value')
-
-        
+        self.refund = kwargs.get('refund')
 
-    
-    @property
-    def label(self):
-        """Gets the label of this LineItemAttributeCreate.
-
-            
-
-        :return: The label of this LineItemAttributeCreate.
-        :rtype: str
-        """
-        return self._label
-
-    @label.setter
-    def label(self, label):
-        """Sets the label of this LineItemAttributeCreate.
-
-            
-
-        :param label: The label of this LineItemAttributeCreate.
-        :type: str
-        """
-        if label is None:
-            raise ValueError("Invalid value for `label`, must not be `None`")
-        if label is not None and len(label) > 512:
-            raise ValueError("Invalid value for `label`, length must be less than or equal to `512`")
+        super().__init__(**kwargs)
+        self.swagger_types.update(super().swagger_types)
+        self.attribute_map.update(super().attribute_map)
 
-        self._label = label
     
     @property
-    def value(self):
-        """Gets the value of this LineItemAttributeCreate.
+    def refund(self):
+        """Gets the refund of this RefundCommentCreate.
 
             
 
-        :return: The value of this LineItemAttributeCreate.
-        :rtype: str
+        :return: The refund of this RefundCommentCreate.
+        :rtype: int
         """
-        return self._value
+        return self._refund
 
-    @value.setter
-    def value(self, value):
-        """Sets the value of this LineItemAttributeCreate.
+    @refund.setter
+    def refund(self, refund):
+        """Sets the refund of this RefundCommentCreate.
 
             
 
-        :param value: The value of this LineItemAttributeCreate.
-        :type: str
+        :param refund: The refund of this RefundCommentCreate.
+        :type: int
         """
-        if value is None:
-            raise ValueError("Invalid value for `value`, must not be `None`")
-        if value is not None and len(value) > 512:
-            raise ValueError("Invalid value for `value`, length must be less than or equal to `512`")
+        if refund is None:
+            raise ValueError("Invalid value for `refund`, must not be `None`")
 
-        self._value = value
+        self._refund = refund
     
 
     def to_dict(self):
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
@@ -104,27 +73,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(LineItemAttributeCreate, dict):
+        if issubclass(RefundCommentCreate, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, LineItemAttributeCreate):
+        if not isinstance(other, RefundCommentCreate):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/line_item_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/line_item_create.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/line_item_reduction.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/line_item_reduction.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/line_item_reduction_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/line_item_reduction_create.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/localized_string.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/localized_string.py`

 * *Files 16% similar despite different names*

```diff
@@ -5,73 +5,99 @@
 
 
 
 class LocalizedString:
 
     swagger_types = {
     
+        'display_name': 'str',
         'language': 'str',
         'string': 'str',
     }
 
     attribute_map = {
-        'language': 'language','string': 'string',
+        'display_name': 'displayName','language': 'language','string': 'string',
     }
 
     
+    _display_name = None
     _language = None
     _string = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
+        self.display_name = kwargs.get('display_name', None)
         self.language = kwargs.get('language', None)
         self.string = kwargs.get('string', None)
         
 
     
     @property
+    def display_name(self):
+        """Gets the display_name of this LocalizedString.
+
+            
+
+        :return: The display_name of this LocalizedString.
+        :rtype: str
+        """
+        return self._display_name
+
+    @display_name.setter
+    def display_name(self, display_name):
+        """Sets the display_name of this LocalizedString.
+
+            
+
+        :param display_name: The display_name of this LocalizedString.
+        :type: str
+        """
+
+        self._display_name = display_name
+    
+    @property
     def language(self):
         """Gets the language of this LocalizedString.
 
-            The term's language.
+            
 
         :return: The language of this LocalizedString.
         :rtype: str
         """
         return self._language
 
     @language.setter
     def language(self, language):
         """Sets the language of this LocalizedString.
 
-            The term's language.
+            
 
         :param language: The language of this LocalizedString.
         :type: str
         """
 
         self._language = language
     
     @property
     def string(self):
         """Gets the string of this LocalizedString.
 
-            The localized term.
+            
 
         :return: The string of this LocalizedString.
         :rtype: str
         """
         return self._string
 
     @string.setter
     def string(self, string):
         """Sets the string of this LocalizedString.
 
-            The localized term.
+            
 
         :param string: The string of this LocalizedString.
         :type: str
         """
 
         self._string = string
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/manual_task.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/manual_task.py`

 * *Files 20% similar despite different names*

```diff
@@ -12,248 +12,274 @@
         'actions': 'list[int]',
         'context_entity_id': 'int',
         'created_on': 'datetime',
         'expires_on': 'datetime',
         'id': 'int',
         'linked_space_id': 'int',
         'planned_purge_date': 'datetime',
+        'space_id': 'int',
         'state': 'ManualTaskState',
         'type': 'int',
     }
 
     attribute_map = {
-        'actions': 'actions','context_entity_id': 'contextEntityId','created_on': 'createdOn','expires_on': 'expiresOn','id': 'id','linked_space_id': 'linkedSpaceId','planned_purge_date': 'plannedPurgeDate','state': 'state','type': 'type',
+        'actions': 'actions','context_entity_id': 'contextEntityId','created_on': 'createdOn','expires_on': 'expiresOn','id': 'id','linked_space_id': 'linkedSpaceId','planned_purge_date': 'plannedPurgeDate','space_id': 'spaceId','state': 'state','type': 'type',
     }
 
     
     _actions = None
     _context_entity_id = None
     _created_on = None
     _expires_on = None
     _id = None
     _linked_space_id = None
     _planned_purge_date = None
+    _space_id = None
     _state = None
     _type = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
         self.actions = kwargs.get('actions', None)
         self.context_entity_id = kwargs.get('context_entity_id', None)
         self.created_on = kwargs.get('created_on', None)
         self.expires_on = kwargs.get('expires_on', None)
         self.id = kwargs.get('id', None)
         self.linked_space_id = kwargs.get('linked_space_id', None)
         self.planned_purge_date = kwargs.get('planned_purge_date', None)
+        self.space_id = kwargs.get('space_id', None)
         self.state = kwargs.get('state', None)
         self.type = kwargs.get('type', None)
         
 
     
     @property
     def actions(self):
         """Gets the actions of this ManualTask.
 
-            The actions that can be triggered to handle the manual task.
+            
 
         :return: The actions of this ManualTask.
         :rtype: list[int]
         """
         return self._actions
 
     @actions.setter
     def actions(self, actions):
         """Sets the actions of this ManualTask.
 
-            The actions that can be triggered to handle the manual task.
+            
 
         :param actions: The actions of this ManualTask.
         :type: list[int]
         """
 
         self._actions = actions
     
     @property
     def context_entity_id(self):
         """Gets the context_entity_id of this ManualTask.
 
-            The ID of the entity the manual task is linked to.
+            The context entity ID links the manual task to the entity which caused its creation.
 
         :return: The context_entity_id of this ManualTask.
         :rtype: int
         """
         return self._context_entity_id
 
     @context_entity_id.setter
     def context_entity_id(self, context_entity_id):
         """Sets the context_entity_id of this ManualTask.
 
-            The ID of the entity the manual task is linked to.
+            The context entity ID links the manual task to the entity which caused its creation.
 
         :param context_entity_id: The context_entity_id of this ManualTask.
         :type: int
         """
 
         self._context_entity_id = context_entity_id
     
     @property
     def created_on(self):
         """Gets the created_on of this ManualTask.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :return: The created_on of this ManualTask.
         :rtype: datetime
         """
         return self._created_on
 
     @created_on.setter
     def created_on(self, created_on):
         """Sets the created_on of this ManualTask.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :param created_on: The created_on of this ManualTask.
         :type: datetime
         """
 
         self._created_on = created_on
     
     @property
     def expires_on(self):
         """Gets the expires_on of this ManualTask.
 
-            The date and time until when the manual task has to be handled.
+            The expiry date indicates until when the manual task has to be executed.
 
         :return: The expires_on of this ManualTask.
         :rtype: datetime
         """
         return self._expires_on
 
     @expires_on.setter
     def expires_on(self, expires_on):
         """Sets the expires_on of this ManualTask.
 
-            The date and time until when the manual task has to be handled.
+            The expiry date indicates until when the manual task has to be executed.
 
         :param expires_on: The expires_on of this ManualTask.
         :type: datetime
         """
 
         self._expires_on = expires_on
     
     @property
     def id(self):
         """Gets the id of this ManualTask.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this ManualTask.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this ManualTask.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this ManualTask.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this ManualTask.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this ManualTask.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this ManualTask.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this ManualTask.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this ManualTask.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this ManualTask.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this ManualTask.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this ManualTask.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
     @property
+    def space_id(self):
+        """Gets the space_id of this ManualTask.
+
+            
+
+        :return: The space_id of this ManualTask.
+        :rtype: int
+        """
+        return self._space_id
+
+    @space_id.setter
+    def space_id(self, space_id):
+        """Sets the space_id of this ManualTask.
+
+            
+
+        :param space_id: The space_id of this ManualTask.
+        :type: int
+        """
+
+        self._space_id = space_id
+    
+    @property
     def state(self):
         """Gets the state of this ManualTask.
 
-            The object's current state.
+            
 
         :return: The state of this ManualTask.
         :rtype: ManualTaskState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this ManualTask.
 
-            The object's current state.
+            
 
         :param state: The state of this ManualTask.
         :type: ManualTaskState
         """
 
         self._state = state
     
     @property
     def type(self):
         """Gets the type of this ManualTask.
 
-            The manual task's type.
+            The type categorizes the manual task.
 
         :return: The type of this ManualTask.
         :rtype: int
         """
         return self._type
 
     @type.setter
     def type(self, type):
         """Sets the type of this ManualTask.
 
-            The manual task's type.
+            The type categorizes the manual task.
 
         :param type: The type of this ManualTask.
         :type: int
         """
 
         self._type = type
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/manual_task_action.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/manual_task_action.py`

 * *Files 6% similar despite different names*

```diff
@@ -35,95 +35,95 @@
         
 
     
     @property
     def id(self):
         """Gets the id of this ManualTaskAction.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this ManualTaskAction.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this ManualTaskAction.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this ManualTaskAction.
         :type: int
         """
 
         self._id = id
     
     @property
     def label(self):
         """Gets the label of this ManualTaskAction.
 
-            The action's label.
+            
 
         :return: The label of this ManualTaskAction.
         :rtype: dict(str, str)
         """
         return self._label
 
     @label.setter
     def label(self, label):
         """Sets the label of this ManualTaskAction.
 
-            The action's label.
+            
 
         :param label: The label of this ManualTaskAction.
         :type: dict(str, str)
         """
 
         self._label = label
     
     @property
     def style(self):
         """Gets the style of this ManualTaskAction.
 
-            The action's style.
+            
 
         :return: The style of this ManualTaskAction.
         :rtype: ManualTaskActionStyle
         """
         return self._style
 
     @style.setter
     def style(self, style):
         """Sets the style of this ManualTaskAction.
 
-            The action's style.
+            
 
         :param style: The style of this ManualTaskAction.
         :type: ManualTaskActionStyle
         """
 
         self._style = style
     
     @property
     def task_type(self):
         """Gets the task_type of this ManualTaskAction.
 
-            The type of manual tasks this action belongs to.
+            
 
         :return: The task_type of this ManualTaskAction.
         :rtype: int
         """
         return self._task_type
 
     @task_type.setter
     def task_type(self, task_type):
         """Sets the task_type of this ManualTaskAction.
 
-            The type of manual tasks this action belongs to.
+            
 
         :param task_type: The task_type of this ManualTaskAction.
         :type: int
         """
 
         self._task_type = task_type
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/manual_task_type.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/token_version_type.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,131 +1,131 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
 
 
 
-class ManualTaskType:
+class TokenVersionType:
 
     swagger_types = {
     
         'description': 'dict(str, str)',
-        'features': 'list[int]',
+        'feature': 'Feature',
         'id': 'int',
         'name': 'dict(str, str)',
     }
 
     attribute_map = {
-        'description': 'description','features': 'features','id': 'id','name': 'name',
+        'description': 'description','feature': 'feature','id': 'id','name': 'name',
     }
 
     
     _description = None
-    _features = None
+    _feature = None
     _id = None
     _name = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
         self.description = kwargs.get('description', None)
-        self.features = kwargs.get('features', None)
+        self.feature = kwargs.get('feature', None)
         self.id = kwargs.get('id', None)
         self.name = kwargs.get('name', None)
         
 
     
     @property
     def description(self):
-        """Gets the description of this ManualTaskType.
+        """Gets the description of this TokenVersionType.
 
-            The localized description of the object.
+            
 
-        :return: The description of this ManualTaskType.
+        :return: The description of this TokenVersionType.
         :rtype: dict(str, str)
         """
         return self._description
 
     @description.setter
     def description(self, description):
-        """Sets the description of this ManualTaskType.
+        """Sets the description of this TokenVersionType.
 
-            The localized description of the object.
+            
 
-        :param description: The description of this ManualTaskType.
+        :param description: The description of this TokenVersionType.
         :type: dict(str, str)
         """
 
         self._description = description
     
     @property
-    def features(self):
-        """Gets the features of this ManualTaskType.
+    def feature(self):
+        """Gets the feature of this TokenVersionType.
 
-            The features that this type belongs to.
+            
 
-        :return: The features of this ManualTaskType.
-        :rtype: list[int]
+        :return: The feature of this TokenVersionType.
+        :rtype: Feature
         """
-        return self._features
+        return self._feature
 
-    @features.setter
-    def features(self, features):
-        """Sets the features of this ManualTaskType.
+    @feature.setter
+    def feature(self, feature):
+        """Sets the feature of this TokenVersionType.
 
-            The features that this type belongs to.
+            
 
-        :param features: The features of this ManualTaskType.
-        :type: list[int]
+        :param feature: The feature of this TokenVersionType.
+        :type: Feature
         """
 
-        self._features = features
+        self._feature = feature
     
     @property
     def id(self):
-        """Gets the id of this ManualTaskType.
+        """Gets the id of this TokenVersionType.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
-        :return: The id of this ManualTaskType.
+        :return: The id of this TokenVersionType.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
-        """Sets the id of this ManualTaskType.
+        """Sets the id of this TokenVersionType.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
-        :param id: The id of this ManualTaskType.
+        :param id: The id of this TokenVersionType.
         :type: int
         """
 
         self._id = id
     
     @property
     def name(self):
-        """Gets the name of this ManualTaskType.
+        """Gets the name of this TokenVersionType.
 
-            The localized name of the object.
+            
 
-        :return: The name of this ManualTaskType.
+        :return: The name of this TokenVersionType.
         :rtype: dict(str, str)
         """
         return self._name
 
     @name.setter
     def name(self, name):
-        """Sets the name of this ManualTaskType.
+        """Sets the name of this TokenVersionType.
 
-            The localized name of the object.
+            
 
-        :param name: The name of this ManualTaskType.
+        :param name: The name of this TokenVersionType.
         :type: dict(str, str)
         """
 
         self._name = name
     
 
     def to_dict(self):
@@ -146,27 +146,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(ManualTaskType, dict):
+        if issubclass(TokenVersionType, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, ManualTaskType):
+        if not isinstance(other, TokenVersionType):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/metric_usage.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/metric_usage.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_adjustment.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_adjustment.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_adjustment_type.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_adjustment_type.py`

 * *Files 7% similar despite different names*

```diff
@@ -32,72 +32,72 @@
         
 
     
     @property
     def description(self):
         """Gets the description of this PaymentAdjustmentType.
 
-            The localized description of the object.
+            
 
         :return: The description of this PaymentAdjustmentType.
         :rtype: dict(str, str)
         """
         return self._description
 
     @description.setter
     def description(self, description):
         """Sets the description of this PaymentAdjustmentType.
 
-            The localized description of the object.
+            
 
         :param description: The description of this PaymentAdjustmentType.
         :type: dict(str, str)
         """
 
         self._description = description
     
     @property
     def id(self):
         """Gets the id of this PaymentAdjustmentType.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this PaymentAdjustmentType.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this PaymentAdjustmentType.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this PaymentAdjustmentType.
         :type: int
         """
 
         self._id = id
     
     @property
     def name(self):
         """Gets the name of this PaymentAdjustmentType.
 
-            The localized name of the object.
+            
 
         :return: The name of this PaymentAdjustmentType.
         :rtype: dict(str, str)
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this PaymentAdjustmentType.
 
-            The localized name of the object.
+            
 
         :param name: The name of this PaymentAdjustmentType.
         :type: dict(str, str)
         """
 
         self._name = name
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_app_charge_attempt_update_request.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_app_charge_attempt_update_request.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_app_completion_configuration.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_app_completion_configuration.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_app_completion_configuration_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_app_completion_configuration_create.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_app_completion_update_request.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_app_completion_update_request.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_app_connector.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_app_connector.py`

 * *Files 4% similar despite different names*

```diff
@@ -182,49 +182,49 @@
 
         self._external_id = external_id
     
     @property
     def id(self):
         """Gets the id of this PaymentAppConnector.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this PaymentAppConnector.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this PaymentAppConnector.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this PaymentAppConnector.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this PaymentAppConnector.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this PaymentAppConnector.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this PaymentAppConnector.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this PaymentAppConnector.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -322,26 +322,26 @@
 
         self._refund_configuration = refund_configuration
     
     @property
     def state(self):
         """Gets the state of this PaymentAppConnector.
 
-            The object's current state.
+            
 
         :return: The state of this PaymentAppConnector.
         :rtype: PaymentAppConnectorState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this PaymentAppConnector.
 
-            The object's current state.
+            
 
         :param state: The state of this PaymentAppConnector.
         :type: PaymentAppConnectorState
         """
 
         self._state = state
     
@@ -368,26 +368,26 @@
 
         self._updated_on = updated_on
     
     @property
     def version(self):
         """Gets the version of this PaymentAppConnector.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this PaymentAppConnector.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this PaymentAppConnector.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this PaymentAppConnector.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_app_connector_creation_request.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_app_connector_creation_request.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_app_processor.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_app_processor.py`

 * *Files 2% similar despite different names*

```diff
@@ -165,26 +165,26 @@
 
         self._external_id = external_id
     
     @property
     def id(self):
         """Gets the id of this PaymentAppProcessor.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this PaymentAppProcessor.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this PaymentAppProcessor.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this PaymentAppProcessor.
         :type: int
         """
 
         self._id = id
     
@@ -211,26 +211,26 @@
 
         self._installation_id = installation_id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this PaymentAppProcessor.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this PaymentAppProcessor.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this PaymentAppProcessor.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this PaymentAppProcessor.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -305,26 +305,26 @@
 
         self._production_mode_url = production_mode_url
     
     @property
     def state(self):
         """Gets the state of this PaymentAppProcessor.
 
-            The object's current state.
+            
 
         :return: The state of this PaymentAppProcessor.
         :rtype: PaymentAppProcessorState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this PaymentAppProcessor.
 
-            The object's current state.
+            
 
         :param state: The state of this PaymentAppProcessor.
         :type: PaymentAppProcessorState
         """
 
         self._state = state
     
@@ -422,26 +422,26 @@
 
         self._usable_in_production_since = usable_in_production_since
     
     @property
     def version(self):
         """Gets the version of this PaymentAppProcessor.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this PaymentAppProcessor.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this PaymentAppProcessor.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this PaymentAppProcessor.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_app_processor_creation_request.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_app_processor_creation_request.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_app_refund_configuration.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_app_refund_configuration.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_app_refund_configuration_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_app_refund_configuration_create.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_app_refund_update_request.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_app_refund_update_request.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_app_void_update_request.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_app_void_update_request.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_connector.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_connector.py`

 * *Files 2% similar despite different names*

```diff
@@ -131,26 +131,26 @@
 
         self._deprecation_reason = deprecation_reason
     
     @property
     def description(self):
         """Gets the description of this PaymentConnector.
 
-            The localized description of the object.
+            
 
         :return: The description of this PaymentConnector.
         :rtype: dict(str, str)
         """
         return self._description
 
     @description.setter
     def description(self, description):
         """Sets the description of this PaymentConnector.
 
-            The localized description of the object.
+            
 
         :param description: The description of this PaymentConnector.
         :type: dict(str, str)
         """
 
         self._description = description
     
@@ -177,49 +177,49 @@
 
         self._feature = feature
     
     @property
     def id(self):
         """Gets the id of this PaymentConnector.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this PaymentConnector.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this PaymentConnector.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this PaymentConnector.
         :type: int
         """
 
         self._id = id
     
     @property
     def name(self):
         """Gets the name of this PaymentConnector.
 
-            The localized name of the object.
+            
 
         :return: The name of this PaymentConnector.
         :rtype: dict(str, str)
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this PaymentConnector.
 
-            The localized name of the object.
+            
 
         :param name: The name of this PaymentConnector.
         :type: dict(str, str)
         """
 
         self._name = name
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_connector_configuration.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_connector_configuration.py`

 * *Files 5% similar despite different names*

```diff
@@ -180,49 +180,49 @@
 
         self._enabled_space_views = enabled_space_views
     
     @property
     def id(self):
         """Gets the id of this PaymentConnectorConfiguration.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this PaymentConnectorConfiguration.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this PaymentConnectorConfiguration.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this PaymentConnectorConfiguration.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this PaymentConnectorConfiguration.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this PaymentConnectorConfiguration.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this PaymentConnectorConfiguration.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this PaymentConnectorConfiguration.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -274,26 +274,26 @@
 
         self._payment_method_configuration = payment_method_configuration
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this PaymentConnectorConfiguration.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this PaymentConnectorConfiguration.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this PaymentConnectorConfiguration.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this PaymentConnectorConfiguration.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -343,49 +343,49 @@
 
         self._processor_configuration = processor_configuration
     
     @property
     def state(self):
         """Gets the state of this PaymentConnectorConfiguration.
 
-            The object's current state.
+            
 
         :return: The state of this PaymentConnectorConfiguration.
         :rtype: CreationEntityState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this PaymentConnectorConfiguration.
 
-            The object's current state.
+            
 
         :param state: The state of this PaymentConnectorConfiguration.
         :type: CreationEntityState
         """
 
         self._state = state
     
     @property
     def version(self):
         """Gets the version of this PaymentConnectorConfiguration.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this PaymentConnectorConfiguration.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this PaymentConnectorConfiguration.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this PaymentConnectorConfiguration.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_connector_feature.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_connector_feature.py`

 * *Files 7% similar despite different names*

```diff
@@ -78,26 +78,26 @@
 
         self._feature = feature
     
     @property
     def id(self):
         """Gets the id of this PaymentConnectorFeature.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this PaymentConnectorFeature.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this PaymentConnectorFeature.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this PaymentConnectorFeature.
         :type: int
         """
 
         self._id = id
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_contract.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_contract.py`

 * *Files 3% similar despite different names*

```diff
@@ -183,26 +183,26 @@
 
         self._created_by = created_by
     
     @property
     def created_on(self):
         """Gets the created_on of this PaymentContract.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :return: The created_on of this PaymentContract.
         :rtype: datetime
         """
         return self._created_on
 
     @created_on.setter
     def created_on(self, created_on):
         """Sets the created_on of this PaymentContract.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :param created_on: The created_on of this PaymentContract.
         :type: datetime
         """
 
         self._created_on = created_on
     
@@ -229,26 +229,26 @@
 
         self._external_id = external_id
     
     @property
     def id(self):
         """Gets the id of this PaymentContract.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this PaymentContract.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this PaymentContract.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this PaymentContract.
         :type: int
         """
 
         self._id = id
     
@@ -321,26 +321,26 @@
 
         self._start_terminating_on = start_terminating_on
     
     @property
     def state(self):
         """Gets the state of this PaymentContract.
 
-            The object's current state.
+            
 
         :return: The state of this PaymentContract.
         :rtype: PaymentContractState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this PaymentContract.
 
-            The object's current state.
+            
 
         :param state: The state of this PaymentContract.
         :type: PaymentContractState
         """
 
         self._state = state
     
@@ -390,26 +390,26 @@
 
         self._terminated_on = terminated_on
     
     @property
     def version(self):
         """Gets the version of this PaymentContract.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this PaymentContract.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this PaymentContract.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this PaymentContract.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_contract_type.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_metric_type.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
 
 
 
-class PaymentContractType:
+class SubscriptionMetricType:
 
     swagger_types = {
     
         'description': 'dict(str, str)',
         'feature': 'Feature',
         'id': 'int',
         'name': 'dict(str, str)',
@@ -33,99 +33,99 @@
         self.id = kwargs.get('id', None)
         self.name = kwargs.get('name', None)
         
 
     
     @property
     def description(self):
-        """Gets the description of this PaymentContractType.
+        """Gets the description of this SubscriptionMetricType.
 
-            The localized description of the object.
+            
 
-        :return: The description of this PaymentContractType.
+        :return: The description of this SubscriptionMetricType.
         :rtype: dict(str, str)
         """
         return self._description
 
     @description.setter
     def description(self, description):
-        """Sets the description of this PaymentContractType.
+        """Sets the description of this SubscriptionMetricType.
 
-            The localized description of the object.
+            
 
-        :param description: The description of this PaymentContractType.
+        :param description: The description of this SubscriptionMetricType.
         :type: dict(str, str)
         """
 
         self._description = description
     
     @property
     def feature(self):
-        """Gets the feature of this PaymentContractType.
+        """Gets the feature of this SubscriptionMetricType.
 
             
 
-        :return: The feature of this PaymentContractType.
+        :return: The feature of this SubscriptionMetricType.
         :rtype: Feature
         """
         return self._feature
 
     @feature.setter
     def feature(self, feature):
-        """Sets the feature of this PaymentContractType.
+        """Sets the feature of this SubscriptionMetricType.
 
             
 
-        :param feature: The feature of this PaymentContractType.
+        :param feature: The feature of this SubscriptionMetricType.
         :type: Feature
         """
 
         self._feature = feature
     
     @property
     def id(self):
-        """Gets the id of this PaymentContractType.
+        """Gets the id of this SubscriptionMetricType.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
-        :return: The id of this PaymentContractType.
+        :return: The id of this SubscriptionMetricType.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
-        """Sets the id of this PaymentContractType.
+        """Sets the id of this SubscriptionMetricType.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
-        :param id: The id of this PaymentContractType.
+        :param id: The id of this SubscriptionMetricType.
         :type: int
         """
 
         self._id = id
     
     @property
     def name(self):
-        """Gets the name of this PaymentContractType.
+        """Gets the name of this SubscriptionMetricType.
 
-            The localized name of the object.
+            
 
-        :return: The name of this PaymentContractType.
+        :return: The name of this SubscriptionMetricType.
         :rtype: dict(str, str)
         """
         return self._name
 
     @name.setter
     def name(self, name):
-        """Sets the name of this PaymentContractType.
+        """Sets the name of this SubscriptionMetricType.
 
-            The localized name of the object.
+            
 
-        :param name: The name of this PaymentContractType.
+        :param name: The name of this SubscriptionMetricType.
         :type: dict(str, str)
         """
 
         self._name = name
     
 
     def to_dict(self):
@@ -146,27 +146,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(PaymentContractType, dict):
+        if issubclass(SubscriptionMetricType, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, PaymentContractType):
+        if not isinstance(other, SubscriptionMetricType):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_information_hash.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_information_hash.py`

 * *Files 8% similar despite different names*

```diff
@@ -32,26 +32,26 @@
         
 
     
     @property
     def id(self):
         """Gets the id of this PaymentInformationHash.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this PaymentInformationHash.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this PaymentInformationHash.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this PaymentInformationHash.
         :type: int
         """
 
         self._id = id
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_information_hash_type.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_information_hash_type.py`

 * *Files 5% similar despite different names*

```diff
@@ -29,26 +29,26 @@
         
 
     
     @property
     def id(self):
         """Gets the id of this PaymentInformationHashType.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this PaymentInformationHashType.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this PaymentInformationHashType.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this PaymentInformationHashType.
         :type: int
         """
 
         self._id = id
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_initiation_advice_file.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/scope.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,291 +1,349 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
 
 
 
-class PaymentInitiationAdviceFile:
+class Scope:
 
     swagger_types = {
     
-        'created_on': 'datetime',
-        'failure_message': 'str',
-        'file_generated_on': 'datetime',
-        'forwarded_on': 'datetime',
+        'domain_name': 'str',
+        'features': 'list[Feature]',
         'id': 'int',
-        'linked_space_id': 'int',
+        'machine_name': 'str',
         'name': 'str',
-        'processed_on': 'datetime',
-        'processor': 'PaymentProcessor',
-        'state': 'PaymentInitiationAdviceFileState',
+        'planned_purge_date': 'datetime',
+        'port': 'int',
+        'ssl_active': 'bool',
+        'state': 'CreationEntityState',
+        'themes': 'list[str]',
+        'url': 'str',
+        'version': 'int',
     }
 
     attribute_map = {
-        'created_on': 'createdOn','failure_message': 'failureMessage','file_generated_on': 'fileGeneratedOn','forwarded_on': 'forwardedOn','id': 'id','linked_space_id': 'linkedSpaceId','name': 'name','processed_on': 'processedOn','processor': 'processor','state': 'state',
+        'domain_name': 'domainName','features': 'features','id': 'id','machine_name': 'machineName','name': 'name','planned_purge_date': 'plannedPurgeDate','port': 'port','ssl_active': 'sslActive','state': 'state','themes': 'themes','url': 'url','version': 'version',
     }
 
     
-    _created_on = None
-    _failure_message = None
-    _file_generated_on = None
-    _forwarded_on = None
+    _domain_name = None
+    _features = None
     _id = None
-    _linked_space_id = None
+    _machine_name = None
     _name = None
-    _processed_on = None
-    _processor = None
+    _planned_purge_date = None
+    _port = None
+    _ssl_active = None
     _state = None
+    _themes = None
+    _url = None
+    _version = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
-        self.created_on = kwargs.get('created_on', None)
-        self.failure_message = kwargs.get('failure_message', None)
-        self.file_generated_on = kwargs.get('file_generated_on', None)
-        self.forwarded_on = kwargs.get('forwarded_on', None)
+        self.domain_name = kwargs.get('domain_name', None)
+        self.features = kwargs.get('features', None)
         self.id = kwargs.get('id', None)
-        self.linked_space_id = kwargs.get('linked_space_id', None)
+        self.machine_name = kwargs.get('machine_name', None)
         self.name = kwargs.get('name', None)
-        self.processed_on = kwargs.get('processed_on', None)
-        self.processor = kwargs.get('processor', None)
+        self.planned_purge_date = kwargs.get('planned_purge_date', None)
+        self.port = kwargs.get('port', None)
+        self.ssl_active = kwargs.get('ssl_active', None)
         self.state = kwargs.get('state', None)
+        self.themes = kwargs.get('themes', None)
+        self.url = kwargs.get('url', None)
+        self.version = kwargs.get('version', None)
         
 
     
     @property
-    def created_on(self):
-        """Gets the created_on of this PaymentInitiationAdviceFile.
+    def domain_name(self):
+        """Gets the domain_name of this Scope.
 
-            The created on date indicates the date on which the entity was stored into the database.
+            The domain name to which this scope is mapped to.
 
-        :return: The created_on of this PaymentInitiationAdviceFile.
-        :rtype: datetime
+        :return: The domain_name of this Scope.
+        :rtype: str
         """
-        return self._created_on
+        return self._domain_name
 
-    @created_on.setter
-    def created_on(self, created_on):
-        """Sets the created_on of this PaymentInitiationAdviceFile.
+    @domain_name.setter
+    def domain_name(self, domain_name):
+        """Sets the domain_name of this Scope.
 
-            The created on date indicates the date on which the entity was stored into the database.
+            The domain name to which this scope is mapped to.
 
-        :param created_on: The created_on of this PaymentInitiationAdviceFile.
-        :type: datetime
+        :param domain_name: The domain_name of this Scope.
+        :type: str
         """
+        if domain_name is not None and len(domain_name) > 40:
+            raise ValueError("Invalid value for `domain_name`, length must be less than or equal to `40`")
 
-        self._created_on = created_on
+        self._domain_name = domain_name
     
     @property
-    def failure_message(self):
-        """Gets the failure_message of this PaymentInitiationAdviceFile.
+    def features(self):
+        """Gets the features of this Scope.
 
             
 
-        :return: The failure_message of this PaymentInitiationAdviceFile.
-        :rtype: str
+        :return: The features of this Scope.
+        :rtype: list[Feature]
         """
-        return self._failure_message
+        return self._features
 
-    @failure_message.setter
-    def failure_message(self, failure_message):
-        """Sets the failure_message of this PaymentInitiationAdviceFile.
+    @features.setter
+    def features(self, features):
+        """Sets the features of this Scope.
 
             
 
-        :param failure_message: The failure_message of this PaymentInitiationAdviceFile.
-        :type: str
+        :param features: The features of this Scope.
+        :type: list[Feature]
+        """
+
+        self._features = features
+    
+    @property
+    def id(self):
+        """Gets the id of this Scope.
+
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
+
+        :return: The id of this Scope.
+        :rtype: int
+        """
+        return self._id
+
+    @id.setter
+    def id(self, id):
+        """Sets the id of this Scope.
+
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
+
+        :param id: The id of this Scope.
+        :type: int
         """
 
-        self._failure_message = failure_message
+        self._id = id
     
     @property
-    def file_generated_on(self):
-        """Gets the file_generated_on of this PaymentInitiationAdviceFile.
+    def machine_name(self):
+        """Gets the machine_name of this Scope.
 
             
 
-        :return: The file_generated_on of this PaymentInitiationAdviceFile.
-        :rtype: datetime
+        :return: The machine_name of this Scope.
+        :rtype: str
         """
-        return self._file_generated_on
+        return self._machine_name
 
-    @file_generated_on.setter
-    def file_generated_on(self, file_generated_on):
-        """Sets the file_generated_on of this PaymentInitiationAdviceFile.
+    @machine_name.setter
+    def machine_name(self, machine_name):
+        """Sets the machine_name of this Scope.
 
             
 
-        :param file_generated_on: The file_generated_on of this PaymentInitiationAdviceFile.
-        :type: datetime
+        :param machine_name: The machine_name of this Scope.
+        :type: str
+        """
+        if machine_name is not None and len(machine_name) > 50:
+            raise ValueError("Invalid value for `machine_name`, length must be less than or equal to `50`")
+
+        self._machine_name = machine_name
+    
+    @property
+    def name(self):
+        """Gets the name of this Scope.
+
+            The name of the scope is shown to the user where the user should select a scope.
+
+        :return: The name of this Scope.
+        :rtype: str
+        """
+        return self._name
+
+    @name.setter
+    def name(self, name):
+        """Sets the name of this Scope.
+
+            The name of the scope is shown to the user where the user should select a scope.
+
+        :param name: The name of this Scope.
+        :type: str
         """
+        if name is not None and len(name) > 50:
+            raise ValueError("Invalid value for `name`, length must be less than or equal to `50`")
 
-        self._file_generated_on = file_generated_on
+        self._name = name
     
     @property
-    def forwarded_on(self):
-        """Gets the forwarded_on of this PaymentInitiationAdviceFile.
+    def planned_purge_date(self):
+        """Gets the planned_purge_date of this Scope.
 
-            The shipping date indicates the date on which the pain file was transferred to an external processing system.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
-        :return: The forwarded_on of this PaymentInitiationAdviceFile.
+        :return: The planned_purge_date of this Scope.
         :rtype: datetime
         """
-        return self._forwarded_on
+        return self._planned_purge_date
 
-    @forwarded_on.setter
-    def forwarded_on(self, forwarded_on):
-        """Sets the forwarded_on of this PaymentInitiationAdviceFile.
+    @planned_purge_date.setter
+    def planned_purge_date(self, planned_purge_date):
+        """Sets the planned_purge_date of this Scope.
 
-            The shipping date indicates the date on which the pain file was transferred to an external processing system.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
-        :param forwarded_on: The forwarded_on of this PaymentInitiationAdviceFile.
+        :param planned_purge_date: The planned_purge_date of this Scope.
         :type: datetime
         """
 
-        self._forwarded_on = forwarded_on
+        self._planned_purge_date = planned_purge_date
     
     @property
-    def id(self):
-        """Gets the id of this PaymentInitiationAdviceFile.
+    def port(self):
+        """Gets the port of this Scope.
 
-            A unique identifier for the object.
+            The port number to which this scope is mapped to.
 
-        :return: The id of this PaymentInitiationAdviceFile.
+        :return: The port of this Scope.
         :rtype: int
         """
-        return self._id
+        return self._port
 
-    @id.setter
-    def id(self, id):
-        """Sets the id of this PaymentInitiationAdviceFile.
+    @port.setter
+    def port(self, port):
+        """Sets the port of this Scope.
 
-            A unique identifier for the object.
+            The port number to which this scope is mapped to.
 
-        :param id: The id of this PaymentInitiationAdviceFile.
+        :param port: The port of this Scope.
         :type: int
         """
 
-        self._id = id
+        self._port = port
     
     @property
-    def linked_space_id(self):
-        """Gets the linked_space_id of this PaymentInitiationAdviceFile.
+    def ssl_active(self):
+        """Gets the ssl_active of this Scope.
 
-            The ID of the space this object belongs to.
+            Define whether the scope supports SSL.
 
-        :return: The linked_space_id of this PaymentInitiationAdviceFile.
-        :rtype: int
+        :return: The ssl_active of this Scope.
+        :rtype: bool
         """
-        return self._linked_space_id
+        return self._ssl_active
 
-    @linked_space_id.setter
-    def linked_space_id(self, linked_space_id):
-        """Sets the linked_space_id of this PaymentInitiationAdviceFile.
+    @ssl_active.setter
+    def ssl_active(self, ssl_active):
+        """Sets the ssl_active of this Scope.
 
-            The ID of the space this object belongs to.
+            Define whether the scope supports SSL.
 
-        :param linked_space_id: The linked_space_id of this PaymentInitiationAdviceFile.
-        :type: int
+        :param ssl_active: The ssl_active of this Scope.
+        :type: bool
         """
 
-        self._linked_space_id = linked_space_id
+        self._ssl_active = ssl_active
     
     @property
-    def name(self):
-        """Gets the name of this PaymentInitiationAdviceFile.
+    def state(self):
+        """Gets the state of this Scope.
 
             
 
-        :return: The name of this PaymentInitiationAdviceFile.
-        :rtype: str
+        :return: The state of this Scope.
+        :rtype: CreationEntityState
         """
-        return self._name
+        return self._state
 
-    @name.setter
-    def name(self, name):
-        """Sets the name of this PaymentInitiationAdviceFile.
+    @state.setter
+    def state(self, state):
+        """Sets the state of this Scope.
 
             
 
-        :param name: The name of this PaymentInitiationAdviceFile.
-        :type: str
+        :param state: The state of this Scope.
+        :type: CreationEntityState
         """
 
-        self._name = name
+        self._state = state
     
     @property
-    def processed_on(self):
-        """Gets the processed_on of this PaymentInitiationAdviceFile.
+    def themes(self):
+        """Gets the themes of this Scope.
 
-            
+            The themes determines how the application layout, look and feel is. By providing multiple themes you can fallback to other themes.
 
-        :return: The processed_on of this PaymentInitiationAdviceFile.
-        :rtype: datetime
+        :return: The themes of this Scope.
+        :rtype: list[str]
         """
-        return self._processed_on
+        return self._themes
 
-    @processed_on.setter
-    def processed_on(self, processed_on):
-        """Sets the processed_on of this PaymentInitiationAdviceFile.
+    @themes.setter
+    def themes(self, themes):
+        """Sets the themes of this Scope.
 
-            
+            The themes determines how the application layout, look and feel is. By providing multiple themes you can fallback to other themes.
 
-        :param processed_on: The processed_on of this PaymentInitiationAdviceFile.
-        :type: datetime
+        :param themes: The themes of this Scope.
+        :type: list[str]
         """
 
-        self._processed_on = processed_on
+        self._themes = themes
     
     @property
-    def processor(self):
-        """Gets the processor of this PaymentInitiationAdviceFile.
+    def url(self):
+        """Gets the url of this Scope.
 
             
 
-        :return: The processor of this PaymentInitiationAdviceFile.
-        :rtype: PaymentProcessor
+        :return: The url of this Scope.
+        :rtype: str
         """
-        return self._processor
+        return self._url
 
-    @processor.setter
-    def processor(self, processor):
-        """Sets the processor of this PaymentInitiationAdviceFile.
+    @url.setter
+    def url(self, url):
+        """Sets the url of this Scope.
 
             
 
-        :param processor: The processor of this PaymentInitiationAdviceFile.
-        :type: PaymentProcessor
+        :param url: The url of this Scope.
+        :type: str
         """
 
-        self._processor = processor
+        self._url = url
     
     @property
-    def state(self):
-        """Gets the state of this PaymentInitiationAdviceFile.
+    def version(self):
+        """Gets the version of this Scope.
 
-            The object's current state.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
-        :return: The state of this PaymentInitiationAdviceFile.
-        :rtype: PaymentInitiationAdviceFileState
+        :return: The version of this Scope.
+        :rtype: int
         """
-        return self._state
+        return self._version
 
-    @state.setter
-    def state(self, state):
-        """Sets the state of this PaymentInitiationAdviceFile.
+    @version.setter
+    def version(self, version):
+        """Sets the version of this Scope.
 
-            The object's current state.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
-        :param state: The state of this PaymentInitiationAdviceFile.
-        :type: PaymentInitiationAdviceFileState
+        :param version: The version of this Scope.
+        :type: int
         """
 
-        self._state = state
+        self._version = version
     
 
     def to_dict(self):
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
@@ -302,27 +360,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(PaymentInitiationAdviceFile, dict):
+        if issubclass(Scope, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, PaymentInitiationAdviceFile):
+        if not isinstance(other, Scope):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_link.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_link.py`

 * *Files 8% similar despite different names*

```diff
@@ -241,26 +241,26 @@
 
         self._external_id = external_id
     
     @property
     def id(self):
         """Gets the id of this PaymentLink.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this PaymentLink.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this PaymentLink.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this PaymentLink.
         :type: int
         """
 
         self._id = id
     
@@ -310,26 +310,26 @@
 
         self._line_items = line_items
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this PaymentLink.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this PaymentLink.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this PaymentLink.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this PaymentLink.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -381,26 +381,26 @@
 
         self._name = name
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this PaymentLink.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this PaymentLink.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this PaymentLink.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this PaymentLink.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -450,26 +450,26 @@
 
         self._shipping_address_handling_mode = shipping_address_handling_mode
     
     @property
     def state(self):
         """Gets the state of this PaymentLink.
 
-            The object's current state.
+            
 
         :return: The state of this PaymentLink.
         :rtype: CreationEntityState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this PaymentLink.
 
-            The object's current state.
+            
 
         :param state: The state of this PaymentLink.
         :type: CreationEntityState
         """
 
         self._state = state
     
@@ -496,26 +496,26 @@
 
         self._url = url
     
     @property
     def version(self):
         """Gets the version of this PaymentLink.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this PaymentLink.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this PaymentLink.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this PaymentLink.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_link_active.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_link_active.py`

 * *Files 6% similar despite different names*

```diff
@@ -28,26 +28,26 @@
         self.attribute_map.update(super().attribute_map)
 
     
     @property
     def state(self):
         """Gets the state of this PaymentLinkActive.
 
-            The object's current state.
+            
 
         :return: The state of this PaymentLinkActive.
         :rtype: CreationEntityState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this PaymentLinkActive.
 
-            The object's current state.
+            
 
         :param state: The state of this PaymentLinkActive.
         :type: CreationEntityState
         """
 
         self._state = state
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_link_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_link_create.py`

 * *Files 5% similar despite different names*

```diff
@@ -35,26 +35,26 @@
         self.attribute_map.update(super().attribute_map)
 
     
     @property
     def state(self):
         """Gets the state of this PaymentLinkCreate.
 
-            The object's current state.
+            
 
         :return: The state of this PaymentLinkCreate.
         :rtype: CreationEntityState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this PaymentLinkCreate.
 
-            The object's current state.
+            
 
         :param state: The state of this PaymentLinkCreate.
         :type: CreationEntityState
         """
 
         self._state = state
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_link_update.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_link_update.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_method.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_method.py`

 * *Files 6% similar despite different names*

```diff
@@ -67,49 +67,49 @@
 
         self._data_collection_types = data_collection_types
     
     @property
     def description(self):
         """Gets the description of this PaymentMethod.
 
-            The localized description of the object.
+            
 
         :return: The description of this PaymentMethod.
         :rtype: dict(str, str)
         """
         return self._description
 
     @description.setter
     def description(self, description):
         """Sets the description of this PaymentMethod.
 
-            The localized description of the object.
+            
 
         :param description: The description of this PaymentMethod.
         :type: dict(str, str)
         """
 
         self._description = description
     
     @property
     def id(self):
         """Gets the id of this PaymentMethod.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this PaymentMethod.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this PaymentMethod.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this PaymentMethod.
         :type: int
         """
 
         self._id = id
     
@@ -159,26 +159,26 @@
 
         self._merchant_description = merchant_description
     
     @property
     def name(self):
         """Gets the name of this PaymentMethod.
 
-            The localized name of the object.
+            
 
         :return: The name of this PaymentMethod.
         :rtype: dict(str, str)
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this PaymentMethod.
 
-            The localized name of the object.
+            
 
         :param name: The name of this PaymentMethod.
         :type: dict(str, str)
         """
 
         self._name = name
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_method_brand.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_method_brand.py`

 * *Files 10% similar despite different names*

```diff
@@ -41,26 +41,26 @@
         
 
     
     @property
     def description(self):
         """Gets the description of this PaymentMethodBrand.
 
-            The localized description of the object.
+            
 
         :return: The description of this PaymentMethodBrand.
         :rtype: dict(str, str)
         """
         return self._description
 
     @description.setter
     def description(self, description):
         """Sets the description of this PaymentMethodBrand.
 
-            The localized description of the object.
+            
 
         :param description: The description of this PaymentMethodBrand.
         :type: dict(str, str)
         """
 
         self._description = description
     
@@ -87,26 +87,26 @@
 
         self._gray_image_path = gray_image_path
     
     @property
     def id(self):
         """Gets the id of this PaymentMethodBrand.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this PaymentMethodBrand.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this PaymentMethodBrand.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this PaymentMethodBrand.
         :type: int
         """
 
         self._id = id
     
@@ -133,26 +133,26 @@
 
         self._image_path = image_path
     
     @property
     def name(self):
         """Gets the name of this PaymentMethodBrand.
 
-            The localized name of the object.
+            
 
         :return: The name of this PaymentMethodBrand.
         :rtype: dict(str, str)
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this PaymentMethodBrand.
 
-            The localized name of the object.
+            
 
         :param name: The name of this PaymentMethodBrand.
         :type: dict(str, str)
         """
 
         self._name = name
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_method_configuration.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_product_version.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,471 +1,575 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
 
 
 
-class PaymentMethodConfiguration:
+class SubscriptionProductVersion:
 
     swagger_types = {
     
-        'data_collection_type': 'DataCollectionType',
-        'description': 'dict(str, str)',
+        'activated_on': 'datetime',
+        'billing_cycle': 'str',
+        'comment': 'str',
+        'created_on': 'datetime',
+        'default_currency': 'str',
+        'enabled_currencies': 'list[str]',
         'id': 'int',
-        'image_resource_path': 'ResourcePath',
+        'increment_number': 'int',
         'linked_space_id': 'int',
-        'name': 'str',
-        'one_click_payment_mode': 'OneClickPaymentMode',
-        'payment_method': 'int',
+        'minimal_number_of_periods': 'int',
+        'name': 'DatabaseTranslatedString',
+        'number_of_notice_periods': 'int',
+        'obsoleted_on': 'datetime',
         'planned_purge_date': 'datetime',
-        'resolved_description': 'dict(str, str)',
-        'resolved_image_url': 'str',
-        'resolved_title': 'dict(str, str)',
-        'sort_order': 'int',
-        'space_id': 'int',
-        'state': 'CreationEntityState',
-        'title': 'dict(str, str)',
+        'product': 'SubscriptionProduct',
+        'reference': 'str',
+        'retiring_finished_on': 'datetime',
+        'retiring_started_on': 'datetime',
+        'state': 'SubscriptionProductVersionState',
+        'tax_calculation': 'TaxCalculation',
         'version': 'int',
     }
 
     attribute_map = {
-        'data_collection_type': 'dataCollectionType','description': 'description','id': 'id','image_resource_path': 'imageResourcePath','linked_space_id': 'linkedSpaceId','name': 'name','one_click_payment_mode': 'oneClickPaymentMode','payment_method': 'paymentMethod','planned_purge_date': 'plannedPurgeDate','resolved_description': 'resolvedDescription','resolved_image_url': 'resolvedImageUrl','resolved_title': 'resolvedTitle','sort_order': 'sortOrder','space_id': 'spaceId','state': 'state','title': 'title','version': 'version',
+        'activated_on': 'activatedOn','billing_cycle': 'billingCycle','comment': 'comment','created_on': 'createdOn','default_currency': 'defaultCurrency','enabled_currencies': 'enabledCurrencies','id': 'id','increment_number': 'incrementNumber','linked_space_id': 'linkedSpaceId','minimal_number_of_periods': 'minimalNumberOfPeriods','name': 'name','number_of_notice_periods': 'numberOfNoticePeriods','obsoleted_on': 'obsoletedOn','planned_purge_date': 'plannedPurgeDate','product': 'product','reference': 'reference','retiring_finished_on': 'retiringFinishedOn','retiring_started_on': 'retiringStartedOn','state': 'state','tax_calculation': 'taxCalculation','version': 'version',
     }
 
     
-    _data_collection_type = None
-    _description = None
+    _activated_on = None
+    _billing_cycle = None
+    _comment = None
+    _created_on = None
+    _default_currency = None
+    _enabled_currencies = None
     _id = None
-    _image_resource_path = None
+    _increment_number = None
     _linked_space_id = None
+    _minimal_number_of_periods = None
     _name = None
-    _one_click_payment_mode = None
-    _payment_method = None
+    _number_of_notice_periods = None
+    _obsoleted_on = None
     _planned_purge_date = None
-    _resolved_description = None
-    _resolved_image_url = None
-    _resolved_title = None
-    _sort_order = None
-    _space_id = None
+    _product = None
+    _reference = None
+    _retiring_finished_on = None
+    _retiring_started_on = None
     _state = None
-    _title = None
+    _tax_calculation = None
     _version = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
-        self.data_collection_type = kwargs.get('data_collection_type', None)
-        self.description = kwargs.get('description', None)
+        self.activated_on = kwargs.get('activated_on', None)
+        self.billing_cycle = kwargs.get('billing_cycle', None)
+        self.comment = kwargs.get('comment', None)
+        self.created_on = kwargs.get('created_on', None)
+        self.default_currency = kwargs.get('default_currency', None)
+        self.enabled_currencies = kwargs.get('enabled_currencies', None)
         self.id = kwargs.get('id', None)
-        self.image_resource_path = kwargs.get('image_resource_path', None)
+        self.increment_number = kwargs.get('increment_number', None)
         self.linked_space_id = kwargs.get('linked_space_id', None)
+        self.minimal_number_of_periods = kwargs.get('minimal_number_of_periods', None)
         self.name = kwargs.get('name', None)
-        self.one_click_payment_mode = kwargs.get('one_click_payment_mode', None)
-        self.payment_method = kwargs.get('payment_method', None)
+        self.number_of_notice_periods = kwargs.get('number_of_notice_periods', None)
+        self.obsoleted_on = kwargs.get('obsoleted_on', None)
         self.planned_purge_date = kwargs.get('planned_purge_date', None)
-        self.resolved_description = kwargs.get('resolved_description', None)
-        self.resolved_image_url = kwargs.get('resolved_image_url', None)
-        self.resolved_title = kwargs.get('resolved_title', None)
-        self.sort_order = kwargs.get('sort_order', None)
-        self.space_id = kwargs.get('space_id', None)
+        self.product = kwargs.get('product', None)
+        self.reference = kwargs.get('reference', None)
+        self.retiring_finished_on = kwargs.get('retiring_finished_on', None)
+        self.retiring_started_on = kwargs.get('retiring_started_on', None)
         self.state = kwargs.get('state', None)
-        self.title = kwargs.get('title', None)
+        self.tax_calculation = kwargs.get('tax_calculation', None)
         self.version = kwargs.get('version', None)
         
 
     
     @property
-    def data_collection_type(self):
-        """Gets the data_collection_type of this PaymentMethodConfiguration.
+    def activated_on(self):
+        """Gets the activated_on of this SubscriptionProductVersion.
 
-            The data collection type determines who is collecting the payment information. This can be done either by the processor (offsite) or by our application (onsite).
+            
+
+        :return: The activated_on of this SubscriptionProductVersion.
+        :rtype: datetime
+        """
+        return self._activated_on
+
+    @activated_on.setter
+    def activated_on(self, activated_on):
+        """Sets the activated_on of this SubscriptionProductVersion.
+
+            
+
+        :param activated_on: The activated_on of this SubscriptionProductVersion.
+        :type: datetime
+        """
+
+        self._activated_on = activated_on
+    
+    @property
+    def billing_cycle(self):
+        """Gets the billing_cycle of this SubscriptionProductVersion.
+
+            The billing cycle determines the rhythm with which the subscriber is billed. The charging may have different rhythm.
+
+        :return: The billing_cycle of this SubscriptionProductVersion.
+        :rtype: str
+        """
+        return self._billing_cycle
+
+    @billing_cycle.setter
+    def billing_cycle(self, billing_cycle):
+        """Sets the billing_cycle of this SubscriptionProductVersion.
+
+            The billing cycle determines the rhythm with which the subscriber is billed. The charging may have different rhythm.
+
+        :param billing_cycle: The billing_cycle of this SubscriptionProductVersion.
+        :type: str
+        """
+
+        self._billing_cycle = billing_cycle
+    
+    @property
+    def comment(self):
+        """Gets the comment of this SubscriptionProductVersion.
+
+            The comment allows to provide a internal comment for the version. It helps to document why a product was changed. The comment is not disclosed to the subscriber.
+
+        :return: The comment of this SubscriptionProductVersion.
+        :rtype: str
+        """
+        return self._comment
+
+    @comment.setter
+    def comment(self, comment):
+        """Sets the comment of this SubscriptionProductVersion.
+
+            The comment allows to provide a internal comment for the version. It helps to document why a product was changed. The comment is not disclosed to the subscriber.
+
+        :param comment: The comment of this SubscriptionProductVersion.
+        :type: str
+        """
+
+        self._comment = comment
+    
+    @property
+    def created_on(self):
+        """Gets the created_on of this SubscriptionProductVersion.
+
+            
+
+        :return: The created_on of this SubscriptionProductVersion.
+        :rtype: datetime
+        """
+        return self._created_on
+
+    @created_on.setter
+    def created_on(self, created_on):
+        """Sets the created_on of this SubscriptionProductVersion.
+
+            
+
+        :param created_on: The created_on of this SubscriptionProductVersion.
+        :type: datetime
+        """
+
+        self._created_on = created_on
+    
+    @property
+    def default_currency(self):
+        """Gets the default_currency of this SubscriptionProductVersion.
 
-        :return: The data_collection_type of this PaymentMethodConfiguration.
-        :rtype: DataCollectionType
+            The default currency has to be used in all fees.
+
+        :return: The default_currency of this SubscriptionProductVersion.
+        :rtype: str
         """
-        return self._data_collection_type
+        return self._default_currency
 
-    @data_collection_type.setter
-    def data_collection_type(self, data_collection_type):
-        """Sets the data_collection_type of this PaymentMethodConfiguration.
+    @default_currency.setter
+    def default_currency(self, default_currency):
+        """Sets the default_currency of this SubscriptionProductVersion.
 
-            The data collection type determines who is collecting the payment information. This can be done either by the processor (offsite) or by our application (onsite).
+            The default currency has to be used in all fees.
 
-        :param data_collection_type: The data_collection_type of this PaymentMethodConfiguration.
-        :type: DataCollectionType
+        :param default_currency: The default_currency of this SubscriptionProductVersion.
+        :type: str
         """
 
-        self._data_collection_type = data_collection_type
+        self._default_currency = default_currency
     
     @property
-    def description(self):
-        """Gets the description of this PaymentMethodConfiguration.
+    def enabled_currencies(self):
+        """Gets the enabled_currencies of this SubscriptionProductVersion.
 
-            The payment method configuration description can be used to show a text during the payment process. Choose an appropriate description as it will be displayed to your customer.
+            The currencies which are enabled can be selected to define component fees. Currencies which are not enabled cannot be used to define fees.
 
-        :return: The description of this PaymentMethodConfiguration.
-        :rtype: dict(str, str)
+        :return: The enabled_currencies of this SubscriptionProductVersion.
+        :rtype: list[str]
         """
-        return self._description
+        return self._enabled_currencies
 
-    @description.setter
-    def description(self, description):
-        """Sets the description of this PaymentMethodConfiguration.
+    @enabled_currencies.setter
+    def enabled_currencies(self, enabled_currencies):
+        """Sets the enabled_currencies of this SubscriptionProductVersion.
 
-            The payment method configuration description can be used to show a text during the payment process. Choose an appropriate description as it will be displayed to your customer.
+            The currencies which are enabled can be selected to define component fees. Currencies which are not enabled cannot be used to define fees.
 
-        :param description: The description of this PaymentMethodConfiguration.
-        :type: dict(str, str)
+        :param enabled_currencies: The enabled_currencies of this SubscriptionProductVersion.
+        :type: list[str]
         """
 
-        self._description = description
+        self._enabled_currencies = enabled_currencies
     
     @property
     def id(self):
-        """Gets the id of this PaymentMethodConfiguration.
+        """Gets the id of this SubscriptionProductVersion.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
-        :return: The id of this PaymentMethodConfiguration.
+        :return: The id of this SubscriptionProductVersion.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
-        """Sets the id of this PaymentMethodConfiguration.
+        """Sets the id of this SubscriptionProductVersion.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
-        :param id: The id of this PaymentMethodConfiguration.
+        :param id: The id of this SubscriptionProductVersion.
         :type: int
         """
 
         self._id = id
     
     @property
-    def image_resource_path(self):
-        """Gets the image_resource_path of this PaymentMethodConfiguration.
+    def increment_number(self):
+        """Gets the increment_number of this SubscriptionProductVersion.
 
-            The image of the payment method configuration overrides the default image of the payment method.
+            The increment number represents the version number incremented whenever a new version is activated.
 
-        :return: The image_resource_path of this PaymentMethodConfiguration.
-        :rtype: ResourcePath
+        :return: The increment_number of this SubscriptionProductVersion.
+        :rtype: int
         """
-        return self._image_resource_path
+        return self._increment_number
 
-    @image_resource_path.setter
-    def image_resource_path(self, image_resource_path):
-        """Sets the image_resource_path of this PaymentMethodConfiguration.
+    @increment_number.setter
+    def increment_number(self, increment_number):
+        """Sets the increment_number of this SubscriptionProductVersion.
 
-            The image of the payment method configuration overrides the default image of the payment method.
+            The increment number represents the version number incremented whenever a new version is activated.
 
-        :param image_resource_path: The image_resource_path of this PaymentMethodConfiguration.
-        :type: ResourcePath
+        :param increment_number: The increment_number of this SubscriptionProductVersion.
+        :type: int
         """
 
-        self._image_resource_path = image_resource_path
+        self._increment_number = increment_number
     
     @property
     def linked_space_id(self):
-        """Gets the linked_space_id of this PaymentMethodConfiguration.
+        """Gets the linked_space_id of this SubscriptionProductVersion.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
-        :return: The linked_space_id of this PaymentMethodConfiguration.
+        :return: The linked_space_id of this SubscriptionProductVersion.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
-        """Sets the linked_space_id of this PaymentMethodConfiguration.
+        """Sets the linked_space_id of this SubscriptionProductVersion.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
-        :param linked_space_id: The linked_space_id of this PaymentMethodConfiguration.
+        :param linked_space_id: The linked_space_id of this SubscriptionProductVersion.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
     @property
+    def minimal_number_of_periods(self):
+        """Gets the minimal_number_of_periods of this SubscriptionProductVersion.
+
+            The minimal number of periods determines how long the subscription has to run before the subscription can be terminated.
+
+        :return: The minimal_number_of_periods of this SubscriptionProductVersion.
+        :rtype: int
+        """
+        return self._minimal_number_of_periods
+
+    @minimal_number_of_periods.setter
+    def minimal_number_of_periods(self, minimal_number_of_periods):
+        """Sets the minimal_number_of_periods of this SubscriptionProductVersion.
+
+            The minimal number of periods determines how long the subscription has to run before the subscription can be terminated.
+
+        :param minimal_number_of_periods: The minimal_number_of_periods of this SubscriptionProductVersion.
+        :type: int
+        """
+
+        self._minimal_number_of_periods = minimal_number_of_periods
+    
+    @property
     def name(self):
-        """Gets the name of this PaymentMethodConfiguration.
+        """Gets the name of this SubscriptionProductVersion.
 
-            The payment method configuration name is used internally to identify the payment method configuration. For example the name is used within search fields and hence it should be distinct and descriptive.
+            The product version name is the name of the product which is shown to the user for the version. When the visible product name should be changed for a particular product a new version has to be created which contains the new name of the product.
 
-        :return: The name of this PaymentMethodConfiguration.
-        :rtype: str
+        :return: The name of this SubscriptionProductVersion.
+        :rtype: DatabaseTranslatedString
         """
         return self._name
 
     @name.setter
     def name(self, name):
-        """Sets the name of this PaymentMethodConfiguration.
+        """Sets the name of this SubscriptionProductVersion.
 
-            The payment method configuration name is used internally to identify the payment method configuration. For example the name is used within search fields and hence it should be distinct and descriptive.
+            The product version name is the name of the product which is shown to the user for the version. When the visible product name should be changed for a particular product a new version has to be created which contains the new name of the product.
 
-        :param name: The name of this PaymentMethodConfiguration.
-        :type: str
+        :param name: The name of this SubscriptionProductVersion.
+        :type: DatabaseTranslatedString
         """
-        if name is not None and len(name) > 100:
-            raise ValueError("Invalid value for `name`, length must be less than or equal to `100`")
 
         self._name = name
     
     @property
-    def one_click_payment_mode(self):
-        """Gets the one_click_payment_mode of this PaymentMethodConfiguration.
+    def number_of_notice_periods(self):
+        """Gets the number_of_notice_periods of this SubscriptionProductVersion.
 
-            When the buyer is present on the payment page or within the iFrame the payment details can be stored automatically. The buyer will be able to use the stored payment details for subsequent transactions. When the transaction already contains a token one-click payments are disabled anyway
+            The number of notice periods determines the number of periods which need to be paid between the request to terminate the subscription and the final period.
 
-        :return: The one_click_payment_mode of this PaymentMethodConfiguration.
-        :rtype: OneClickPaymentMode
+        :return: The number_of_notice_periods of this SubscriptionProductVersion.
+        :rtype: int
         """
-        return self._one_click_payment_mode
+        return self._number_of_notice_periods
 
-    @one_click_payment_mode.setter
-    def one_click_payment_mode(self, one_click_payment_mode):
-        """Sets the one_click_payment_mode of this PaymentMethodConfiguration.
+    @number_of_notice_periods.setter
+    def number_of_notice_periods(self, number_of_notice_periods):
+        """Sets the number_of_notice_periods of this SubscriptionProductVersion.
 
-            When the buyer is present on the payment page or within the iFrame the payment details can be stored automatically. The buyer will be able to use the stored payment details for subsequent transactions. When the transaction already contains a token one-click payments are disabled anyway
+            The number of notice periods determines the number of periods which need to be paid between the request to terminate the subscription and the final period.
 
-        :param one_click_payment_mode: The one_click_payment_mode of this PaymentMethodConfiguration.
-        :type: OneClickPaymentMode
+        :param number_of_notice_periods: The number_of_notice_periods of this SubscriptionProductVersion.
+        :type: int
         """
 
-        self._one_click_payment_mode = one_click_payment_mode
+        self._number_of_notice_periods = number_of_notice_periods
     
     @property
-    def payment_method(self):
-        """Gets the payment_method of this PaymentMethodConfiguration.
+    def obsoleted_on(self):
+        """Gets the obsoleted_on of this SubscriptionProductVersion.
 
             
 
-        :return: The payment_method of this PaymentMethodConfiguration.
-        :rtype: int
+        :return: The obsoleted_on of this SubscriptionProductVersion.
+        :rtype: datetime
         """
-        return self._payment_method
+        return self._obsoleted_on
 
-    @payment_method.setter
-    def payment_method(self, payment_method):
-        """Sets the payment_method of this PaymentMethodConfiguration.
+    @obsoleted_on.setter
+    def obsoleted_on(self, obsoleted_on):
+        """Sets the obsoleted_on of this SubscriptionProductVersion.
 
             
 
-        :param payment_method: The payment_method of this PaymentMethodConfiguration.
-        :type: int
+        :param obsoleted_on: The obsoleted_on of this SubscriptionProductVersion.
+        :type: datetime
         """
 
-        self._payment_method = payment_method
+        self._obsoleted_on = obsoleted_on
     
     @property
     def planned_purge_date(self):
-        """Gets the planned_purge_date of this PaymentMethodConfiguration.
+        """Gets the planned_purge_date of this SubscriptionProductVersion.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
-        :return: The planned_purge_date of this PaymentMethodConfiguration.
+        :return: The planned_purge_date of this SubscriptionProductVersion.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
-        """Sets the planned_purge_date of this PaymentMethodConfiguration.
+        """Sets the planned_purge_date of this SubscriptionProductVersion.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
-        :param planned_purge_date: The planned_purge_date of this PaymentMethodConfiguration.
+        :param planned_purge_date: The planned_purge_date of this SubscriptionProductVersion.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
     @property
-    def resolved_description(self):
-        """Gets the resolved_description of this PaymentMethodConfiguration.
+    def product(self):
+        """Gets the product of this SubscriptionProductVersion.
 
-            The resolved description uses the specified description or the default one when it is not overridden.
+            Each product version is linked to a product.
 
-        :return: The resolved_description of this PaymentMethodConfiguration.
-        :rtype: dict(str, str)
+        :return: The product of this SubscriptionProductVersion.
+        :rtype: SubscriptionProduct
         """
-        return self._resolved_description
+        return self._product
 
-    @resolved_description.setter
-    def resolved_description(self, resolved_description):
-        """Sets the resolved_description of this PaymentMethodConfiguration.
+    @product.setter
+    def product(self, product):
+        """Sets the product of this SubscriptionProductVersion.
 
-            The resolved description uses the specified description or the default one when it is not overridden.
+            Each product version is linked to a product.
 
-        :param resolved_description: The resolved_description of this PaymentMethodConfiguration.
-        :type: dict(str, str)
+        :param product: The product of this SubscriptionProductVersion.
+        :type: SubscriptionProduct
         """
 
-        self._resolved_description = resolved_description
+        self._product = product
     
     @property
-    def resolved_image_url(self):
-        """Gets the resolved_image_url of this PaymentMethodConfiguration.
+    def reference(self):
+        """Gets the reference of this SubscriptionProductVersion.
 
-            The resolved URL of the image to use with this payment method.
+            The product version reference helps to identify the version. The reference is generated out of the product reference.
 
-        :return: The resolved_image_url of this PaymentMethodConfiguration.
+        :return: The reference of this SubscriptionProductVersion.
         :rtype: str
         """
-        return self._resolved_image_url
+        return self._reference
 
-    @resolved_image_url.setter
-    def resolved_image_url(self, resolved_image_url):
-        """Sets the resolved_image_url of this PaymentMethodConfiguration.
+    @reference.setter
+    def reference(self, reference):
+        """Sets the reference of this SubscriptionProductVersion.
 
-            The resolved URL of the image to use with this payment method.
+            The product version reference helps to identify the version. The reference is generated out of the product reference.
 
-        :param resolved_image_url: The resolved_image_url of this PaymentMethodConfiguration.
+        :param reference: The reference of this SubscriptionProductVersion.
         :type: str
         """
+        if reference is not None and len(reference) > 125:
+            raise ValueError("Invalid value for `reference`, length must be less than or equal to `125`")
 
-        self._resolved_image_url = resolved_image_url
-    
-    @property
-    def resolved_title(self):
-        """Gets the resolved_title of this PaymentMethodConfiguration.
-
-            The resolved title uses the specified title or the default one when it is not overridden.
-
-        :return: The resolved_title of this PaymentMethodConfiguration.
-        :rtype: dict(str, str)
-        """
-        return self._resolved_title
-
-    @resolved_title.setter
-    def resolved_title(self, resolved_title):
-        """Sets the resolved_title of this PaymentMethodConfiguration.
-
-            The resolved title uses the specified title or the default one when it is not overridden.
-
-        :param resolved_title: The resolved_title of this PaymentMethodConfiguration.
-        :type: dict(str, str)
-        """
-
-        self._resolved_title = resolved_title
+        self._reference = reference
     
     @property
-    def sort_order(self):
-        """Gets the sort_order of this PaymentMethodConfiguration.
+    def retiring_finished_on(self):
+        """Gets the retiring_finished_on of this SubscriptionProductVersion.
 
-            The sort order of the payment method determines the ordering of the methods shown to the user during the payment process.
+            
 
-        :return: The sort_order of this PaymentMethodConfiguration.
-        :rtype: int
+        :return: The retiring_finished_on of this SubscriptionProductVersion.
+        :rtype: datetime
         """
-        return self._sort_order
+        return self._retiring_finished_on
 
-    @sort_order.setter
-    def sort_order(self, sort_order):
-        """Sets the sort_order of this PaymentMethodConfiguration.
+    @retiring_finished_on.setter
+    def retiring_finished_on(self, retiring_finished_on):
+        """Sets the retiring_finished_on of this SubscriptionProductVersion.
 
-            The sort order of the payment method determines the ordering of the methods shown to the user during the payment process.
+            
 
-        :param sort_order: The sort_order of this PaymentMethodConfiguration.
-        :type: int
+        :param retiring_finished_on: The retiring_finished_on of this SubscriptionProductVersion.
+        :type: datetime
         """
 
-        self._sort_order = sort_order
+        self._retiring_finished_on = retiring_finished_on
     
     @property
-    def space_id(self):
-        """Gets the space_id of this PaymentMethodConfiguration.
+    def retiring_started_on(self):
+        """Gets the retiring_started_on of this SubscriptionProductVersion.
 
             
 
-        :return: The space_id of this PaymentMethodConfiguration.
-        :rtype: int
+        :return: The retiring_started_on of this SubscriptionProductVersion.
+        :rtype: datetime
         """
-        return self._space_id
+        return self._retiring_started_on
 
-    @space_id.setter
-    def space_id(self, space_id):
-        """Sets the space_id of this PaymentMethodConfiguration.
+    @retiring_started_on.setter
+    def retiring_started_on(self, retiring_started_on):
+        """Sets the retiring_started_on of this SubscriptionProductVersion.
 
             
 
-        :param space_id: The space_id of this PaymentMethodConfiguration.
-        :type: int
+        :param retiring_started_on: The retiring_started_on of this SubscriptionProductVersion.
+        :type: datetime
         """
 
-        self._space_id = space_id
+        self._retiring_started_on = retiring_started_on
     
     @property
     def state(self):
-        """Gets the state of this PaymentMethodConfiguration.
+        """Gets the state of this SubscriptionProductVersion.
 
-            The object's current state.
+            
 
-        :return: The state of this PaymentMethodConfiguration.
-        :rtype: CreationEntityState
+        :return: The state of this SubscriptionProductVersion.
+        :rtype: SubscriptionProductVersionState
         """
         return self._state
 
     @state.setter
     def state(self, state):
-        """Sets the state of this PaymentMethodConfiguration.
+        """Sets the state of this SubscriptionProductVersion.
 
-            The object's current state.
+            
 
-        :param state: The state of this PaymentMethodConfiguration.
-        :type: CreationEntityState
+        :param state: The state of this SubscriptionProductVersion.
+        :type: SubscriptionProductVersionState
         """
 
         self._state = state
     
     @property
-    def title(self):
-        """Gets the title of this PaymentMethodConfiguration.
+    def tax_calculation(self):
+        """Gets the tax_calculation of this SubscriptionProductVersion.
 
-            The title of the payment method configuration is used within the payment process. The title is visible to the customer.
+            Strategy that is used for tax calculation in fees.
 
-        :return: The title of this PaymentMethodConfiguration.
-        :rtype: dict(str, str)
+        :return: The tax_calculation of this SubscriptionProductVersion.
+        :rtype: TaxCalculation
         """
-        return self._title
+        return self._tax_calculation
 
-    @title.setter
-    def title(self, title):
-        """Sets the title of this PaymentMethodConfiguration.
+    @tax_calculation.setter
+    def tax_calculation(self, tax_calculation):
+        """Sets the tax_calculation of this SubscriptionProductVersion.
 
-            The title of the payment method configuration is used within the payment process. The title is visible to the customer.
+            Strategy that is used for tax calculation in fees.
 
-        :param title: The title of this PaymentMethodConfiguration.
-        :type: dict(str, str)
+        :param tax_calculation: The tax_calculation of this SubscriptionProductVersion.
+        :type: TaxCalculation
         """
 
-        self._title = title
+        self._tax_calculation = tax_calculation
     
     @property
     def version(self):
-        """Gets the version of this PaymentMethodConfiguration.
+        """Gets the version of this SubscriptionProductVersion.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
-        :return: The version of this PaymentMethodConfiguration.
+        :return: The version of this SubscriptionProductVersion.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
-        """Sets the version of this PaymentMethodConfiguration.
+        """Sets the version of this SubscriptionProductVersion.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
-        :param version: The version of this PaymentMethodConfiguration.
+        :param version: The version of this SubscriptionProductVersion.
         :type: int
         """
 
         self._version = version
     
 
     def to_dict(self):
@@ -486,27 +590,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(PaymentMethodConfiguration, dict):
+        if issubclass(SubscriptionProductVersion, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, PaymentMethodConfiguration):
+        if not isinstance(other, SubscriptionProductVersion):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_processor.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_processor.py`

 * *Files 2% similar despite different names*

```diff
@@ -70,26 +70,26 @@
 
         self._company_name = company_name
     
     @property
     def description(self):
         """Gets the description of this PaymentProcessor.
 
-            The localized description of the object.
+            
 
         :return: The description of this PaymentProcessor.
         :rtype: dict(str, str)
         """
         return self._description
 
     @description.setter
     def description(self, description):
         """Sets the description of this PaymentProcessor.
 
-            The localized description of the object.
+            
 
         :param description: The description of this PaymentProcessor.
         :type: dict(str, str)
         """
 
         self._description = description
     
@@ -139,26 +139,26 @@
 
         self._headquarters_location = headquarters_location
     
     @property
     def id(self):
         """Gets the id of this PaymentProcessor.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this PaymentProcessor.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this PaymentProcessor.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this PaymentProcessor.
         :type: int
         """
 
         self._id = id
     
@@ -185,26 +185,26 @@
 
         self._logo_path = logo_path
     
     @property
     def name(self):
         """Gets the name of this PaymentProcessor.
 
-            The localized name of the object.
+            
 
         :return: The name of this PaymentProcessor.
         :rtype: dict(str, str)
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this PaymentProcessor.
 
-            The localized name of the object.
+            
 
         :param name: The name of this PaymentProcessor.
         :type: dict(str, str)
         """
 
         self._name = name
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_processor_configuration.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_processor_configuration.py`

 * *Files 20% similar despite different names*

```diff
@@ -96,49 +96,49 @@
 
         self._contract_id = contract_id
     
     @property
     def id(self):
         """Gets the id of this PaymentProcessorConfiguration.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this PaymentProcessorConfiguration.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this PaymentProcessorConfiguration.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this PaymentProcessorConfiguration.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this PaymentProcessorConfiguration.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this PaymentProcessorConfiguration.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this PaymentProcessorConfiguration.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this PaymentProcessorConfiguration.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -167,26 +167,26 @@
 
         self._name = name
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this PaymentProcessorConfiguration.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this PaymentProcessorConfiguration.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this PaymentProcessorConfiguration.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this PaymentProcessorConfiguration.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -213,49 +213,49 @@
 
         self._processor = processor
     
     @property
     def state(self):
         """Gets the state of this PaymentProcessorConfiguration.
 
-            The object's current state.
+            
 
         :return: The state of this PaymentProcessorConfiguration.
         :rtype: CreationEntityState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this PaymentProcessorConfiguration.
 
-            The object's current state.
+            
 
         :param state: The state of this PaymentProcessorConfiguration.
         :type: CreationEntityState
         """
 
         self._state = state
     
     @property
     def version(self):
         """Gets the version of this PaymentProcessorConfiguration.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this PaymentProcessorConfiguration.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this PaymentProcessorConfiguration.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this PaymentProcessorConfiguration.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_terminal_address.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_terminal_address.py`

 * *Files 5% similar despite different names*

```diff
@@ -65,335 +65,335 @@
         
 
     
     @property
     def city(self):
         """Gets the city of this PaymentTerminalAddress.
 
-            The city, town or village.
+            
 
         :return: The city of this PaymentTerminalAddress.
         :rtype: str
         """
         return self._city
 
     @city.setter
     def city(self, city):
         """Sets the city of this PaymentTerminalAddress.
 
-            The city, town or village.
+            
 
         :param city: The city of this PaymentTerminalAddress.
         :type: str
         """
 
         self._city = city
     
     @property
     def country(self):
         """Gets the country of this PaymentTerminalAddress.
 
-            The two-letter country code (ISO 3166 format).
+            
 
         :return: The country of this PaymentTerminalAddress.
         :rtype: str
         """
         return self._country
 
     @country.setter
     def country(self, country):
         """Sets the country of this PaymentTerminalAddress.
 
-            The two-letter country code (ISO 3166 format).
+            
 
         :param country: The country of this PaymentTerminalAddress.
         :type: str
         """
 
         self._country = country
     
     @property
     def dependent_locality(self):
         """Gets the dependent_locality of this PaymentTerminalAddress.
 
-            The dependent locality which is a sub-division of the state.
+            
 
         :return: The dependent_locality of this PaymentTerminalAddress.
         :rtype: str
         """
         return self._dependent_locality
 
     @dependent_locality.setter
     def dependent_locality(self, dependent_locality):
         """Sets the dependent_locality of this PaymentTerminalAddress.
 
-            The dependent locality which is a sub-division of the state.
+            
 
         :param dependent_locality: The dependent_locality of this PaymentTerminalAddress.
         :type: str
         """
         if dependent_locality is not None and len(dependent_locality) > 100:
             raise ValueError("Invalid value for `dependent_locality`, length must be less than or equal to `100`")
 
         self._dependent_locality = dependent_locality
     
     @property
     def email_address(self):
         """Gets the email_address of this PaymentTerminalAddress.
 
-            The email address.
+            
 
         :return: The email_address of this PaymentTerminalAddress.
         :rtype: str
         """
         return self._email_address
 
     @email_address.setter
     def email_address(self, email_address):
         """Sets the email_address of this PaymentTerminalAddress.
 
-            The email address.
+            
 
         :param email_address: The email_address of this PaymentTerminalAddress.
         :type: str
         """
         if email_address is not None and len(email_address) > 254:
             raise ValueError("Invalid value for `email_address`, length must be less than or equal to `254`")
 
         self._email_address = email_address
     
     @property
     def family_name(self):
         """Gets the family_name of this PaymentTerminalAddress.
 
-            The family or last name.
+            
 
         :return: The family_name of this PaymentTerminalAddress.
         :rtype: str
         """
         return self._family_name
 
     @family_name.setter
     def family_name(self, family_name):
         """Sets the family_name of this PaymentTerminalAddress.
 
-            The family or last name.
+            
 
         :param family_name: The family_name of this PaymentTerminalAddress.
         :type: str
         """
 
         self._family_name = family_name
     
     @property
     def given_name(self):
         """Gets the given_name of this PaymentTerminalAddress.
 
-            The given or first name.
+            
 
         :return: The given_name of this PaymentTerminalAddress.
         :rtype: str
         """
         return self._given_name
 
     @given_name.setter
     def given_name(self, given_name):
         """Sets the given_name of this PaymentTerminalAddress.
 
-            The given or first name.
+            
 
         :param given_name: The given_name of this PaymentTerminalAddress.
         :type: str
         """
 
         self._given_name = given_name
     
     @property
     def mobile_phone_number(self):
         """Gets the mobile_phone_number of this PaymentTerminalAddress.
 
-            The phone number of a mobile phone.
+            
 
         :return: The mobile_phone_number of this PaymentTerminalAddress.
         :rtype: str
         """
         return self._mobile_phone_number
 
     @mobile_phone_number.setter
     def mobile_phone_number(self, mobile_phone_number):
         """Sets the mobile_phone_number of this PaymentTerminalAddress.
 
-            The phone number of a mobile phone.
+            
 
         :param mobile_phone_number: The mobile_phone_number of this PaymentTerminalAddress.
         :type: str
         """
         if mobile_phone_number is not None and len(mobile_phone_number) > 100:
             raise ValueError("Invalid value for `mobile_phone_number`, length must be less than or equal to `100`")
 
         self._mobile_phone_number = mobile_phone_number
     
     @property
     def organization_name(self):
         """Gets the organization_name of this PaymentTerminalAddress.
 
-            The organization's name.
+            
 
         :return: The organization_name of this PaymentTerminalAddress.
         :rtype: str
         """
         return self._organization_name
 
     @organization_name.setter
     def organization_name(self, organization_name):
         """Sets the organization_name of this PaymentTerminalAddress.
 
-            The organization's name.
+            
 
         :param organization_name: The organization_name of this PaymentTerminalAddress.
         :type: str
         """
 
         self._organization_name = organization_name
     
     @property
     def phone_number(self):
         """Gets the phone_number of this PaymentTerminalAddress.
 
-            The phone number.
+            
 
         :return: The phone_number of this PaymentTerminalAddress.
         :rtype: str
         """
         return self._phone_number
 
     @phone_number.setter
     def phone_number(self, phone_number):
         """Sets the phone_number of this PaymentTerminalAddress.
 
-            The phone number.
+            
 
         :param phone_number: The phone_number of this PaymentTerminalAddress.
         :type: str
         """
 
         self._phone_number = phone_number
     
     @property
     def postal_state(self):
         """Gets the postal_state of this PaymentTerminalAddress.
 
-            The name of the region, typically a state, county, province or prefecture.
+            
 
         :return: The postal_state of this PaymentTerminalAddress.
         :rtype: str
         """
         return self._postal_state
 
     @postal_state.setter
     def postal_state(self, postal_state):
         """Sets the postal_state of this PaymentTerminalAddress.
 
-            The name of the region, typically a state, county, province or prefecture.
+            
 
         :param postal_state: The postal_state of this PaymentTerminalAddress.
         :type: str
         """
 
         self._postal_state = postal_state
     
     @property
     def postcode(self):
         """Gets the postcode of this PaymentTerminalAddress.
 
-            The postal code, also known as ZIP, postcode, etc.
+            
 
         :return: The postcode of this PaymentTerminalAddress.
         :rtype: str
         """
         return self._postcode
 
     @postcode.setter
     def postcode(self, postcode):
         """Sets the postcode of this PaymentTerminalAddress.
 
-            The postal code, also known as ZIP, postcode, etc.
+            
 
         :param postcode: The postcode of this PaymentTerminalAddress.
         :type: str
         """
 
         self._postcode = postcode
     
     @property
     def salutation(self):
         """Gets the salutation of this PaymentTerminalAddress.
 
-            The salutation e.g. Mrs, Mr, Dr.
+            
 
         :return: The salutation of this PaymentTerminalAddress.
         :rtype: str
         """
         return self._salutation
 
     @salutation.setter
     def salutation(self, salutation):
         """Sets the salutation of this PaymentTerminalAddress.
 
-            The salutation e.g. Mrs, Mr, Dr.
+            
 
         :param salutation: The salutation of this PaymentTerminalAddress.
         :type: str
         """
         if salutation is not None and len(salutation) > 20:
             raise ValueError("Invalid value for `salutation`, length must be less than or equal to `20`")
 
         self._salutation = salutation
     
     @property
     def sorting_code(self):
         """Gets the sorting_code of this PaymentTerminalAddress.
 
-            The sorting code identifying the post office where the PO Box is located.
+            The sorting code identifies the post office at which the post box is located in.
 
         :return: The sorting_code of this PaymentTerminalAddress.
         :rtype: str
         """
         return self._sorting_code
 
     @sorting_code.setter
     def sorting_code(self, sorting_code):
         """Sets the sorting_code of this PaymentTerminalAddress.
 
-            The sorting code identifying the post office where the PO Box is located.
+            The sorting code identifies the post office at which the post box is located in.
 
         :param sorting_code: The sorting_code of this PaymentTerminalAddress.
         :type: str
         """
         if sorting_code is not None and len(sorting_code) > 100:
             raise ValueError("Invalid value for `sorting_code`, length must be less than or equal to `100`")
 
         self._sorting_code = sorting_code
     
     @property
     def street(self):
         """Gets the street of this PaymentTerminalAddress.
 
-            The street or PO Box.
+            
 
         :return: The street of this PaymentTerminalAddress.
         :rtype: str
         """
         return self._street
 
     @street.setter
     def street(self, street):
         """Sets the street of this PaymentTerminalAddress.
 
-            The street or PO Box.
+            
 
         :param street: The street of this PaymentTerminalAddress.
         :type: str
         """
 
         self._street = street
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_terminal_configuration.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_terminal_configuration.py`

 * *Files 12% similar despite different names*

```diff
@@ -44,49 +44,49 @@
         
 
     
     @property
     def id(self):
         """Gets the id of this PaymentTerminalConfiguration.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this PaymentTerminalConfiguration.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this PaymentTerminalConfiguration.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this PaymentTerminalConfiguration.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this PaymentTerminalConfiguration.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this PaymentTerminalConfiguration.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this PaymentTerminalConfiguration.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this PaymentTerminalConfiguration.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -115,49 +115,49 @@
 
         self._name = name
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this PaymentTerminalConfiguration.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this PaymentTerminalConfiguration.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this PaymentTerminalConfiguration.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this PaymentTerminalConfiguration.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
     @property
     def state(self):
         """Gets the state of this PaymentTerminalConfiguration.
 
-            The object's current state.
+            
 
         :return: The state of this PaymentTerminalConfiguration.
         :rtype: PaymentTerminalConfigurationState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this PaymentTerminalConfiguration.
 
-            The object's current state.
+            
 
         :param state: The state of this PaymentTerminalConfiguration.
         :type: PaymentTerminalConfigurationState
         """
 
         self._state = state
     
@@ -184,26 +184,26 @@
 
         self._type = type
     
     @property
     def version(self):
         """Gets the version of this PaymentTerminalConfiguration.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this PaymentTerminalConfiguration.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this PaymentTerminalConfiguration.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this PaymentTerminalConfiguration.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_terminal_configuration_version.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_terminal_configuration_version.py`

 * *Files 17% similar despite different names*

```diff
@@ -134,26 +134,26 @@
 
         self._created_by = created_by
     
     @property
     def created_on(self):
         """Gets the created_on of this PaymentTerminalConfigurationVersion.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :return: The created_on of this PaymentTerminalConfigurationVersion.
         :rtype: datetime
         """
         return self._created_on
 
     @created_on.setter
     def created_on(self, created_on):
         """Sets the created_on of this PaymentTerminalConfigurationVersion.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :param created_on: The created_on of this PaymentTerminalConfigurationVersion.
         :type: datetime
         """
 
         self._created_on = created_on
     
@@ -180,49 +180,49 @@
 
         self._default_currency = default_currency
     
     @property
     def id(self):
         """Gets the id of this PaymentTerminalConfigurationVersion.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this PaymentTerminalConfigurationVersion.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this PaymentTerminalConfigurationVersion.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this PaymentTerminalConfigurationVersion.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this PaymentTerminalConfigurationVersion.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this PaymentTerminalConfigurationVersion.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this PaymentTerminalConfigurationVersion.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this PaymentTerminalConfigurationVersion.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -272,49 +272,49 @@
 
         self._maintenance_window_start = maintenance_window_start
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this PaymentTerminalConfigurationVersion.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this PaymentTerminalConfigurationVersion.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this PaymentTerminalConfigurationVersion.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this PaymentTerminalConfigurationVersion.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
     @property
     def state(self):
         """Gets the state of this PaymentTerminalConfigurationVersion.
 
-            The object's current state.
+            
 
         :return: The state of this PaymentTerminalConfigurationVersion.
         :rtype: PaymentTerminalConfigurationVersionState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this PaymentTerminalConfigurationVersion.
 
-            The object's current state.
+            
 
         :param state: The state of this PaymentTerminalConfigurationVersion.
         :type: PaymentTerminalConfigurationVersionState
         """
 
         self._state = state
     
@@ -341,26 +341,26 @@
 
         self._time_zone = time_zone
     
     @property
     def version(self):
         """Gets the version of this PaymentTerminalConfigurationVersion.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this PaymentTerminalConfigurationVersion.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this PaymentTerminalConfigurationVersion.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this PaymentTerminalConfigurationVersion.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_terminal_dcc_transaction_sum.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_metric.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,235 +1,235 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
 
 
 
-class PaymentTerminalDccTransactionSum:
+class SubscriptionMetric:
 
     swagger_types = {
     
-        'brand': 'str',
-        'dcc_amount': 'float',
-        'dcc_currency': 'str',
+        'description': 'DatabaseTranslatedString',
         'id': 'int',
-        'transaction_amount': 'float',
-        'transaction_count': 'int',
-        'transaction_currency': 'str',
+        'linked_space_id': 'int',
+        'name': 'DatabaseTranslatedString',
+        'planned_purge_date': 'datetime',
+        'state': 'CreationEntityState',
+        'type': 'SubscriptionMetricType',
         'version': 'int',
     }
 
     attribute_map = {
-        'brand': 'brand','dcc_amount': 'dccAmount','dcc_currency': 'dccCurrency','id': 'id','transaction_amount': 'transactionAmount','transaction_count': 'transactionCount','transaction_currency': 'transactionCurrency','version': 'version',
+        'description': 'description','id': 'id','linked_space_id': 'linkedSpaceId','name': 'name','planned_purge_date': 'plannedPurgeDate','state': 'state','type': 'type','version': 'version',
     }
 
     
-    _brand = None
-    _dcc_amount = None
-    _dcc_currency = None
+    _description = None
     _id = None
-    _transaction_amount = None
-    _transaction_count = None
-    _transaction_currency = None
+    _linked_space_id = None
+    _name = None
+    _planned_purge_date = None
+    _state = None
+    _type = None
     _version = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
-        self.brand = kwargs.get('brand', None)
-        self.dcc_amount = kwargs.get('dcc_amount', None)
-        self.dcc_currency = kwargs.get('dcc_currency', None)
+        self.description = kwargs.get('description', None)
         self.id = kwargs.get('id', None)
-        self.transaction_amount = kwargs.get('transaction_amount', None)
-        self.transaction_count = kwargs.get('transaction_count', None)
-        self.transaction_currency = kwargs.get('transaction_currency', None)
+        self.linked_space_id = kwargs.get('linked_space_id', None)
+        self.name = kwargs.get('name', None)
+        self.planned_purge_date = kwargs.get('planned_purge_date', None)
+        self.state = kwargs.get('state', None)
+        self.type = kwargs.get('type', None)
         self.version = kwargs.get('version', None)
         
 
     
     @property
-    def brand(self):
-        """Gets the brand of this PaymentTerminalDccTransactionSum.
+    def description(self):
+        """Gets the description of this SubscriptionMetric.
 
             
 
-        :return: The brand of this PaymentTerminalDccTransactionSum.
-        :rtype: str
+        :return: The description of this SubscriptionMetric.
+        :rtype: DatabaseTranslatedString
         """
-        return self._brand
+        return self._description
 
-    @brand.setter
-    def brand(self, brand):
-        """Sets the brand of this PaymentTerminalDccTransactionSum.
+    @description.setter
+    def description(self, description):
+        """Sets the description of this SubscriptionMetric.
 
             
 
-        :param brand: The brand of this PaymentTerminalDccTransactionSum.
-        :type: str
+        :param description: The description of this SubscriptionMetric.
+        :type: DatabaseTranslatedString
         """
 
-        self._brand = brand
+        self._description = description
     
     @property
-    def dcc_amount(self):
-        """Gets the dcc_amount of this PaymentTerminalDccTransactionSum.
+    def id(self):
+        """Gets the id of this SubscriptionMetric.
 
-            
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
-        :return: The dcc_amount of this PaymentTerminalDccTransactionSum.
-        :rtype: float
+        :return: The id of this SubscriptionMetric.
+        :rtype: int
         """
-        return self._dcc_amount
+        return self._id
 
-    @dcc_amount.setter
-    def dcc_amount(self, dcc_amount):
-        """Sets the dcc_amount of this PaymentTerminalDccTransactionSum.
+    @id.setter
+    def id(self, id):
+        """Sets the id of this SubscriptionMetric.
 
-            
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
-        :param dcc_amount: The dcc_amount of this PaymentTerminalDccTransactionSum.
-        :type: float
+        :param id: The id of this SubscriptionMetric.
+        :type: int
         """
 
-        self._dcc_amount = dcc_amount
+        self._id = id
     
     @property
-    def dcc_currency(self):
-        """Gets the dcc_currency of this PaymentTerminalDccTransactionSum.
+    def linked_space_id(self):
+        """Gets the linked_space_id of this SubscriptionMetric.
 
-            
+            The linked space id holds the ID of the space to which the entity belongs to.
 
-        :return: The dcc_currency of this PaymentTerminalDccTransactionSum.
-        :rtype: str
+        :return: The linked_space_id of this SubscriptionMetric.
+        :rtype: int
         """
-        return self._dcc_currency
+        return self._linked_space_id
 
-    @dcc_currency.setter
-    def dcc_currency(self, dcc_currency):
-        """Sets the dcc_currency of this PaymentTerminalDccTransactionSum.
+    @linked_space_id.setter
+    def linked_space_id(self, linked_space_id):
+        """Sets the linked_space_id of this SubscriptionMetric.
 
-            
+            The linked space id holds the ID of the space to which the entity belongs to.
 
-        :param dcc_currency: The dcc_currency of this PaymentTerminalDccTransactionSum.
-        :type: str
+        :param linked_space_id: The linked_space_id of this SubscriptionMetric.
+        :type: int
         """
 
-        self._dcc_currency = dcc_currency
+        self._linked_space_id = linked_space_id
     
     @property
-    def id(self):
-        """Gets the id of this PaymentTerminalDccTransactionSum.
+    def name(self):
+        """Gets the name of this SubscriptionMetric.
 
-            A unique identifier for the object.
+            
 
-        :return: The id of this PaymentTerminalDccTransactionSum.
-        :rtype: int
+        :return: The name of this SubscriptionMetric.
+        :rtype: DatabaseTranslatedString
         """
-        return self._id
+        return self._name
 
-    @id.setter
-    def id(self, id):
-        """Sets the id of this PaymentTerminalDccTransactionSum.
+    @name.setter
+    def name(self, name):
+        """Sets the name of this SubscriptionMetric.
 
-            A unique identifier for the object.
+            
 
-        :param id: The id of this PaymentTerminalDccTransactionSum.
-        :type: int
+        :param name: The name of this SubscriptionMetric.
+        :type: DatabaseTranslatedString
         """
 
-        self._id = id
+        self._name = name
     
     @property
-    def transaction_amount(self):
-        """Gets the transaction_amount of this PaymentTerminalDccTransactionSum.
+    def planned_purge_date(self):
+        """Gets the planned_purge_date of this SubscriptionMetric.
 
-            
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
-        :return: The transaction_amount of this PaymentTerminalDccTransactionSum.
-        :rtype: float
+        :return: The planned_purge_date of this SubscriptionMetric.
+        :rtype: datetime
         """
-        return self._transaction_amount
+        return self._planned_purge_date
 
-    @transaction_amount.setter
-    def transaction_amount(self, transaction_amount):
-        """Sets the transaction_amount of this PaymentTerminalDccTransactionSum.
+    @planned_purge_date.setter
+    def planned_purge_date(self, planned_purge_date):
+        """Sets the planned_purge_date of this SubscriptionMetric.
 
-            
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
-        :param transaction_amount: The transaction_amount of this PaymentTerminalDccTransactionSum.
-        :type: float
+        :param planned_purge_date: The planned_purge_date of this SubscriptionMetric.
+        :type: datetime
         """
 
-        self._transaction_amount = transaction_amount
+        self._planned_purge_date = planned_purge_date
     
     @property
-    def transaction_count(self):
-        """Gets the transaction_count of this PaymentTerminalDccTransactionSum.
+    def state(self):
+        """Gets the state of this SubscriptionMetric.
 
             
 
-        :return: The transaction_count of this PaymentTerminalDccTransactionSum.
-        :rtype: int
+        :return: The state of this SubscriptionMetric.
+        :rtype: CreationEntityState
         """
-        return self._transaction_count
+        return self._state
 
-    @transaction_count.setter
-    def transaction_count(self, transaction_count):
-        """Sets the transaction_count of this PaymentTerminalDccTransactionSum.
+    @state.setter
+    def state(self, state):
+        """Sets the state of this SubscriptionMetric.
 
             
 
-        :param transaction_count: The transaction_count of this PaymentTerminalDccTransactionSum.
-        :type: int
+        :param state: The state of this SubscriptionMetric.
+        :type: CreationEntityState
         """
 
-        self._transaction_count = transaction_count
+        self._state = state
     
     @property
-    def transaction_currency(self):
-        """Gets the transaction_currency of this PaymentTerminalDccTransactionSum.
+    def type(self):
+        """Gets the type of this SubscriptionMetric.
 
             
 
-        :return: The transaction_currency of this PaymentTerminalDccTransactionSum.
-        :rtype: str
+        :return: The type of this SubscriptionMetric.
+        :rtype: SubscriptionMetricType
         """
-        return self._transaction_currency
+        return self._type
 
-    @transaction_currency.setter
-    def transaction_currency(self, transaction_currency):
-        """Sets the transaction_currency of this PaymentTerminalDccTransactionSum.
+    @type.setter
+    def type(self, type):
+        """Sets the type of this SubscriptionMetric.
 
             
 
-        :param transaction_currency: The transaction_currency of this PaymentTerminalDccTransactionSum.
-        :type: str
+        :param type: The type of this SubscriptionMetric.
+        :type: SubscriptionMetricType
         """
 
-        self._transaction_currency = transaction_currency
+        self._type = type
     
     @property
     def version(self):
-        """Gets the version of this PaymentTerminalDccTransactionSum.
+        """Gets the version of this SubscriptionMetric.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
-        :return: The version of this PaymentTerminalDccTransactionSum.
+        :return: The version of this SubscriptionMetric.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
-        """Sets the version of this PaymentTerminalDccTransactionSum.
+        """Sets the version of this SubscriptionMetric.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
-        :param version: The version of this PaymentTerminalDccTransactionSum.
+        :param version: The version of this SubscriptionMetric.
         :type: int
         """
 
         self._version = version
     
 
     def to_dict(self):
@@ -250,27 +250,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(PaymentTerminalDccTransactionSum, dict):
+        if issubclass(SubscriptionMetric, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, PaymentTerminalDccTransactionSum):
+        if not isinstance(other, SubscriptionMetric):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_terminal_location.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_terminal_location.py`

 * *Files 10% similar despite different names*

```diff
@@ -67,49 +67,49 @@
 
         self._external_id = external_id
     
     @property
     def id(self):
         """Gets the id of this PaymentTerminalLocation.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this PaymentTerminalLocation.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this PaymentTerminalLocation.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this PaymentTerminalLocation.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this PaymentTerminalLocation.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this PaymentTerminalLocation.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this PaymentTerminalLocation.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this PaymentTerminalLocation.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -138,72 +138,72 @@
 
         self._name = name
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this PaymentTerminalLocation.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this PaymentTerminalLocation.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this PaymentTerminalLocation.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this PaymentTerminalLocation.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
     @property
     def state(self):
         """Gets the state of this PaymentTerminalLocation.
 
-            The object's current state.
+            
 
         :return: The state of this PaymentTerminalLocation.
         :rtype: PaymentTerminalLocationState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this PaymentTerminalLocation.
 
-            The object's current state.
+            
 
         :param state: The state of this PaymentTerminalLocation.
         :type: PaymentTerminalLocationState
         """
 
         self._state = state
     
     @property
     def version(self):
         """Gets the version of this PaymentTerminalLocation.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this PaymentTerminalLocation.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this PaymentTerminalLocation.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this PaymentTerminalLocation.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_terminal_location_version.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/payment_terminal_location_version.py`

 * *Files 15% similar despite different names*

```diff
@@ -125,72 +125,72 @@
 
         self._created_by = created_by
     
     @property
     def created_on(self):
         """Gets the created_on of this PaymentTerminalLocationVersion.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :return: The created_on of this PaymentTerminalLocationVersion.
         :rtype: datetime
         """
         return self._created_on
 
     @created_on.setter
     def created_on(self, created_on):
         """Sets the created_on of this PaymentTerminalLocationVersion.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :param created_on: The created_on of this PaymentTerminalLocationVersion.
         :type: datetime
         """
 
         self._created_on = created_on
     
     @property
     def id(self):
         """Gets the id of this PaymentTerminalLocationVersion.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this PaymentTerminalLocationVersion.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this PaymentTerminalLocationVersion.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this PaymentTerminalLocationVersion.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this PaymentTerminalLocationVersion.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this PaymentTerminalLocationVersion.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this PaymentTerminalLocationVersion.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this PaymentTerminalLocationVersion.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -217,72 +217,72 @@
 
         self._location = location
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this PaymentTerminalLocationVersion.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this PaymentTerminalLocationVersion.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this PaymentTerminalLocationVersion.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this PaymentTerminalLocationVersion.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
     @property
     def state(self):
         """Gets the state of this PaymentTerminalLocationVersion.
 
-            The object's current state.
+            
 
         :return: The state of this PaymentTerminalLocationVersion.
         :rtype: PaymentTerminalLocationVersionState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this PaymentTerminalLocationVersion.
 
-            The object's current state.
+            
 
         :param state: The state of this PaymentTerminalLocationVersion.
         :type: PaymentTerminalLocationVersionState
         """
 
         self._state = state
     
     @property
     def version(self):
         """Gets the version of this PaymentTerminalLocationVersion.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this PaymentTerminalLocationVersion.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this PaymentTerminalLocationVersion.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this PaymentTerminalLocationVersion.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_terminal_receipt_type.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/token_update.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,109 +1,91 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
+from . import AbstractTokenUpdate
 
 
-
-class PaymentTerminalReceiptType:
+class TokenUpdate(AbstractTokenUpdate):
 
     swagger_types = {
     
-        'description': 'dict(str, str)',
         'id': 'int',
-        'name': 'dict(str, str)',
+        'version': 'int',
     }
 
     attribute_map = {
-        'description': 'description','id': 'id','name': 'name',
+        'id': 'id','version': 'version',
     }
 
     
-    _description = None
     _id = None
-    _name = None
+    _version = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
-        self.description = kwargs.get('description', None)
-        self.id = kwargs.get('id', None)
-        self.name = kwargs.get('name', None)
-        
-
-    
-    @property
-    def description(self):
-        """Gets the description of this PaymentTerminalReceiptType.
-
-            The localized description of the object.
+        self.id = kwargs.get('id')
 
-        :return: The description of this PaymentTerminalReceiptType.
-        :rtype: dict(str, str)
-        """
-        return self._description
-
-    @description.setter
-    def description(self, description):
-        """Sets the description of this PaymentTerminalReceiptType.
-
-            The localized description of the object.
+        self.version = kwargs.get('version')
 
-        :param description: The description of this PaymentTerminalReceiptType.
-        :type: dict(str, str)
-        """
+        super().__init__(**kwargs)
+        self.swagger_types.update(super().swagger_types)
+        self.attribute_map.update(super().attribute_map)
 
-        self._description = description
     
     @property
     def id(self):
-        """Gets the id of this PaymentTerminalReceiptType.
+        """Gets the id of this TokenUpdate.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
-        :return: The id of this PaymentTerminalReceiptType.
+        :return: The id of this TokenUpdate.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
-        """Sets the id of this PaymentTerminalReceiptType.
+        """Sets the id of this TokenUpdate.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
-        :param id: The id of this PaymentTerminalReceiptType.
+        :param id: The id of this TokenUpdate.
         :type: int
         """
+        if id is None:
+            raise ValueError("Invalid value for `id`, must not be `None`")
 
         self._id = id
     
     @property
-    def name(self):
-        """Gets the name of this PaymentTerminalReceiptType.
+    def version(self):
+        """Gets the version of this TokenUpdate.
 
-            The localized name of the object.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
-        :return: The name of this PaymentTerminalReceiptType.
-        :rtype: dict(str, str)
+        :return: The version of this TokenUpdate.
+        :rtype: int
         """
-        return self._name
+        return self._version
 
-    @name.setter
-    def name(self, name):
-        """Sets the name of this PaymentTerminalReceiptType.
+    @version.setter
+    def version(self, version):
+        """Sets the version of this TokenUpdate.
 
-            The localized name of the object.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
-        :param name: The name of this PaymentTerminalReceiptType.
-        :type: dict(str, str)
+        :param version: The version of this TokenUpdate.
+        :type: int
         """
+        if version is None:
+            raise ValueError("Invalid value for `version`, must not be `None`")
 
-        self._name = name
+        self._version = version
     
 
     def to_dict(self):
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
@@ -120,27 +102,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(PaymentTerminalReceiptType, dict):
+        if issubclass(TokenUpdate, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, PaymentTerminalReceiptType):
+        if not isinstance(other, TokenUpdate):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_terminal_transaction_summary_fetch_request.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/terminal_receipt_fetch_request.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,111 +1,111 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
 
 
 
-class PaymentTerminalTransactionSummaryFetchRequest:
+class TerminalReceiptFetchRequest:
 
     swagger_types = {
     
         'format': 'TerminalReceiptFormat',
-        'summary_id': 'int',
+        'transaction': 'int',
         'width': 'int',
     }
 
     attribute_map = {
-        'format': 'format','summary_id': 'summaryId','width': 'width',
+        'format': 'format','transaction': 'transaction','width': 'width',
     }
 
     
     _format = None
-    _summary_id = None
+    _transaction = None
     _width = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
         self.format = kwargs.get('format')
 
-        self.summary_id = kwargs.get('summary_id')
+        self.transaction = kwargs.get('transaction')
 
         self.width = kwargs.get('width', None)
         
 
     
     @property
     def format(self):
-        """Gets the format of this PaymentTerminalTransactionSummaryFetchRequest.
+        """Gets the format of this TerminalReceiptFetchRequest.
 
-            The format determines in what format the receipt will be returned in.
+            The format determines in what format the receipts will be returned in.
 
-        :return: The format of this PaymentTerminalTransactionSummaryFetchRequest.
+        :return: The format of this TerminalReceiptFetchRequest.
         :rtype: TerminalReceiptFormat
         """
         return self._format
 
     @format.setter
     def format(self, format):
-        """Sets the format of this PaymentTerminalTransactionSummaryFetchRequest.
+        """Sets the format of this TerminalReceiptFetchRequest.
 
-            The format determines in what format the receipt will be returned in.
+            The format determines in what format the receipts will be returned in.
 
-        :param format: The format of this PaymentTerminalTransactionSummaryFetchRequest.
+        :param format: The format of this TerminalReceiptFetchRequest.
         :type: TerminalReceiptFormat
         """
         if format is None:
             raise ValueError("Invalid value for `format`, must not be `None`")
 
         self._format = format
     
     @property
-    def summary_id(self):
-        """Gets the summary_id of this PaymentTerminalTransactionSummaryFetchRequest.
+    def transaction(self):
+        """Gets the transaction of this TerminalReceiptFetchRequest.
 
-            The id of the transaction summary receipt whose content should be returned.
+            Provide here the ID of the transaction for which the receipts should be fetched.
 
-        :return: The summary_id of this PaymentTerminalTransactionSummaryFetchRequest.
+        :return: The transaction of this TerminalReceiptFetchRequest.
         :rtype: int
         """
-        return self._summary_id
+        return self._transaction
 
-    @summary_id.setter
-    def summary_id(self, summary_id):
-        """Sets the summary_id of this PaymentTerminalTransactionSummaryFetchRequest.
+    @transaction.setter
+    def transaction(self, transaction):
+        """Sets the transaction of this TerminalReceiptFetchRequest.
 
-            The id of the transaction summary receipt whose content should be returned.
+            Provide here the ID of the transaction for which the receipts should be fetched.
 
-        :param summary_id: The summary_id of this PaymentTerminalTransactionSummaryFetchRequest.
+        :param transaction: The transaction of this TerminalReceiptFetchRequest.
         :type: int
         """
-        if summary_id is None:
-            raise ValueError("Invalid value for `summary_id`, must not be `None`")
+        if transaction is None:
+            raise ValueError("Invalid value for `transaction`, must not be `None`")
 
-        self._summary_id = summary_id
+        self._transaction = transaction
     
     @property
     def width(self):
-        """Gets the width of this PaymentTerminalTransactionSummaryFetchRequest.
+        """Gets the width of this TerminalReceiptFetchRequest.
 
             The width controls how width the document will be rendered. In case of the PDF format the width is in mm. In case of the text format the width is in the number of chars per line.
 
-        :return: The width of this PaymentTerminalTransactionSummaryFetchRequest.
+        :return: The width of this TerminalReceiptFetchRequest.
         :rtype: int
         """
         return self._width
 
     @width.setter
     def width(self, width):
-        """Sets the width of this PaymentTerminalTransactionSummaryFetchRequest.
+        """Sets the width of this TerminalReceiptFetchRequest.
 
             The width controls how width the document will be rendered. In case of the PDF format the width is in mm. In case of the text format the width is in the number of chars per line.
 
-        :param width: The width of this PaymentTerminalTransactionSummaryFetchRequest.
+        :param width: The width of this TerminalReceiptFetchRequest.
         :type: int
         """
 
         self._width = width
     
 
     def to_dict(self):
@@ -126,27 +126,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(PaymentTerminalTransactionSummaryFetchRequest, dict):
+        if issubclass(TerminalReceiptFetchRequest, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, PaymentTerminalTransactionSummaryFetchRequest):
+        if not isinstance(other, TerminalReceiptFetchRequest):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/payment_terminal_type.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/tax.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,109 +1,87 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
 
 
 
-class PaymentTerminalType:
+class Tax:
 
     swagger_types = {
     
-        'description': 'dict(str, str)',
-        'id': 'int',
-        'name': 'dict(str, str)',
+        'rate': 'float',
+        'title': 'str',
     }
 
     attribute_map = {
-        'description': 'description','id': 'id','name': 'name',
+        'rate': 'rate','title': 'title',
     }
 
     
-    _description = None
-    _id = None
-    _name = None
+    _rate = None
+    _title = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
-        self.description = kwargs.get('description', None)
-        self.id = kwargs.get('id', None)
-        self.name = kwargs.get('name', None)
+        self.rate = kwargs.get('rate', None)
+        self.title = kwargs.get('title', None)
         
 
     
     @property
-    def description(self):
-        """Gets the description of this PaymentTerminalType.
+    def rate(self):
+        """Gets the rate of this Tax.
 
-            The localized description of the object.
+            
 
-        :return: The description of this PaymentTerminalType.
-        :rtype: dict(str, str)
+        :return: The rate of this Tax.
+        :rtype: float
         """
-        return self._description
+        return self._rate
 
-    @description.setter
-    def description(self, description):
-        """Sets the description of this PaymentTerminalType.
+    @rate.setter
+    def rate(self, rate):
+        """Sets the rate of this Tax.
 
-            The localized description of the object.
+            
 
-        :param description: The description of this PaymentTerminalType.
-        :type: dict(str, str)
+        :param rate: The rate of this Tax.
+        :type: float
         """
 
-        self._description = description
+        self._rate = rate
     
     @property
-    def id(self):
-        """Gets the id of this PaymentTerminalType.
+    def title(self):
+        """Gets the title of this Tax.
 
-            A unique identifier for the object.
+            
 
-        :return: The id of this PaymentTerminalType.
-        :rtype: int
+        :return: The title of this Tax.
+        :rtype: str
         """
-        return self._id
+        return self._title
 
-    @id.setter
-    def id(self, id):
-        """Sets the id of this PaymentTerminalType.
+    @title.setter
+    def title(self, title):
+        """Sets the title of this Tax.
 
-            A unique identifier for the object.
+            
 
-        :param id: The id of this PaymentTerminalType.
-        :type: int
+        :param title: The title of this Tax.
+        :type: str
         """
+        if title is not None and len(title) > 40:
+            raise ValueError("Invalid value for `title`, length must be less than or equal to `40`")
+        if title is not None and len(title) < 2:
+            raise ValueError("Invalid value for `title`, length must be greater than or equal to `2`")
 
-        self._id = id
-    
-    @property
-    def name(self):
-        """Gets the name of this PaymentTerminalType.
-
-            The localized name of the object.
-
-        :return: The name of this PaymentTerminalType.
-        :rtype: dict(str, str)
-        """
-        return self._name
-
-    @name.setter
-    def name(self, name):
-        """Sets the name of this PaymentTerminalType.
-
-            The localized name of the object.
-
-        :param name: The name of this PaymentTerminalType.
-        :type: dict(str, str)
-        """
-
-        self._name = name
+        self._title = title
     
 
     def to_dict(self):
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
@@ -120,27 +98,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(PaymentTerminalType, dict):
+        if issubclass(Tax, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, PaymentTerminalType):
+        if not isinstance(other, Tax):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/permission.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/permission.py`

 * *Files 9% similar despite different names*

```diff
@@ -56,233 +56,233 @@
         
 
     
     @property
     def description(self):
         """Gets the description of this Permission.
 
-            The localized description of the object.
+            
 
         :return: The description of this Permission.
         :rtype: dict(str, str)
         """
         return self._description
 
     @description.setter
     def description(self, description):
         """Sets the description of this Permission.
 
-            The localized description of the object.
+            
 
         :param description: The description of this Permission.
         :type: dict(str, str)
         """
 
         self._description = description
     
     @property
     def feature(self):
         """Gets the feature of this Permission.
 
-            The feature that this permission belongs to.
+            
 
         :return: The feature of this Permission.
         :rtype: int
         """
         return self._feature
 
     @feature.setter
     def feature(self, feature):
         """Sets the feature of this Permission.
 
-            The feature that this permission belongs to.
+            
 
         :param feature: The feature of this Permission.
         :type: int
         """
 
         self._feature = feature
     
     @property
     def group(self):
         """Gets the group of this Permission.
 
-            Whether this is a permission group.
+            
 
         :return: The group of this Permission.
         :rtype: bool
         """
         return self._group
 
     @group.setter
     def group(self, group):
         """Sets the group of this Permission.
 
-            Whether this is a permission group.
+            
 
         :param group: The group of this Permission.
         :type: bool
         """
 
         self._group = group
     
     @property
     def id(self):
         """Gets the id of this Permission.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this Permission.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this Permission.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this Permission.
         :type: int
         """
 
         self._id = id
     
     @property
     def leaf(self):
         """Gets the leaf of this Permission.
 
-            Whether this is a leaf in the tree of permissions, and not a group.
+            
 
         :return: The leaf of this Permission.
         :rtype: bool
         """
         return self._leaf
 
     @leaf.setter
     def leaf(self, leaf):
         """Sets the leaf of this Permission.
 
-            Whether this is a leaf in the tree of permissions, and not a group.
+            
 
         :param leaf: The leaf of this Permission.
         :type: bool
         """
 
         self._leaf = leaf
     
     @property
     def name(self):
         """Gets the name of this Permission.
 
-            The localized name of the object.
+            
 
         :return: The name of this Permission.
         :rtype: dict(str, str)
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this Permission.
 
-            The localized name of the object.
+            
 
         :param name: The name of this Permission.
         :type: dict(str, str)
         """
 
         self._name = name
     
     @property
     def parent(self):
         """Gets the parent of this Permission.
 
-            The group that this permission belongs to.
+            
 
         :return: The parent of this Permission.
         :rtype: int
         """
         return self._parent
 
     @parent.setter
     def parent(self, parent):
         """Sets the parent of this Permission.
 
-            The group that this permission belongs to.
+            
 
         :param parent: The parent of this Permission.
         :type: int
         """
 
         self._parent = parent
     
     @property
     def path_to_root(self):
         """Gets the path_to_root of this Permission.
 
-            All parents of this permission up to the root of the permission tree.
+            
 
         :return: The path_to_root of this Permission.
         :rtype: list[int]
         """
         return self._path_to_root
 
     @path_to_root.setter
     def path_to_root(self, path_to_root):
         """Sets the path_to_root of this Permission.
 
-            All parents of this permission up to the root of the permission tree.
+            
 
         :param path_to_root: The path_to_root of this Permission.
         :type: list[int]
         """
 
         self._path_to_root = path_to_root
     
     @property
     def title(self):
         """Gets the title of this Permission.
 
-            The localized name of the object.
+            
 
         :return: The title of this Permission.
         :rtype: dict(str, str)
         """
         return self._title
 
     @title.setter
     def title(self, title):
         """Sets the title of this Permission.
 
-            The localized name of the object.
+            
 
         :param title: The title of this Permission.
         :type: dict(str, str)
         """
 
         self._title = title
     
     @property
     def two_factor_required(self):
         """Gets the two_factor_required of this Permission.
 
-            Whether users with this permission are required to enable two-factor authentication.
+            
 
         :return: The two_factor_required of this Permission.
         :rtype: bool
         """
         return self._two_factor_required
 
     @two_factor_required.setter
     def two_factor_required(self, two_factor_required):
         """Sets the two_factor_required of this Permission.
 
-            Whether users with this permission are required to enable two-factor authentication.
+            
 
         :param two_factor_required: The two_factor_required of this Permission.
         :type: bool
         """
 
         self._two_factor_required = two_factor_required
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/persistable_currency_amount.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/persistable_currency_amount.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/persistable_currency_amount_update.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/persistable_currency_amount_update.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/product_metered_fee.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_change_request.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,265 +1,196 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
 
 
 
-class ProductMeteredFee:
+class SubscriptionChangeRequest:
 
     swagger_types = {
     
-        'component': 'SubscriptionProductComponent',
-        'description': 'dict(str, str)',
-        'id': 'int',
-        'linked_space_id': 'int',
-        'metric': 'SubscriptionMetric',
-        'name': 'dict(str, str)',
-        'tier_pricing': 'ProductMeteredTierPricing',
-        'type': 'ProductFeeType',
-        'version': 'int',
+        'component_configurations': 'list[SubscriptionComponentReferenceConfiguration]',
+        'currency': 'str',
+        'product': 'int',
+        'respect_termination_period': 'bool',
+        'selected_components': 'list[SubscriptionProductComponentReference]',
+        'subscription': 'int',
     }
 
     attribute_map = {
-        'component': 'component','description': 'description','id': 'id','linked_space_id': 'linkedSpaceId','metric': 'metric','name': 'name','tier_pricing': 'tierPricing','type': 'type','version': 'version',
+        'component_configurations': 'componentConfigurations','currency': 'currency','product': 'product','respect_termination_period': 'respectTerminationPeriod','selected_components': 'selectedComponents','subscription': 'subscription',
     }
 
     
-    _component = None
-    _description = None
-    _id = None
-    _linked_space_id = None
-    _metric = None
-    _name = None
-    _tier_pricing = None
-    _type = None
-    _version = None
+    _component_configurations = None
+    _currency = None
+    _product = None
+    _respect_termination_period = None
+    _selected_components = None
+    _subscription = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
-        self.component = kwargs.get('component', None)
-        self.description = kwargs.get('description', None)
-        self.id = kwargs.get('id', None)
-        self.linked_space_id = kwargs.get('linked_space_id', None)
-        self.metric = kwargs.get('metric', None)
-        self.name = kwargs.get('name', None)
-        self.tier_pricing = kwargs.get('tier_pricing', None)
-        self.type = kwargs.get('type', None)
-        self.version = kwargs.get('version', None)
+        self.component_configurations = kwargs.get('component_configurations', None)
+        self.currency = kwargs.get('currency')
+
+        self.product = kwargs.get('product')
+
+        self.respect_termination_period = kwargs.get('respect_termination_period', None)
+        self.selected_components = kwargs.get('selected_components', None)
+        self.subscription = kwargs.get('subscription')
+
         
 
     
     @property
-    def component(self):
-        """Gets the component of this ProductMeteredFee.
+    def component_configurations(self):
+        """Gets the component_configurations of this SubscriptionChangeRequest.
 
             
 
-        :return: The component of this ProductMeteredFee.
-        :rtype: SubscriptionProductComponent
+        :return: The component_configurations of this SubscriptionChangeRequest.
+        :rtype: list[SubscriptionComponentReferenceConfiguration]
         """
-        return self._component
+        return self._component_configurations
 
-    @component.setter
-    def component(self, component):
-        """Sets the component of this ProductMeteredFee.
+    @component_configurations.setter
+    def component_configurations(self, component_configurations):
+        """Sets the component_configurations of this SubscriptionChangeRequest.
 
             
 
-        :param component: The component of this ProductMeteredFee.
-        :type: SubscriptionProductComponent
+        :param component_configurations: The component_configurations of this SubscriptionChangeRequest.
+        :type: list[SubscriptionComponentReferenceConfiguration]
         """
 
-        self._component = component
+        self._component_configurations = component_configurations
     
     @property
-    def description(self):
-        """Gets the description of this ProductMeteredFee.
+    def currency(self):
+        """Gets the currency of this SubscriptionChangeRequest.
 
-            The description of a component fee describes the fee to the subscriber. The description may be shown in documents or on certain user interfaces.
+            
 
-        :return: The description of this ProductMeteredFee.
-        :rtype: dict(str, str)
+        :return: The currency of this SubscriptionChangeRequest.
+        :rtype: str
         """
-        return self._description
+        return self._currency
 
-    @description.setter
-    def description(self, description):
-        """Sets the description of this ProductMeteredFee.
+    @currency.setter
+    def currency(self, currency):
+        """Sets the currency of this SubscriptionChangeRequest.
 
-            The description of a component fee describes the fee to the subscriber. The description may be shown in documents or on certain user interfaces.
+            
 
-        :param description: The description of this ProductMeteredFee.
-        :type: dict(str, str)
+        :param currency: The currency of this SubscriptionChangeRequest.
+        :type: str
         """
+        if currency is None:
+            raise ValueError("Invalid value for `currency`, must not be `None`")
 
-        self._description = description
+        self._currency = currency
     
     @property
-    def id(self):
-        """Gets the id of this ProductMeteredFee.
+    def product(self):
+        """Gets the product of this SubscriptionChangeRequest.
 
-            A unique identifier for the object.
+            The subscription has to be linked with a product.
 
-        :return: The id of this ProductMeteredFee.
+        :return: The product of this SubscriptionChangeRequest.
         :rtype: int
         """
-        return self._id
+        return self._product
 
-    @id.setter
-    def id(self, id):
-        """Sets the id of this ProductMeteredFee.
+    @product.setter
+    def product(self, product):
+        """Sets the product of this SubscriptionChangeRequest.
 
-            A unique identifier for the object.
+            The subscription has to be linked with a product.
 
-        :param id: The id of this ProductMeteredFee.
+        :param product: The product of this SubscriptionChangeRequest.
         :type: int
         """
+        if product is None:
+            raise ValueError("Invalid value for `product`, must not be `None`")
 
-        self._id = id
+        self._product = product
     
     @property
-    def linked_space_id(self):
-        """Gets the linked_space_id of this ProductMeteredFee.
+    def respect_termination_period(self):
+        """Gets the respect_termination_period of this SubscriptionChangeRequest.
 
-            The ID of the space this object belongs to.
+            The subscription version may be retired. The respect termination period controls whether the termination period configured on the product version should be respected or if the operation should take effect immediately.
 
-        :return: The linked_space_id of this ProductMeteredFee.
-        :rtype: int
+        :return: The respect_termination_period of this SubscriptionChangeRequest.
+        :rtype: bool
         """
-        return self._linked_space_id
+        return self._respect_termination_period
 
-    @linked_space_id.setter
-    def linked_space_id(self, linked_space_id):
-        """Sets the linked_space_id of this ProductMeteredFee.
+    @respect_termination_period.setter
+    def respect_termination_period(self, respect_termination_period):
+        """Sets the respect_termination_period of this SubscriptionChangeRequest.
 
-            The ID of the space this object belongs to.
+            The subscription version may be retired. The respect termination period controls whether the termination period configured on the product version should be respected or if the operation should take effect immediately.
 
-        :param linked_space_id: The linked_space_id of this ProductMeteredFee.
-        :type: int
+        :param respect_termination_period: The respect_termination_period of this SubscriptionChangeRequest.
+        :type: bool
         """
 
-        self._linked_space_id = linked_space_id
+        self._respect_termination_period = respect_termination_period
     
     @property
-    def metric(self):
-        """Gets the metric of this ProductMeteredFee.
+    def selected_components(self):
+        """Gets the selected_components of this SubscriptionChangeRequest.
 
             
 
-        :return: The metric of this ProductMeteredFee.
-        :rtype: SubscriptionMetric
+        :return: The selected_components of this SubscriptionChangeRequest.
+        :rtype: list[SubscriptionProductComponentReference]
         """
-        return self._metric
+        return self._selected_components
 
-    @metric.setter
-    def metric(self, metric):
-        """Sets the metric of this ProductMeteredFee.
+    @selected_components.setter
+    def selected_components(self, selected_components):
+        """Sets the selected_components of this SubscriptionChangeRequest.
 
             
 
-        :param metric: The metric of this ProductMeteredFee.
-        :type: SubscriptionMetric
-        """
-
-        self._metric = metric
-    
-    @property
-    def name(self):
-        """Gets the name of this ProductMeteredFee.
-
-            The name of the fee should describe for the subscriber in few words for what the fee is for.
-
-        :return: The name of this ProductMeteredFee.
-        :rtype: dict(str, str)
-        """
-        return self._name
-
-    @name.setter
-    def name(self, name):
-        """Sets the name of this ProductMeteredFee.
-
-            The name of the fee should describe for the subscriber in few words for what the fee is for.
-
-        :param name: The name of this ProductMeteredFee.
-        :type: dict(str, str)
+        :param selected_components: The selected_components of this SubscriptionChangeRequest.
+        :type: list[SubscriptionProductComponentReference]
         """
 
-        self._name = name
+        self._selected_components = selected_components
     
     @property
-    def tier_pricing(self):
-        """Gets the tier_pricing of this ProductMeteredFee.
-
-            The tier pricing determines the calculation method of the tiers. The prices of the different tiers can be applied in different ways. The tier pricing controls this calculation.
-
-        :return: The tier_pricing of this ProductMeteredFee.
-        :rtype: ProductMeteredTierPricing
-        """
-        return self._tier_pricing
-
-    @tier_pricing.setter
-    def tier_pricing(self, tier_pricing):
-        """Sets the tier_pricing of this ProductMeteredFee.
-
-            The tier pricing determines the calculation method of the tiers. The prices of the different tiers can be applied in different ways. The tier pricing controls this calculation.
-
-        :param tier_pricing: The tier_pricing of this ProductMeteredFee.
-        :type: ProductMeteredTierPricing
-        """
-
-        self._tier_pricing = tier_pricing
-    
-    @property
-    def type(self):
-        """Gets the type of this ProductMeteredFee.
+    def subscription(self):
+        """Gets the subscription of this SubscriptionChangeRequest.
 
             
 
-        :return: The type of this ProductMeteredFee.
-        :rtype: ProductFeeType
-        """
-        return self._type
-
-    @type.setter
-    def type(self, type):
-        """Sets the type of this ProductMeteredFee.
-
-            
-
-        :param type: The type of this ProductMeteredFee.
-        :type: ProductFeeType
-        """
-
-        self._type = type
-    
-    @property
-    def version(self):
-        """Gets the version of this ProductMeteredFee.
-
-            The version is used for optimistic locking and incremented whenever the object is updated.
-
-        :return: The version of this ProductMeteredFee.
+        :return: The subscription of this SubscriptionChangeRequest.
         :rtype: int
         """
-        return self._version
+        return self._subscription
 
-    @version.setter
-    def version(self, version):
-        """Sets the version of this ProductMeteredFee.
+    @subscription.setter
+    def subscription(self, subscription):
+        """Sets the subscription of this SubscriptionChangeRequest.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            
 
-        :param version: The version of this ProductMeteredFee.
+        :param subscription: The subscription of this SubscriptionChangeRequest.
         :type: int
         """
+        if subscription is None:
+            raise ValueError("Invalid value for `subscription`, must not be `None`")
 
-        self._version = version
+        self._subscription = subscription
     
 
     def to_dict(self):
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
@@ -276,27 +207,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(ProductMeteredFee, dict):
+        if issubclass(SubscriptionChangeRequest, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, ProductMeteredFee):
+        if not isinstance(other, SubscriptionChangeRequest):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/product_metered_fee_update.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/product_metered_fee_update.py`

 * *Files 13% similar despite different names*

```diff
@@ -8,17 +8,17 @@
 class ProductMeteredFeeUpdate:
 
     swagger_types = {
     
         'id': 'int',
         'version': 'int',
         'component': 'int',
-        'description': 'dict(str, str)',
+        'description': 'DatabaseTranslatedStringCreate',
         'metric': 'int',
-        'name': 'dict(str, str)',
+        'name': 'DatabaseTranslatedStringCreate',
         'tier_pricing': 'ProductMeteredTierPricing',
     }
 
     attribute_map = {
         'id': 'id','version': 'version','component': 'component','description': 'description','metric': 'metric','name': 'name','tier_pricing': 'tierPricing',
     }
 
@@ -122,26 +122,26 @@
     @property
     def description(self):
         """Gets the description of this ProductMeteredFeeUpdate.
 
             The description of a component fee describes the fee to the subscriber. The description may be shown in documents or on certain user interfaces.
 
         :return: The description of this ProductMeteredFeeUpdate.
-        :rtype: dict(str, str)
+        :rtype: DatabaseTranslatedStringCreate
         """
         return self._description
 
     @description.setter
     def description(self, description):
         """Sets the description of this ProductMeteredFeeUpdate.
 
             The description of a component fee describes the fee to the subscriber. The description may be shown in documents or on certain user interfaces.
 
         :param description: The description of this ProductMeteredFeeUpdate.
-        :type: dict(str, str)
+        :type: DatabaseTranslatedStringCreate
         """
 
         self._description = description
     
     @property
     def metric(self):
         """Gets the metric of this ProductMeteredFeeUpdate.
@@ -168,26 +168,26 @@
     @property
     def name(self):
         """Gets the name of this ProductMeteredFeeUpdate.
 
             The name of the fee should describe for the subscriber in few words for what the fee is for.
 
         :return: The name of this ProductMeteredFeeUpdate.
-        :rtype: dict(str, str)
+        :rtype: DatabaseTranslatedStringCreate
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this ProductMeteredFeeUpdate.
 
             The name of the fee should describe for the subscriber in few words for what the fee is for.
 
         :param name: The name of this ProductMeteredFeeUpdate.
-        :type: dict(str, str)
+        :type: DatabaseTranslatedStringCreate
         """
 
         self._name = name
     
     @property
     def tier_pricing(self):
         """Gets the tier_pricing of this ProductMeteredFeeUpdate.
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/product_metered_tier_fee.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/product_metered_tier_fee.py`

 * *Files 6% similar despite different names*

```diff
@@ -61,26 +61,26 @@
 
         self._fee = fee
     
     @property
     def id(self):
         """Gets the id of this ProductMeteredTierFee.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this ProductMeteredTierFee.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this ProductMeteredTierFee.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this ProductMeteredTierFee.
         :type: int
         """
 
         self._id = id
     
@@ -130,26 +130,26 @@
 
         self._start_range = start_range
     
     @property
     def version(self):
         """Gets the version of this ProductMeteredTierFee.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this ProductMeteredTierFee.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this ProductMeteredTierFee.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this ProductMeteredTierFee.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/product_metered_tier_fee_update.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/product_metered_tier_fee_update.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/product_period_fee.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/product_period_fee.py`

 * *Files 4% similar despite different names*

```diff
@@ -6,19 +6,19 @@
 
 
 class ProductPeriodFee:
 
     swagger_types = {
     
         'component': 'SubscriptionProductComponent',
-        'description': 'dict(str, str)',
+        'description': 'DatabaseTranslatedString',
         'id': 'int',
-        'ledger_entry_title': 'dict(str, str)',
+        'ledger_entry_title': 'DatabaseTranslatedString',
         'linked_space_id': 'int',
-        'name': 'dict(str, str)',
+        'name': 'DatabaseTranslatedString',
         'number_of_free_trial_periods': 'int',
         'period_fee': 'list[PersistableCurrencyAmount]',
         'type': 'ProductFeeType',
         'version': 'int',
     }
 
     attribute_map = {
@@ -79,118 +79,118 @@
     @property
     def description(self):
         """Gets the description of this ProductPeriodFee.
 
             The description of a component fee describes the fee to the subscriber. The description may be shown in documents or on certain user interfaces.
 
         :return: The description of this ProductPeriodFee.
-        :rtype: dict(str, str)
+        :rtype: DatabaseTranslatedString
         """
         return self._description
 
     @description.setter
     def description(self, description):
         """Sets the description of this ProductPeriodFee.
 
             The description of a component fee describes the fee to the subscriber. The description may be shown in documents or on certain user interfaces.
 
         :param description: The description of this ProductPeriodFee.
-        :type: dict(str, str)
+        :type: DatabaseTranslatedString
         """
 
         self._description = description
     
     @property
     def id(self):
         """Gets the id of this ProductPeriodFee.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this ProductPeriodFee.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this ProductPeriodFee.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this ProductPeriodFee.
         :type: int
         """
 
         self._id = id
     
     @property
     def ledger_entry_title(self):
         """Gets the ledger_entry_title of this ProductPeriodFee.
 
             The ledger entry title will be used for the title in the ledger entry and in the invoice.
 
         :return: The ledger_entry_title of this ProductPeriodFee.
-        :rtype: dict(str, str)
+        :rtype: DatabaseTranslatedString
         """
         return self._ledger_entry_title
 
     @ledger_entry_title.setter
     def ledger_entry_title(self, ledger_entry_title):
         """Sets the ledger_entry_title of this ProductPeriodFee.
 
             The ledger entry title will be used for the title in the ledger entry and in the invoice.
 
         :param ledger_entry_title: The ledger_entry_title of this ProductPeriodFee.
-        :type: dict(str, str)
+        :type: DatabaseTranslatedString
         """
 
         self._ledger_entry_title = ledger_entry_title
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this ProductPeriodFee.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this ProductPeriodFee.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this ProductPeriodFee.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this ProductPeriodFee.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
     @property
     def name(self):
         """Gets the name of this ProductPeriodFee.
 
             The name of the fee should describe for the subscriber in few words for what the fee is for.
 
         :return: The name of this ProductPeriodFee.
-        :rtype: dict(str, str)
+        :rtype: DatabaseTranslatedString
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this ProductPeriodFee.
 
             The name of the fee should describe for the subscriber in few words for what the fee is for.
 
         :param name: The name of this ProductPeriodFee.
-        :type: dict(str, str)
+        :type: DatabaseTranslatedString
         """
 
         self._name = name
     
     @property
     def number_of_free_trial_periods(self):
         """Gets the number_of_free_trial_periods of this ProductPeriodFee.
@@ -260,26 +260,26 @@
 
         self._type = type
     
     @property
     def version(self):
         """Gets the version of this ProductPeriodFee.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this ProductPeriodFee.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this ProductPeriodFee.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this ProductPeriodFee.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/product_period_fee_update.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/product_period_fee_update.py`

 * *Files 18% similar despite different names*

```diff
@@ -8,17 +8,17 @@
 class ProductPeriodFeeUpdate:
 
     swagger_types = {
     
         'id': 'int',
         'version': 'int',
         'component': 'int',
-        'description': 'dict(str, str)',
-        'ledger_entry_title': 'dict(str, str)',
-        'name': 'dict(str, str)',
+        'description': 'DatabaseTranslatedStringCreate',
+        'ledger_entry_title': 'DatabaseTranslatedStringCreate',
+        'name': 'DatabaseTranslatedStringCreate',
         'number_of_free_trial_periods': 'int',
         'period_fee': 'list[PersistableCurrencyAmountUpdate]',
     }
 
     attribute_map = {
         'id': 'id','version': 'version','component': 'component','description': 'description','ledger_entry_title': 'ledgerEntryTitle','name': 'name','number_of_free_trial_periods': 'numberOfFreeTrialPeriods','period_fee': 'periodFee',
     }
@@ -125,72 +125,72 @@
     @property
     def description(self):
         """Gets the description of this ProductPeriodFeeUpdate.
 
             The description of a component fee describes the fee to the subscriber. The description may be shown in documents or on certain user interfaces.
 
         :return: The description of this ProductPeriodFeeUpdate.
-        :rtype: dict(str, str)
+        :rtype: DatabaseTranslatedStringCreate
         """
         return self._description
 
     @description.setter
     def description(self, description):
         """Sets the description of this ProductPeriodFeeUpdate.
 
             The description of a component fee describes the fee to the subscriber. The description may be shown in documents or on certain user interfaces.
 
         :param description: The description of this ProductPeriodFeeUpdate.
-        :type: dict(str, str)
+        :type: DatabaseTranslatedStringCreate
         """
 
         self._description = description
     
     @property
     def ledger_entry_title(self):
         """Gets the ledger_entry_title of this ProductPeriodFeeUpdate.
 
             The ledger entry title will be used for the title in the ledger entry and in the invoice.
 
         :return: The ledger_entry_title of this ProductPeriodFeeUpdate.
-        :rtype: dict(str, str)
+        :rtype: DatabaseTranslatedStringCreate
         """
         return self._ledger_entry_title
 
     @ledger_entry_title.setter
     def ledger_entry_title(self, ledger_entry_title):
         """Sets the ledger_entry_title of this ProductPeriodFeeUpdate.
 
             The ledger entry title will be used for the title in the ledger entry and in the invoice.
 
         :param ledger_entry_title: The ledger_entry_title of this ProductPeriodFeeUpdate.
-        :type: dict(str, str)
+        :type: DatabaseTranslatedStringCreate
         """
 
         self._ledger_entry_title = ledger_entry_title
     
     @property
     def name(self):
         """Gets the name of this ProductPeriodFeeUpdate.
 
             The name of the fee should describe for the subscriber in few words for what the fee is for.
 
         :return: The name of this ProductPeriodFeeUpdate.
-        :rtype: dict(str, str)
+        :rtype: DatabaseTranslatedStringCreate
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this ProductPeriodFeeUpdate.
 
             The name of the fee should describe for the subscriber in few words for what the fee is for.
 
         :param name: The name of this ProductPeriodFeeUpdate.
-        :type: dict(str, str)
+        :type: DatabaseTranslatedStringCreate
         """
 
         self._name = name
     
     @property
     def number_of_free_trial_periods(self):
         """Gets the number_of_free_trial_periods of this ProductPeriodFeeUpdate.
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/product_setup_fee.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/product_setup_fee.py`

 * *Files 7% similar despite different names*

```diff
@@ -6,18 +6,18 @@
 
 
 class ProductSetupFee:
 
     swagger_types = {
     
         'component': 'SubscriptionProductComponent',
-        'description': 'dict(str, str)',
+        'description': 'DatabaseTranslatedString',
         'id': 'int',
         'linked_space_id': 'int',
-        'name': 'dict(str, str)',
+        'name': 'DatabaseTranslatedString',
         'on_downgrade_credited_amount': 'list[PersistableCurrencyAmount]',
         'on_upgrade_credited_amount': 'list[PersistableCurrencyAmount]',
         'setup_fee': 'list[PersistableCurrencyAmount]',
         'type': 'ProductFeeType',
         'version': 'int',
     }
 
@@ -79,95 +79,95 @@
     @property
     def description(self):
         """Gets the description of this ProductSetupFee.
 
             The description of a component fee describes the fee to the subscriber. The description may be shown in documents or on certain user interfaces.
 
         :return: The description of this ProductSetupFee.
-        :rtype: dict(str, str)
+        :rtype: DatabaseTranslatedString
         """
         return self._description
 
     @description.setter
     def description(self, description):
         """Sets the description of this ProductSetupFee.
 
             The description of a component fee describes the fee to the subscriber. The description may be shown in documents or on certain user interfaces.
 
         :param description: The description of this ProductSetupFee.
-        :type: dict(str, str)
+        :type: DatabaseTranslatedString
         """
 
         self._description = description
     
     @property
     def id(self):
         """Gets the id of this ProductSetupFee.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this ProductSetupFee.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this ProductSetupFee.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this ProductSetupFee.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this ProductSetupFee.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this ProductSetupFee.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this ProductSetupFee.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this ProductSetupFee.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
     @property
     def name(self):
         """Gets the name of this ProductSetupFee.
 
             The name of the fee should describe for the subscriber in few words for what the fee is for.
 
         :return: The name of this ProductSetupFee.
-        :rtype: dict(str, str)
+        :rtype: DatabaseTranslatedString
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this ProductSetupFee.
 
             The name of the fee should describe for the subscriber in few words for what the fee is for.
 
         :param name: The name of this ProductSetupFee.
-        :type: dict(str, str)
+        :type: DatabaseTranslatedString
         """
 
         self._name = name
     
     @property
     def on_downgrade_credited_amount(self):
         """Gets the on_downgrade_credited_amount of this ProductSetupFee.
@@ -260,26 +260,26 @@
 
         self._type = type
     
     @property
     def version(self):
         """Gets the version of this ProductSetupFee.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this ProductSetupFee.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this ProductSetupFee.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this ProductSetupFee.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/product_setup_fee_update.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/product_setup_fee_update.py`

 * *Files 3% similar despite different names*

```diff
@@ -8,16 +8,16 @@
 class ProductSetupFeeUpdate:
 
     swagger_types = {
     
         'id': 'int',
         'version': 'int',
         'component': 'int',
-        'description': 'dict(str, str)',
-        'name': 'dict(str, str)',
+        'description': 'DatabaseTranslatedStringCreate',
+        'name': 'DatabaseTranslatedStringCreate',
         'on_downgrade_credited_amount': 'list[PersistableCurrencyAmountUpdate]',
         'on_upgrade_credited_amount': 'list[PersistableCurrencyAmountUpdate]',
         'setup_fee': 'list[PersistableCurrencyAmountUpdate]',
     }
 
     attribute_map = {
         'id': 'id','version': 'version','component': 'component','description': 'description','name': 'name','on_downgrade_credited_amount': 'onDowngradeCreditedAmount','on_upgrade_credited_amount': 'onUpgradeCreditedAmount','setup_fee': 'setupFee',
@@ -125,49 +125,49 @@
     @property
     def description(self):
         """Gets the description of this ProductSetupFeeUpdate.
 
             The description of a component fee describes the fee to the subscriber. The description may be shown in documents or on certain user interfaces.
 
         :return: The description of this ProductSetupFeeUpdate.
-        :rtype: dict(str, str)
+        :rtype: DatabaseTranslatedStringCreate
         """
         return self._description
 
     @description.setter
     def description(self, description):
         """Sets the description of this ProductSetupFeeUpdate.
 
             The description of a component fee describes the fee to the subscriber. The description may be shown in documents or on certain user interfaces.
 
         :param description: The description of this ProductSetupFeeUpdate.
-        :type: dict(str, str)
+        :type: DatabaseTranslatedStringCreate
         """
 
         self._description = description
     
     @property
     def name(self):
         """Gets the name of this ProductSetupFeeUpdate.
 
             The name of the fee should describe for the subscriber in few words for what the fee is for.
 
         :return: The name of this ProductSetupFeeUpdate.
-        :rtype: dict(str, str)
+        :rtype: DatabaseTranslatedStringCreate
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this ProductSetupFeeUpdate.
 
             The name of the fee should describe for the subscriber in few words for what the fee is for.
 
         :param name: The name of this ProductSetupFeeUpdate.
-        :type: dict(str, str)
+        :type: DatabaseTranslatedStringCreate
         """
 
         self._name = name
     
     @property
     def on_downgrade_credited_amount(self):
         """Gets the on_downgrade_credited_amount of this ProductSetupFeeUpdate.
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/refund.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/refund.py`

 * *Files 2% similar despite different names*

```diff
@@ -211,26 +211,26 @@
 
         self._created_by = created_by
     
     @property
     def created_on(self):
         """Gets the created_on of this Refund.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :return: The created_on of this Refund.
         :rtype: datetime
         """
         return self._created_on
 
     @created_on.setter
     def created_on(self, created_on):
         """Sets the created_on of this Refund.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :param created_on: The created_on of this Refund.
         :type: datetime
         """
 
         self._created_on = created_on
     
@@ -330,26 +330,26 @@
 
         self._failure_reason = failure_reason
     
     @property
     def id(self):
         """Gets the id of this Refund.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this Refund.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this Refund.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this Refund.
         :type: int
         """
 
         self._id = id
     
@@ -376,26 +376,26 @@
 
         self._labels = labels
     
     @property
     def language(self):
         """Gets the language of this Refund.
 
-            The language that is linked to the object.
+            
 
         :return: The language of this Refund.
         :rtype: str
         """
         return self._language
 
     @language.setter
     def language(self, language):
         """Sets the language of this Refund.
 
-            The language that is linked to the object.
+            
 
         :param language: The language of this Refund.
         :type: str
         """
 
         self._language = language
     
@@ -422,26 +422,26 @@
 
         self._line_items = line_items
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this Refund.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this Refund.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this Refund.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this Refund.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -493,26 +493,26 @@
 
         self._next_update_on = next_update_on
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this Refund.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this Refund.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this Refund.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this Refund.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -610,26 +610,26 @@
 
         self._reductions = reductions
     
     @property
     def state(self):
         """Gets the state of this Refund.
 
-            The object's current state.
+            
 
         :return: The state of this Refund.
         :rtype: RefundState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this Refund.
 
-            The object's current state.
+            
 
         :param state: The state of this Refund.
         :type: RefundState
         """
 
         self._state = state
     
@@ -840,26 +840,26 @@
 
         self._updated_invoice = updated_invoice
     
     @property
     def version(self):
         """Gets the version of this Refund.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this Refund.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this Refund.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this Refund.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/refund_bank_transaction.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/refund_bank_transaction.py`

 * *Files 2% similar despite different names*

```diff
@@ -69,26 +69,26 @@
 
         self._bank_transaction = bank_transaction
     
     @property
     def language(self):
         """Gets the language of this RefundBankTransaction.
 
-            The language that is linked to the object.
+            
 
         :return: The language of this RefundBankTransaction.
         :rtype: str
         """
         return self._language
 
     @language.setter
     def language(self, language):
         """Sets the language of this RefundBankTransaction.
 
-            The language that is linked to the object.
+            
 
         :param language: The language of this RefundBankTransaction.
         :type: str
         """
 
         self._language = language
     
@@ -184,26 +184,26 @@
 
         self._space_view_id = space_view_id
     
     @property
     def version(self):
         """Gets the version of this RefundBankTransaction.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this RefundBankTransaction.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this RefundBankTransaction.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this RefundBankTransaction.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/refund_comment.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/refund_comment.py`

 * *Files 6% similar despite different names*

```diff
@@ -53,189 +53,189 @@
         
 
     
     @property
     def content(self):
         """Gets the content of this RefundComment.
 
-            The comment's actual content.
+            
 
         :return: The content of this RefundComment.
         :rtype: str
         """
         return self._content
 
     @content.setter
     def content(self, content):
         """Sets the content of this RefundComment.
 
-            The comment's actual content.
+            
 
         :param content: The content of this RefundComment.
         :type: str
         """
         if content is not None and len(content) > 262144:
             raise ValueError("Invalid value for `content`, length must be less than or equal to `262144`")
 
         self._content = content
     
     @property
     def created_by(self):
         """Gets the created_by of this RefundComment.
 
-            The ID of the user the comment was created by.
+            
 
         :return: The created_by of this RefundComment.
         :rtype: int
         """
         return self._created_by
 
     @created_by.setter
     def created_by(self, created_by):
         """Sets the created_by of this RefundComment.
 
-            The ID of the user the comment was created by.
+            
 
         :param created_by: The created_by of this RefundComment.
         :type: int
         """
 
         self._created_by = created_by
     
     @property
     def created_on(self):
         """Gets the created_on of this RefundComment.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :return: The created_on of this RefundComment.
         :rtype: datetime
         """
         return self._created_on
 
     @created_on.setter
     def created_on(self, created_on):
         """Sets the created_on of this RefundComment.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :param created_on: The created_on of this RefundComment.
         :type: datetime
         """
 
         self._created_on = created_on
     
     @property
     def edited_by(self):
         """Gets the edited_by of this RefundComment.
 
-            The ID of the user the comment was last updated by.
+            
 
         :return: The edited_by of this RefundComment.
         :rtype: int
         """
         return self._edited_by
 
     @edited_by.setter
     def edited_by(self, edited_by):
         """Sets the edited_by of this RefundComment.
 
-            The ID of the user the comment was last updated by.
+            
 
         :param edited_by: The edited_by of this RefundComment.
         :type: int
         """
 
         self._edited_by = edited_by
     
     @property
     def edited_on(self):
         """Gets the edited_on of this RefundComment.
 
-            The date and time when the comment was last updated.
+            The date on which the comment was last edited.
 
         :return: The edited_on of this RefundComment.
         :rtype: datetime
         """
         return self._edited_on
 
     @edited_on.setter
     def edited_on(self, edited_on):
         """Sets the edited_on of this RefundComment.
 
-            The date and time when the comment was last updated.
+            The date on which the comment was last edited.
 
         :param edited_on: The edited_on of this RefundComment.
         :type: datetime
         """
 
         self._edited_on = edited_on
     
     @property
     def id(self):
         """Gets the id of this RefundComment.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this RefundComment.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this RefundComment.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this RefundComment.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this RefundComment.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this RefundComment.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this RefundComment.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this RefundComment.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
     @property
     def pinned(self):
         """Gets the pinned of this RefundComment.
 
-            Whether the comment is pinned to the top.
+            
 
         :return: The pinned of this RefundComment.
         :rtype: bool
         """
         return self._pinned
 
     @pinned.setter
     def pinned(self, pinned):
         """Sets the pinned of this RefundComment.
 
-            Whether the comment is pinned to the top.
+            
 
         :param pinned: The pinned of this RefundComment.
         :type: bool
         """
 
         self._pinned = pinned
     
@@ -262,26 +262,26 @@
 
         self._refund = refund
     
     @property
     def version(self):
         """Gets the version of this RefundComment.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this RefundComment.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this RefundComment.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this RefundComment.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/refund_comment_active.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/refund_comment_active.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/refund_comment_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscriber_active.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,62 +1,59 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
-from . import AbstractRefundCommentActive
+from . import SubscriberUpdate
 
 
-class RefundCommentCreate(AbstractRefundCommentActive):
+class SubscriberActive(SubscriberUpdate):
 
     swagger_types = {
     
-        'refund': 'int',
+        'state': 'CreationEntityState',
     }
 
     attribute_map = {
-        'refund': 'refund',
+        'state': 'state',
     }
 
     
-    _refund = None
+    _state = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
-        self.refund = kwargs.get('refund')
-
+        self.state = kwargs.get('state', None)
         super().__init__(**kwargs)
         self.swagger_types.update(super().swagger_types)
         self.attribute_map.update(super().attribute_map)
 
     
     @property
-    def refund(self):
-        """Gets the refund of this RefundCommentCreate.
+    def state(self):
+        """Gets the state of this SubscriberActive.
 
             
 
-        :return: The refund of this RefundCommentCreate.
-        :rtype: int
+        :return: The state of this SubscriberActive.
+        :rtype: CreationEntityState
         """
-        return self._refund
+        return self._state
 
-    @refund.setter
-    def refund(self, refund):
-        """Sets the refund of this RefundCommentCreate.
+    @state.setter
+    def state(self, state):
+        """Sets the state of this SubscriberActive.
 
             
 
-        :param refund: The refund of this RefundCommentCreate.
-        :type: int
+        :param state: The state of this SubscriberActive.
+        :type: CreationEntityState
         """
-        if refund is None:
-            raise ValueError("Invalid value for `refund`, must not be `None`")
 
-        self._refund = refund
+        self._state = state
     
 
     def to_dict(self):
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
@@ -73,27 +70,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(RefundCommentCreate, dict):
+        if issubclass(SubscriberActive, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, RefundCommentCreate):
+        if not isinstance(other, SubscriberActive):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/refund_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/refund_create.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/refund_recovery_bank_transaction.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/refund_recovery_bank_transaction.py`

 * *Files 2% similar despite different names*

```diff
@@ -72,26 +72,26 @@
 
         self._bank_transaction = bank_transaction
     
     @property
     def language(self):
         """Gets the language of this RefundRecoveryBankTransaction.
 
-            The language that is linked to the object.
+            
 
         :return: The language of this RefundRecoveryBankTransaction.
         :rtype: str
         """
         return self._language
 
     @language.setter
     def language(self, language):
         """Sets the language of this RefundRecoveryBankTransaction.
 
-            The language that is linked to the object.
+            
 
         :param language: The language of this RefundRecoveryBankTransaction.
         :type: str
         """
 
         self._language = language
     
@@ -210,26 +210,26 @@
 
         self._space_view_id = space_view_id
     
     @property
     def version(self):
         """Gets the version of this RefundRecoveryBankTransaction.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this RefundRecoveryBankTransaction.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this RefundRecoveryBankTransaction.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this RefundRecoveryBankTransaction.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/rendered_document.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/rendered_document.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/rendered_terminal_receipt.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/rendered_terminal_receipt.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/rendered_terminal_transaction_summary.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/webhook_url_update.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,83 +1,91 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
+from . import AbstractWebhookUrlUpdate
 
 
-
-class RenderedTerminalTransactionSummary:
+class WebhookUrlUpdate(AbstractWebhookUrlUpdate):
 
     swagger_types = {
     
-        'data': 'list[str]',
-        'mime_type': 'str',
+        'id': 'int',
+        'version': 'int',
     }
 
     attribute_map = {
-        'data': 'data','mime_type': 'mimeType',
+        'id': 'id','version': 'version',
     }
 
     
-    _data = None
-    _mime_type = None
+    _id = None
+    _version = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
-        self.data = kwargs.get('data', None)
-        self.mime_type = kwargs.get('mime_type', None)
-        
+        self.id = kwargs.get('id')
+
+        self.version = kwargs.get('version')
+
+        super().__init__(**kwargs)
+        self.swagger_types.update(super().swagger_types)
+        self.attribute_map.update(super().attribute_map)
 
     
     @property
-    def data(self):
-        """Gets the data of this RenderedTerminalTransactionSummary.
+    def id(self):
+        """Gets the id of this WebhookUrlUpdate.
 
-            The data property contains the binary data of the receipt document encoded as base 64 encoded string.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
-        :return: The data of this RenderedTerminalTransactionSummary.
-        :rtype: list[str]
+        :return: The id of this WebhookUrlUpdate.
+        :rtype: int
         """
-        return self._data
+        return self._id
 
-    @data.setter
-    def data(self, data):
-        """Sets the data of this RenderedTerminalTransactionSummary.
+    @id.setter
+    def id(self, id):
+        """Sets the id of this WebhookUrlUpdate.
 
-            The data property contains the binary data of the receipt document encoded as base 64 encoded string.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
-        :param data: The data of this RenderedTerminalTransactionSummary.
-        :type: list[str]
+        :param id: The id of this WebhookUrlUpdate.
+        :type: int
         """
+        if id is None:
+            raise ValueError("Invalid value for `id`, must not be `None`")
 
-        self._data = data
+        self._id = id
     
     @property
-    def mime_type(self):
-        """Gets the mime_type of this RenderedTerminalTransactionSummary.
+    def version(self):
+        """Gets the version of this WebhookUrlUpdate.
 
-            The mime type indicates the format of the receipt document. The mime type depends on the requested receipt format.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
-        :return: The mime_type of this RenderedTerminalTransactionSummary.
-        :rtype: str
+        :return: The version of this WebhookUrlUpdate.
+        :rtype: int
         """
-        return self._mime_type
+        return self._version
 
-    @mime_type.setter
-    def mime_type(self, mime_type):
-        """Sets the mime_type of this RenderedTerminalTransactionSummary.
+    @version.setter
+    def version(self, version):
+        """Sets the version of this WebhookUrlUpdate.
 
-            The mime type indicates the format of the receipt document. The mime type depends on the requested receipt format.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
-        :param mime_type: The mime_type of this RenderedTerminalTransactionSummary.
-        :type: str
+        :param version: The version of this WebhookUrlUpdate.
+        :type: int
         """
+        if version is None:
+            raise ValueError("Invalid value for `version`, must not be `None`")
 
-        self._mime_type = mime_type
+        self._version = version
     
 
     def to_dict(self):
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
@@ -94,27 +102,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(RenderedTerminalTransactionSummary, dict):
+        if issubclass(WebhookUrlUpdate, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, RenderedTerminalTransactionSummary):
+        if not isinstance(other, WebhookUrlUpdate):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/resource_path.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/resource_path.py`

 * *Files 14% similar despite different names*

```diff
@@ -44,49 +44,49 @@
         
 
     
     @property
     def id(self):
         """Gets the id of this ResourcePath.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this ResourcePath.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this ResourcePath.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this ResourcePath.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this ResourcePath.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this ResourcePath.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this ResourcePath.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this ResourcePath.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -117,26 +117,26 @@
 
         self._path = path
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this ResourcePath.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this ResourcePath.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this ResourcePath.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this ResourcePath.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -163,49 +163,49 @@
 
         self._space_id = space_id
     
     @property
     def state(self):
         """Gets the state of this ResourcePath.
 
-            The object's current state.
+            
 
         :return: The state of this ResourcePath.
         :rtype: ResourceState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this ResourcePath.
 
-            The object's current state.
+            
 
         :param state: The state of this ResourcePath.
         :type: ResourceState
         """
 
         self._state = state
     
     @property
     def version(self):
         """Gets the version of this ResourcePath.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this ResourcePath.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this ResourcePath.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this ResourcePath.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/rest_address_format.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/rest_address_format.py`

 * *Files 10% similar despite different names*

```diff
@@ -35,95 +35,95 @@
         
 
     
     @property
     def post_code_examples(self):
         """Gets the post_code_examples of this RestAddressFormat.
 
-            A list of sample post codes.
+            The example post codes allow the user to understand what we expect here.
 
         :return: The post_code_examples of this RestAddressFormat.
         :rtype: list[str]
         """
         return self._post_code_examples
 
     @post_code_examples.setter
     def post_code_examples(self, post_code_examples):
         """Sets the post_code_examples of this RestAddressFormat.
 
-            A list of sample post codes.
+            The example post codes allow the user to understand what we expect here.
 
         :param post_code_examples: The post_code_examples of this RestAddressFormat.
         :type: list[str]
         """
 
         self._post_code_examples = post_code_examples
     
     @property
     def post_code_regex(self):
         """Gets the post_code_regex of this RestAddressFormat.
 
-            The regular expression to validate post codes.
+            The post code regex is a regular expression which can validates the input of the post code.
 
         :return: The post_code_regex of this RestAddressFormat.
         :rtype: str
         """
         return self._post_code_regex
 
     @post_code_regex.setter
     def post_code_regex(self, post_code_regex):
         """Sets the post_code_regex of this RestAddressFormat.
 
-            The regular expression to validate post codes.
+            The post code regex is a regular expression which can validates the input of the post code.
 
         :param post_code_regex: The post_code_regex of this RestAddressFormat.
         :type: str
         """
 
         self._post_code_regex = post_code_regex
     
     @property
     def required_fields(self):
         """Gets the required_fields of this RestAddressFormat.
 
-            The fields that are required in the address format.
+            The required fields indicate what fields are required within an address to comply with the address format.
 
         :return: The required_fields of this RestAddressFormat.
         :rtype: list[RestAddressFormatField]
         """
         return self._required_fields
 
     @required_fields.setter
     def required_fields(self, required_fields):
         """Sets the required_fields of this RestAddressFormat.
 
-            The fields that are required in the address format.
+            The required fields indicate what fields are required within an address to comply with the address format.
 
         :param required_fields: The required_fields of this RestAddressFormat.
         :type: list[RestAddressFormatField]
         """
 
         self._required_fields = required_fields
     
     @property
     def used_fields(self):
         """Gets the used_fields of this RestAddressFormat.
 
-            The fields that are used in the address format.
+            The used fields indicate what fields are used within this address format.
 
         :return: The used_fields of this RestAddressFormat.
         :rtype: list[RestAddressFormatField]
         """
         return self._used_fields
 
     @used_fields.setter
     def used_fields(self, used_fields):
         """Sets the used_fields of this RestAddressFormat.
 
-            The fields that are used in the address format.
+            The used fields indicate what fields are used within this address format.
 
         :param used_fields: The used_fields of this RestAddressFormat.
         :type: list[RestAddressFormatField]
         """
 
         self._used_fields = used_fields
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/rest_country.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/rest_country.py`

 * *Files 18% similar despite different names*

```diff
@@ -41,141 +41,141 @@
         
 
     
     @property
     def iso_code2_letter(self):
         """Gets the iso_code2_letter of this RestCountry.
 
-            The country's two-letter code (ISO 3166-1 alpha-2 format).
+            The ISO code 2 letter identifies the country by two chars as defined in ISO 3166-1 (e.g. US, DE, CH).
 
         :return: The iso_code2_letter of this RestCountry.
         :rtype: str
         """
         return self._iso_code2_letter
 
     @iso_code2_letter.setter
     def iso_code2_letter(self, iso_code2_letter):
         """Sets the iso_code2_letter of this RestCountry.
 
-            The country's two-letter code (ISO 3166-1 alpha-2 format).
+            The ISO code 2 letter identifies the country by two chars as defined in ISO 3166-1 (e.g. US, DE, CH).
 
         :param iso_code2_letter: The iso_code2_letter of this RestCountry.
         :type: str
         """
 
         self._iso_code2_letter = iso_code2_letter
     
     @property
     def iso_code3_letter(self):
         """Gets the iso_code3_letter of this RestCountry.
 
-            The country's three-letter code (ISO 3166-1 alpha-3 format).
+            The ISO code 3 letter identifies the country by three chars as defined in ISO 3166-1 (e.g. CHE, USA, GBR).
 
         :return: The iso_code3_letter of this RestCountry.
         :rtype: str
         """
         return self._iso_code3_letter
 
     @iso_code3_letter.setter
     def iso_code3_letter(self, iso_code3_letter):
         """Sets the iso_code3_letter of this RestCountry.
 
-            The country's three-letter code (ISO 3166-1 alpha-3 format).
+            The ISO code 3 letter identifies the country by three chars as defined in ISO 3166-1 (e.g. CHE, USA, GBR).
 
         :param iso_code3_letter: The iso_code3_letter of this RestCountry.
         :type: str
         """
 
         self._iso_code3_letter = iso_code3_letter
     
     @property
     def address_format(self):
         """Gets the address_format of this RestCountry.
 
-            Specifies the country's way of formatting addresses.
+            The address format of the country indicates how an address has to look like for the country.
 
         :return: The address_format of this RestCountry.
         :rtype: RestAddressFormat
         """
         return self._address_format
 
     @address_format.setter
     def address_format(self, address_format):
         """Sets the address_format of this RestCountry.
 
-            Specifies the country's way of formatting addresses.
+            The address format of the country indicates how an address has to look like for the country.
 
         :param address_format: The address_format of this RestCountry.
         :type: RestAddressFormat
         """
 
         self._address_format = address_format
     
     @property
     def name(self):
         """Gets the name of this RestCountry.
 
-            The name of the country.
+            The name labels the country by a name in English.
 
         :return: The name of this RestCountry.
         :rtype: str
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this RestCountry.
 
-            The name of the country.
+            The name labels the country by a name in English.
 
         :param name: The name of this RestCountry.
         :type: str
         """
 
         self._name = name
     
     @property
     def numeric_code(self):
         """Gets the numeric_code of this RestCountry.
 
-            The country's three-digit code (ISO 3166-1 numeric format).
+            The numeric code identifies the country by a three digit number as defined in ISO 3166-1 (e.g. 840, 826, 756).
 
         :return: The numeric_code of this RestCountry.
         :rtype: str
         """
         return self._numeric_code
 
     @numeric_code.setter
     def numeric_code(self, numeric_code):
         """Sets the numeric_code of this RestCountry.
 
-            The country's three-digit code (ISO 3166-1 numeric format).
+            The numeric code identifies the country by a three digit number as defined in ISO 3166-1 (e.g. 840, 826, 756).
 
         :param numeric_code: The numeric_code of this RestCountry.
         :type: str
         """
 
         self._numeric_code = numeric_code
     
     @property
     def state_codes(self):
         """Gets the state_codes of this RestCountry.
 
-            The codes of all regions (e.g. states, provinces) of the country (ISO 3166-2 format).
+            The state codes field is a list of all states associated with this country. The list contains the identifiers of the states. The identifiers corresponds to the ISO 3166-2 subdivision identifier.
 
         :return: The state_codes of this RestCountry.
         :rtype: list[str]
         """
         return self._state_codes
 
     @state_codes.setter
     def state_codes(self, state_codes):
         """Sets the state_codes of this RestCountry.
 
-            The codes of all regions (e.g. states, provinces) of the country (ISO 3166-2 format).
+            The state codes field is a list of all states associated with this country. The list contains the identifiers of the states. The identifiers corresponds to the ISO 3166-2 subdivision identifier.
 
         :param state_codes: The state_codes of this RestCountry.
         :type: list[str]
         """
 
         self._state_codes = state_codes
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/rest_country_state.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/rest_country_state.py`

 * *Files 15% similar despite different names*

```diff
@@ -6,150 +6,124 @@
 
 
 class RestCountryState:
 
     swagger_types = {
     
         'code': 'str',
-        'country': 'str',
         'country_code': 'str',
         'id': 'str',
         'name': 'str',
     }
 
     attribute_map = {
-        'code': 'code','country': 'country','country_code': 'countryCode','id': 'id','name': 'name',
+        'code': 'code','country_code': 'countryCode','id': 'id','name': 'name',
     }
 
     
     _code = None
-    _country = None
     _country_code = None
     _id = None
     _name = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
         self.code = kwargs.get('code', None)
-        self.country = kwargs.get('country', None)
         self.country_code = kwargs.get('country_code', None)
         self.id = kwargs.get('id', None)
         self.name = kwargs.get('name', None)
         
 
     
     @property
     def code(self):
         """Gets the code of this RestCountryState.
 
-            The state's code used within addresses.
+            The code of the state identifies the state. The code is typically used within addresses. Some countries may not provide a code. For those the field is null.
 
         :return: The code of this RestCountryState.
         :rtype: str
         """
         return self._code
 
     @code.setter
     def code(self, code):
         """Sets the code of this RestCountryState.
 
-            The state's code used within addresses.
+            The code of the state identifies the state. The code is typically used within addresses. Some countries may not provide a code. For those the field is null.
 
         :param code: The code of this RestCountryState.
         :type: str
         """
 
         self._code = code
     
     @property
-    def country(self):
-        """Gets the country of this RestCountryState.
-
-            
-
-        :return: The country of this RestCountryState.
-        :rtype: str
-        """
-        return self._country
-
-    @country.setter
-    def country(self, country):
-        """Sets the country of this RestCountryState.
-
-            
-
-        :param country: The country of this RestCountryState.
-        :type: str
-        """
-
-        self._country = country
-    
-    @property
     def country_code(self):
         """Gets the country_code of this RestCountryState.
 
-            The two-letter code of the state's country (ISO 3166-1 alpha-2 format).
+            The country code in ISO two letter format (e.g. UK, DE, CH, US).
 
         :return: The country_code of this RestCountryState.
         :rtype: str
         """
         return self._country_code
 
     @country_code.setter
     def country_code(self, country_code):
         """Sets the country_code of this RestCountryState.
 
-            The two-letter code of the state's country (ISO 3166-1 alpha-2 format).
+            The country code in ISO two letter format (e.g. UK, DE, CH, US).
 
         :param country_code: The country_code of this RestCountryState.
         :type: str
         """
 
         self._country_code = country_code
     
     @property
     def id(self):
         """Gets the id of this RestCountryState.
 
-            The state's code in ISO 3166-2 format.
+            The ID of the state corresponds to the subdivision identifier defined in ISO 3166-2. The format consists of the country code followed by a dash and a subdivision identifier.
 
         :return: The id of this RestCountryState.
         :rtype: str
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this RestCountryState.
 
-            The state's code in ISO 3166-2 format.
+            The ID of the state corresponds to the subdivision identifier defined in ISO 3166-2. The format consists of the country code followed by a dash and a subdivision identifier.
 
         :param id: The id of this RestCountryState.
         :type: str
         """
 
         self._id = id
     
     @property
     def name(self):
         """Gets the name of this RestCountryState.
 
-            The name of the state.
+            The name is a human readable label of the state in the language of the region.
 
         :return: The name of this RestCountryState.
         :rtype: str
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this RestCountryState.
 
-            The name of the state.
+            The name is a human readable label of the state in the language of the region.
 
         :param name: The name of this RestCountryState.
         :type: str
         """
 
         self._name = name
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/rest_currency.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/rest_currency.py`

 * *Files 14% similar despite different names*

```diff
@@ -7,123 +7,97 @@
 
 class RestCurrency:
 
     swagger_types = {
     
         'currency_code': 'str',
         'fraction_digits': 'int',
-        'name': 'str',
         'numeric_code': 'int',
     }
 
     attribute_map = {
-        'currency_code': 'currencyCode','fraction_digits': 'fractionDigits','name': 'name','numeric_code': 'numericCode',
+        'currency_code': 'currencyCode','fraction_digits': 'fractionDigits','numeric_code': 'numericCode',
     }
 
     
     _currency_code = None
     _fraction_digits = None
-    _name = None
     _numeric_code = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
         self.currency_code = kwargs.get('currency_code', None)
         self.fraction_digits = kwargs.get('fraction_digits', None)
-        self.name = kwargs.get('name', None)
         self.numeric_code = kwargs.get('numeric_code', None)
         
 
     
     @property
     def currency_code(self):
         """Gets the currency_code of this RestCurrency.
 
-            The currency's three-letter code (ISO 4217 format).
+            The currency code identifies the currency with the three char long ISO 4217 code (e.g. USD, CHF, EUR).
 
         :return: The currency_code of this RestCurrency.
         :rtype: str
         """
         return self._currency_code
 
     @currency_code.setter
     def currency_code(self, currency_code):
         """Sets the currency_code of this RestCurrency.
 
-            The currency's three-letter code (ISO 4217 format).
+            The currency code identifies the currency with the three char long ISO 4217 code (e.g. USD, CHF, EUR).
 
         :param currency_code: The currency_code of this RestCurrency.
         :type: str
         """
 
         self._currency_code = currency_code
     
     @property
     def fraction_digits(self):
         """Gets the fraction_digits of this RestCurrency.
 
-            The currency's number of decimals. When calculating amounts in this currency, the fraction digits determine the accuracy.
+            The fraction digits indicates how many places the currency has. This also indicates with which precision we calculate internally when we do calculations with this currency.
 
         :return: The fraction_digits of this RestCurrency.
         :rtype: int
         """
         return self._fraction_digits
 
     @fraction_digits.setter
     def fraction_digits(self, fraction_digits):
         """Sets the fraction_digits of this RestCurrency.
 
-            The currency's number of decimals. When calculating amounts in this currency, the fraction digits determine the accuracy.
+            The fraction digits indicates how many places the currency has. This also indicates with which precision we calculate internally when we do calculations with this currency.
 
         :param fraction_digits: The fraction_digits of this RestCurrency.
         :type: int
         """
 
         self._fraction_digits = fraction_digits
     
     @property
-    def name(self):
-        """Gets the name of this RestCurrency.
-
-            The name of the currency.
-
-        :return: The name of this RestCurrency.
-        :rtype: str
-        """
-        return self._name
-
-    @name.setter
-    def name(self, name):
-        """Sets the name of this RestCurrency.
-
-            The name of the currency.
-
-        :param name: The name of this RestCurrency.
-        :type: str
-        """
-
-        self._name = name
-    
-    @property
     def numeric_code(self):
         """Gets the numeric_code of this RestCurrency.
 
-            The currency's three-digit code (ISO 4217 format).
+            The numeric code identifies the currency with the three digit long ISO 4217 code (e.g. 978, 756, 840).
 
         :return: The numeric_code of this RestCurrency.
         :rtype: int
         """
         return self._numeric_code
 
     @numeric_code.setter
     def numeric_code(self, numeric_code):
         """Sets the numeric_code of this RestCurrency.
 
-            The currency's three-digit code (ISO 4217 format).
+            The numeric code identifies the currency with the three digit long ISO 4217 code (e.g. 978, 756, 840).
 
         :param numeric_code: The numeric_code of this RestCurrency.
         :type: int
         """
 
         self._numeric_code = numeric_code
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/rest_language.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/rest_language.py`

 * *Files 5% similar despite different names*

```diff
@@ -9,199 +9,173 @@
 
     swagger_types = {
     
         'country_code': 'str',
         'ietf_code': 'str',
         'iso2_code': 'str',
         'iso3_code': 'str',
-        'name': 'str',
         'plural_expression': 'str',
         'primary_of_group': 'bool',
     }
 
     attribute_map = {
-        'country_code': 'countryCode','ietf_code': 'ietfCode','iso2_code': 'iso2Code','iso3_code': 'iso3Code','name': 'name','plural_expression': 'pluralExpression','primary_of_group': 'primaryOfGroup',
+        'country_code': 'countryCode','ietf_code': 'ietfCode','iso2_code': 'iso2Code','iso3_code': 'iso3Code','plural_expression': 'pluralExpression','primary_of_group': 'primaryOfGroup',
     }
 
     
     _country_code = None
     _ietf_code = None
     _iso2_code = None
     _iso3_code = None
-    _name = None
     _plural_expression = None
     _primary_of_group = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
         self.country_code = kwargs.get('country_code', None)
         self.ietf_code = kwargs.get('ietf_code', None)
         self.iso2_code = kwargs.get('iso2_code', None)
         self.iso3_code = kwargs.get('iso3_code', None)
-        self.name = kwargs.get('name', None)
         self.plural_expression = kwargs.get('plural_expression', None)
         self.primary_of_group = kwargs.get('primary_of_group', None)
         
 
     
     @property
     def country_code(self):
         """Gets the country_code of this RestLanguage.
 
-            The two-letter code of the language's region (ISO 3166-1 alpha-2 format).
+            The country code represents the region of the language as a 2 letter ISO code.
 
         :return: The country_code of this RestLanguage.
         :rtype: str
         """
         return self._country_code
 
     @country_code.setter
     def country_code(self, country_code):
         """Sets the country_code of this RestLanguage.
 
-            The two-letter code of the language's region (ISO 3166-1 alpha-2 format).
+            The country code represents the region of the language as a 2 letter ISO code.
 
         :param country_code: The country_code of this RestLanguage.
         :type: str
         """
 
         self._country_code = country_code
     
     @property
     def ietf_code(self):
         """Gets the ietf_code of this RestLanguage.
 
-            The language's IETF tag consisting of the two-letter ISO code and region e.g. en-US, de-CH.
+            The IETF code represents the language as the two letter ISO code including the region (e.g. en-US).
 
         :return: The ietf_code of this RestLanguage.
         :rtype: str
         """
         return self._ietf_code
 
     @ietf_code.setter
     def ietf_code(self, ietf_code):
         """Sets the ietf_code of this RestLanguage.
 
-            The language's IETF tag consisting of the two-letter ISO code and region e.g. en-US, de-CH.
+            The IETF code represents the language as the two letter ISO code including the region (e.g. en-US).
 
         :param ietf_code: The ietf_code of this RestLanguage.
         :type: str
         """
 
         self._ietf_code = ietf_code
     
     @property
     def iso2_code(self):
         """Gets the iso2_code of this RestLanguage.
 
-            The language's two-letter code (ISO 639-1 format).
+            The ISO 2 letter code represents the language with two letters.
 
         :return: The iso2_code of this RestLanguage.
         :rtype: str
         """
         return self._iso2_code
 
     @iso2_code.setter
     def iso2_code(self, iso2_code):
         """Sets the iso2_code of this RestLanguage.
 
-            The language's two-letter code (ISO 639-1 format).
+            The ISO 2 letter code represents the language with two letters.
 
         :param iso2_code: The iso2_code of this RestLanguage.
         :type: str
         """
 
         self._iso2_code = iso2_code
     
     @property
     def iso3_code(self):
         """Gets the iso3_code of this RestLanguage.
 
-            The language's three-letter code (ISO 639-2/T format).
+            The ISO 3 letter code represents the language with three letters.
 
         :return: The iso3_code of this RestLanguage.
         :rtype: str
         """
         return self._iso3_code
 
     @iso3_code.setter
     def iso3_code(self, iso3_code):
         """Sets the iso3_code of this RestLanguage.
 
-            The language's three-letter code (ISO 639-2/T format).
+            The ISO 3 letter code represents the language with three letters.
 
         :param iso3_code: The iso3_code of this RestLanguage.
         :type: str
         """
 
         self._iso3_code = iso3_code
     
     @property
-    def name(self):
-        """Gets the name of this RestLanguage.
-
-            The name of the language.
-
-        :return: The name of this RestLanguage.
-        :rtype: str
-        """
-        return self._name
-
-    @name.setter
-    def name(self, name):
-        """Sets the name of this RestLanguage.
-
-            The name of the language.
-
-        :param name: The name of this RestLanguage.
-        :type: str
-        """
-
-        self._name = name
-    
-    @property
     def plural_expression(self):
         """Gets the plural_expression of this RestLanguage.
 
-            The expression to determine the plural index for a given number of items used to find the proper plural form for translations.
+            The plural expression defines how to map a plural into the language index. This expression is used to determine the plural form for the translations.
 
         :return: The plural_expression of this RestLanguage.
         :rtype: str
         """
         return self._plural_expression
 
     @plural_expression.setter
     def plural_expression(self, plural_expression):
         """Sets the plural_expression of this RestLanguage.
 
-            The expression to determine the plural index for a given number of items used to find the proper plural form for translations.
+            The plural expression defines how to map a plural into the language index. This expression is used to determine the plural form for the translations.
 
         :param plural_expression: The plural_expression of this RestLanguage.
         :type: str
         """
 
         self._plural_expression = plural_expression
     
     @property
     def primary_of_group(self):
         """Gets the primary_of_group of this RestLanguage.
 
-            Whether this is the primary language in a group of languages.
+            The primary language of a group indicates whether a language is the primary language of a group of languages. The group is determine by the ISO 2 letter code.
 
         :return: The primary_of_group of this RestLanguage.
         :rtype: bool
         """
         return self._primary_of_group
 
     @primary_of_group.setter
     def primary_of_group(self, primary_of_group):
         """Sets the primary_of_group of this RestLanguage.
 
-            Whether this is the primary language in a group of languages.
+            The primary language of a group indicates whether a language is the primary language of a group of languages. The group is determine by the ISO 2 letter code.
 
         :param primary_of_group: The primary_of_group of this RestLanguage.
         :type: bool
         """
 
         self._primary_of_group = primary_of_group
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/role.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/role.py`

 * *Files 10% similar despite different names*

```diff
@@ -7,15 +7,15 @@
 
 class Role:
 
     swagger_types = {
     
         'account': 'Account',
         'id': 'int',
-        'name': 'dict(str, str)',
+        'name': 'DatabaseTranslatedString',
         'permissions': 'list[Permission]',
         'planned_purge_date': 'datetime',
         'state': 'RoleState',
         'two_factor_required': 'bool',
         'version': 'int',
     }
 
@@ -47,187 +47,187 @@
         
 
     
     @property
     def account(self):
         """Gets the account of this Role.
 
-            The account the role belongs to. The role can only be assigned within this account.
+            The account to which this role belongs to. This role can only be assigned within the assigned account and the sub accounts of the assigned account.
 
         :return: The account of this Role.
         :rtype: Account
         """
         return self._account
 
     @account.setter
     def account(self, account):
         """Sets the account of this Role.
 
-            The account the role belongs to. The role can only be assigned within this account.
+            The account to which this role belongs to. This role can only be assigned within the assigned account and the sub accounts of the assigned account.
 
         :param account: The account of this Role.
         :type: Account
         """
 
         self._account = account
     
     @property
     def id(self):
         """Gets the id of this Role.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this Role.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this Role.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this Role.
         :type: int
         """
 
         self._id = id
     
     @property
     def name(self):
         """Gets the name of this Role.
 
-            The name used to identify the role.
+            The name of this role is used to identify the role within administrative interfaces.
 
         :return: The name of this Role.
-        :rtype: dict(str, str)
+        :rtype: DatabaseTranslatedString
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this Role.
 
-            The name used to identify the role.
+            The name of this role is used to identify the role within administrative interfaces.
 
         :param name: The name of this Role.
-        :type: dict(str, str)
+        :type: DatabaseTranslatedString
         """
 
         self._name = name
     
     @property
     def permissions(self):
         """Gets the permissions of this Role.
 
-            The permissions granted to users with this role.
+            Set of permissions that are granted to this role.
 
         :return: The permissions of this Role.
         :rtype: list[Permission]
         """
         return self._permissions
 
     @permissions.setter
     def permissions(self, permissions):
         """Sets the permissions of this Role.
 
-            The permissions granted to users with this role.
+            Set of permissions that are granted to this role.
 
         :param permissions: The permissions of this Role.
         :type: list[Permission]
         """
 
         self._permissions = permissions
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this Role.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this Role.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this Role.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this Role.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
     @property
     def state(self):
         """Gets the state of this Role.
 
-            The object's current state.
+            
 
         :return: The state of this Role.
         :rtype: RoleState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this Role.
 
-            The object's current state.
+            
 
         :param state: The state of this Role.
         :type: RoleState
         """
 
         self._state = state
     
     @property
     def two_factor_required(self):
         """Gets the two_factor_required of this Role.
 
-            Whether users with this role are required to use two-factor authentication.
+            Defines whether having been granted this role will force a user to use two-factor authentication.
 
         :return: The two_factor_required of this Role.
         :rtype: bool
         """
         return self._two_factor_required
 
     @two_factor_required.setter
     def two_factor_required(self, two_factor_required):
         """Sets the two_factor_required of this Role.
 
-            Whether users with this role are required to use two-factor authentication.
+            Defines whether having been granted this role will force a user to use two-factor authentication.
 
         :param two_factor_required: The two_factor_required of this Role.
         :type: bool
         """
 
         self._two_factor_required = two_factor_required
     
     @property
     def version(self):
         """Gets the version of this Role.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this Role.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this Role.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this Role.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/sales_channel.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/sales_channel.py`

 * *Files 19% similar despite different names*

```diff
@@ -41,26 +41,26 @@
         
 
     
     @property
     def description(self):
         """Gets the description of this SalesChannel.
 
-            The localized description of the object.
+            
 
         :return: The description of this SalesChannel.
         :rtype: dict(str, str)
         """
         return self._description
 
     @description.setter
     def description(self, description):
         """Sets the description of this SalesChannel.
 
-            The localized description of the object.
+            
 
         :param description: The description of this SalesChannel.
         :type: dict(str, str)
         """
 
         self._description = description
     
@@ -87,49 +87,49 @@
 
         self._icon = icon
     
     @property
     def id(self):
         """Gets the id of this SalesChannel.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this SalesChannel.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this SalesChannel.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this SalesChannel.
         :type: int
         """
 
         self._id = id
     
     @property
     def name(self):
         """Gets the name of this SalesChannel.
 
-            The localized name of the object.
+            
 
         :return: The name of this SalesChannel.
         :rtype: dict(str, str)
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this SalesChannel.
 
-            The localized name of the object.
+            
 
         :param name: The name of this SalesChannel.
         :type: dict(str, str)
         """
 
         self._name = name
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/scope.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/space_address.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,349 +1,383 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
 
 
 
-class Scope:
+class SpaceAddress:
 
     swagger_types = {
     
-        'domain_name': 'str',
-        'features': 'list[Feature]',
-        'id': 'int',
-        'machine_name': 'str',
-        'name': 'str',
-        'planned_purge_date': 'datetime',
-        'port': 'int',
-        'ssl_active': 'bool',
-        'state': 'CreationEntityState',
-        'themes': 'list[str]',
-        'url': 'str',
-        'version': 'int',
+        'city': 'str',
+        'country': 'str',
+        'dependent_locality': 'str',
+        'email_address': 'str',
+        'family_name': 'str',
+        'given_name': 'str',
+        'organization_name': 'str',
+        'postal_state': 'str',
+        'postcode': 'str',
+        'sales_tax_number': 'str',
+        'salutation': 'str',
+        'sorting_code': 'str',
+        'street': 'str',
     }
 
     attribute_map = {
-        'domain_name': 'domainName','features': 'features','id': 'id','machine_name': 'machineName','name': 'name','planned_purge_date': 'plannedPurgeDate','port': 'port','ssl_active': 'sslActive','state': 'state','themes': 'themes','url': 'url','version': 'version',
+        'city': 'city','country': 'country','dependent_locality': 'dependentLocality','email_address': 'emailAddress','family_name': 'familyName','given_name': 'givenName','organization_name': 'organizationName','postal_state': 'postalState','postcode': 'postcode','sales_tax_number': 'salesTaxNumber','salutation': 'salutation','sorting_code': 'sortingCode','street': 'street',
     }
 
     
-    _domain_name = None
-    _features = None
-    _id = None
-    _machine_name = None
-    _name = None
-    _planned_purge_date = None
-    _port = None
-    _ssl_active = None
-    _state = None
-    _themes = None
-    _url = None
-    _version = None
+    _city = None
+    _country = None
+    _dependent_locality = None
+    _email_address = None
+    _family_name = None
+    _given_name = None
+    _organization_name = None
+    _postal_state = None
+    _postcode = None
+    _sales_tax_number = None
+    _salutation = None
+    _sorting_code = None
+    _street = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
-        self.domain_name = kwargs.get('domain_name', None)
-        self.features = kwargs.get('features', None)
-        self.id = kwargs.get('id', None)
-        self.machine_name = kwargs.get('machine_name', None)
-        self.name = kwargs.get('name', None)
-        self.planned_purge_date = kwargs.get('planned_purge_date', None)
-        self.port = kwargs.get('port', None)
-        self.ssl_active = kwargs.get('ssl_active', None)
-        self.state = kwargs.get('state', None)
-        self.themes = kwargs.get('themes', None)
-        self.url = kwargs.get('url', None)
-        self.version = kwargs.get('version', None)
+        self.city = kwargs.get('city', None)
+        self.country = kwargs.get('country', None)
+        self.dependent_locality = kwargs.get('dependent_locality', None)
+        self.email_address = kwargs.get('email_address', None)
+        self.family_name = kwargs.get('family_name', None)
+        self.given_name = kwargs.get('given_name', None)
+        self.organization_name = kwargs.get('organization_name', None)
+        self.postal_state = kwargs.get('postal_state', None)
+        self.postcode = kwargs.get('postcode', None)
+        self.sales_tax_number = kwargs.get('sales_tax_number', None)
+        self.salutation = kwargs.get('salutation', None)
+        self.sorting_code = kwargs.get('sorting_code', None)
+        self.street = kwargs.get('street', None)
         
 
     
     @property
-    def domain_name(self):
-        """Gets the domain_name of this Scope.
+    def city(self):
+        """Gets the city of this SpaceAddress.
 
-            The domain name that belongs to the scope.
+            
 
-        :return: The domain_name of this Scope.
+        :return: The city of this SpaceAddress.
         :rtype: str
         """
-        return self._domain_name
+        return self._city
 
-    @domain_name.setter
-    def domain_name(self, domain_name):
-        """Sets the domain_name of this Scope.
+    @city.setter
+    def city(self, city):
+        """Sets the city of this SpaceAddress.
 
-            The domain name that belongs to the scope.
+            
 
-        :param domain_name: The domain_name of this Scope.
+        :param city: The city of this SpaceAddress.
         :type: str
         """
-        if domain_name is not None and len(domain_name) > 40:
-            raise ValueError("Invalid value for `domain_name`, length must be less than or equal to `40`")
 
-        self._domain_name = domain_name
+        self._city = city
     
     @property
-    def features(self):
-        """Gets the features of this Scope.
+    def country(self):
+        """Gets the country of this SpaceAddress.
 
-            The list of features that are active in the scope.
+            
 
-        :return: The features of this Scope.
-        :rtype: list[Feature]
+        :return: The country of this SpaceAddress.
+        :rtype: str
+        """
+        return self._country
+
+    @country.setter
+    def country(self, country):
+        """Sets the country of this SpaceAddress.
+
+            
+
+        :param country: The country of this SpaceAddress.
+        :type: str
+        """
+
+        self._country = country
+    
+    @property
+    def dependent_locality(self):
+        """Gets the dependent_locality of this SpaceAddress.
+
+            
+
+        :return: The dependent_locality of this SpaceAddress.
+        :rtype: str
         """
-        return self._features
+        return self._dependent_locality
 
-    @features.setter
-    def features(self, features):
-        """Sets the features of this Scope.
+    @dependent_locality.setter
+    def dependent_locality(self, dependent_locality):
+        """Sets the dependent_locality of this SpaceAddress.
 
-            The list of features that are active in the scope.
+            
 
-        :param features: The features of this Scope.
-        :type: list[Feature]
+        :param dependent_locality: The dependent_locality of this SpaceAddress.
+        :type: str
         """
+        if dependent_locality is not None and len(dependent_locality) > 100:
+            raise ValueError("Invalid value for `dependent_locality`, length must be less than or equal to `100`")
 
-        self._features = features
+        self._dependent_locality = dependent_locality
     
     @property
-    def id(self):
-        """Gets the id of this Scope.
+    def email_address(self):
+        """Gets the email_address of this SpaceAddress.
 
-            A unique identifier for the object.
+            The email address is used within emails and as reply to address.
 
-        :return: The id of this Scope.
-        :rtype: int
+        :return: The email_address of this SpaceAddress.
+        :rtype: str
         """
-        return self._id
+        return self._email_address
 
-    @id.setter
-    def id(self, id):
-        """Sets the id of this Scope.
+    @email_address.setter
+    def email_address(self, email_address):
+        """Sets the email_address of this SpaceAddress.
 
-            A unique identifier for the object.
+            The email address is used within emails and as reply to address.
 
-        :param id: The id of this Scope.
-        :type: int
+        :param email_address: The email_address of this SpaceAddress.
+        :type: str
         """
 
-        self._id = id
+        self._email_address = email_address
     
     @property
-    def machine_name(self):
-        """Gets the machine_name of this Scope.
+    def family_name(self):
+        """Gets the family_name of this SpaceAddress.
 
-            The name identifying the scope in e.g. URLs.
+            
 
-        :return: The machine_name of this Scope.
+        :return: The family_name of this SpaceAddress.
         :rtype: str
         """
-        return self._machine_name
+        return self._family_name
 
-    @machine_name.setter
-    def machine_name(self, machine_name):
-        """Sets the machine_name of this Scope.
+    @family_name.setter
+    def family_name(self, family_name):
+        """Sets the family_name of this SpaceAddress.
 
-            The name identifying the scope in e.g. URLs.
+            
 
-        :param machine_name: The machine_name of this Scope.
+        :param family_name: The family_name of this SpaceAddress.
         :type: str
         """
-        if machine_name is not None and len(machine_name) > 50:
-            raise ValueError("Invalid value for `machine_name`, length must be less than or equal to `50`")
+        if family_name is not None and len(family_name) > 100:
+            raise ValueError("Invalid value for `family_name`, length must be less than or equal to `100`")
 
-        self._machine_name = machine_name
+        self._family_name = family_name
     
     @property
-    def name(self):
-        """Gets the name of this Scope.
+    def given_name(self):
+        """Gets the given_name of this SpaceAddress.
 
-            The name used to identify the scope.
+            
 
-        :return: The name of this Scope.
+        :return: The given_name of this SpaceAddress.
         :rtype: str
         """
-        return self._name
+        return self._given_name
 
-    @name.setter
-    def name(self, name):
-        """Sets the name of this Scope.
+    @given_name.setter
+    def given_name(self, given_name):
+        """Sets the given_name of this SpaceAddress.
 
-            The name used to identify the scope.
+            
 
-        :param name: The name of this Scope.
+        :param given_name: The given_name of this SpaceAddress.
         :type: str
         """
-        if name is not None and len(name) > 50:
-            raise ValueError("Invalid value for `name`, length must be less than or equal to `50`")
+        if given_name is not None and len(given_name) > 100:
+            raise ValueError("Invalid value for `given_name`, length must be less than or equal to `100`")
 
-        self._name = name
+        self._given_name = given_name
     
     @property
-    def planned_purge_date(self):
-        """Gets the planned_purge_date of this Scope.
+    def organization_name(self):
+        """Gets the organization_name of this SpaceAddress.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            
 
-        :return: The planned_purge_date of this Scope.
-        :rtype: datetime
+        :return: The organization_name of this SpaceAddress.
+        :rtype: str
         """
-        return self._planned_purge_date
+        return self._organization_name
 
-    @planned_purge_date.setter
-    def planned_purge_date(self, planned_purge_date):
-        """Sets the planned_purge_date of this Scope.
+    @organization_name.setter
+    def organization_name(self, organization_name):
+        """Sets the organization_name of this SpaceAddress.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            
 
-        :param planned_purge_date: The planned_purge_date of this Scope.
-        :type: datetime
+        :param organization_name: The organization_name of this SpaceAddress.
+        :type: str
         """
+        if organization_name is not None and len(organization_name) > 100:
+            raise ValueError("Invalid value for `organization_name`, length must be less than or equal to `100`")
 
-        self._planned_purge_date = planned_purge_date
+        self._organization_name = organization_name
     
     @property
-    def port(self):
-        """Gets the port of this Scope.
+    def postal_state(self):
+        """Gets the postal_state of this SpaceAddress.
 
-            The port where the scope can be accessed.
+            
 
-        :return: The port of this Scope.
-        :rtype: int
+        :return: The postal_state of this SpaceAddress.
+        :rtype: str
         """
-        return self._port
+        return self._postal_state
 
-    @port.setter
-    def port(self, port):
-        """Sets the port of this Scope.
+    @postal_state.setter
+    def postal_state(self, postal_state):
+        """Sets the postal_state of this SpaceAddress.
 
-            The port where the scope can be accessed.
+            
 
-        :param port: The port of this Scope.
-        :type: int
+        :param postal_state: The postal_state of this SpaceAddress.
+        :type: str
         """
 
-        self._port = port
+        self._postal_state = postal_state
     
     @property
-    def ssl_active(self):
-        """Gets the ssl_active of this Scope.
+    def postcode(self):
+        """Gets the postcode of this SpaceAddress.
 
-            Whether the scope supports SSL.
+            
 
-        :return: The ssl_active of this Scope.
-        :rtype: bool
+        :return: The postcode of this SpaceAddress.
+        :rtype: str
         """
-        return self._ssl_active
+        return self._postcode
 
-    @ssl_active.setter
-    def ssl_active(self, ssl_active):
-        """Sets the ssl_active of this Scope.
+    @postcode.setter
+    def postcode(self, postcode):
+        """Sets the postcode of this SpaceAddress.
 
-            Whether the scope supports SSL.
+            
 
-        :param ssl_active: The ssl_active of this Scope.
-        :type: bool
+        :param postcode: The postcode of this SpaceAddress.
+        :type: str
         """
 
-        self._ssl_active = ssl_active
+        self._postcode = postcode
     
     @property
-    def state(self):
-        """Gets the state of this Scope.
+    def sales_tax_number(self):
+        """Gets the sales_tax_number of this SpaceAddress.
 
-            The object's current state.
+            
 
-        :return: The state of this Scope.
-        :rtype: CreationEntityState
+        :return: The sales_tax_number of this SpaceAddress.
+        :rtype: str
         """
-        return self._state
+        return self._sales_tax_number
 
-    @state.setter
-    def state(self, state):
-        """Sets the state of this Scope.
+    @sales_tax_number.setter
+    def sales_tax_number(self, sales_tax_number):
+        """Sets the sales_tax_number of this SpaceAddress.
 
-            The object's current state.
+            
 
-        :param state: The state of this Scope.
-        :type: CreationEntityState
+        :param sales_tax_number: The sales_tax_number of this SpaceAddress.
+        :type: str
         """
+        if sales_tax_number is not None and len(sales_tax_number) > 100:
+            raise ValueError("Invalid value for `sales_tax_number`, length must be less than or equal to `100`")
 
-        self._state = state
+        self._sales_tax_number = sales_tax_number
     
     @property
-    def themes(self):
-        """Gets the themes of this Scope.
+    def salutation(self):
+        """Gets the salutation of this SpaceAddress.
 
-            The themes that determine the look and feel of the scope's user interface. A fall-through strategy is applied when building the actual theme.
+            
 
-        :return: The themes of this Scope.
-        :rtype: list[str]
+        :return: The salutation of this SpaceAddress.
+        :rtype: str
         """
-        return self._themes
+        return self._salutation
 
-    @themes.setter
-    def themes(self, themes):
-        """Sets the themes of this Scope.
+    @salutation.setter
+    def salutation(self, salutation):
+        """Sets the salutation of this SpaceAddress.
 
-            The themes that determine the look and feel of the scope's user interface. A fall-through strategy is applied when building the actual theme.
+            
 
-        :param themes: The themes of this Scope.
-        :type: list[str]
+        :param salutation: The salutation of this SpaceAddress.
+        :type: str
         """
+        if salutation is not None and len(salutation) > 20:
+            raise ValueError("Invalid value for `salutation`, length must be less than or equal to `20`")
 
-        self._themes = themes
+        self._salutation = salutation
     
     @property
-    def url(self):
-        """Gets the url of this Scope.
+    def sorting_code(self):
+        """Gets the sorting_code of this SpaceAddress.
 
-            The URL where the scope can be accessed.
+            The sorting code identifies the post office at which the post box is located in.
 
-        :return: The url of this Scope.
+        :return: The sorting_code of this SpaceAddress.
         :rtype: str
         """
-        return self._url
+        return self._sorting_code
 
-    @url.setter
-    def url(self, url):
-        """Sets the url of this Scope.
+    @sorting_code.setter
+    def sorting_code(self, sorting_code):
+        """Sets the sorting_code of this SpaceAddress.
 
-            The URL where the scope can be accessed.
+            The sorting code identifies the post office at which the post box is located in.
 
-        :param url: The url of this Scope.
+        :param sorting_code: The sorting_code of this SpaceAddress.
         :type: str
         """
+        if sorting_code is not None and len(sorting_code) > 100:
+            raise ValueError("Invalid value for `sorting_code`, length must be less than or equal to `100`")
 
-        self._url = url
+        self._sorting_code = sorting_code
     
     @property
-    def version(self):
-        """Gets the version of this Scope.
+    def street(self):
+        """Gets the street of this SpaceAddress.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            
 
-        :return: The version of this Scope.
-        :rtype: int
+        :return: The street of this SpaceAddress.
+        :rtype: str
         """
-        return self._version
+        return self._street
 
-    @version.setter
-    def version(self, version):
-        """Sets the version of this Scope.
+    @street.setter
+    def street(self, street):
+        """Sets the street of this SpaceAddress.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            
 
-        :param version: The version of this Scope.
-        :type: int
+        :param street: The street of this SpaceAddress.
+        :type: str
         """
 
-        self._version = version
+        self._street = street
     
 
     def to_dict(self):
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
@@ -360,27 +394,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(Scope, dict):
+        if issubclass(SpaceAddress, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, Scope):
+        if not isinstance(other, SpaceAddress):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/server_error.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/server_error.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_integration.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_integration.py`

 * *Files 2% similar despite different names*

```diff
@@ -187,26 +187,26 @@
 
         self._currency = currency
     
     @property
     def id(self):
         """Gets the id of this ShopifyIntegration.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this ShopifyIntegration.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this ShopifyIntegration.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this ShopifyIntegration.
         :type: int
         """
 
         self._id = id
     
@@ -375,26 +375,26 @@
 
         self._payment_proxy_path = payment_proxy_path
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this ShopifyIntegration.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this ShopifyIntegration.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this ShopifyIntegration.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this ShopifyIntegration.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -538,26 +538,26 @@
 
         self._space_view_id = space_view_id
     
     @property
     def state(self):
         """Gets the state of this ShopifyIntegration.
 
-            The object's current state.
+            
 
         :return: The state of this ShopifyIntegration.
         :rtype: CreationEntityState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this ShopifyIntegration.
 
-            The object's current state.
+            
 
         :param state: The state of this ShopifyIntegration.
         :type: CreationEntityState
         """
 
         self._state = state
     
@@ -630,26 +630,26 @@
 
         self._subscription_proxy_path = subscription_proxy_path
     
     @property
     def version(self):
         """Gets the version of this ShopifyIntegration.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this ShopifyIntegration.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this ShopifyIntegration.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this ShopifyIntegration.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_recurring_order.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_recurring_order.py`

 * *Files 2% similar despite different names*

```diff
@@ -228,26 +228,26 @@
 
         self._planned_execution_date = planned_execution_date
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this ShopifyRecurringOrder.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this ShopifyRecurringOrder.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this ShopifyRecurringOrder.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this ShopifyRecurringOrder.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -320,26 +320,26 @@
 
         self._started_processing_on = started_processing_on
     
     @property
     def state(self):
         """Gets the state of this ShopifyRecurringOrder.
 
-            The object's current state.
+            
 
         :return: The state of this ShopifyRecurringOrder.
         :rtype: ShopifyRecurringOrderState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this ShopifyRecurringOrder.
 
-            The object's current state.
+            
 
         :param state: The state of this ShopifyRecurringOrder.
         :type: ShopifyRecurringOrderState
         """
 
         self._state = state
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_recurring_order_update_request.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_recurring_order_update_request.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscriber.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscriber.py`

 * *Files 17% similar despite different names*

```diff
@@ -124,49 +124,49 @@
 
         self._external_id = external_id
     
     @property
     def id(self):
         """Gets the id of this ShopifySubscriber.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this ShopifySubscriber.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this ShopifySubscriber.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this ShopifySubscriber.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this ShopifySubscriber.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this ShopifySubscriber.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this ShopifySubscriber.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this ShopifySubscriber.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -195,26 +195,26 @@
 
         self._phone_number = phone_number
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this ShopifySubscriber.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this ShopifySubscriber.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this ShopifySubscriber.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this ShopifySubscriber.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -241,49 +241,49 @@
 
         self._shop = shop
     
     @property
     def state(self):
         """Gets the state of this ShopifySubscriber.
 
-            The object's current state.
+            
 
         :return: The state of this ShopifySubscriber.
         :rtype: ShopifySubscriberState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this ShopifySubscriber.
 
-            The object's current state.
+            
 
         :param state: The state of this ShopifySubscriber.
         :type: ShopifySubscriberState
         """
 
         self._state = state
     
     @property
     def version(self):
         """Gets the version of this ShopifySubscriber.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this ShopifySubscriber.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this ShopifySubscriber.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this ShopifySubscriber.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscriber_active.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscriber_active.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscriber_creation.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscriber_creation.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription.py`

 * *Files 5% similar despite different names*

```diff
@@ -147,26 +147,26 @@
 
         self._external_id = external_id
     
     @property
     def id(self):
         """Gets the id of this ShopifySubscription.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this ShopifySubscription.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this ShopifySubscription.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this ShopifySubscription.
         :type: int
         """
 
         self._id = id
     
@@ -239,49 +239,49 @@
 
         self._initial_shopify_transaction = initial_shopify_transaction
     
     @property
     def language(self):
         """Gets the language of this ShopifySubscription.
 
-            The language that is linked to the object.
+            
 
         :return: The language of this ShopifySubscription.
         :rtype: str
         """
         return self._language
 
     @language.setter
     def language(self, language):
         """Sets the language of this ShopifySubscription.
 
-            The language that is linked to the object.
+            
 
         :param language: The language of this ShopifySubscription.
         :type: str
         """
 
         self._language = language
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this ShopifySubscription.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this ShopifySubscription.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this ShopifySubscription.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this ShopifySubscription.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -331,26 +331,26 @@
 
         self._shop = shop
     
     @property
     def state(self):
         """Gets the state of this ShopifySubscription.
 
-            The object's current state.
+            
 
         :return: The state of this ShopifySubscription.
         :rtype: ShopifySubscriptionState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this ShopifySubscription.
 
-            The object's current state.
+            
 
         :param state: The state of this ShopifySubscription.
         :type: ShopifySubscriptionState
         """
 
         self._state = state
     
@@ -446,26 +446,26 @@
 
         self._termination_request_date = termination_request_date
     
     @property
     def version(self):
         """Gets the version of this ShopifySubscription.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this ShopifySubscription.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this ShopifySubscription.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this ShopifySubscription.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription_address.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription_address.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription_address_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription_address_create.py`

 * *Files 3% similar despite different names*

```diff
@@ -83,485 +83,485 @@
         
 
     
     @property
     def city(self):
         """Gets the city of this ShopifySubscriptionAddressCreate.
 
-            The city, town or village.
+            
 
         :return: The city of this ShopifySubscriptionAddressCreate.
         :rtype: str
         """
         return self._city
 
     @city.setter
     def city(self, city):
         """Sets the city of this ShopifySubscriptionAddressCreate.
 
-            The city, town or village.
+            
 
         :param city: The city of this ShopifySubscriptionAddressCreate.
         :type: str
         """
 
         self._city = city
     
     @property
     def commercial_register_number(self):
         """Gets the commercial_register_number of this ShopifySubscriptionAddressCreate.
 
-            The commercial registration number of the organization.
+            
 
         :return: The commercial_register_number of this ShopifySubscriptionAddressCreate.
         :rtype: str
         """
         return self._commercial_register_number
 
     @commercial_register_number.setter
     def commercial_register_number(self, commercial_register_number):
         """Sets the commercial_register_number of this ShopifySubscriptionAddressCreate.
 
-            The commercial registration number of the organization.
+            
 
         :param commercial_register_number: The commercial_register_number of this ShopifySubscriptionAddressCreate.
         :type: str
         """
         if commercial_register_number is not None and len(commercial_register_number) > 100:
             raise ValueError("Invalid value for `commercial_register_number`, length must be less than or equal to `100`")
 
         self._commercial_register_number = commercial_register_number
     
     @property
     def country(self):
         """Gets the country of this ShopifySubscriptionAddressCreate.
 
-            The two-letter country code (ISO 3166 format).
+            
 
         :return: The country of this ShopifySubscriptionAddressCreate.
         :rtype: str
         """
         return self._country
 
     @country.setter
     def country(self, country):
         """Sets the country of this ShopifySubscriptionAddressCreate.
 
-            The two-letter country code (ISO 3166 format).
+            
 
         :param country: The country of this ShopifySubscriptionAddressCreate.
         :type: str
         """
 
         self._country = country
     
     @property
     def date_of_birth(self):
         """Gets the date_of_birth of this ShopifySubscriptionAddressCreate.
 
-            The date of birth.
+            
 
         :return: The date_of_birth of this ShopifySubscriptionAddressCreate.
         :rtype: date
         """
         return self._date_of_birth
 
     @date_of_birth.setter
     def date_of_birth(self, date_of_birth):
         """Sets the date_of_birth of this ShopifySubscriptionAddressCreate.
 
-            The date of birth.
+            
 
         :param date_of_birth: The date_of_birth of this ShopifySubscriptionAddressCreate.
         :type: date
         """
 
         self._date_of_birth = date_of_birth
     
     @property
     def dependent_locality(self):
         """Gets the dependent_locality of this ShopifySubscriptionAddressCreate.
 
-            The dependent locality which is a sub-division of the state.
+            
 
         :return: The dependent_locality of this ShopifySubscriptionAddressCreate.
         :rtype: str
         """
         return self._dependent_locality
 
     @dependent_locality.setter
     def dependent_locality(self, dependent_locality):
         """Sets the dependent_locality of this ShopifySubscriptionAddressCreate.
 
-            The dependent locality which is a sub-division of the state.
+            
 
         :param dependent_locality: The dependent_locality of this ShopifySubscriptionAddressCreate.
         :type: str
         """
         if dependent_locality is not None and len(dependent_locality) > 100:
             raise ValueError("Invalid value for `dependent_locality`, length must be less than or equal to `100`")
 
         self._dependent_locality = dependent_locality
     
     @property
     def email_address(self):
         """Gets the email_address of this ShopifySubscriptionAddressCreate.
 
-            The email address.
+            
 
         :return: The email_address of this ShopifySubscriptionAddressCreate.
         :rtype: str
         """
         return self._email_address
 
     @email_address.setter
     def email_address(self, email_address):
         """Sets the email_address of this ShopifySubscriptionAddressCreate.
 
-            The email address.
+            
 
         :param email_address: The email_address of this ShopifySubscriptionAddressCreate.
         :type: str
         """
         if email_address is not None and len(email_address) > 254:
             raise ValueError("Invalid value for `email_address`, length must be less than or equal to `254`")
 
         self._email_address = email_address
     
     @property
     def family_name(self):
         """Gets the family_name of this ShopifySubscriptionAddressCreate.
 
-            The family or last name.
+            
 
         :return: The family_name of this ShopifySubscriptionAddressCreate.
         :rtype: str
         """
         return self._family_name
 
     @family_name.setter
     def family_name(self, family_name):
         """Sets the family_name of this ShopifySubscriptionAddressCreate.
 
-            The family or last name.
+            
 
         :param family_name: The family_name of this ShopifySubscriptionAddressCreate.
         :type: str
         """
 
         self._family_name = family_name
     
     @property
     def gender(self):
         """Gets the gender of this ShopifySubscriptionAddressCreate.
 
-            The gender.
+            
 
         :return: The gender of this ShopifySubscriptionAddressCreate.
         :rtype: Gender
         """
         return self._gender
 
     @gender.setter
     def gender(self, gender):
         """Sets the gender of this ShopifySubscriptionAddressCreate.
 
-            The gender.
+            
 
         :param gender: The gender of this ShopifySubscriptionAddressCreate.
         :type: Gender
         """
 
         self._gender = gender
     
     @property
     def given_name(self):
         """Gets the given_name of this ShopifySubscriptionAddressCreate.
 
-            The given or first name.
+            
 
         :return: The given_name of this ShopifySubscriptionAddressCreate.
         :rtype: str
         """
         return self._given_name
 
     @given_name.setter
     def given_name(self, given_name):
         """Sets the given_name of this ShopifySubscriptionAddressCreate.
 
-            The given or first name.
+            
 
         :param given_name: The given_name of this ShopifySubscriptionAddressCreate.
         :type: str
         """
         if given_name is not None and len(given_name) > 100:
             raise ValueError("Invalid value for `given_name`, length must be less than or equal to `100`")
 
         self._given_name = given_name
     
     @property
     def legal_organization_form(self):
         """Gets the legal_organization_form of this ShopifySubscriptionAddressCreate.
 
-            The legal form of the organization.
+            
 
         :return: The legal_organization_form of this ShopifySubscriptionAddressCreate.
         :rtype: int
         """
         return self._legal_organization_form
 
     @legal_organization_form.setter
     def legal_organization_form(self, legal_organization_form):
         """Sets the legal_organization_form of this ShopifySubscriptionAddressCreate.
 
-            The legal form of the organization.
+            
 
         :param legal_organization_form: The legal_organization_form of this ShopifySubscriptionAddressCreate.
         :type: int
         """
 
         self._legal_organization_form = legal_organization_form
     
     @property
     def mobile_phone_number(self):
         """Gets the mobile_phone_number of this ShopifySubscriptionAddressCreate.
 
-            The phone number of a mobile phone.
+            
 
         :return: The mobile_phone_number of this ShopifySubscriptionAddressCreate.
         :rtype: str
         """
         return self._mobile_phone_number
 
     @mobile_phone_number.setter
     def mobile_phone_number(self, mobile_phone_number):
         """Sets the mobile_phone_number of this ShopifySubscriptionAddressCreate.
 
-            The phone number of a mobile phone.
+            
 
         :param mobile_phone_number: The mobile_phone_number of this ShopifySubscriptionAddressCreate.
         :type: str
         """
         if mobile_phone_number is not None and len(mobile_phone_number) > 100:
             raise ValueError("Invalid value for `mobile_phone_number`, length must be less than or equal to `100`")
 
         self._mobile_phone_number = mobile_phone_number
     
     @property
     def organization_name(self):
         """Gets the organization_name of this ShopifySubscriptionAddressCreate.
 
-            The organization's name.
+            
 
         :return: The organization_name of this ShopifySubscriptionAddressCreate.
         :rtype: str
         """
         return self._organization_name
 
     @organization_name.setter
     def organization_name(self, organization_name):
         """Sets the organization_name of this ShopifySubscriptionAddressCreate.
 
-            The organization's name.
+            
 
         :param organization_name: The organization_name of this ShopifySubscriptionAddressCreate.
         :type: str
         """
         if organization_name is not None and len(organization_name) > 100:
             raise ValueError("Invalid value for `organization_name`, length must be less than or equal to `100`")
 
         self._organization_name = organization_name
     
     @property
     def phone_number(self):
         """Gets the phone_number of this ShopifySubscriptionAddressCreate.
 
-            The phone number.
+            
 
         :return: The phone_number of this ShopifySubscriptionAddressCreate.
         :rtype: str
         """
         return self._phone_number
 
     @phone_number.setter
     def phone_number(self, phone_number):
         """Sets the phone_number of this ShopifySubscriptionAddressCreate.
 
-            The phone number.
+            
 
         :param phone_number: The phone_number of this ShopifySubscriptionAddressCreate.
         :type: str
         """
         if phone_number is not None and len(phone_number) > 100:
             raise ValueError("Invalid value for `phone_number`, length must be less than or equal to `100`")
 
         self._phone_number = phone_number
     
     @property
     def postal_state(self):
         """Gets the postal_state of this ShopifySubscriptionAddressCreate.
 
-            The name of the region, typically a state, county, province or prefecture.
+            
 
         :return: The postal_state of this ShopifySubscriptionAddressCreate.
         :rtype: str
         """
         return self._postal_state
 
     @postal_state.setter
     def postal_state(self, postal_state):
         """Sets the postal_state of this ShopifySubscriptionAddressCreate.
 
-            The name of the region, typically a state, county, province or prefecture.
+            
 
         :param postal_state: The postal_state of this ShopifySubscriptionAddressCreate.
         :type: str
         """
 
         self._postal_state = postal_state
     
     @property
     def postcode(self):
         """Gets the postcode of this ShopifySubscriptionAddressCreate.
 
-            The postal code, also known as ZIP, postcode, etc.
+            
 
         :return: The postcode of this ShopifySubscriptionAddressCreate.
         :rtype: str
         """
         return self._postcode
 
     @postcode.setter
     def postcode(self, postcode):
         """Sets the postcode of this ShopifySubscriptionAddressCreate.
 
-            The postal code, also known as ZIP, postcode, etc.
+            
 
         :param postcode: The postcode of this ShopifySubscriptionAddressCreate.
         :type: str
         """
 
         self._postcode = postcode
     
     @property
     def sales_tax_number(self):
         """Gets the sales_tax_number of this ShopifySubscriptionAddressCreate.
 
-            The sales tax number of the organization.
+            
 
         :return: The sales_tax_number of this ShopifySubscriptionAddressCreate.
         :rtype: str
         """
         return self._sales_tax_number
 
     @sales_tax_number.setter
     def sales_tax_number(self, sales_tax_number):
         """Sets the sales_tax_number of this ShopifySubscriptionAddressCreate.
 
-            The sales tax number of the organization.
+            
 
         :param sales_tax_number: The sales_tax_number of this ShopifySubscriptionAddressCreate.
         :type: str
         """
         if sales_tax_number is not None and len(sales_tax_number) > 100:
             raise ValueError("Invalid value for `sales_tax_number`, length must be less than or equal to `100`")
 
         self._sales_tax_number = sales_tax_number
     
     @property
     def salutation(self):
         """Gets the salutation of this ShopifySubscriptionAddressCreate.
 
-            The salutation e.g. Mrs, Mr, Dr.
+            
 
         :return: The salutation of this ShopifySubscriptionAddressCreate.
         :rtype: str
         """
         return self._salutation
 
     @salutation.setter
     def salutation(self, salutation):
         """Sets the salutation of this ShopifySubscriptionAddressCreate.
 
-            The salutation e.g. Mrs, Mr, Dr.
+            
 
         :param salutation: The salutation of this ShopifySubscriptionAddressCreate.
         :type: str
         """
         if salutation is not None and len(salutation) > 20:
             raise ValueError("Invalid value for `salutation`, length must be less than or equal to `20`")
 
         self._salutation = salutation
     
     @property
     def social_security_number(self):
         """Gets the social_security_number of this ShopifySubscriptionAddressCreate.
 
-            The social security number.
+            
 
         :return: The social_security_number of this ShopifySubscriptionAddressCreate.
         :rtype: str
         """
         return self._social_security_number
 
     @social_security_number.setter
     def social_security_number(self, social_security_number):
         """Sets the social_security_number of this ShopifySubscriptionAddressCreate.
 
-            The social security number.
+            
 
         :param social_security_number: The social_security_number of this ShopifySubscriptionAddressCreate.
         :type: str
         """
         if social_security_number is not None and len(social_security_number) > 100:
             raise ValueError("Invalid value for `social_security_number`, length must be less than or equal to `100`")
 
         self._social_security_number = social_security_number
     
     @property
     def sorting_code(self):
         """Gets the sorting_code of this ShopifySubscriptionAddressCreate.
 
-            The sorting code identifying the post office where the PO Box is located.
+            The sorting code identifies the post office at which the post box is located in.
 
         :return: The sorting_code of this ShopifySubscriptionAddressCreate.
         :rtype: str
         """
         return self._sorting_code
 
     @sorting_code.setter
     def sorting_code(self, sorting_code):
         """Sets the sorting_code of this ShopifySubscriptionAddressCreate.
 
-            The sorting code identifying the post office where the PO Box is located.
+            The sorting code identifies the post office at which the post box is located in.
 
         :param sorting_code: The sorting_code of this ShopifySubscriptionAddressCreate.
         :type: str
         """
         if sorting_code is not None and len(sorting_code) > 100:
             raise ValueError("Invalid value for `sorting_code`, length must be less than or equal to `100`")
 
         self._sorting_code = sorting_code
     
     @property
     def street(self):
         """Gets the street of this ShopifySubscriptionAddressCreate.
 
-            The street or PO Box.
+            
 
         :return: The street of this ShopifySubscriptionAddressCreate.
         :rtype: str
         """
         return self._street
 
     @street.setter
     def street(self, street):
         """Sets the street of this ShopifySubscriptionAddressCreate.
 
-            The street or PO Box.
+            
 
         :param street: The street of this ShopifySubscriptionAddressCreate.
         :type: str
         """
 
         self._street = street
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription_creation_request.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription_creation_request.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription_model_billing_configuration.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription_model_billing_configuration.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription_model_item.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription_model_item.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription_model_tax_line.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription_model_tax_line.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription_product.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription_product.py`

 * *Files 9% similar despite different names*

```diff
@@ -248,49 +248,49 @@
 
         self._fixed_price = fixed_price
     
     @property
     def id(self):
         """Gets the id of this ShopifySubscriptionProduct.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this ShopifySubscriptionProduct.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this ShopifySubscriptionProduct.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this ShopifySubscriptionProduct.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this ShopifySubscriptionProduct.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this ShopifySubscriptionProduct.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this ShopifySubscriptionProduct.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this ShopifySubscriptionProduct.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -363,26 +363,26 @@
 
         self._minimal_billing_cycles = minimal_billing_cycles
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this ShopifySubscriptionProduct.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this ShopifySubscriptionProduct.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this ShopifySubscriptionProduct.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this ShopifySubscriptionProduct.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -616,26 +616,26 @@
 
         self._shop = shop
     
     @property
     def state(self):
         """Gets the state of this ShopifySubscriptionProduct.
 
-            The object's current state.
+            
 
         :return: The state of this ShopifySubscriptionProduct.
         :rtype: ShopifySubscriptionProductState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this ShopifySubscriptionProduct.
 
-            The object's current state.
+            
 
         :param state: The state of this ShopifySubscriptionProduct.
         :type: ShopifySubscriptionProductState
         """
 
         self._state = state
     
@@ -754,26 +754,26 @@
 
         self._updated_at = updated_at
     
     @property
     def version(self):
         """Gets the version of this ShopifySubscriptionProduct.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this ShopifySubscriptionProduct.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this ShopifySubscriptionProduct.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this ShopifySubscriptionProduct.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription_product_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription_product_create.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription_product_update.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription_product_update.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription_suspension.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription_suspension.py`

 * *Files 4% similar despite different names*

```diff
@@ -154,26 +154,26 @@
 
         self._ended_on = ended_on
     
     @property
     def id(self):
         """Gets the id of this ShopifySubscriptionSuspension.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this ShopifySubscriptionSuspension.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this ShopifySubscriptionSuspension.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this ShopifySubscriptionSuspension.
         :type: int
         """
 
         self._id = id
     
@@ -200,26 +200,26 @@
 
         self._initiator = initiator
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this ShopifySubscriptionSuspension.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this ShopifySubscriptionSuspension.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this ShopifySubscriptionSuspension.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this ShopifySubscriptionSuspension.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -269,26 +269,26 @@
 
         self._shop = shop
     
     @property
     def state(self):
         """Gets the state of this ShopifySubscriptionSuspension.
 
-            The object's current state.
+            
 
         :return: The state of this ShopifySubscriptionSuspension.
         :rtype: ShopifySubscriptionSuspensionState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this ShopifySubscriptionSuspension.
 
-            The object's current state.
+            
 
         :param state: The state of this ShopifySubscriptionSuspension.
         :type: ShopifySubscriptionSuspensionState
         """
 
         self._state = state
     
@@ -338,26 +338,26 @@
 
         self._type = type
     
     @property
     def version(self):
         """Gets the version of this ShopifySubscriptionSuspension.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this ShopifySubscriptionSuspension.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this ShopifySubscriptionSuspension.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this ShopifySubscriptionSuspension.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription_suspension_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription_suspension_create.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription_update_addresses_request.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription_update_addresses_request.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription_update_request.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription_update_request.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription_version.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription_version.py`

 * *Files 8% similar despite different names*

```diff
@@ -360,26 +360,26 @@
 
         self._discharged_on = discharged_on
     
     @property
     def id(self):
         """Gets the id of this ShopifySubscriptionVersion.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this ShopifySubscriptionVersion.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this ShopifySubscriptionVersion.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this ShopifySubscriptionVersion.
         :type: int
         """
 
         self._id = id
     
@@ -406,26 +406,26 @@
 
         self._items = items
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this ShopifySubscriptionVersion.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this ShopifySubscriptionVersion.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this ShopifySubscriptionVersion.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this ShopifySubscriptionVersion.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -590,26 +590,26 @@
 
         self._shop = shop
     
     @property
     def state(self):
         """Gets the state of this ShopifySubscriptionVersion.
 
-            The object's current state.
+            
 
         :return: The state of this ShopifySubscriptionVersion.
         :rtype: ShopifySubscriptionVersionState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this ShopifySubscriptionVersion.
 
-            The object's current state.
+            
 
         :param state: The state of this ShopifySubscriptionVersion.
         :type: ShopifySubscriptionVersionState
         """
 
         self._state = state
     
@@ -728,26 +728,26 @@
 
         self._token = token
     
     @property
     def version(self):
         """Gets the version of this ShopifySubscriptionVersion.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this ShopifySubscriptionVersion.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this ShopifySubscriptionVersion.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this ShopifySubscriptionVersion.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_subscription_version_item.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_subscription_version_item.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_tax_line.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_tax_line.py`

 * *Files 7% similar despite different names*

```diff
@@ -61,26 +61,26 @@
 
         self._fraction_rate = fraction_rate
     
     @property
     def id(self):
         """Gets the id of this ShopifyTaxLine.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this ShopifyTaxLine.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this ShopifyTaxLine.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this ShopifyTaxLine.
         :type: int
         """
 
         self._id = id
     
@@ -130,26 +130,26 @@
 
         self._title = title
     
     @property
     def version(self):
         """Gets the version of this ShopifyTaxLine.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this ShopifyTaxLine.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this ShopifyTaxLine.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this ShopifyTaxLine.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/shopify_transaction.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/shopify_transaction.py`

 * *Files 4% similar despite different names*

```diff
@@ -75,26 +75,26 @@
 
         self._checkout_id = checkout_id
     
     @property
     def created_on(self):
         """Gets the created_on of this ShopifyTransaction.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :return: The created_on of this ShopifyTransaction.
         :rtype: datetime
         """
         return self._created_on
 
     @created_on.setter
     def created_on(self, created_on):
         """Sets the created_on of this ShopifyTransaction.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :param created_on: The created_on of this ShopifyTransaction.
         :type: datetime
         """
 
         self._created_on = created_on
     
@@ -167,26 +167,26 @@
 
         self._order_name = order_name
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this ShopifyTransaction.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this ShopifyTransaction.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this ShopifyTransaction.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this ShopifyTransaction.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -236,26 +236,26 @@
 
         self._transaction = transaction
     
     @property
     def version(self):
         """Gets the version of this ShopifyTransaction.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this ShopifyTransaction.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this ShopifyTransaction.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this ShopifyTransaction.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/space.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/space.py`

 * *Files 4% similar despite different names*

```diff
@@ -83,256 +83,256 @@
         
 
     
     @property
     def account(self):
         """Gets the account of this Space.
 
-            The account that the space belongs to.
+            The account to which the space belongs to.
 
         :return: The account of this Space.
         :rtype: Account
         """
         return self._account
 
     @account.setter
     def account(self, account):
         """Sets the account of this Space.
 
-            The account that the space belongs to.
+            The account to which the space belongs to.
 
         :param account: The account of this Space.
         :type: Account
         """
 
         self._account = account
     
     @property
     def active(self):
         """Gets the active of this Space.
 
-            Whether this space and all its parent accounts are active.
+            Active means that this account and all accounts in the hierarchy are active.
 
         :return: The active of this Space.
         :rtype: bool
         """
         return self._active
 
     @active.setter
     def active(self, active):
         """Sets the active of this Space.
 
-            Whether this space and all its parent accounts are active.
+            Active means that this account and all accounts in the hierarchy are active.
 
         :param active: The active of this Space.
         :type: bool
         """
 
         self._active = active
     
     @property
     def active_or_restricted_active(self):
         """Gets the active_or_restricted_active of this Space.
 
-            Whether this space and all its parent accounts are active or restricted active.
+            This property is true when all accounts in the hierarchy are active or restricted active.
 
         :return: The active_or_restricted_active of this Space.
         :rtype: bool
         """
         return self._active_or_restricted_active
 
     @active_or_restricted_active.setter
     def active_or_restricted_active(self, active_or_restricted_active):
         """Sets the active_or_restricted_active of this Space.
 
-            Whether this space and all its parent accounts are active or restricted active.
+            This property is true when all accounts in the hierarchy are active or restricted active.
 
         :param active_or_restricted_active: The active_or_restricted_active of this Space.
         :type: bool
         """
 
         self._active_or_restricted_active = active_or_restricted_active
     
     @property
     def created_by(self):
         """Gets the created_by of this Space.
 
-            The ID of the user the space was created by.
+            The ID of the user who created this entity.
 
         :return: The created_by of this Space.
         :rtype: int
         """
         return self._created_by
 
     @created_by.setter
     def created_by(self, created_by):
         """Sets the created_by of this Space.
 
-            The ID of the user the space was created by.
+            The ID of the user who created this entity.
 
         :param created_by: The created_by of this Space.
         :type: int
         """
 
         self._created_by = created_by
     
     @property
     def created_on(self):
         """Gets the created_on of this Space.
 
-            The date and time when the space was created.
+            The date and time when this entity was created.
 
         :return: The created_on of this Space.
         :rtype: datetime
         """
         return self._created_on
 
     @created_on.setter
     def created_on(self, created_on):
         """Sets the created_on of this Space.
 
-            The date and time when the space was created.
+            The date and time when this entity was created.
 
         :param created_on: The created_on of this Space.
         :type: datetime
         """
 
         self._created_on = created_on
     
     @property
     def database(self):
         """Gets the database of this Space.
 
-            The database the space is connected to and that holds the space's data.
+            The database in which the space's data are stored in.
 
         :return: The database of this Space.
         :rtype: TenantDatabase
         """
         return self._database
 
     @database.setter
     def database(self, database):
         """Sets the database of this Space.
 
-            The database the space is connected to and that holds the space's data.
+            The database in which the space's data are stored in.
 
         :param database: The database of this Space.
         :type: TenantDatabase
         """
 
         self._database = database
     
     @property
     def deleted_by(self):
         """Gets the deleted_by of this Space.
 
-            The ID of the user the space was deleted by.
+            The ID of a user that deleted this entity.
 
         :return: The deleted_by of this Space.
         :rtype: int
         """
         return self._deleted_by
 
     @deleted_by.setter
     def deleted_by(self, deleted_by):
         """Sets the deleted_by of this Space.
 
-            The ID of the user the space was deleted by.
+            The ID of a user that deleted this entity.
 
         :param deleted_by: The deleted_by of this Space.
         :type: int
         """
 
         self._deleted_by = deleted_by
     
     @property
     def deleted_on(self):
         """Gets the deleted_on of this Space.
 
-            The date and time when the space was deleted.
+            The date and time when this entity was deleted.
 
         :return: The deleted_on of this Space.
         :rtype: datetime
         """
         return self._deleted_on
 
     @deleted_on.setter
     def deleted_on(self, deleted_on):
         """Sets the deleted_on of this Space.
 
-            The date and time when the space was deleted.
+            The date and time when this entity was deleted.
 
         :param deleted_on: The deleted_on of this Space.
         :type: datetime
         """
 
         self._deleted_on = deleted_on
     
     @property
     def id(self):
         """Gets the id of this Space.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this Space.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this Space.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this Space.
         :type: int
         """
 
         self._id = id
     
     @property
     def last_modified_date(self):
         """Gets the last_modified_date of this Space.
 
-            The date and time when the object was last modified.
+            
 
         :return: The last_modified_date of this Space.
         :rtype: datetime
         """
         return self._last_modified_date
 
     @last_modified_date.setter
     def last_modified_date(self, last_modified_date):
         """Sets the last_modified_date of this Space.
 
-            The date and time when the object was last modified.
+            
 
         :param last_modified_date: The last_modified_date of this Space.
         :type: datetime
         """
 
         self._last_modified_date = last_modified_date
     
     @property
     def name(self):
         """Gets the name of this Space.
 
-            The name used to identify the space.
+            The space name is used internally to identify the space in administrative interfaces. For example it is used within search fields and hence it should be distinct and descriptive.
 
         :return: The name of this Space.
         :rtype: str
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this Space.
 
-            The name used to identify the space.
+            The space name is used internally to identify the space in administrative interfaces. For example it is used within search fields and hence it should be distinct and descriptive.
 
         :param name: The name of this Space.
         :type: str
         """
         if name is not None and len(name) > 200:
             raise ValueError("Invalid value for `name`, length must be less than or equal to `200`")
         if name is not None and len(name) < 3:
@@ -340,210 +340,210 @@
 
         self._name = name
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this Space.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this Space.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this Space.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this Space.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
     @property
     def postal_address(self):
         """Gets the postal_address of this Space.
 
-            The address that is used in communication with clients for example in emails, documents, etc.
+            The address to use in communication with clients for example in email, documents etc.
 
         :return: The postal_address of this Space.
         :rtype: SpaceAddress
         """
         return self._postal_address
 
     @postal_address.setter
     def postal_address(self, postal_address):
         """Sets the postal_address of this Space.
 
-            The address that is used in communication with clients for example in emails, documents, etc.
+            The address to use in communication with clients for example in email, documents etc.
 
         :param postal_address: The postal_address of this Space.
         :type: SpaceAddress
         """
 
         self._postal_address = postal_address
     
     @property
     def primary_currency(self):
         """Gets the primary_currency of this Space.
 
-            The currency that is used to display aggregated amounts in the space.
+            This is the currency that is used to display aggregated amounts in the space.
 
         :return: The primary_currency of this Space.
         :rtype: str
         """
         return self._primary_currency
 
     @primary_currency.setter
     def primary_currency(self, primary_currency):
         """Sets the primary_currency of this Space.
 
-            The currency that is used to display aggregated amounts in the space.
+            This is the currency that is used to display aggregated amounts in the space.
 
         :param primary_currency: The primary_currency of this Space.
         :type: str
         """
 
         self._primary_currency = primary_currency
     
     @property
     def request_limit(self):
         """Gets the request_limit of this Space.
 
-            The maximum number of API requests that are accepted within two minutes. This limit can only be changed with special privileges.
+            The request limit defines the maximum number of API request accepted within 2 minutes for this space. This limit can only be changed with special privileges.
 
         :return: The request_limit of this Space.
         :rtype: int
         """
         return self._request_limit
 
     @request_limit.setter
     def request_limit(self, request_limit):
         """Sets the request_limit of this Space.
 
-            The maximum number of API requests that are accepted within two minutes. This limit can only be changed with special privileges.
+            The request limit defines the maximum number of API request accepted within 2 minutes for this space. This limit can only be changed with special privileges.
 
         :param request_limit: The request_limit of this Space.
         :type: int
         """
 
         self._request_limit = request_limit
     
     @property
     def restricted_active(self):
         """Gets the restricted_active of this Space.
 
-            Whether this space and all its parent accounts are active or restricted active. There is least one parent account that is restricted active.
+            Restricted active means that at least one account in the hierarchy is only restricted active, but all are either restricted active or active.
 
         :return: The restricted_active of this Space.
         :rtype: bool
         """
         return self._restricted_active
 
     @restricted_active.setter
     def restricted_active(self, restricted_active):
         """Sets the restricted_active of this Space.
 
-            Whether this space and all its parent accounts are active or restricted active. There is least one parent account that is restricted active.
+            Restricted active means that at least one account in the hierarchy is only restricted active, but all are either restricted active or active.
 
         :param restricted_active: The restricted_active of this Space.
         :type: bool
         """
 
         self._restricted_active = restricted_active
     
     @property
     def state(self):
         """Gets the state of this Space.
 
-            The object's current state.
+            
 
         :return: The state of this Space.
         :rtype: CreationEntityState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this Space.
 
-            The object's current state.
+            
 
         :param state: The state of this Space.
         :type: CreationEntityState
         """
 
         self._state = state
     
     @property
     def technical_contact_addresses(self):
         """Gets the technical_contact_addresses of this Space.
 
-            The email address that will receive messages about technical issues and errors that occur in the space.
+            The email address provided as contact addresses will be informed about technical issues or errors triggered by the space.
 
         :return: The technical_contact_addresses of this Space.
         :rtype: list[str]
         """
         return self._technical_contact_addresses
 
     @technical_contact_addresses.setter
     def technical_contact_addresses(self, technical_contact_addresses):
         """Sets the technical_contact_addresses of this Space.
 
-            The email address that will receive messages about technical issues and errors that occur in the space.
+            The email address provided as contact addresses will be informed about technical issues or errors triggered by the space.
 
         :param technical_contact_addresses: The technical_contact_addresses of this Space.
         :type: list[str]
         """
 
         self._technical_contact_addresses = technical_contact_addresses
     
     @property
     def time_zone(self):
         """Gets the time_zone of this Space.
 
-            The time zone that is used to schedule and run background processes. This does not affect the formatting of dates in the user interface.
+            The time zone assigned to the space determines the time offset for calculating dates within the space. This is typically used for background processed which needs to be triggered on a specific hour within the day. Changing the space time zone will not change the display of dates.
 
         :return: The time_zone of this Space.
         :rtype: str
         """
         return self._time_zone
 
     @time_zone.setter
     def time_zone(self, time_zone):
         """Sets the time_zone of this Space.
 
-            The time zone that is used to schedule and run background processes. This does not affect the formatting of dates in the user interface.
+            The time zone assigned to the space determines the time offset for calculating dates within the space. This is typically used for background processed which needs to be triggered on a specific hour within the day. Changing the space time zone will not change the display of dates.
 
         :param time_zone: The time_zone of this Space.
         :type: str
         """
 
         self._time_zone = time_zone
     
     @property
     def version(self):
         """Gets the version of this Space.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this Space.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this Space.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this Space.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/space_address_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/space_address_create.py`

 * *Files 22% similar despite different names*

```diff
@@ -11,39 +11,35 @@
     
         'city': 'str',
         'country': 'str',
         'dependent_locality': 'str',
         'email_address': 'str',
         'family_name': 'str',
         'given_name': 'str',
-        'mobile_phone_number': 'str',
         'organization_name': 'str',
-        'phone_number': 'str',
         'postal_state': 'str',
         'postcode': 'str',
         'sales_tax_number': 'str',
         'salutation': 'str',
         'sorting_code': 'str',
         'street': 'str',
     }
 
     attribute_map = {
-        'city': 'city','country': 'country','dependent_locality': 'dependentLocality','email_address': 'emailAddress','family_name': 'familyName','given_name': 'givenName','mobile_phone_number': 'mobilePhoneNumber','organization_name': 'organizationName','phone_number': 'phoneNumber','postal_state': 'postalState','postcode': 'postcode','sales_tax_number': 'salesTaxNumber','salutation': 'salutation','sorting_code': 'sortingCode','street': 'street',
+        'city': 'city','country': 'country','dependent_locality': 'dependentLocality','email_address': 'emailAddress','family_name': 'familyName','given_name': 'givenName','organization_name': 'organizationName','postal_state': 'postalState','postcode': 'postcode','sales_tax_number': 'salesTaxNumber','salutation': 'salutation','sorting_code': 'sortingCode','street': 'street',
     }
 
     
     _city = None
     _country = None
     _dependent_locality = None
     _email_address = None
     _family_name = None
     _given_name = None
-    _mobile_phone_number = None
     _organization_name = None
-    _phone_number = None
     _postal_state = None
     _postcode = None
     _sales_tax_number = None
     _salutation = None
     _sorting_code = None
     _street = None
 
@@ -52,382 +48,330 @@
         
         self.city = kwargs.get('city', None)
         self.country = kwargs.get('country', None)
         self.dependent_locality = kwargs.get('dependent_locality', None)
         self.email_address = kwargs.get('email_address', None)
         self.family_name = kwargs.get('family_name', None)
         self.given_name = kwargs.get('given_name', None)
-        self.mobile_phone_number = kwargs.get('mobile_phone_number', None)
         self.organization_name = kwargs.get('organization_name', None)
-        self.phone_number = kwargs.get('phone_number', None)
         self.postal_state = kwargs.get('postal_state', None)
         self.postcode = kwargs.get('postcode', None)
         self.sales_tax_number = kwargs.get('sales_tax_number', None)
         self.salutation = kwargs.get('salutation', None)
         self.sorting_code = kwargs.get('sorting_code', None)
         self.street = kwargs.get('street', None)
         
 
     
     @property
     def city(self):
         """Gets the city of this SpaceAddressCreate.
 
-            The city, town or village.
+            
 
         :return: The city of this SpaceAddressCreate.
         :rtype: str
         """
         return self._city
 
     @city.setter
     def city(self, city):
         """Sets the city of this SpaceAddressCreate.
 
-            The city, town or village.
+            
 
         :param city: The city of this SpaceAddressCreate.
         :type: str
         """
 
         self._city = city
     
     @property
     def country(self):
         """Gets the country of this SpaceAddressCreate.
 
-            The two-letter country code (ISO 3166 format).
+            
 
         :return: The country of this SpaceAddressCreate.
         :rtype: str
         """
         return self._country
 
     @country.setter
     def country(self, country):
         """Sets the country of this SpaceAddressCreate.
 
-            The two-letter country code (ISO 3166 format).
+            
 
         :param country: The country of this SpaceAddressCreate.
         :type: str
         """
 
         self._country = country
     
     @property
     def dependent_locality(self):
         """Gets the dependent_locality of this SpaceAddressCreate.
 
-            The dependent locality which is a sub-division of the state.
+            
 
         :return: The dependent_locality of this SpaceAddressCreate.
         :rtype: str
         """
         return self._dependent_locality
 
     @dependent_locality.setter
     def dependent_locality(self, dependent_locality):
         """Sets the dependent_locality of this SpaceAddressCreate.
 
-            The dependent locality which is a sub-division of the state.
+            
 
         :param dependent_locality: The dependent_locality of this SpaceAddressCreate.
         :type: str
         """
         if dependent_locality is not None and len(dependent_locality) > 100:
             raise ValueError("Invalid value for `dependent_locality`, length must be less than or equal to `100`")
 
         self._dependent_locality = dependent_locality
     
     @property
     def email_address(self):
         """Gets the email_address of this SpaceAddressCreate.
 
-            The email address used for communication with clients.
+            The email address is used within emails and as reply to address.
 
         :return: The email_address of this SpaceAddressCreate.
         :rtype: str
         """
         return self._email_address
 
     @email_address.setter
     def email_address(self, email_address):
         """Sets the email_address of this SpaceAddressCreate.
 
-            The email address used for communication with clients.
+            The email address is used within emails and as reply to address.
 
         :param email_address: The email_address of this SpaceAddressCreate.
         :type: str
         """
 
         self._email_address = email_address
     
     @property
     def family_name(self):
         """Gets the family_name of this SpaceAddressCreate.
 
-            The family or last name.
+            
 
         :return: The family_name of this SpaceAddressCreate.
         :rtype: str
         """
         return self._family_name
 
     @family_name.setter
     def family_name(self, family_name):
         """Sets the family_name of this SpaceAddressCreate.
 
-            The family or last name.
+            
 
         :param family_name: The family_name of this SpaceAddressCreate.
         :type: str
         """
         if family_name is not None and len(family_name) > 100:
             raise ValueError("Invalid value for `family_name`, length must be less than or equal to `100`")
 
         self._family_name = family_name
     
     @property
     def given_name(self):
         """Gets the given_name of this SpaceAddressCreate.
 
-            The given or first name.
+            
 
         :return: The given_name of this SpaceAddressCreate.
         :rtype: str
         """
         return self._given_name
 
     @given_name.setter
     def given_name(self, given_name):
         """Sets the given_name of this SpaceAddressCreate.
 
-            The given or first name.
+            
 
         :param given_name: The given_name of this SpaceAddressCreate.
         :type: str
         """
         if given_name is not None and len(given_name) > 100:
             raise ValueError("Invalid value for `given_name`, length must be less than or equal to `100`")
 
         self._given_name = given_name
     
     @property
-    def mobile_phone_number(self):
-        """Gets the mobile_phone_number of this SpaceAddressCreate.
-
-            The phone number of a mobile phone.
-
-        :return: The mobile_phone_number of this SpaceAddressCreate.
-        :rtype: str
-        """
-        return self._mobile_phone_number
-
-    @mobile_phone_number.setter
-    def mobile_phone_number(self, mobile_phone_number):
-        """Sets the mobile_phone_number of this SpaceAddressCreate.
-
-            The phone number of a mobile phone.
-
-        :param mobile_phone_number: The mobile_phone_number of this SpaceAddressCreate.
-        :type: str
-        """
-        if mobile_phone_number is not None and len(mobile_phone_number) > 100:
-            raise ValueError("Invalid value for `mobile_phone_number`, length must be less than or equal to `100`")
-
-        self._mobile_phone_number = mobile_phone_number
-    
-    @property
     def organization_name(self):
         """Gets the organization_name of this SpaceAddressCreate.
 
-            The organization's name.
+            
 
         :return: The organization_name of this SpaceAddressCreate.
         :rtype: str
         """
         return self._organization_name
 
     @organization_name.setter
     def organization_name(self, organization_name):
         """Sets the organization_name of this SpaceAddressCreate.
 
-            The organization's name.
+            
 
         :param organization_name: The organization_name of this SpaceAddressCreate.
         :type: str
         """
         if organization_name is not None and len(organization_name) > 100:
             raise ValueError("Invalid value for `organization_name`, length must be less than or equal to `100`")
 
         self._organization_name = organization_name
     
     @property
-    def phone_number(self):
-        """Gets the phone_number of this SpaceAddressCreate.
-
-            The phone number.
-
-        :return: The phone_number of this SpaceAddressCreate.
-        :rtype: str
-        """
-        return self._phone_number
-
-    @phone_number.setter
-    def phone_number(self, phone_number):
-        """Sets the phone_number of this SpaceAddressCreate.
-
-            The phone number.
-
-        :param phone_number: The phone_number of this SpaceAddressCreate.
-        :type: str
-        """
-        if phone_number is not None and len(phone_number) > 100:
-            raise ValueError("Invalid value for `phone_number`, length must be less than or equal to `100`")
-
-        self._phone_number = phone_number
-    
-    @property
     def postal_state(self):
         """Gets the postal_state of this SpaceAddressCreate.
 
-            The name of the region, typically a state, county, province or prefecture.
+            
 
         :return: The postal_state of this SpaceAddressCreate.
         :rtype: str
         """
         return self._postal_state
 
     @postal_state.setter
     def postal_state(self, postal_state):
         """Sets the postal_state of this SpaceAddressCreate.
 
-            The name of the region, typically a state, county, province or prefecture.
+            
 
         :param postal_state: The postal_state of this SpaceAddressCreate.
         :type: str
         """
 
         self._postal_state = postal_state
     
     @property
     def postcode(self):
         """Gets the postcode of this SpaceAddressCreate.
 
-            The postal code, also known as ZIP, postcode, etc.
+            
 
         :return: The postcode of this SpaceAddressCreate.
         :rtype: str
         """
         return self._postcode
 
     @postcode.setter
     def postcode(self, postcode):
         """Sets the postcode of this SpaceAddressCreate.
 
-            The postal code, also known as ZIP, postcode, etc.
+            
 
         :param postcode: The postcode of this SpaceAddressCreate.
         :type: str
         """
 
         self._postcode = postcode
     
     @property
     def sales_tax_number(self):
         """Gets the sales_tax_number of this SpaceAddressCreate.
 
-            The sales tax number of the organization.
+            
 
         :return: The sales_tax_number of this SpaceAddressCreate.
         :rtype: str
         """
         return self._sales_tax_number
 
     @sales_tax_number.setter
     def sales_tax_number(self, sales_tax_number):
         """Sets the sales_tax_number of this SpaceAddressCreate.
 
-            The sales tax number of the organization.
+            
 
         :param sales_tax_number: The sales_tax_number of this SpaceAddressCreate.
         :type: str
         """
         if sales_tax_number is not None and len(sales_tax_number) > 100:
             raise ValueError("Invalid value for `sales_tax_number`, length must be less than or equal to `100`")
 
         self._sales_tax_number = sales_tax_number
     
     @property
     def salutation(self):
         """Gets the salutation of this SpaceAddressCreate.
 
-            The salutation e.g. Mrs, Mr, Dr.
+            
 
         :return: The salutation of this SpaceAddressCreate.
         :rtype: str
         """
         return self._salutation
 
     @salutation.setter
     def salutation(self, salutation):
         """Sets the salutation of this SpaceAddressCreate.
 
-            The salutation e.g. Mrs, Mr, Dr.
+            
 
         :param salutation: The salutation of this SpaceAddressCreate.
         :type: str
         """
         if salutation is not None and len(salutation) > 20:
             raise ValueError("Invalid value for `salutation`, length must be less than or equal to `20`")
 
         self._salutation = salutation
     
     @property
     def sorting_code(self):
         """Gets the sorting_code of this SpaceAddressCreate.
 
-            The sorting code identifying the post office where the PO Box is located.
+            The sorting code identifies the post office at which the post box is located in.
 
         :return: The sorting_code of this SpaceAddressCreate.
         :rtype: str
         """
         return self._sorting_code
 
     @sorting_code.setter
     def sorting_code(self, sorting_code):
         """Sets the sorting_code of this SpaceAddressCreate.
 
-            The sorting code identifying the post office where the PO Box is located.
+            The sorting code identifies the post office at which the post box is located in.
 
         :param sorting_code: The sorting_code of this SpaceAddressCreate.
         :type: str
         """
         if sorting_code is not None and len(sorting_code) > 100:
             raise ValueError("Invalid value for `sorting_code`, length must be less than or equal to `100`")
 
         self._sorting_code = sorting_code
     
     @property
     def street(self):
         """Gets the street of this SpaceAddressCreate.
 
-            The street or PO Box.
+            
 
         :return: The street of this SpaceAddressCreate.
         :rtype: str
         """
         return self._street
 
     @street.setter
     def street(self, street):
         """Sets the street of this SpaceAddressCreate.
 
-            The street or PO Box.
+            
 
         :param street: The street of this SpaceAddressCreate.
         :type: str
         """
 
         self._street = street
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/space_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/space_create.py`

 * *Files 9% similar despite different names*

```diff
@@ -29,26 +29,26 @@
         self.attribute_map.update(super().attribute_map)
 
     
     @property
     def account(self):
         """Gets the account of this SpaceCreate.
 
-            The account that the space belongs to.
+            The account to which the space belongs to.
 
         :return: The account of this SpaceCreate.
         :rtype: int
         """
         return self._account
 
     @account.setter
     def account(self, account):
         """Sets the account of this SpaceCreate.
 
-            The account that the space belongs to.
+            The account to which the space belongs to.
 
         :param account: The account of this SpaceCreate.
         :type: int
         """
         if account is None:
             raise ValueError("Invalid value for `account`, must not be `None`")
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/space_reference.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/space_reference.py`

 * *Files 13% similar despite different names*

```diff
@@ -67,72 +67,72 @@
 
         self._created_on = created_on
     
     @property
     def id(self):
         """Gets the id of this SpaceReference.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this SpaceReference.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this SpaceReference.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this SpaceReference.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this SpaceReference.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this SpaceReference.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this SpaceReference.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this SpaceReference.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this SpaceReference.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this SpaceReference.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this SpaceReference.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this SpaceReference.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -159,49 +159,49 @@
 
         self._space_id = space_id
     
     @property
     def state(self):
         """Gets the state of this SpaceReference.
 
-            The object's current state.
+            
 
         :return: The state of this SpaceReference.
         :rtype: SpaceReferenceState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this SpaceReference.
 
-            The object's current state.
+            
 
         :param state: The state of this SpaceReference.
         :type: SpaceReferenceState
         """
 
         self._state = state
     
     @property
     def version(self):
         """Gets the version of this SpaceReference.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this SpaceReference.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this SpaceReference.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this SpaceReference.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/space_update.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/space_update.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/space_view.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/space_view.py`

 * *Files 7% similar despite different names*

```diff
@@ -44,49 +44,49 @@
         
 
     
     @property
     def id(self):
         """Gets the id of this SpaceView.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this SpaceView.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this SpaceView.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this SpaceView.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this SpaceView.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this SpaceView.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this SpaceView.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this SpaceView.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -117,26 +117,26 @@
 
         self._name = name
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this SpaceView.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this SpaceView.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this SpaceView.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this SpaceView.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -163,49 +163,49 @@
 
         self._space = space
     
     @property
     def state(self):
         """Gets the state of this SpaceView.
 
-            The object's current state.
+            
 
         :return: The state of this SpaceView.
         :rtype: CreationEntityState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this SpaceView.
 
-            The object's current state.
+            
 
         :param state: The state of this SpaceView.
         :type: CreationEntityState
         """
 
         self._state = state
     
     @property
     def version(self):
         """Gets the version of this SpaceView.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this SpaceView.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this SpaceView.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this SpaceView.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/static_value.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/manual_task_type.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
 
 
 
-class StaticValue:
+class ManualTaskType:
 
     swagger_types = {
     
         'description': 'dict(str, str)',
         'features': 'list[int]',
         'id': 'int',
         'name': 'dict(str, str)',
@@ -33,99 +33,99 @@
         self.id = kwargs.get('id', None)
         self.name = kwargs.get('name', None)
         
 
     
     @property
     def description(self):
-        """Gets the description of this StaticValue.
+        """Gets the description of this ManualTaskType.
 
-            The localized description of the object.
+            
 
-        :return: The description of this StaticValue.
+        :return: The description of this ManualTaskType.
         :rtype: dict(str, str)
         """
         return self._description
 
     @description.setter
     def description(self, description):
-        """Sets the description of this StaticValue.
+        """Sets the description of this ManualTaskType.
 
-            The localized description of the object.
+            
 
-        :param description: The description of this StaticValue.
+        :param description: The description of this ManualTaskType.
         :type: dict(str, str)
         """
 
         self._description = description
     
     @property
     def features(self):
-        """Gets the features of this StaticValue.
+        """Gets the features of this ManualTaskType.
 
             
 
-        :return: The features of this StaticValue.
+        :return: The features of this ManualTaskType.
         :rtype: list[int]
         """
         return self._features
 
     @features.setter
     def features(self, features):
-        """Sets the features of this StaticValue.
+        """Sets the features of this ManualTaskType.
 
             
 
-        :param features: The features of this StaticValue.
+        :param features: The features of this ManualTaskType.
         :type: list[int]
         """
 
         self._features = features
     
     @property
     def id(self):
-        """Gets the id of this StaticValue.
+        """Gets the id of this ManualTaskType.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
-        :return: The id of this StaticValue.
+        :return: The id of this ManualTaskType.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
-        """Sets the id of this StaticValue.
+        """Sets the id of this ManualTaskType.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
-        :param id: The id of this StaticValue.
+        :param id: The id of this ManualTaskType.
         :type: int
         """
 
         self._id = id
     
     @property
     def name(self):
-        """Gets the name of this StaticValue.
+        """Gets the name of this ManualTaskType.
 
-            The localized name of the object.
+            
 
-        :return: The name of this StaticValue.
+        :return: The name of this ManualTaskType.
         :rtype: dict(str, str)
         """
         return self._name
 
     @name.setter
     def name(self, name):
-        """Sets the name of this StaticValue.
+        """Sets the name of this ManualTaskType.
 
-            The localized name of the object.
+            
 
-        :param name: The name of this StaticValue.
+        :param name: The name of this ManualTaskType.
         :type: dict(str, str)
         """
 
         self._name = name
     
 
     def to_dict(self):
@@ -146,27 +146,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(StaticValue, dict):
+        if issubclass(ManualTaskType, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, StaticValue):
+        if not isinstance(other, ManualTaskType):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscriber.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscriber.py`

 * *Files 4% similar despite different names*

```diff
@@ -210,26 +210,26 @@
 
         self._external_id = external_id
     
     @property
     def id(self):
         """Gets the id of this Subscriber.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this Subscriber.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this Subscriber.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this Subscriber.
         :type: int
         """
 
         self._id = id
     
@@ -256,72 +256,72 @@
 
         self._language = language
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this Subscriber.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this Subscriber.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this Subscriber.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this Subscriber.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
     @property
     def meta_data(self):
         """Gets the meta_data of this Subscriber.
 
-            Allow to store additional information about the object.
+            Meta data allow to store additional data along the object.
 
         :return: The meta_data of this Subscriber.
         :rtype: dict(str, str)
         """
         return self._meta_data
 
     @meta_data.setter
     def meta_data(self, meta_data):
         """Sets the meta_data of this Subscriber.
 
-            Allow to store additional information about the object.
+            Meta data allow to store additional data along the object.
 
         :param meta_data: The meta_data of this Subscriber.
         :type: dict(str, str)
         """
 
         self._meta_data = meta_data
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this Subscriber.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this Subscriber.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this Subscriber.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this Subscriber.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -373,49 +373,49 @@
 
         self._shipping_address = shipping_address
     
     @property
     def state(self):
         """Gets the state of this Subscriber.
 
-            The object's current state.
+            
 
         :return: The state of this Subscriber.
         :rtype: CreationEntityState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this Subscriber.
 
-            The object's current state.
+            
 
         :param state: The state of this Subscriber.
         :type: CreationEntityState
         """
 
         self._state = state
     
     @property
     def version(self):
         """Gets the version of this Subscriber.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this Subscriber.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this Subscriber.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this Subscriber.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscriber_active.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/webhook_url_create.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,60 +1,34 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
-from . import SubscriberUpdate
+from . import AbstractWebhookUrlUpdate
 
 
-class SubscriberActive(SubscriberUpdate):
+class WebhookUrlCreate(AbstractWebhookUrlUpdate):
 
     swagger_types = {
     
-        'state': 'CreationEntityState',
     }
 
     attribute_map = {
-        'state': 'state',
+        
     }
 
     
-    _state = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
-        self.state = kwargs.get('state', None)
         super().__init__(**kwargs)
         self.swagger_types.update(super().swagger_types)
         self.attribute_map.update(super().attribute_map)
 
     
-    @property
-    def state(self):
-        """Gets the state of this SubscriberActive.
-
-            The object's current state.
-
-        :return: The state of this SubscriberActive.
-        :rtype: CreationEntityState
-        """
-        return self._state
-
-    @state.setter
-    def state(self, state):
-        """Sets the state of this SubscriberActive.
-
-            The object's current state.
-
-        :param state: The state of this SubscriberActive.
-        :type: CreationEntityState
-        """
-
-        self._state = state
-    
 
     def to_dict(self):
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
@@ -70,27 +44,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(SubscriberActive, dict):
+        if issubclass(WebhookUrlCreate, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, SubscriberActive):
+        if not isinstance(other, WebhookUrlCreate):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscriber_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscriber_create.py`

 * *Files 6% similar despite different names*

```diff
@@ -32,26 +32,26 @@
         self.attribute_map.update(super().attribute_map)
 
     
     @property
     def state(self):
         """Gets the state of this SubscriberCreate.
 
-            The object's current state.
+            
 
         :return: The state of this SubscriberCreate.
         :rtype: CreationEntityState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this SubscriberCreate.
 
-            The object's current state.
+            
 
         :param state: The state of this SubscriberCreate.
         :type: CreationEntityState
         """
 
         self._state = state
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscriber_update.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscriber_update.py`

 * *Files 2% similar despite different names*

```diff
@@ -250,26 +250,26 @@
 
         self._language = language
     
     @property
     def meta_data(self):
         """Gets the meta_data of this SubscriberUpdate.
 
-            Allow to store additional information about the object.
+            Meta data allow to store additional data along the object.
 
         :return: The meta_data of this SubscriberUpdate.
         :rtype: dict(str, str)
         """
         return self._meta_data
 
     @meta_data.setter
     def meta_data(self, meta_data):
         """Sets the meta_data of this SubscriberUpdate.
 
-            Allow to store additional information about the object.
+            Meta data allow to store additional data along the object.
 
         :param meta_data: The meta_data of this SubscriberUpdate.
         :type: dict(str, str)
         """
 
         self._meta_data = meta_data
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription.py`

 * *Files 4% similar despite different names*

```diff
@@ -200,26 +200,26 @@
 
         self._description = description
     
     @property
     def id(self):
         """Gets the id of this Subscription.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this Subscription.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this Subscription.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this Subscription.
         :type: int
         """
 
         self._id = id
     
@@ -246,72 +246,72 @@
 
         self._initialized_on = initialized_on
     
     @property
     def language(self):
         """Gets the language of this Subscription.
 
-            The language that is linked to the object.
+            
 
         :return: The language of this Subscription.
         :rtype: str
         """
         return self._language
 
     @language.setter
     def language(self, language):
         """Sets the language of this Subscription.
 
-            The language that is linked to the object.
+            
 
         :param language: The language of this Subscription.
         :type: str
         """
 
         self._language = language
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this Subscription.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this Subscription.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this Subscription.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this Subscription.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this Subscription.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this Subscription.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this Subscription.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this Subscription.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -363,26 +363,26 @@
 
         self._reference = reference
     
     @property
     def state(self):
         """Gets the state of this Subscription.
 
-            The object's current state.
+            
 
         :return: The state of this Subscription.
         :rtype: SubscriptionState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this Subscription.
 
-            The object's current state.
+            
 
         :param state: The state of this Subscription.
         :type: SubscriptionState
         """
 
         self._state = state
     
@@ -524,26 +524,26 @@
 
         self._token = token
     
     @property
     def version(self):
         """Gets the version of this Subscription.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this Subscription.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this Subscription.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this Subscription.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_affiliate.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_affiliate.py`

 * *Files 11% similar despite different names*

```diff
@@ -76,95 +76,95 @@
 
         self._external_id = external_id
     
     @property
     def id(self):
         """Gets the id of this SubscriptionAffiliate.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this SubscriptionAffiliate.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this SubscriptionAffiliate.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this SubscriptionAffiliate.
         :type: int
         """
 
         self._id = id
     
     @property
     def language(self):
         """Gets the language of this SubscriptionAffiliate.
 
-            The language that is linked to the object.
+            
 
         :return: The language of this SubscriptionAffiliate.
         :rtype: str
         """
         return self._language
 
     @language.setter
     def language(self, language):
         """Sets the language of this SubscriptionAffiliate.
 
-            The language that is linked to the object.
+            
 
         :param language: The language of this SubscriptionAffiliate.
         :type: str
         """
 
         self._language = language
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this SubscriptionAffiliate.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this SubscriptionAffiliate.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this SubscriptionAffiliate.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this SubscriptionAffiliate.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
     @property
     def meta_data(self):
         """Gets the meta_data of this SubscriptionAffiliate.
 
-            Allow to store additional information about the object.
+            Meta data allow to store additional data along the object.
 
         :return: The meta_data of this SubscriptionAffiliate.
         :rtype: dict(str, str)
         """
         return self._meta_data
 
     @meta_data.setter
     def meta_data(self, meta_data):
         """Sets the meta_data of this SubscriptionAffiliate.
 
-            Allow to store additional information about the object.
+            Meta data allow to store additional data along the object.
 
         :param meta_data: The meta_data of this SubscriptionAffiliate.
         :type: dict(str, str)
         """
 
         self._meta_data = meta_data
     
@@ -195,26 +195,26 @@
 
         self._name = name
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this SubscriptionAffiliate.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this SubscriptionAffiliate.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this SubscriptionAffiliate.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this SubscriptionAffiliate.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -245,49 +245,49 @@
 
         self._reference = reference
     
     @property
     def state(self):
         """Gets the state of this SubscriptionAffiliate.
 
-            The object's current state.
+            
 
         :return: The state of this SubscriptionAffiliate.
         :rtype: CreationEntityState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this SubscriptionAffiliate.
 
-            The object's current state.
+            
 
         :param state: The state of this SubscriptionAffiliate.
         :type: CreationEntityState
         """
 
         self._state = state
     
     @property
     def version(self):
         """Gets the version of this SubscriptionAffiliate.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this SubscriptionAffiliate.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this SubscriptionAffiliate.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this SubscriptionAffiliate.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_affiliate_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_affiliate_create.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_affiliate_deleted.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_affiliate_deleted.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_affiliate_deleting.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_affiliate_deleting.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_affiliate_inactive.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_affiliate_inactive.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_affiliate_update.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_affiliate_update.py`

 * *Files 4% similar despite different names*

```diff
@@ -93,49 +93,49 @@
 
         self._version = version
     
     @property
     def language(self):
         """Gets the language of this SubscriptionAffiliateUpdate.
 
-            The language that is linked to the object.
+            
 
         :return: The language of this SubscriptionAffiliateUpdate.
         :rtype: str
         """
         return self._language
 
     @language.setter
     def language(self, language):
         """Sets the language of this SubscriptionAffiliateUpdate.
 
-            The language that is linked to the object.
+            
 
         :param language: The language of this SubscriptionAffiliateUpdate.
         :type: str
         """
 
         self._language = language
     
     @property
     def meta_data(self):
         """Gets the meta_data of this SubscriptionAffiliateUpdate.
 
-            Allow to store additional information about the object.
+            Meta data allow to store additional data along the object.
 
         :return: The meta_data of this SubscriptionAffiliateUpdate.
         :rtype: dict(str, str)
         """
         return self._meta_data
 
     @meta_data.setter
     def meta_data(self, meta_data):
         """Sets the meta_data of this SubscriptionAffiliateUpdate.
 
-            Allow to store additional information about the object.
+            Meta data allow to store additional data along the object.
 
         :param meta_data: The meta_data of this SubscriptionAffiliateUpdate.
         :type: dict(str, str)
         """
 
         self._meta_data = meta_data
     
@@ -166,26 +166,26 @@
 
         self._name = name
     
     @property
     def state(self):
         """Gets the state of this SubscriptionAffiliateUpdate.
 
-            The object's current state.
+            
 
         :return: The state of this SubscriptionAffiliateUpdate.
         :rtype: CreationEntityState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this SubscriptionAffiliateUpdate.
 
-            The object's current state.
+            
 
         :param state: The state of this SubscriptionAffiliateUpdate.
         :type: CreationEntityState
         """
 
         self._state = state
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_change_request.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_create_request.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,191 +1,165 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
 
 
 
-class SubscriptionChangeRequest:
+class SubscriptionCreateRequest:
 
     swagger_types = {
     
         'component_configurations': 'list[SubscriptionComponentReferenceConfiguration]',
         'currency': 'str',
         'product': 'int',
-        'respect_termination_period': 'bool',
         'selected_components': 'list[SubscriptionProductComponentReference]',
-        'subscription': 'int',
+        'subscription': 'SubscriptionPending',
     }
 
     attribute_map = {
-        'component_configurations': 'componentConfigurations','currency': 'currency','product': 'product','respect_termination_period': 'respectTerminationPeriod','selected_components': 'selectedComponents','subscription': 'subscription',
+        'component_configurations': 'componentConfigurations','currency': 'currency','product': 'product','selected_components': 'selectedComponents','subscription': 'subscription',
     }
 
     
     _component_configurations = None
     _currency = None
     _product = None
-    _respect_termination_period = None
     _selected_components = None
     _subscription = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
         self.component_configurations = kwargs.get('component_configurations', None)
         self.currency = kwargs.get('currency')
 
         self.product = kwargs.get('product')
 
-        self.respect_termination_period = kwargs.get('respect_termination_period', None)
         self.selected_components = kwargs.get('selected_components', None)
         self.subscription = kwargs.get('subscription')
 
         
 
     
     @property
     def component_configurations(self):
-        """Gets the component_configurations of this SubscriptionChangeRequest.
+        """Gets the component_configurations of this SubscriptionCreateRequest.
 
             
 
-        :return: The component_configurations of this SubscriptionChangeRequest.
+        :return: The component_configurations of this SubscriptionCreateRequest.
         :rtype: list[SubscriptionComponentReferenceConfiguration]
         """
         return self._component_configurations
 
     @component_configurations.setter
     def component_configurations(self, component_configurations):
-        """Sets the component_configurations of this SubscriptionChangeRequest.
+        """Sets the component_configurations of this SubscriptionCreateRequest.
 
             
 
-        :param component_configurations: The component_configurations of this SubscriptionChangeRequest.
+        :param component_configurations: The component_configurations of this SubscriptionCreateRequest.
         :type: list[SubscriptionComponentReferenceConfiguration]
         """
 
         self._component_configurations = component_configurations
     
     @property
     def currency(self):
-        """Gets the currency of this SubscriptionChangeRequest.
+        """Gets the currency of this SubscriptionCreateRequest.
 
             
 
-        :return: The currency of this SubscriptionChangeRequest.
+        :return: The currency of this SubscriptionCreateRequest.
         :rtype: str
         """
         return self._currency
 
     @currency.setter
     def currency(self, currency):
-        """Sets the currency of this SubscriptionChangeRequest.
+        """Sets the currency of this SubscriptionCreateRequest.
 
             
 
-        :param currency: The currency of this SubscriptionChangeRequest.
+        :param currency: The currency of this SubscriptionCreateRequest.
         :type: str
         """
         if currency is None:
             raise ValueError("Invalid value for `currency`, must not be `None`")
 
         self._currency = currency
     
     @property
     def product(self):
-        """Gets the product of this SubscriptionChangeRequest.
+        """Gets the product of this SubscriptionCreateRequest.
 
             The subscription has to be linked with a product.
 
-        :return: The product of this SubscriptionChangeRequest.
+        :return: The product of this SubscriptionCreateRequest.
         :rtype: int
         """
         return self._product
 
     @product.setter
     def product(self, product):
-        """Sets the product of this SubscriptionChangeRequest.
+        """Sets the product of this SubscriptionCreateRequest.
 
             The subscription has to be linked with a product.
 
-        :param product: The product of this SubscriptionChangeRequest.
+        :param product: The product of this SubscriptionCreateRequest.
         :type: int
         """
         if product is None:
             raise ValueError("Invalid value for `product`, must not be `None`")
 
         self._product = product
     
     @property
-    def respect_termination_period(self):
-        """Gets the respect_termination_period of this SubscriptionChangeRequest.
-
-            The subscription version may be retired. The respect termination period controls whether the termination period configured on the product version should be respected or if the operation should take effect immediately.
-
-        :return: The respect_termination_period of this SubscriptionChangeRequest.
-        :rtype: bool
-        """
-        return self._respect_termination_period
-
-    @respect_termination_period.setter
-    def respect_termination_period(self, respect_termination_period):
-        """Sets the respect_termination_period of this SubscriptionChangeRequest.
-
-            The subscription version may be retired. The respect termination period controls whether the termination period configured on the product version should be respected or if the operation should take effect immediately.
-
-        :param respect_termination_period: The respect_termination_period of this SubscriptionChangeRequest.
-        :type: bool
-        """
-
-        self._respect_termination_period = respect_termination_period
-    
-    @property
     def selected_components(self):
-        """Gets the selected_components of this SubscriptionChangeRequest.
+        """Gets the selected_components of this SubscriptionCreateRequest.
 
             
 
-        :return: The selected_components of this SubscriptionChangeRequest.
+        :return: The selected_components of this SubscriptionCreateRequest.
         :rtype: list[SubscriptionProductComponentReference]
         """
         return self._selected_components
 
     @selected_components.setter
     def selected_components(self, selected_components):
-        """Sets the selected_components of this SubscriptionChangeRequest.
+        """Sets the selected_components of this SubscriptionCreateRequest.
 
             
 
-        :param selected_components: The selected_components of this SubscriptionChangeRequest.
+        :param selected_components: The selected_components of this SubscriptionCreateRequest.
         :type: list[SubscriptionProductComponentReference]
         """
 
         self._selected_components = selected_components
     
     @property
     def subscription(self):
-        """Gets the subscription of this SubscriptionChangeRequest.
+        """Gets the subscription of this SubscriptionCreateRequest.
 
             
 
-        :return: The subscription of this SubscriptionChangeRequest.
-        :rtype: int
+        :return: The subscription of this SubscriptionCreateRequest.
+        :rtype: SubscriptionPending
         """
         return self._subscription
 
     @subscription.setter
     def subscription(self, subscription):
-        """Sets the subscription of this SubscriptionChangeRequest.
+        """Sets the subscription of this SubscriptionCreateRequest.
 
             
 
-        :param subscription: The subscription of this SubscriptionChangeRequest.
-        :type: int
+        :param subscription: The subscription of this SubscriptionCreateRequest.
+        :type: SubscriptionPending
         """
         if subscription is None:
             raise ValueError("Invalid value for `subscription`, must not be `None`")
 
         self._subscription = subscription
     
 
@@ -207,27 +181,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(SubscriptionChangeRequest, dict):
+        if issubclass(SubscriptionCreateRequest, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, SubscriptionChangeRequest):
+        if not isinstance(other, SubscriptionCreateRequest):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_charge.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_charge.py`

 * *Files 3% similar despite different names*

```diff
@@ -228,49 +228,49 @@
 
         self._failed_url = failed_url
     
     @property
     def id(self):
         """Gets the id of this SubscriptionCharge.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this SubscriptionCharge.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this SubscriptionCharge.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this SubscriptionCharge.
         :type: int
         """
 
         self._id = id
     
     @property
     def language(self):
         """Gets the language of this SubscriptionCharge.
 
-            The language that is linked to the object.
+            
 
         :return: The language of this SubscriptionCharge.
         :rtype: str
         """
         return self._language
 
     @language.setter
     def language(self, language):
         """Sets the language of this SubscriptionCharge.
 
-            The language that is linked to the object.
+            
 
         :param language: The language of this SubscriptionCharge.
         :type: str
         """
 
         self._language = language
     
@@ -297,26 +297,26 @@
 
         self._ledger_entries = ledger_entries
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this SubscriptionCharge.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this SubscriptionCharge.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this SubscriptionCharge.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this SubscriptionCharge.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -343,26 +343,26 @@
 
         self._planned_execution_date = planned_execution_date
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this SubscriptionCharge.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this SubscriptionCharge.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this SubscriptionCharge.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this SubscriptionCharge.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -414,26 +414,26 @@
 
         self._reference = reference
     
     @property
     def state(self):
         """Gets the state of this SubscriptionCharge.
 
-            The object's current state.
+            
 
         :return: The state of this SubscriptionCharge.
         :rtype: SubscriptionChargeState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this SubscriptionCharge.
 
-            The object's current state.
+            
 
         :param state: The state of this SubscriptionCharge.
         :type: SubscriptionChargeState
         """
 
         self._state = state
     
@@ -556,26 +556,26 @@
 
         self._type = type
     
     @property
     def version(self):
         """Gets the version of this SubscriptionCharge.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this SubscriptionCharge.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this SubscriptionCharge.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this SubscriptionCharge.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_charge_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_charge_create.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_component_configuration.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_component_configuration.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_component_reference_configuration.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_component_reference_configuration.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_ledger_entry.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_ledger_entry.py`

 * *Files 10% similar despite different names*

```diff
@@ -166,26 +166,26 @@
 
         self._created_by = created_by
     
     @property
     def created_on(self):
         """Gets the created_on of this SubscriptionLedgerEntry.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :return: The created_on of this SubscriptionLedgerEntry.
         :rtype: datetime
         """
         return self._created_on
 
     @created_on.setter
     def created_on(self, created_on):
         """Sets the created_on of this SubscriptionLedgerEntry.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :param created_on: The created_on of this SubscriptionLedgerEntry.
         :type: datetime
         """
 
         self._created_on = created_on
     
@@ -235,72 +235,72 @@
 
         self._external_id = external_id
     
     @property
     def id(self):
         """Gets the id of this SubscriptionLedgerEntry.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this SubscriptionLedgerEntry.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this SubscriptionLedgerEntry.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this SubscriptionLedgerEntry.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this SubscriptionLedgerEntry.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this SubscriptionLedgerEntry.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this SubscriptionLedgerEntry.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this SubscriptionLedgerEntry.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this SubscriptionLedgerEntry.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this SubscriptionLedgerEntry.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this SubscriptionLedgerEntry.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this SubscriptionLedgerEntry.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -327,26 +327,26 @@
 
         self._quantity = quantity
     
     @property
     def state(self):
         """Gets the state of this SubscriptionLedgerEntry.
 
-            The object's current state.
+            
 
         :return: The state of this SubscriptionLedgerEntry.
         :rtype: SubscriptionLedgerEntryState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this SubscriptionLedgerEntry.
 
-            The object's current state.
+            
 
         :param state: The state of this SubscriptionLedgerEntry.
         :type: SubscriptionLedgerEntryState
         """
 
         self._state = state
     
@@ -446,26 +446,26 @@
 
         self._title = title
     
     @property
     def version(self):
         """Gets the version of this SubscriptionLedgerEntry.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this SubscriptionLedgerEntry.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this SubscriptionLedgerEntry.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this SubscriptionLedgerEntry.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_ledger_entry_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_ledger_entry_create.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_metric.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_suspension_create.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,239 +1,146 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
 
 
 
-class SubscriptionMetric:
+class SubscriptionSuspensionCreate:
 
     swagger_types = {
     
-        'description': 'dict(str, str)',
-        'id': 'int',
-        'linked_space_id': 'int',
-        'name': 'dict(str, str)',
-        'planned_purge_date': 'datetime',
-        'state': 'CreationEntityState',
-        'type': 'SubscriptionMetricType',
-        'version': 'int',
+        'end_action': 'SubscriptionSuspensionAction',
+        'note': 'str',
+        'planned_end_date': 'datetime',
+        'subscription': 'int',
     }
 
     attribute_map = {
-        'description': 'description','id': 'id','linked_space_id': 'linkedSpaceId','name': 'name','planned_purge_date': 'plannedPurgeDate','state': 'state','type': 'type','version': 'version',
+        'end_action': 'endAction','note': 'note','planned_end_date': 'plannedEndDate','subscription': 'subscription',
     }
 
     
-    _description = None
-    _id = None
-    _linked_space_id = None
-    _name = None
-    _planned_purge_date = None
-    _state = None
-    _type = None
-    _version = None
+    _end_action = None
+    _note = None
+    _planned_end_date = None
+    _subscription = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
-        self.description = kwargs.get('description', None)
-        self.id = kwargs.get('id', None)
-        self.linked_space_id = kwargs.get('linked_space_id', None)
-        self.name = kwargs.get('name', None)
-        self.planned_purge_date = kwargs.get('planned_purge_date', None)
-        self.state = kwargs.get('state', None)
-        self.type = kwargs.get('type', None)
-        self.version = kwargs.get('version', None)
-        
-
-    
-    @property
-    def description(self):
-        """Gets the description of this SubscriptionMetric.
+        self.end_action = kwargs.get('end_action')
 
-            
-
-        :return: The description of this SubscriptionMetric.
-        :rtype: dict(str, str)
-        """
-        return self._description
+        self.note = kwargs.get('note', None)
+        self.planned_end_date = kwargs.get('planned_end_date')
 
-    @description.setter
-    def description(self, description):
-        """Sets the description of this SubscriptionMetric.
+        self.subscription = kwargs.get('subscription')
 
-            
-
-        :param description: The description of this SubscriptionMetric.
-        :type: dict(str, str)
-        """
+        
 
-        self._description = description
     
     @property
-    def id(self):
-        """Gets the id of this SubscriptionMetric.
+    def end_action(self):
+        """Gets the end_action of this SubscriptionSuspensionCreate.
 
-            A unique identifier for the object.
+            When the suspension reaches the planned end date the end action will be carried out. This action is only executed when the suspension is ended automatically based on the end date.
 
-        :return: The id of this SubscriptionMetric.
-        :rtype: int
+        :return: The end_action of this SubscriptionSuspensionCreate.
+        :rtype: SubscriptionSuspensionAction
         """
-        return self._id
+        return self._end_action
 
-    @id.setter
-    def id(self, id):
-        """Sets the id of this SubscriptionMetric.
+    @end_action.setter
+    def end_action(self, end_action):
+        """Sets the end_action of this SubscriptionSuspensionCreate.
 
-            A unique identifier for the object.
+            When the suspension reaches the planned end date the end action will be carried out. This action is only executed when the suspension is ended automatically based on the end date.
 
-        :param id: The id of this SubscriptionMetric.
-        :type: int
+        :param end_action: The end_action of this SubscriptionSuspensionCreate.
+        :type: SubscriptionSuspensionAction
         """
+        if end_action is None:
+            raise ValueError("Invalid value for `end_action`, must not be `None`")
 
-        self._id = id
+        self._end_action = end_action
     
     @property
-    def linked_space_id(self):
-        """Gets the linked_space_id of this SubscriptionMetric.
+    def note(self):
+        """Gets the note of this SubscriptionSuspensionCreate.
 
-            The ID of the space this object belongs to.
+            The note may contain some internal information for the suspension. The note will not be disclosed to the subscriber.
 
-        :return: The linked_space_id of this SubscriptionMetric.
-        :rtype: int
+        :return: The note of this SubscriptionSuspensionCreate.
+        :rtype: str
         """
-        return self._linked_space_id
+        return self._note
 
-    @linked_space_id.setter
-    def linked_space_id(self, linked_space_id):
-        """Sets the linked_space_id of this SubscriptionMetric.
+    @note.setter
+    def note(self, note):
+        """Sets the note of this SubscriptionSuspensionCreate.
 
-            The ID of the space this object belongs to.
+            The note may contain some internal information for the suspension. The note will not be disclosed to the subscriber.
 
-        :param linked_space_id: The linked_space_id of this SubscriptionMetric.
-        :type: int
+        :param note: The note of this SubscriptionSuspensionCreate.
+        :type: str
         """
+        if note is not None and len(note) > 300:
+            raise ValueError("Invalid value for `note`, length must be less than or equal to `300`")
 
-        self._linked_space_id = linked_space_id
+        self._note = note
     
     @property
-    def name(self):
-        """Gets the name of this SubscriptionMetric.
-
-            
-
-        :return: The name of this SubscriptionMetric.
-        :rtype: dict(str, str)
-        """
-        return self._name
+    def planned_end_date(self):
+        """Gets the planned_end_date of this SubscriptionSuspensionCreate.
 
-    @name.setter
-    def name(self, name):
-        """Sets the name of this SubscriptionMetric.
+            The planned end date of the suspension identifies the date on which the suspension will be ended automatically.
 
-            
-
-        :param name: The name of this SubscriptionMetric.
-        :type: dict(str, str)
-        """
-
-        self._name = name
-    
-    @property
-    def planned_purge_date(self):
-        """Gets the planned_purge_date of this SubscriptionMetric.
-
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
-
-        :return: The planned_purge_date of this SubscriptionMetric.
+        :return: The planned_end_date of this SubscriptionSuspensionCreate.
         :rtype: datetime
         """
-        return self._planned_purge_date
+        return self._planned_end_date
 
-    @planned_purge_date.setter
-    def planned_purge_date(self, planned_purge_date):
-        """Sets the planned_purge_date of this SubscriptionMetric.
+    @planned_end_date.setter
+    def planned_end_date(self, planned_end_date):
+        """Sets the planned_end_date of this SubscriptionSuspensionCreate.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned end date of the suspension identifies the date on which the suspension will be ended automatically.
 
-        :param planned_purge_date: The planned_purge_date of this SubscriptionMetric.
+        :param planned_end_date: The planned_end_date of this SubscriptionSuspensionCreate.
         :type: datetime
         """
+        if planned_end_date is None:
+            raise ValueError("Invalid value for `planned_end_date`, must not be `None`")
 
-        self._planned_purge_date = planned_purge_date
-    
-    @property
-    def state(self):
-        """Gets the state of this SubscriptionMetric.
-
-            The object's current state.
-
-        :return: The state of this SubscriptionMetric.
-        :rtype: CreationEntityState
-        """
-        return self._state
-
-    @state.setter
-    def state(self, state):
-        """Sets the state of this SubscriptionMetric.
-
-            The object's current state.
-
-        :param state: The state of this SubscriptionMetric.
-        :type: CreationEntityState
-        """
-
-        self._state = state
+        self._planned_end_date = planned_end_date
     
     @property
-    def type(self):
-        """Gets the type of this SubscriptionMetric.
+    def subscription(self):
+        """Gets the subscription of this SubscriptionSuspensionCreate.
 
             
 
-        :return: The type of this SubscriptionMetric.
-        :rtype: SubscriptionMetricType
-        """
-        return self._type
-
-    @type.setter
-    def type(self, type):
-        """Sets the type of this SubscriptionMetric.
-
-            
-
-        :param type: The type of this SubscriptionMetric.
-        :type: SubscriptionMetricType
-        """
-
-        self._type = type
-    
-    @property
-    def version(self):
-        """Gets the version of this SubscriptionMetric.
-
-            The version is used for optimistic locking and incremented whenever the object is updated.
-
-        :return: The version of this SubscriptionMetric.
+        :return: The subscription of this SubscriptionSuspensionCreate.
         :rtype: int
         """
-        return self._version
+        return self._subscription
 
-    @version.setter
-    def version(self, version):
-        """Sets the version of this SubscriptionMetric.
+    @subscription.setter
+    def subscription(self, subscription):
+        """Sets the subscription of this SubscriptionSuspensionCreate.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            
 
-        :param version: The version of this SubscriptionMetric.
+        :param subscription: The subscription of this SubscriptionSuspensionCreate.
         :type: int
         """
+        if subscription is None:
+            raise ValueError("Invalid value for `subscription`, must not be `None`")
 
-        self._version = version
+        self._subscription = subscription
     
 
     def to_dict(self):
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
@@ -250,27 +157,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(SubscriptionMetric, dict):
+        if issubclass(SubscriptionSuspensionCreate, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, SubscriptionMetric):
+        if not isinstance(other, SubscriptionSuspensionCreate):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_metric_active.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_metric_active.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_metric_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_metric_create.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_metric_type.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_product_retirement_create.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,135 +1,112 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
 
 
 
-class SubscriptionMetricType:
+class SubscriptionProductRetirementCreate:
 
     swagger_types = {
     
-        'description': 'dict(str, str)',
-        'feature': 'Feature',
-        'id': 'int',
-        'name': 'dict(str, str)',
+        'product': 'int',
+        'respect_terminiation_periods_enabled': 'bool',
+        'target_product': 'int',
     }
 
     attribute_map = {
-        'description': 'description','feature': 'feature','id': 'id','name': 'name',
+        'product': 'product','respect_terminiation_periods_enabled': 'respectTerminiationPeriodsEnabled','target_product': 'targetProduct',
     }
 
     
-    _description = None
-    _feature = None
-    _id = None
-    _name = None
+    _product = None
+    _respect_terminiation_periods_enabled = None
+    _target_product = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
-        self.description = kwargs.get('description', None)
-        self.feature = kwargs.get('feature', None)
-        self.id = kwargs.get('id', None)
-        self.name = kwargs.get('name', None)
+        self.product = kwargs.get('product')
+
+        self.respect_terminiation_periods_enabled = kwargs.get('respect_terminiation_periods_enabled', None)
+        self.target_product = kwargs.get('target_product', None)
         
 
     
     @property
-    def description(self):
-        """Gets the description of this SubscriptionMetricType.
+    def product(self):
+        """Gets the product of this SubscriptionProductRetirementCreate.
 
-            The localized description of the object.
+            
 
-        :return: The description of this SubscriptionMetricType.
-        :rtype: dict(str, str)
+        :return: The product of this SubscriptionProductRetirementCreate.
+        :rtype: int
         """
-        return self._description
+        return self._product
 
-    @description.setter
-    def description(self, description):
-        """Sets the description of this SubscriptionMetricType.
+    @product.setter
+    def product(self, product):
+        """Sets the product of this SubscriptionProductRetirementCreate.
 
-            The localized description of the object.
+            
 
-        :param description: The description of this SubscriptionMetricType.
-        :type: dict(str, str)
+        :param product: The product of this SubscriptionProductRetirementCreate.
+        :type: int
         """
+        if product is None:
+            raise ValueError("Invalid value for `product`, must not be `None`")
 
-        self._description = description
+        self._product = product
     
     @property
-    def feature(self):
-        """Gets the feature of this SubscriptionMetricType.
+    def respect_terminiation_periods_enabled(self):
+        """Gets the respect_terminiation_periods_enabled of this SubscriptionProductRetirementCreate.
 
             
 
-        :return: The feature of this SubscriptionMetricType.
-        :rtype: Feature
+        :return: The respect_terminiation_periods_enabled of this SubscriptionProductRetirementCreate.
+        :rtype: bool
         """
-        return self._feature
+        return self._respect_terminiation_periods_enabled
 
-    @feature.setter
-    def feature(self, feature):
-        """Sets the feature of this SubscriptionMetricType.
+    @respect_terminiation_periods_enabled.setter
+    def respect_terminiation_periods_enabled(self, respect_terminiation_periods_enabled):
+        """Sets the respect_terminiation_periods_enabled of this SubscriptionProductRetirementCreate.
 
             
 
-        :param feature: The feature of this SubscriptionMetricType.
-        :type: Feature
+        :param respect_terminiation_periods_enabled: The respect_terminiation_periods_enabled of this SubscriptionProductRetirementCreate.
+        :type: bool
         """
 
-        self._feature = feature
+        self._respect_terminiation_periods_enabled = respect_terminiation_periods_enabled
     
     @property
-    def id(self):
-        """Gets the id of this SubscriptionMetricType.
+    def target_product(self):
+        """Gets the target_product of this SubscriptionProductRetirementCreate.
 
-            A unique identifier for the object.
+            
 
-        :return: The id of this SubscriptionMetricType.
+        :return: The target_product of this SubscriptionProductRetirementCreate.
         :rtype: int
         """
-        return self._id
+        return self._target_product
 
-    @id.setter
-    def id(self, id):
-        """Sets the id of this SubscriptionMetricType.
+    @target_product.setter
+    def target_product(self, target_product):
+        """Sets the target_product of this SubscriptionProductRetirementCreate.
 
-            A unique identifier for the object.
+            
 
-        :param id: The id of this SubscriptionMetricType.
+        :param target_product: The target_product of this SubscriptionProductRetirementCreate.
         :type: int
         """
 
-        self._id = id
-    
-    @property
-    def name(self):
-        """Gets the name of this SubscriptionMetricType.
-
-            The localized name of the object.
-
-        :return: The name of this SubscriptionMetricType.
-        :rtype: dict(str, str)
-        """
-        return self._name
-
-    @name.setter
-    def name(self, name):
-        """Sets the name of this SubscriptionMetricType.
-
-            The localized name of the object.
-
-        :param name: The name of this SubscriptionMetricType.
-        :type: dict(str, str)
-        """
-
-        self._name = name
+        self._target_product = target_product
     
 
     def to_dict(self):
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
@@ -146,27 +123,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(SubscriptionMetricType, dict):
+        if issubclass(SubscriptionProductRetirementCreate, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, SubscriptionMetricType):
+        if not isinstance(other, SubscriptionProductRetirementCreate):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_metric_update.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_metric_update.py`

 * *Files 3% similar despite different names*

```diff
@@ -7,16 +7,16 @@
 
 class SubscriptionMetricUpdate:
 
     swagger_types = {
     
         'id': 'int',
         'version': 'int',
-        'description': 'dict(str, str)',
-        'name': 'dict(str, str)',
+        'description': 'DatabaseTranslatedStringCreate',
+        'name': 'DatabaseTranslatedStringCreate',
     }
 
     attribute_map = {
         'id': 'id','version': 'version','description': 'description','name': 'name',
     }
 
     
@@ -90,49 +90,49 @@
     @property
     def description(self):
         """Gets the description of this SubscriptionMetricUpdate.
 
             
 
         :return: The description of this SubscriptionMetricUpdate.
-        :rtype: dict(str, str)
+        :rtype: DatabaseTranslatedStringCreate
         """
         return self._description
 
     @description.setter
     def description(self, description):
         """Sets the description of this SubscriptionMetricUpdate.
 
             
 
         :param description: The description of this SubscriptionMetricUpdate.
-        :type: dict(str, str)
+        :type: DatabaseTranslatedStringCreate
         """
 
         self._description = description
     
     @property
     def name(self):
         """Gets the name of this SubscriptionMetricUpdate.
 
             
 
         :return: The name of this SubscriptionMetricUpdate.
-        :rtype: dict(str, str)
+        :rtype: DatabaseTranslatedStringCreate
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this SubscriptionMetricUpdate.
 
             
 
         :param name: The name of this SubscriptionMetricUpdate.
-        :type: dict(str, str)
+        :type: DatabaseTranslatedStringCreate
         """
 
         self._name = name
     
 
     def to_dict(self):
         result = {}
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_metric_usage_report.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_metric_usage_report.py`

 * *Files 3% similar despite different names*

```diff
@@ -173,49 +173,49 @@
 
         self._external_id = external_id
     
     @property
     def id(self):
         """Gets the id of this SubscriptionMetricUsageReport.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this SubscriptionMetricUsageReport.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this SubscriptionMetricUsageReport.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this SubscriptionMetricUsageReport.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this SubscriptionMetricUsageReport.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this SubscriptionMetricUsageReport.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this SubscriptionMetricUsageReport.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this SubscriptionMetricUsageReport.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -242,26 +242,26 @@
 
         self._metric = metric
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this SubscriptionMetricUsageReport.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this SubscriptionMetricUsageReport.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this SubscriptionMetricUsageReport.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this SubscriptionMetricUsageReport.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -288,26 +288,26 @@
 
         self._subscription = subscription
     
     @property
     def version(self):
         """Gets the version of this SubscriptionMetricUsageReport.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this SubscriptionMetricUsageReport.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this SubscriptionMetricUsageReport.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this SubscriptionMetricUsageReport.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_metric_usage_report_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_metric_usage_report_create.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_pending.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_pending.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_period_bill.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_period_bill.py`

 * *Files 8% similar despite different names*

```diff
@@ -102,72 +102,72 @@
 
         self._effective_period_end_date = effective_period_end_date
     
     @property
     def id(self):
         """Gets the id of this SubscriptionPeriodBill.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this SubscriptionPeriodBill.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this SubscriptionPeriodBill.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this SubscriptionPeriodBill.
         :type: int
         """
 
         self._id = id
     
     @property
     def language(self):
         """Gets the language of this SubscriptionPeriodBill.
 
-            The language that is linked to the object.
+            
 
         :return: The language of this SubscriptionPeriodBill.
         :rtype: str
         """
         return self._language
 
     @language.setter
     def language(self, language):
         """Sets the language of this SubscriptionPeriodBill.
 
-            The language that is linked to the object.
+            
 
         :param language: The language of this SubscriptionPeriodBill.
         :type: str
         """
 
         self._language = language
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this SubscriptionPeriodBill.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this SubscriptionPeriodBill.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this SubscriptionPeriodBill.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this SubscriptionPeriodBill.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -217,49 +217,49 @@
 
         self._planned_period_end_date = planned_period_end_date
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this SubscriptionPeriodBill.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this SubscriptionPeriodBill.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this SubscriptionPeriodBill.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this SubscriptionPeriodBill.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
     @property
     def state(self):
         """Gets the state of this SubscriptionPeriodBill.
 
-            The object's current state.
+            
 
         :return: The state of this SubscriptionPeriodBill.
         :rtype: SubscriptionPeriodBillState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this SubscriptionPeriodBill.
 
-            The object's current state.
+            
 
         :param state: The state of this SubscriptionPeriodBill.
         :type: SubscriptionPeriodBillState
         """
 
         self._state = state
     
@@ -286,26 +286,26 @@
 
         self._subscription_version = subscription_version
     
     @property
     def version(self):
         """Gets the version of this SubscriptionPeriodBill.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this SubscriptionPeriodBill.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this SubscriptionPeriodBill.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this SubscriptionPeriodBill.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_product.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_product.py`

 * *Files 2% similar despite different names*

```diff
@@ -105,49 +105,49 @@
 
         self._failed_payment_suspension_period = failed_payment_suspension_period
     
     @property
     def id(self):
         """Gets the id of this SubscriptionProduct.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this SubscriptionProduct.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this SubscriptionProduct.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this SubscriptionProduct.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this SubscriptionProduct.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this SubscriptionProduct.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this SubscriptionProduct.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this SubscriptionProduct.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -176,26 +176,26 @@
 
         self._name = name
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this SubscriptionProduct.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this SubscriptionProduct.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this SubscriptionProduct.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this SubscriptionProduct.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -293,49 +293,49 @@
 
         self._space_id = space_id
     
     @property
     def state(self):
         """Gets the state of this SubscriptionProduct.
 
-            The object's current state.
+            
 
         :return: The state of this SubscriptionProduct.
         :rtype: SubscriptionProductState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this SubscriptionProduct.
 
-            The object's current state.
+            
 
         :param state: The state of this SubscriptionProduct.
         :type: SubscriptionProductState
         """
 
         self._state = state
     
     @property
     def version(self):
         """Gets the version of this SubscriptionProduct.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this SubscriptionProduct.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this SubscriptionProduct.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this SubscriptionProduct.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_product_active.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_product_active.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_product_component.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_product_component.py`

 * *Files 4% similar despite different names*

```diff
@@ -8,20 +8,20 @@
 class SubscriptionProductComponent:
 
     swagger_types = {
     
         'component_change_weight': 'int',
         'component_group': 'SubscriptionProductComponentGroup',
         'default_component': 'bool',
-        'description': 'dict(str, str)',
+        'description': 'DatabaseTranslatedString',
         'id': 'int',
         'linked_space_id': 'int',
         'maximal_quantity': 'float',
         'minimal_quantity': 'float',
-        'name': 'dict(str, str)',
+        'name': 'DatabaseTranslatedString',
         'quantity_step': 'float',
         'reference': 'SubscriptionProductComponentReference',
         'sort_order': 'int',
         'tax_class': 'TaxClass',
         'version': 'int',
     }
 
@@ -137,69 +137,69 @@
     @property
     def description(self):
         """Gets the description of this SubscriptionProductComponent.
 
             The component description may contain a longer description which gives the subscriber a better understanding of what the component contains.
 
         :return: The description of this SubscriptionProductComponent.
-        :rtype: dict(str, str)
+        :rtype: DatabaseTranslatedString
         """
         return self._description
 
     @description.setter
     def description(self, description):
         """Sets the description of this SubscriptionProductComponent.
 
             The component description may contain a longer description which gives the subscriber a better understanding of what the component contains.
 
         :param description: The description of this SubscriptionProductComponent.
-        :type: dict(str, str)
+        :type: DatabaseTranslatedString
         """
 
         self._description = description
     
     @property
     def id(self):
         """Gets the id of this SubscriptionProductComponent.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this SubscriptionProductComponent.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this SubscriptionProductComponent.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this SubscriptionProductComponent.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this SubscriptionProductComponent.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this SubscriptionProductComponent.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this SubscriptionProductComponent.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this SubscriptionProductComponent.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -252,26 +252,26 @@
     @property
     def name(self):
         """Gets the name of this SubscriptionProductComponent.
 
             The component name is shown to the subscriber. It should describe in few words what the component does contain.
 
         :return: The name of this SubscriptionProductComponent.
-        :rtype: dict(str, str)
+        :rtype: DatabaseTranslatedString
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this SubscriptionProductComponent.
 
             The component name is shown to the subscriber. It should describe in few words what the component does contain.
 
         :param name: The name of this SubscriptionProductComponent.
-        :type: dict(str, str)
+        :type: DatabaseTranslatedString
         """
 
         self._name = name
     
     @property
     def quantity_step(self):
         """Gets the quantity_step of this SubscriptionProductComponent.
@@ -364,26 +364,26 @@
 
         self._tax_class = tax_class
     
     @property
     def version(self):
         """Gets the version of this SubscriptionProductComponent.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this SubscriptionProductComponent.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this SubscriptionProductComponent.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this SubscriptionProductComponent.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_product_component_group.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_product_component_group.py`

 * *Files 8% similar despite different names*

```diff
@@ -7,15 +7,15 @@
 
 class SubscriptionProductComponentGroup:
 
     swagger_types = {
     
         'id': 'int',
         'linked_space_id': 'int',
-        'name': 'dict(str, str)',
+        'name': 'DatabaseTranslatedString',
         'optional': 'bool',
         'product_version': 'SubscriptionProductVersion',
         'sort_order': 'int',
         'version': 'int',
     }
 
     attribute_map = {
@@ -44,75 +44,75 @@
         
 
     
     @property
     def id(self):
         """Gets the id of this SubscriptionProductComponentGroup.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this SubscriptionProductComponentGroup.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this SubscriptionProductComponentGroup.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this SubscriptionProductComponentGroup.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this SubscriptionProductComponentGroup.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this SubscriptionProductComponentGroup.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this SubscriptionProductComponentGroup.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this SubscriptionProductComponentGroup.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
     @property
     def name(self):
         """Gets the name of this SubscriptionProductComponentGroup.
 
             The component group name will be shown when the components are selected. This can be visible to the subscriber.
 
         :return: The name of this SubscriptionProductComponentGroup.
-        :rtype: dict(str, str)
+        :rtype: DatabaseTranslatedString
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this SubscriptionProductComponentGroup.
 
             The component group name will be shown when the components are selected. This can be visible to the subscriber.
 
         :param name: The name of this SubscriptionProductComponentGroup.
-        :type: dict(str, str)
+        :type: DatabaseTranslatedString
         """
 
         self._name = name
     
     @property
     def optional(self):
         """Gets the optional of this SubscriptionProductComponentGroup.
@@ -182,26 +182,26 @@
 
         self._sort_order = sort_order
     
     @property
     def version(self):
         """Gets the version of this SubscriptionProductComponentGroup.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this SubscriptionProductComponentGroup.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this SubscriptionProductComponentGroup.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this SubscriptionProductComponentGroup.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_product_component_group_update.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_product_component_group_update.py`

 * *Files 6% similar despite different names*

```diff
@@ -7,15 +7,15 @@
 
 class SubscriptionProductComponentGroupUpdate:
 
     swagger_types = {
     
         'id': 'int',
         'version': 'int',
-        'name': 'dict(str, str)',
+        'name': 'DatabaseTranslatedStringCreate',
         'optional': 'bool',
         'product_version': 'int',
         'sort_order': 'int',
     }
 
     attribute_map = {
         'id': 'id','version': 'version','name': 'name','optional': 'optional','product_version': 'productVersion','sort_order': 'sortOrder',
@@ -96,26 +96,26 @@
     @property
     def name(self):
         """Gets the name of this SubscriptionProductComponentGroupUpdate.
 
             The component group name will be shown when the components are selected. This can be visible to the subscriber.
 
         :return: The name of this SubscriptionProductComponentGroupUpdate.
-        :rtype: dict(str, str)
+        :rtype: DatabaseTranslatedStringCreate
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this SubscriptionProductComponentGroupUpdate.
 
             The component group name will be shown when the components are selected. This can be visible to the subscriber.
 
         :param name: The name of this SubscriptionProductComponentGroupUpdate.
-        :type: dict(str, str)
+        :type: DatabaseTranslatedStringCreate
         """
 
         self._name = name
     
     @property
     def optional(self):
         """Gets the optional of this SubscriptionProductComponentGroupUpdate.
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_product_component_reference.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_product_component_reference.py`

 * *Files 6% similar despite different names*

```diff
@@ -44,49 +44,49 @@
         
 
     
     @property
     def id(self):
         """Gets the id of this SubscriptionProductComponentReference.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this SubscriptionProductComponentReference.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this SubscriptionProductComponentReference.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this SubscriptionProductComponentReference.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this SubscriptionProductComponentReference.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this SubscriptionProductComponentReference.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this SubscriptionProductComponentReference.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this SubscriptionProductComponentReference.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -115,26 +115,26 @@
 
         self._name = name
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this SubscriptionProductComponentReference.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this SubscriptionProductComponentReference.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this SubscriptionProductComponentReference.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this SubscriptionProductComponentReference.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -161,49 +161,49 @@
 
         self._space_id = space_id
     
     @property
     def state(self):
         """Gets the state of this SubscriptionProductComponentReference.
 
-            The object's current state.
+            
 
         :return: The state of this SubscriptionProductComponentReference.
         :rtype: SubscriptionProductComponentReferenceState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this SubscriptionProductComponentReference.
 
-            The object's current state.
+            
 
         :param state: The state of this SubscriptionProductComponentReference.
         :type: SubscriptionProductComponentReferenceState
         """
 
         self._state = state
     
     @property
     def version(self):
         """Gets the version of this SubscriptionProductComponentReference.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this SubscriptionProductComponentReference.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this SubscriptionProductComponentReference.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this SubscriptionProductComponentReference.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_product_component_update.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_product_component_update.py`

 * *Files 2% similar despite different names*

```diff
@@ -10,18 +10,18 @@
     swagger_types = {
     
         'id': 'int',
         'version': 'int',
         'component_change_weight': 'int',
         'component_group': 'int',
         'default_component': 'bool',
-        'description': 'dict(str, str)',
+        'description': 'DatabaseTranslatedStringCreate',
         'maximal_quantity': 'float',
         'minimal_quantity': 'float',
-        'name': 'dict(str, str)',
+        'name': 'DatabaseTranslatedStringCreate',
         'quantity_step': 'float',
         'reference': 'int',
         'sort_order': 'int',
         'tax_class': 'int',
     }
 
     attribute_map = {
@@ -186,26 +186,26 @@
     @property
     def description(self):
         """Gets the description of this SubscriptionProductComponentUpdate.
 
             The component description may contain a longer description which gives the subscriber a better understanding of what the component contains.
 
         :return: The description of this SubscriptionProductComponentUpdate.
-        :rtype: dict(str, str)
+        :rtype: DatabaseTranslatedStringCreate
         """
         return self._description
 
     @description.setter
     def description(self, description):
         """Sets the description of this SubscriptionProductComponentUpdate.
 
             The component description may contain a longer description which gives the subscriber a better understanding of what the component contains.
 
         :param description: The description of this SubscriptionProductComponentUpdate.
-        :type: dict(str, str)
+        :type: DatabaseTranslatedStringCreate
         """
 
         self._description = description
     
     @property
     def maximal_quantity(self):
         """Gets the maximal_quantity of this SubscriptionProductComponentUpdate.
@@ -255,26 +255,26 @@
     @property
     def name(self):
         """Gets the name of this SubscriptionProductComponentUpdate.
 
             The component name is shown to the subscriber. It should describe in few words what the component does contain.
 
         :return: The name of this SubscriptionProductComponentUpdate.
-        :rtype: dict(str, str)
+        :rtype: DatabaseTranslatedStringCreate
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this SubscriptionProductComponentUpdate.
 
             The component name is shown to the subscriber. It should describe in few words what the component does contain.
 
         :param name: The name of this SubscriptionProductComponentUpdate.
-        :type: dict(str, str)
+        :type: DatabaseTranslatedStringCreate
         """
 
         self._name = name
     
     @property
     def quantity_step(self):
         """Gets the quantity_step of this SubscriptionProductComponentUpdate.
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_product_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_product_create.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_product_retirement.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_product_retirement.py`

 * *Files 14% similar despite different names*

```diff
@@ -44,72 +44,72 @@
         
 
     
     @property
     def created_on(self):
         """Gets the created_on of this SubscriptionProductRetirement.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :return: The created_on of this SubscriptionProductRetirement.
         :rtype: datetime
         """
         return self._created_on
 
     @created_on.setter
     def created_on(self, created_on):
         """Sets the created_on of this SubscriptionProductRetirement.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :param created_on: The created_on of this SubscriptionProductRetirement.
         :type: datetime
         """
 
         self._created_on = created_on
     
     @property
     def id(self):
         """Gets the id of this SubscriptionProductRetirement.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this SubscriptionProductRetirement.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this SubscriptionProductRetirement.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this SubscriptionProductRetirement.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this SubscriptionProductRetirement.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this SubscriptionProductRetirement.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this SubscriptionProductRetirement.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this SubscriptionProductRetirement.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -182,26 +182,26 @@
 
         self._target_product = target_product
     
     @property
     def version(self):
         """Gets the version of this SubscriptionProductRetirement.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this SubscriptionProductRetirement.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this SubscriptionProductRetirement.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this SubscriptionProductRetirement.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_product_retirement_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_product_version_retirement_create.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,108 +1,108 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
 
 
 
-class SubscriptionProductRetirementCreate:
+class SubscriptionProductVersionRetirementCreate:
 
     swagger_types = {
     
-        'product': 'int',
+        'product_version': 'int',
         'respect_terminiation_periods_enabled': 'bool',
         'target_product': 'int',
     }
 
     attribute_map = {
-        'product': 'product','respect_terminiation_periods_enabled': 'respectTerminiationPeriodsEnabled','target_product': 'targetProduct',
+        'product_version': 'productVersion','respect_terminiation_periods_enabled': 'respectTerminiationPeriodsEnabled','target_product': 'targetProduct',
     }
 
     
-    _product = None
+    _product_version = None
     _respect_terminiation_periods_enabled = None
     _target_product = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
-        self.product = kwargs.get('product')
+        self.product_version = kwargs.get('product_version')
 
         self.respect_terminiation_periods_enabled = kwargs.get('respect_terminiation_periods_enabled', None)
         self.target_product = kwargs.get('target_product', None)
         
 
     
     @property
-    def product(self):
-        """Gets the product of this SubscriptionProductRetirementCreate.
+    def product_version(self):
+        """Gets the product_version of this SubscriptionProductVersionRetirementCreate.
 
             
 
-        :return: The product of this SubscriptionProductRetirementCreate.
+        :return: The product_version of this SubscriptionProductVersionRetirementCreate.
         :rtype: int
         """
-        return self._product
+        return self._product_version
 
-    @product.setter
-    def product(self, product):
-        """Sets the product of this SubscriptionProductRetirementCreate.
+    @product_version.setter
+    def product_version(self, product_version):
+        """Sets the product_version of this SubscriptionProductVersionRetirementCreate.
 
             
 
-        :param product: The product of this SubscriptionProductRetirementCreate.
+        :param product_version: The product_version of this SubscriptionProductVersionRetirementCreate.
         :type: int
         """
-        if product is None:
-            raise ValueError("Invalid value for `product`, must not be `None`")
+        if product_version is None:
+            raise ValueError("Invalid value for `product_version`, must not be `None`")
 
-        self._product = product
+        self._product_version = product_version
     
     @property
     def respect_terminiation_periods_enabled(self):
-        """Gets the respect_terminiation_periods_enabled of this SubscriptionProductRetirementCreate.
+        """Gets the respect_terminiation_periods_enabled of this SubscriptionProductVersionRetirementCreate.
 
             
 
-        :return: The respect_terminiation_periods_enabled of this SubscriptionProductRetirementCreate.
+        :return: The respect_terminiation_periods_enabled of this SubscriptionProductVersionRetirementCreate.
         :rtype: bool
         """
         return self._respect_terminiation_periods_enabled
 
     @respect_terminiation_periods_enabled.setter
     def respect_terminiation_periods_enabled(self, respect_terminiation_periods_enabled):
-        """Sets the respect_terminiation_periods_enabled of this SubscriptionProductRetirementCreate.
+        """Sets the respect_terminiation_periods_enabled of this SubscriptionProductVersionRetirementCreate.
 
             
 
-        :param respect_terminiation_periods_enabled: The respect_terminiation_periods_enabled of this SubscriptionProductRetirementCreate.
+        :param respect_terminiation_periods_enabled: The respect_terminiation_periods_enabled of this SubscriptionProductVersionRetirementCreate.
         :type: bool
         """
 
         self._respect_terminiation_periods_enabled = respect_terminiation_periods_enabled
     
     @property
     def target_product(self):
-        """Gets the target_product of this SubscriptionProductRetirementCreate.
+        """Gets the target_product of this SubscriptionProductVersionRetirementCreate.
 
-            
+            When a target product is not chosen, all customers with the retired product will be terminated.
 
-        :return: The target_product of this SubscriptionProductRetirementCreate.
+        :return: The target_product of this SubscriptionProductVersionRetirementCreate.
         :rtype: int
         """
         return self._target_product
 
     @target_product.setter
     def target_product(self, target_product):
-        """Sets the target_product of this SubscriptionProductRetirementCreate.
+        """Sets the target_product of this SubscriptionProductVersionRetirementCreate.
 
-            
+            When a target product is not chosen, all customers with the retired product will be terminated.
 
-        :param target_product: The target_product of this SubscriptionProductRetirementCreate.
+        :param target_product: The target_product of this SubscriptionProductVersionRetirementCreate.
         :type: int
         """
 
         self._target_product = target_product
     
 
     def to_dict(self):
@@ -123,27 +123,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(SubscriptionProductRetirementCreate, dict):
+        if issubclass(SubscriptionProductVersionRetirementCreate, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, SubscriptionProductRetirementCreate):
+        if not isinstance(other, SubscriptionProductVersionRetirementCreate):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_product_version_pending.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_product_version_pending.py`

 * *Files 5% similar despite different names*

```diff
@@ -12,15 +12,15 @@
         'id': 'int',
         'version': 'int',
         'billing_cycle': 'str',
         'comment': 'str',
         'default_currency': 'str',
         'enabled_currencies': 'list[str]',
         'minimal_number_of_periods': 'int',
-        'name': 'dict(str, str)',
+        'name': 'DatabaseTranslatedStringCreate',
         'number_of_notice_periods': 'int',
         'product': 'int',
         'state': 'SubscriptionProductVersionState',
         'tax_calculation': 'TaxCalculation',
     }
 
     attribute_map = {
@@ -229,26 +229,26 @@
     @property
     def name(self):
         """Gets the name of this SubscriptionProductVersionPending.
 
             The product version name is the name of the product which is shown to the user for the version. When the visible product name should be changed for a particular product a new version has to be created which contains the new name of the product.
 
         :return: The name of this SubscriptionProductVersionPending.
-        :rtype: dict(str, str)
+        :rtype: DatabaseTranslatedStringCreate
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this SubscriptionProductVersionPending.
 
             The product version name is the name of the product which is shown to the user for the version. When the visible product name should be changed for a particular product a new version has to be created which contains the new name of the product.
 
         :param name: The name of this SubscriptionProductVersionPending.
-        :type: dict(str, str)
+        :type: DatabaseTranslatedStringCreate
         """
 
         self._name = name
     
     @property
     def number_of_notice_periods(self):
         """Gets the number_of_notice_periods of this SubscriptionProductVersionPending.
@@ -295,26 +295,26 @@
 
         self._product = product
     
     @property
     def state(self):
         """Gets the state of this SubscriptionProductVersionPending.
 
-            The object's current state.
+            
 
         :return: The state of this SubscriptionProductVersionPending.
         :rtype: SubscriptionProductVersionState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this SubscriptionProductVersionPending.
 
-            The object's current state.
+            
 
         :param state: The state of this SubscriptionProductVersionPending.
         :type: SubscriptionProductVersionState
         """
 
         self._state = state
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_product_version_retirement.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_product_version_retirement.py`

 * *Files 11% similar despite different names*

```diff
@@ -44,72 +44,72 @@
         
 
     
     @property
     def created_on(self):
         """Gets the created_on of this SubscriptionProductVersionRetirement.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :return: The created_on of this SubscriptionProductVersionRetirement.
         :rtype: datetime
         """
         return self._created_on
 
     @created_on.setter
     def created_on(self, created_on):
         """Sets the created_on of this SubscriptionProductVersionRetirement.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :param created_on: The created_on of this SubscriptionProductVersionRetirement.
         :type: datetime
         """
 
         self._created_on = created_on
     
     @property
     def id(self):
         """Gets the id of this SubscriptionProductVersionRetirement.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this SubscriptionProductVersionRetirement.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this SubscriptionProductVersionRetirement.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this SubscriptionProductVersionRetirement.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this SubscriptionProductVersionRetirement.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this SubscriptionProductVersionRetirement.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this SubscriptionProductVersionRetirement.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this SubscriptionProductVersionRetirement.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -182,26 +182,26 @@
 
         self._target_product = target_product
     
     @property
     def version(self):
         """Gets the version of this SubscriptionProductVersionRetirement.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this SubscriptionProductVersionRetirement.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this SubscriptionProductVersionRetirement.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this SubscriptionProductVersionRetirement.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_suspension.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_suspension.py`

 * *Files 5% similar despite different names*

```diff
@@ -65,26 +65,26 @@
         
 
     
     @property
     def created_on(self):
         """Gets the created_on of this SubscriptionSuspension.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :return: The created_on of this SubscriptionSuspension.
         :rtype: datetime
         """
         return self._created_on
 
     @created_on.setter
     def created_on(self, created_on):
         """Sets the created_on of this SubscriptionSuspension.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :param created_on: The created_on of this SubscriptionSuspension.
         :type: datetime
         """
 
         self._created_on = created_on
     
@@ -134,72 +134,72 @@
 
         self._end_action = end_action
     
     @property
     def id(self):
         """Gets the id of this SubscriptionSuspension.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this SubscriptionSuspension.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this SubscriptionSuspension.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this SubscriptionSuspension.
         :type: int
         """
 
         self._id = id
     
     @property
     def language(self):
         """Gets the language of this SubscriptionSuspension.
 
-            The language that is linked to the object.
+            
 
         :return: The language of this SubscriptionSuspension.
         :rtype: str
         """
         return self._language
 
     @language.setter
     def language(self, language):
         """Sets the language of this SubscriptionSuspension.
 
-            The language that is linked to the object.
+            
 
         :param language: The language of this SubscriptionSuspension.
         :type: str
         """
 
         self._language = language
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this SubscriptionSuspension.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this SubscriptionSuspension.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this SubscriptionSuspension.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this SubscriptionSuspension.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -274,26 +274,26 @@
 
         self._planned_end_date = planned_end_date
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this SubscriptionSuspension.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this SubscriptionSuspension.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this SubscriptionSuspension.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this SubscriptionSuspension.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -320,26 +320,26 @@
 
         self._reason = reason
     
     @property
     def state(self):
         """Gets the state of this SubscriptionSuspension.
 
-            The object's current state.
+            
 
         :return: The state of this SubscriptionSuspension.
         :rtype: SubscriptionSuspensionState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this SubscriptionSuspension.
 
-            The object's current state.
+            
 
         :param state: The state of this SubscriptionSuspension.
         :type: SubscriptionSuspensionState
         """
 
         self._state = state
     
@@ -366,26 +366,26 @@
 
         self._subscription = subscription
     
     @property
     def version(self):
         """Gets the version of this SubscriptionSuspension.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this SubscriptionSuspension.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this SubscriptionSuspension.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this SubscriptionSuspension.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_suspension_running.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_suspension_running.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_update.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_update.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_update_request.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_update_request.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/subscription_version.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/subscription_version.py`

 * *Files 3% similar despite different names*

```diff
@@ -218,95 +218,95 @@
 
         self._failed_on = failed_on
     
     @property
     def id(self):
         """Gets the id of this SubscriptionVersion.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this SubscriptionVersion.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this SubscriptionVersion.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this SubscriptionVersion.
         :type: int
         """
 
         self._id = id
     
     @property
     def language(self):
         """Gets the language of this SubscriptionVersion.
 
-            The language that is linked to the object.
+            
 
         :return: The language of this SubscriptionVersion.
         :rtype: str
         """
         return self._language
 
     @language.setter
     def language(self, language):
         """Sets the language of this SubscriptionVersion.
 
-            The language that is linked to the object.
+            
 
         :param language: The language of this SubscriptionVersion.
         :type: str
         """
 
         self._language = language
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this SubscriptionVersion.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this SubscriptionVersion.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this SubscriptionVersion.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this SubscriptionVersion.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this SubscriptionVersion.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this SubscriptionVersion.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this SubscriptionVersion.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this SubscriptionVersion.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -379,26 +379,26 @@
 
         self._selected_components = selected_components
     
     @property
     def state(self):
         """Gets the state of this SubscriptionVersion.
 
-            The object's current state.
+            
 
         :return: The state of this SubscriptionVersion.
         :rtype: SubscriptionVersionState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this SubscriptionVersion.
 
-            The object's current state.
+            
 
         :param state: The state of this SubscriptionVersion.
         :type: SubscriptionVersionState
         """
 
         self._state = state
     
@@ -494,26 +494,26 @@
 
         self._termination_issued_on = termination_issued_on
     
     @property
     def version(self):
         """Gets the version of this SubscriptionVersion.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this SubscriptionVersion.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this SubscriptionVersion.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this SubscriptionVersion.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/tax.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/tax_create.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
 
 
 
-class Tax:
+class TaxCreate:
 
     swagger_types = {
     
         'rate': 'float',
         'title': 'str',
     }
 
@@ -20,62 +20,68 @@
     
     _rate = None
     _title = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
-        self.rate = kwargs.get('rate', None)
-        self.title = kwargs.get('title', None)
+        self.rate = kwargs.get('rate')
+
+        self.title = kwargs.get('title')
+
         
 
     
     @property
     def rate(self):
-        """Gets the rate of this Tax.
+        """Gets the rate of this TaxCreate.
 
             
 
-        :return: The rate of this Tax.
+        :return: The rate of this TaxCreate.
         :rtype: float
         """
         return self._rate
 
     @rate.setter
     def rate(self, rate):
-        """Sets the rate of this Tax.
+        """Sets the rate of this TaxCreate.
 
             
 
-        :param rate: The rate of this Tax.
+        :param rate: The rate of this TaxCreate.
         :type: float
         """
+        if rate is None:
+            raise ValueError("Invalid value for `rate`, must not be `None`")
 
         self._rate = rate
     
     @property
     def title(self):
-        """Gets the title of this Tax.
+        """Gets the title of this TaxCreate.
 
             
 
-        :return: The title of this Tax.
+        :return: The title of this TaxCreate.
         :rtype: str
         """
         return self._title
 
     @title.setter
     def title(self, title):
-        """Sets the title of this Tax.
+        """Sets the title of this TaxCreate.
 
             
 
-        :param title: The title of this Tax.
+        :param title: The title of this TaxCreate.
         :type: str
         """
+        if title is None:
+            raise ValueError("Invalid value for `title`, must not be `None`")
         if title is not None and len(title) > 40:
             raise ValueError("Invalid value for `title`, length must be less than or equal to `40`")
         if title is not None and len(title) < 2:
             raise ValueError("Invalid value for `title`, length must be greater than or equal to `2`")
 
         self._title = title
     
@@ -98,27 +104,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(Tax, dict):
+        if issubclass(TaxCreate, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, Tax):
+        if not isinstance(other, TaxCreate):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/tax_class.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/tax_class.py`

 * *Files 14% similar despite different names*

```diff
@@ -44,49 +44,49 @@
         
 
     
     @property
     def id(self):
         """Gets the id of this TaxClass.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this TaxClass.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this TaxClass.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this TaxClass.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this TaxClass.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this TaxClass.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this TaxClass.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this TaxClass.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -115,26 +115,26 @@
 
         self._name = name
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this TaxClass.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this TaxClass.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this TaxClass.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this TaxClass.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -161,49 +161,49 @@
 
         self._space_id = space_id
     
     @property
     def state(self):
         """Gets the state of this TaxClass.
 
-            The object's current state.
+            
 
         :return: The state of this TaxClass.
         :rtype: CreationEntityState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this TaxClass.
 
-            The object's current state.
+            
 
         :param state: The state of this TaxClass.
         :type: CreationEntityState
         """
 
         self._state = state
     
     @property
     def version(self):
         """Gets the version of this TaxClass.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this TaxClass.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this TaxClass.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this TaxClass.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/tax_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/database_translated_string_item_create.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,93 +1,88 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
 
 
 
-class TaxCreate:
+class DatabaseTranslatedStringItemCreate:
 
     swagger_types = {
     
-        'rate': 'float',
-        'title': 'str',
+        'language': 'str',
+        'translation': 'str',
     }
 
     attribute_map = {
-        'rate': 'rate','title': 'title',
+        'language': 'language','translation': 'translation',
     }
 
     
-    _rate = None
-    _title = None
+    _language = None
+    _translation = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
-        self.rate = kwargs.get('rate')
-
-        self.title = kwargs.get('title')
+        self.language = kwargs.get('language')
 
+        self.translation = kwargs.get('translation', None)
         
 
     
     @property
-    def rate(self):
-        """Gets the rate of this TaxCreate.
+    def language(self):
+        """Gets the language of this DatabaseTranslatedStringItemCreate.
 
             
 
-        :return: The rate of this TaxCreate.
-        :rtype: float
+        :return: The language of this DatabaseTranslatedStringItemCreate.
+        :rtype: str
         """
-        return self._rate
+        return self._language
 
-    @rate.setter
-    def rate(self, rate):
-        """Sets the rate of this TaxCreate.
+    @language.setter
+    def language(self, language):
+        """Sets the language of this DatabaseTranslatedStringItemCreate.
 
             
 
-        :param rate: The rate of this TaxCreate.
-        :type: float
+        :param language: The language of this DatabaseTranslatedStringItemCreate.
+        :type: str
         """
-        if rate is None:
-            raise ValueError("Invalid value for `rate`, must not be `None`")
+        if language is None:
+            raise ValueError("Invalid value for `language`, must not be `None`")
 
-        self._rate = rate
+        self._language = language
     
     @property
-    def title(self):
-        """Gets the title of this TaxCreate.
+    def translation(self):
+        """Gets the translation of this DatabaseTranslatedStringItemCreate.
 
             
 
-        :return: The title of this TaxCreate.
+        :return: The translation of this DatabaseTranslatedStringItemCreate.
         :rtype: str
         """
-        return self._title
+        return self._translation
 
-    @title.setter
-    def title(self, title):
-        """Sets the title of this TaxCreate.
+    @translation.setter
+    def translation(self, translation):
+        """Sets the translation of this DatabaseTranslatedStringItemCreate.
 
             
 
-        :param title: The title of this TaxCreate.
+        :param translation: The translation of this DatabaseTranslatedStringItemCreate.
         :type: str
         """
-        if title is None:
-            raise ValueError("Invalid value for `title`, must not be `None`")
-        if title is not None and len(title) > 40:
-            raise ValueError("Invalid value for `title`, length must be less than or equal to `40`")
-        if title is not None and len(title) < 2:
-            raise ValueError("Invalid value for `title`, length must be greater than or equal to `2`")
+        if translation is not None and len(translation) > 16777216:
+            raise ValueError("Invalid value for `translation`, length must be less than or equal to `16777216`")
 
-        self._title = title
+        self._translation = translation
     
 
     def to_dict(self):
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
@@ -104,27 +99,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(TaxCreate, dict):
+        if issubclass(DatabaseTranslatedStringItemCreate, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, TaxCreate):
+        if not isinstance(other, DatabaseTranslatedStringItemCreate):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/tenant_database.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/tenant_database.py`

 * *Files 14% similar despite different names*

```diff
@@ -32,74 +32,74 @@
         
 
     
     @property
     def id(self):
         """Gets the id of this TenantDatabase.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this TenantDatabase.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this TenantDatabase.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this TenantDatabase.
         :type: int
         """
 
         self._id = id
     
     @property
     def name(self):
         """Gets the name of this TenantDatabase.
 
-            The name used to identify the database.
+            The name of the database.
 
         :return: The name of this TenantDatabase.
         :rtype: str
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this TenantDatabase.
 
-            The name used to identify the database.
+            The name of the database.
 
         :param name: The name of this TenantDatabase.
         :type: str
         """
         if name is not None and len(name) > 200:
             raise ValueError("Invalid value for `name`, length must be less than or equal to `200`")
 
         self._name = name
     
     @property
     def version(self):
         """Gets the version of this TenantDatabase.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this TenantDatabase.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this TenantDatabase.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this TenantDatabase.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/token.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/token.py`

 * *Files 7% similar despite different names*

```diff
@@ -62,26 +62,26 @@
         
 
     
     @property
     def created_on(self):
         """Gets the created_on of this Token.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :return: The created_on of this Token.
         :rtype: datetime
         """
         return self._created_on
 
     @created_on.setter
     def created_on(self, created_on):
         """Sets the created_on of this Token.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :param created_on: The created_on of this Token.
         :type: datetime
         """
 
         self._created_on = created_on
     
@@ -179,118 +179,118 @@
 
         self._external_id = external_id
     
     @property
     def id(self):
         """Gets the id of this Token.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this Token.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this Token.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this Token.
         :type: int
         """
 
         self._id = id
     
     @property
     def language(self):
         """Gets the language of this Token.
 
-            The language that is linked to the object.
+            
 
         :return: The language of this Token.
         :rtype: str
         """
         return self._language
 
     @language.setter
     def language(self, language):
         """Sets the language of this Token.
 
-            The language that is linked to the object.
+            
 
         :param language: The language of this Token.
         :type: str
         """
 
         self._language = language
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this Token.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this Token.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this Token.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this Token.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this Token.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this Token.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this Token.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this Token.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
     @property
     def state(self):
         """Gets the state of this Token.
 
-            The object's current state.
+            
 
         :return: The state of this Token.
         :rtype: CreationEntityState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this Token.
 
-            The object's current state.
+            
 
         :param state: The state of this Token.
         :type: CreationEntityState
         """
 
         self._state = state
     
@@ -342,26 +342,26 @@
 
         self._token_reference = token_reference
     
     @property
     def version(self):
         """Gets the version of this Token.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this Token.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this Token.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this Token.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/token_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/token_create.py`

 * *Files 5% similar despite different names*

```diff
@@ -57,26 +57,26 @@
 
         self._external_id = external_id
     
     @property
     def state(self):
         """Gets the state of this TokenCreate.
 
-            The object's current state.
+            
 
         :return: The state of this TokenCreate.
         :rtype: CreationEntityState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this TokenCreate.
 
-            The object's current state.
+            
 
         :param state: The state of this TokenCreate.
         :type: CreationEntityState
         """
 
         self._state = state
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/token_update.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_pending.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
-from . import AbstractTokenUpdate
+from . import AbstractTransactionPending
 
 
-class TokenUpdate(AbstractTokenUpdate):
+class TransactionPending(AbstractTransactionPending):
 
     swagger_types = {
     
         'id': 'int',
         'version': 'int',
     }
 
@@ -31,55 +31,55 @@
         super().__init__(**kwargs)
         self.swagger_types.update(super().swagger_types)
         self.attribute_map.update(super().attribute_map)
 
     
     @property
     def id(self):
-        """Gets the id of this TokenUpdate.
+        """Gets the id of this TransactionPending.
 
             The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
-        :return: The id of this TokenUpdate.
+        :return: The id of this TransactionPending.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
-        """Sets the id of this TokenUpdate.
+        """Sets the id of this TransactionPending.
 
             The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
-        :param id: The id of this TokenUpdate.
+        :param id: The id of this TransactionPending.
         :type: int
         """
         if id is None:
             raise ValueError("Invalid value for `id`, must not be `None`")
 
         self._id = id
     
     @property
     def version(self):
-        """Gets the version of this TokenUpdate.
+        """Gets the version of this TransactionPending.
 
             The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
-        :return: The version of this TokenUpdate.
+        :return: The version of this TransactionPending.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
-        """Sets the version of this TokenUpdate.
+        """Sets the version of this TransactionPending.
 
             The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
-        :param version: The version of this TokenUpdate.
+        :param version: The version of this TransactionPending.
         :type: int
         """
         if version is None:
             raise ValueError("Invalid value for `version`, must not be `None`")
 
         self._version = version
     
@@ -102,27 +102,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(TokenUpdate, dict):
+        if issubclass(TransactionPending, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, TokenUpdate):
+        if not isinstance(other, TransactionPending):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/token_version.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/token_version.py`

 * *Files 10% similar despite different names*

```diff
@@ -138,26 +138,26 @@
 
         self._billing_address = billing_address
     
     @property
     def created_on(self):
         """Gets the created_on of this TokenVersion.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :return: The created_on of this TokenVersion.
         :rtype: datetime
         """
         return self._created_on
 
     @created_on.setter
     def created_on(self, created_on):
         """Sets the created_on of this TokenVersion.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :param created_on: The created_on of this TokenVersion.
         :type: datetime
         """
 
         self._created_on = created_on
     
@@ -230,26 +230,26 @@
 
         self._icon_url = icon_url
     
     @property
     def id(self):
         """Gets the id of this TokenVersion.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this TokenVersion.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this TokenVersion.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this TokenVersion.
         :type: int
         """
 
         self._id = id
     
@@ -276,49 +276,49 @@
 
         self._labels = labels
     
     @property
     def language(self):
         """Gets the language of this TokenVersion.
 
-            The language that is linked to the object.
+            
 
         :return: The language of this TokenVersion.
         :rtype: str
         """
         return self._language
 
     @language.setter
     def language(self, language):
         """Sets the language of this TokenVersion.
 
-            The language that is linked to the object.
+            
 
         :param language: The language of this TokenVersion.
         :type: str
         """
 
         self._language = language
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this TokenVersion.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this TokenVersion.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this TokenVersion.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this TokenVersion.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -462,26 +462,26 @@
 
         self._payment_method_brand = payment_method_brand
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this TokenVersion.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this TokenVersion.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this TokenVersion.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this TokenVersion.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -533,26 +533,26 @@
 
         self._shipping_address = shipping_address
     
     @property
     def state(self):
         """Gets the state of this TokenVersion.
 
-            The object's current state.
+            
 
         :return: The state of this TokenVersion.
         :rtype: TokenVersionState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this TokenVersion.
 
-            The object's current state.
+            
 
         :param state: The state of this TokenVersion.
         :type: TokenVersionState
         """
 
         self._state = state
     
@@ -602,26 +602,26 @@
 
         self._type = type
     
     @property
     def version(self):
         """Gets the version of this TokenVersion.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this TokenVersion.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this TokenVersion.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this TokenVersion.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/token_version_type.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/bank_transaction_type.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,131 +1,105 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
 
 
 
-class TokenVersionType:
+class BankTransactionType:
 
     swagger_types = {
     
         'description': 'dict(str, str)',
-        'feature': 'Feature',
         'id': 'int',
         'name': 'dict(str, str)',
     }
 
     attribute_map = {
-        'description': 'description','feature': 'feature','id': 'id','name': 'name',
+        'description': 'description','id': 'id','name': 'name',
     }
 
     
     _description = None
-    _feature = None
     _id = None
     _name = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
         self.description = kwargs.get('description', None)
-        self.feature = kwargs.get('feature', None)
         self.id = kwargs.get('id', None)
         self.name = kwargs.get('name', None)
         
 
     
     @property
     def description(self):
-        """Gets the description of this TokenVersionType.
+        """Gets the description of this BankTransactionType.
 
-            The localized description of the object.
+            
 
-        :return: The description of this TokenVersionType.
+        :return: The description of this BankTransactionType.
         :rtype: dict(str, str)
         """
         return self._description
 
     @description.setter
     def description(self, description):
-        """Sets the description of this TokenVersionType.
+        """Sets the description of this BankTransactionType.
 
-            The localized description of the object.
+            
 
-        :param description: The description of this TokenVersionType.
+        :param description: The description of this BankTransactionType.
         :type: dict(str, str)
         """
 
         self._description = description
     
     @property
-    def feature(self):
-        """Gets the feature of this TokenVersionType.
-
-            
-
-        :return: The feature of this TokenVersionType.
-        :rtype: Feature
-        """
-        return self._feature
-
-    @feature.setter
-    def feature(self, feature):
-        """Sets the feature of this TokenVersionType.
-
-            
-
-        :param feature: The feature of this TokenVersionType.
-        :type: Feature
-        """
-
-        self._feature = feature
-    
-    @property
     def id(self):
-        """Gets the id of this TokenVersionType.
+        """Gets the id of this BankTransactionType.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
-        :return: The id of this TokenVersionType.
+        :return: The id of this BankTransactionType.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
-        """Sets the id of this TokenVersionType.
+        """Sets the id of this BankTransactionType.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
-        :param id: The id of this TokenVersionType.
+        :param id: The id of this BankTransactionType.
         :type: int
         """
 
         self._id = id
     
     @property
     def name(self):
-        """Gets the name of this TokenVersionType.
+        """Gets the name of this BankTransactionType.
 
-            The localized name of the object.
+            
 
-        :return: The name of this TokenVersionType.
+        :return: The name of this BankTransactionType.
         :rtype: dict(str, str)
         """
         return self._name
 
     @name.setter
     def name(self, name):
-        """Sets the name of this TokenVersionType.
+        """Sets the name of this BankTransactionType.
 
-            The localized name of the object.
+            
 
-        :param name: The name of this TokenVersionType.
+        :param name: The name of this BankTransactionType.
         :type: dict(str, str)
         """
 
         self._name = name
     
 
     def to_dict(self):
@@ -146,27 +120,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(TokenVersionType, dict):
+        if issubclass(BankTransactionType, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, TokenVersionType):
+        if not isinstance(other, BankTransactionType):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/tokenized_card_data.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/tokenized_card_data.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/tokenized_card_data_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/tokenized_card_data_create.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction.py`

 * *Files 3% similar despite different names*

```diff
@@ -7,15 +7,15 @@
 
 class Transaction:
 
     swagger_types = {
     
         'accept_header': 'str',
         'accept_language_header': 'str',
-        'allowed_payment_method_brands': 'list[int]',
+        'allowed_payment_method_brands': 'list[PaymentMethodBrand]',
         'allowed_payment_method_configurations': 'list[int]',
         'authorization_amount': 'float',
         'authorization_environment': 'ChargeAttemptEnvironment',
         'authorization_sales_channel': 'int',
         'authorization_timeout_on': 'datetime',
         'authorized_on': 'datetime',
         'auto_confirmation_enabled': 'bool',
@@ -74,19 +74,18 @@
         'total_settled_amount': 'float',
         'user_agent_header': 'str',
         'user_failure_message': 'str',
         'user_interface_type': 'TransactionUserInterfaceType',
         'version': 'int',
         'window_height': 'str',
         'window_width': 'str',
-        'years_to_keep': 'int',
     }
 
     attribute_map = {
-        'accept_header': 'acceptHeader','accept_language_header': 'acceptLanguageHeader','allowed_payment_method_brands': 'allowedPaymentMethodBrands','allowed_payment_method_configurations': 'allowedPaymentMethodConfigurations','authorization_amount': 'authorizationAmount','authorization_environment': 'authorizationEnvironment','authorization_sales_channel': 'authorizationSalesChannel','authorization_timeout_on': 'authorizationTimeoutOn','authorized_on': 'authorizedOn','auto_confirmation_enabled': 'autoConfirmationEnabled','billing_address': 'billingAddress','charge_retry_enabled': 'chargeRetryEnabled','completed_amount': 'completedAmount','completed_on': 'completedOn','completion_behavior': 'completionBehavior','completion_timeout_on': 'completionTimeoutOn','confirmed_by': 'confirmedBy','confirmed_on': 'confirmedOn','created_by': 'createdBy','created_on': 'createdOn','currency': 'currency','customer_email_address': 'customerEmailAddress','customer_id': 'customerId','customers_presence': 'customersPresence','delivery_decision_made_on': 'deliveryDecisionMadeOn','device_session_identifier': 'deviceSessionIdentifier','emails_disabled': 'emailsDisabled','end_of_life': 'endOfLife','environment': 'environment','environment_selection_strategy': 'environmentSelectionStrategy','failed_on': 'failedOn','failed_url': 'failedUrl','failure_reason': 'failureReason','group': 'group','id': 'id','internet_protocol_address': 'internetProtocolAddress','internet_protocol_address_country': 'internetProtocolAddressCountry','invoice_merchant_reference': 'invoiceMerchantReference','java_enabled': 'javaEnabled','language': 'language','line_items': 'lineItems','linked_space_id': 'linkedSpaceId','merchant_reference': 'merchantReference','meta_data': 'metaData','parent': 'parent','payment_connector_configuration': 'paymentConnectorConfiguration','planned_purge_date': 'plannedPurgeDate','processing_on': 'processingOn','refunded_amount': 'refundedAmount','screen_color_depth': 'screenColorDepth','screen_height': 'screenHeight','screen_width': 'screenWidth','shipping_address': 'shippingAddress','shipping_method': 'shippingMethod','space_view_id': 'spaceViewId','state': 'state','success_url': 'successUrl','terminal': 'terminal','time_zone': 'timeZone','token': 'token','tokenization_mode': 'tokenizationMode','total_applied_fees': 'totalAppliedFees','total_settled_amount': 'totalSettledAmount','user_agent_header': 'userAgentHeader','user_failure_message': 'userFailureMessage','user_interface_type': 'userInterfaceType','version': 'version','window_height': 'windowHeight','window_width': 'windowWidth','years_to_keep': 'yearsToKeep',
+        'accept_header': 'acceptHeader','accept_language_header': 'acceptLanguageHeader','allowed_payment_method_brands': 'allowedPaymentMethodBrands','allowed_payment_method_configurations': 'allowedPaymentMethodConfigurations','authorization_amount': 'authorizationAmount','authorization_environment': 'authorizationEnvironment','authorization_sales_channel': 'authorizationSalesChannel','authorization_timeout_on': 'authorizationTimeoutOn','authorized_on': 'authorizedOn','auto_confirmation_enabled': 'autoConfirmationEnabled','billing_address': 'billingAddress','charge_retry_enabled': 'chargeRetryEnabled','completed_amount': 'completedAmount','completed_on': 'completedOn','completion_behavior': 'completionBehavior','completion_timeout_on': 'completionTimeoutOn','confirmed_by': 'confirmedBy','confirmed_on': 'confirmedOn','created_by': 'createdBy','created_on': 'createdOn','currency': 'currency','customer_email_address': 'customerEmailAddress','customer_id': 'customerId','customers_presence': 'customersPresence','delivery_decision_made_on': 'deliveryDecisionMadeOn','device_session_identifier': 'deviceSessionIdentifier','emails_disabled': 'emailsDisabled','end_of_life': 'endOfLife','environment': 'environment','environment_selection_strategy': 'environmentSelectionStrategy','failed_on': 'failedOn','failed_url': 'failedUrl','failure_reason': 'failureReason','group': 'group','id': 'id','internet_protocol_address': 'internetProtocolAddress','internet_protocol_address_country': 'internetProtocolAddressCountry','invoice_merchant_reference': 'invoiceMerchantReference','java_enabled': 'javaEnabled','language': 'language','line_items': 'lineItems','linked_space_id': 'linkedSpaceId','merchant_reference': 'merchantReference','meta_data': 'metaData','parent': 'parent','payment_connector_configuration': 'paymentConnectorConfiguration','planned_purge_date': 'plannedPurgeDate','processing_on': 'processingOn','refunded_amount': 'refundedAmount','screen_color_depth': 'screenColorDepth','screen_height': 'screenHeight','screen_width': 'screenWidth','shipping_address': 'shippingAddress','shipping_method': 'shippingMethod','space_view_id': 'spaceViewId','state': 'state','success_url': 'successUrl','terminal': 'terminal','time_zone': 'timeZone','token': 'token','tokenization_mode': 'tokenizationMode','total_applied_fees': 'totalAppliedFees','total_settled_amount': 'totalSettledAmount','user_agent_header': 'userAgentHeader','user_failure_message': 'userFailureMessage','user_interface_type': 'userInterfaceType','version': 'version','window_height': 'windowHeight','window_width': 'windowWidth',
     }
 
     
     _accept_header = None
     _accept_language_header = None
     _allowed_payment_method_brands = None
     _allowed_payment_method_configurations = None
@@ -151,15 +150,14 @@
     _total_settled_amount = None
     _user_agent_header = None
     _user_failure_message = None
     _user_interface_type = None
     _version = None
     _window_height = None
     _window_width = None
-    _years_to_keep = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
         self.accept_header = kwargs.get('accept_header', None)
         self.accept_language_header = kwargs.get('accept_language_header', None)
         self.allowed_payment_method_brands = kwargs.get('allowed_payment_method_brands', None)
@@ -225,15 +223,14 @@
         self.total_settled_amount = kwargs.get('total_settled_amount', None)
         self.user_agent_header = kwargs.get('user_agent_header', None)
         self.user_failure_message = kwargs.get('user_failure_message', None)
         self.user_interface_type = kwargs.get('user_interface_type', None)
         self.version = kwargs.get('version', None)
         self.window_height = kwargs.get('window_height', None)
         self.window_width = kwargs.get('window_width', None)
-        self.years_to_keep = kwargs.get('years_to_keep', None)
         
 
     
     @property
     def accept_header(self):
         """Gets the accept_header of this Transaction.
 
@@ -282,26 +279,26 @@
     @property
     def allowed_payment_method_brands(self):
         """Gets the allowed_payment_method_brands of this Transaction.
 
             
 
         :return: The allowed_payment_method_brands of this Transaction.
-        :rtype: list[int]
+        :rtype: list[PaymentMethodBrand]
         """
         return self._allowed_payment_method_brands
 
     @allowed_payment_method_brands.setter
     def allowed_payment_method_brands(self, allowed_payment_method_brands):
         """Sets the allowed_payment_method_brands of this Transaction.
 
             
 
         :param allowed_payment_method_brands: The allowed_payment_method_brands of this Transaction.
-        :type: list[int]
+        :type: list[PaymentMethodBrand]
         """
 
         self._allowed_payment_method_brands = allowed_payment_method_brands
     
     @property
     def allowed_payment_method_configurations(self):
         """Gets the allowed_payment_method_configurations of this Transaction.
@@ -670,26 +667,26 @@
 
         self._created_by = created_by
     
     @property
     def created_on(self):
         """Gets the created_on of this Transaction.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :return: The created_on of this Transaction.
         :rtype: datetime
         """
         return self._created_on
 
     @created_on.setter
     def created_on(self, created_on):
         """Sets the created_on of this Transaction.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :param created_on: The created_on of this Transaction.
         :type: datetime
         """
 
         self._created_on = created_on
     
@@ -764,26 +761,26 @@
 
         self._customer_id = customer_id
     
     @property
     def customers_presence(self):
         """Gets the customers_presence of this Transaction.
 
-            The customer's presence indicates what kind of authentication method was finally used during authorization of the transaction. If no value is provided, 'Virtually Present' is used by default.
+            The customer's presence indicates what kind of authentication methods can be used during the authorization of the transaction. If no value is provided, 'Virtually Present' is used by default.
 
         :return: The customers_presence of this Transaction.
         :rtype: CustomersPresence
         """
         return self._customers_presence
 
     @customers_presence.setter
     def customers_presence(self, customers_presence):
         """Sets the customers_presence of this Transaction.
 
-            The customer's presence indicates what kind of authentication method was finally used during authorization of the transaction. If no value is provided, 'Virtually Present' is used by default.
+            The customer's presence indicates what kind of authentication methods can be used during the authorization of the transaction. If no value is provided, 'Virtually Present' is used by default.
 
         :param customers_presence: The customers_presence of this Transaction.
         :type: CustomersPresence
         """
 
         self._customers_presence = customers_presence
     
@@ -1025,26 +1022,26 @@
 
         self._group = group
     
     @property
     def id(self):
         """Gets the id of this Transaction.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this Transaction.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this Transaction.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this Transaction.
         :type: int
         """
 
         self._id = id
     
@@ -1142,26 +1139,26 @@
 
         self._java_enabled = java_enabled
     
     @property
     def language(self):
         """Gets the language of this Transaction.
 
-            The language that is linked to the object.
+            
 
         :return: The language of this Transaction.
         :rtype: str
         """
         return self._language
 
     @language.setter
     def language(self, language):
         """Sets the language of this Transaction.
 
-            The language that is linked to the object.
+            
 
         :param language: The language of this Transaction.
         :type: str
         """
 
         self._language = language
     
@@ -1188,26 +1185,26 @@
 
         self._line_items = line_items
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this Transaction.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this Transaction.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this Transaction.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this Transaction.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
@@ -1236,26 +1233,26 @@
 
         self._merchant_reference = merchant_reference
     
     @property
     def meta_data(self):
         """Gets the meta_data of this Transaction.
 
-            Allow to store additional information about the object.
+            Meta data allow to store additional data along the object.
 
         :return: The meta_data of this Transaction.
         :rtype: dict(str, str)
         """
         return self._meta_data
 
     @meta_data.setter
     def meta_data(self, meta_data):
         """Sets the meta_data of this Transaction.
 
-            Allow to store additional information about the object.
+            Meta data allow to store additional data along the object.
 
         :param meta_data: The meta_data of this Transaction.
         :type: dict(str, str)
         """
 
         self._meta_data = meta_data
     
@@ -1305,26 +1302,26 @@
 
         self._payment_connector_configuration = payment_connector_configuration
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this Transaction.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this Transaction.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this Transaction.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this Transaction.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -1514,26 +1511,26 @@
 
         self._space_view_id = space_view_id
     
     @property
     def state(self):
         """Gets the state of this Transaction.
 
-            The object's current state.
+            
 
         :return: The state of this Transaction.
         :rtype: TransactionState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this Transaction.
 
-            The object's current state.
+            
 
         :param state: The state of this Transaction.
         :type: TransactionState
         """
 
         self._state = state
     
@@ -1771,26 +1768,26 @@
 
         self._user_interface_type = user_interface_type
     
     @property
     def version(self):
         """Gets the version of this Transaction.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this Transaction.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this Transaction.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this Transaction.
         :type: int
         """
 
         self._version = version
     
@@ -1836,37 +1833,14 @@
 
         :param window_width: The window_width of this Transaction.
         :type: str
         """
 
         self._window_width = window_width
     
-    @property
-    def years_to_keep(self):
-        """Gets the years_to_keep of this Transaction.
-
-            The number of years the transaction will be stored after it has been authorized.
-
-        :return: The years_to_keep of this Transaction.
-        :rtype: int
-        """
-        return self._years_to_keep
-
-    @years_to_keep.setter
-    def years_to_keep(self, years_to_keep):
-        """Sets the years_to_keep of this Transaction.
-
-            The number of years the transaction will be stored after it has been authorized.
-
-        :param years_to_keep: The years_to_keep of this Transaction.
-        :type: int
-        """
-
-        self._years_to_keep = years_to_keep
-    
 
     def to_dict(self):
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_aware_entity.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_aware_entity.py`

 * *Files 5% similar despite different names*

```diff
@@ -32,49 +32,49 @@
         
 
     
     @property
     def id(self):
         """Gets the id of this TransactionAwareEntity.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this TransactionAwareEntity.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this TransactionAwareEntity.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this TransactionAwareEntity.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this TransactionAwareEntity.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this TransactionAwareEntity.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this TransactionAwareEntity.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this TransactionAwareEntity.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_comment.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_comment.py`

 * *Files 4% similar despite different names*

```diff
@@ -53,189 +53,189 @@
         
 
     
     @property
     def content(self):
         """Gets the content of this TransactionComment.
 
-            The comment's actual content.
+            
 
         :return: The content of this TransactionComment.
         :rtype: str
         """
         return self._content
 
     @content.setter
     def content(self, content):
         """Sets the content of this TransactionComment.
 
-            The comment's actual content.
+            
 
         :param content: The content of this TransactionComment.
         :type: str
         """
         if content is not None and len(content) > 262144:
             raise ValueError("Invalid value for `content`, length must be less than or equal to `262144`")
 
         self._content = content
     
     @property
     def created_by(self):
         """Gets the created_by of this TransactionComment.
 
-            The ID of the user the comment was created by.
+            
 
         :return: The created_by of this TransactionComment.
         :rtype: int
         """
         return self._created_by
 
     @created_by.setter
     def created_by(self, created_by):
         """Sets the created_by of this TransactionComment.
 
-            The ID of the user the comment was created by.
+            
 
         :param created_by: The created_by of this TransactionComment.
         :type: int
         """
 
         self._created_by = created_by
     
     @property
     def created_on(self):
         """Gets the created_on of this TransactionComment.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :return: The created_on of this TransactionComment.
         :rtype: datetime
         """
         return self._created_on
 
     @created_on.setter
     def created_on(self, created_on):
         """Sets the created_on of this TransactionComment.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :param created_on: The created_on of this TransactionComment.
         :type: datetime
         """
 
         self._created_on = created_on
     
     @property
     def edited_by(self):
         """Gets the edited_by of this TransactionComment.
 
-            The ID of the user the comment was last updated by.
+            
 
         :return: The edited_by of this TransactionComment.
         :rtype: int
         """
         return self._edited_by
 
     @edited_by.setter
     def edited_by(self, edited_by):
         """Sets the edited_by of this TransactionComment.
 
-            The ID of the user the comment was last updated by.
+            
 
         :param edited_by: The edited_by of this TransactionComment.
         :type: int
         """
 
         self._edited_by = edited_by
     
     @property
     def edited_on(self):
         """Gets the edited_on of this TransactionComment.
 
-            The date and time when the comment was last updated.
+            The date on which the comment was last edited.
 
         :return: The edited_on of this TransactionComment.
         :rtype: datetime
         """
         return self._edited_on
 
     @edited_on.setter
     def edited_on(self, edited_on):
         """Sets the edited_on of this TransactionComment.
 
-            The date and time when the comment was last updated.
+            The date on which the comment was last edited.
 
         :param edited_on: The edited_on of this TransactionComment.
         :type: datetime
         """
 
         self._edited_on = edited_on
     
     @property
     def id(self):
         """Gets the id of this TransactionComment.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this TransactionComment.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this TransactionComment.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this TransactionComment.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this TransactionComment.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this TransactionComment.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this TransactionComment.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this TransactionComment.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
     @property
     def pinned(self):
         """Gets the pinned of this TransactionComment.
 
-            Whether the comment is pinned to the top.
+            
 
         :return: The pinned of this TransactionComment.
         :rtype: bool
         """
         return self._pinned
 
     @pinned.setter
     def pinned(self, pinned):
         """Sets the pinned of this TransactionComment.
 
-            Whether the comment is pinned to the top.
+            
 
         :param pinned: The pinned of this TransactionComment.
         :type: bool
         """
 
         self._pinned = pinned
     
@@ -262,26 +262,26 @@
 
         self._transaction = transaction
     
     @property
     def version(self):
         """Gets the version of this TransactionComment.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this TransactionComment.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this TransactionComment.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this TransactionComment.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_comment_active.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_comment_active.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_comment_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_comment_create.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_completion_request.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_completion_request.py`

 * *Files 26% similar despite different names*

```diff
@@ -9,40 +9,37 @@
 
     swagger_types = {
     
         'external_id': 'str',
         'invoice_merchant_reference': 'str',
         'last_completion': 'bool',
         'line_items': 'list[CompletionLineItemCreate]',
-        'statement_descriptor': 'str',
         'transaction_id': 'int',
     }
 
     attribute_map = {
-        'external_id': 'externalId','invoice_merchant_reference': 'invoiceMerchantReference','last_completion': 'lastCompletion','line_items': 'lineItems','statement_descriptor': 'statementDescriptor','transaction_id': 'transactionId',
+        'external_id': 'externalId','invoice_merchant_reference': 'invoiceMerchantReference','last_completion': 'lastCompletion','line_items': 'lineItems','transaction_id': 'transactionId',
     }
 
     
     _external_id = None
     _invoice_merchant_reference = None
     _last_completion = None
     _line_items = None
-    _statement_descriptor = None
     _transaction_id = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
         self.external_id = kwargs.get('external_id')
 
         self.invoice_merchant_reference = kwargs.get('invoice_merchant_reference', None)
         self.last_completion = kwargs.get('last_completion')
 
         self.line_items = kwargs.get('line_items', None)
-        self.statement_descriptor = kwargs.get('statement_descriptor', None)
         self.transaction_id = kwargs.get('transaction_id')
 
         
 
     
     @property
     def external_id(self):
@@ -143,39 +140,14 @@
         :param line_items: The line_items of this TransactionCompletionRequest.
         :type: list[CompletionLineItemCreate]
         """
 
         self._line_items = line_items
     
     @property
-    def statement_descriptor(self):
-        """Gets the statement_descriptor of this TransactionCompletionRequest.
-
-            The statement descriptor explain charges or payments on bank statements.
-
-        :return: The statement_descriptor of this TransactionCompletionRequest.
-        :rtype: str
-        """
-        return self._statement_descriptor
-
-    @statement_descriptor.setter
-    def statement_descriptor(self, statement_descriptor):
-        """Sets the statement_descriptor of this TransactionCompletionRequest.
-
-            The statement descriptor explain charges or payments on bank statements.
-
-        :param statement_descriptor: The statement_descriptor of this TransactionCompletionRequest.
-        :type: str
-        """
-        if statement_descriptor is not None and len(statement_descriptor) > 80:
-            raise ValueError("Invalid value for `statement_descriptor`, length must be less than or equal to `80`")
-
-        self._statement_descriptor = statement_descriptor
-    
-    @property
     def transaction_id(self):
         """Gets the transaction_id of this TransactionCompletionRequest.
 
             The ID of the transaction which should be completed.
 
         :return: The transaction_id of this TransactionCompletionRequest.
         :rtype: int
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_create.py`

 * *Files 1% similar despite different names*

```diff
@@ -95,26 +95,26 @@
 
         self._charge_retry_enabled = charge_retry_enabled
     
     @property
     def customers_presence(self):
         """Gets the customers_presence of this TransactionCreate.
 
-            The customer's presence indicates what kind of authentication method was finally used during authorization of the transaction. If no value is provided, 'Virtually Present' is used by default.
+            The customer's presence indicates what kind of authentication methods can be used during the authorization of the transaction. If no value is provided, 'Virtually Present' is used by default.
 
         :return: The customers_presence of this TransactionCreate.
         :rtype: CustomersPresence
         """
         return self._customers_presence
 
     @customers_presence.setter
     def customers_presence(self, customers_presence):
         """Sets the customers_presence of this TransactionCreate.
 
-            The customer's presence indicates what kind of authentication method was finally used during authorization of the transaction. If no value is provided, 'Virtually Present' is used by default.
+            The customer's presence indicates what kind of authentication methods can be used during the authorization of the transaction. If no value is provided, 'Virtually Present' is used by default.
 
         :param customers_presence: The customers_presence of this TransactionCreate.
         :type: CustomersPresence
         """
 
         self._customers_presence = customers_presence
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_group.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_group.py`

 * *Files 6% similar despite different names*

```diff
@@ -118,118 +118,118 @@
 
         self._end_date = end_date
     
     @property
     def id(self):
         """Gets the id of this TransactionGroup.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this TransactionGroup.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this TransactionGroup.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this TransactionGroup.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this TransactionGroup.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this TransactionGroup.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this TransactionGroup.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this TransactionGroup.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this TransactionGroup.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this TransactionGroup.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this TransactionGroup.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this TransactionGroup.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
     @property
     def state(self):
         """Gets the state of this TransactionGroup.
 
-            The object's current state.
+            
 
         :return: The state of this TransactionGroup.
         :rtype: TransactionGroupState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this TransactionGroup.
 
-            The object's current state.
+            
 
         :param state: The state of this TransactionGroup.
         :type: TransactionGroupState
         """
 
         self._state = state
     
     @property
     def version(self):
         """Gets the version of this TransactionGroup.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this TransactionGroup.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this TransactionGroup.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this TransactionGroup.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_invoice.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_invoice.py`

 * *Files 2% similar despite different names*

```diff
@@ -296,26 +296,26 @@
 
         self._external_id = external_id
     
     @property
     def language(self):
         """Gets the language of this TransactionInvoice.
 
-            The language that is linked to the object.
+            
 
         :return: The language of this TransactionInvoice.
         :rtype: str
         """
         return self._language
 
     @language.setter
     def language(self, language):
         """Sets the language of this TransactionInvoice.
 
-            The language that is linked to the object.
+            
 
         :param language: The language of this TransactionInvoice.
         :type: str
         """
 
         self._language = language
     
@@ -413,26 +413,26 @@
 
         self._paid_on = paid_on
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this TransactionInvoice.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this TransactionInvoice.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this TransactionInvoice.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this TransactionInvoice.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -459,26 +459,26 @@
 
         self._space_view_id = space_view_id
     
     @property
     def state(self):
         """Gets the state of this TransactionInvoice.
 
-            The object's current state.
+            
 
         :return: The state of this TransactionInvoice.
         :rtype: TransactionInvoiceState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this TransactionInvoice.
 
-            The object's current state.
+            
 
         :param state: The state of this TransactionInvoice.
         :type: TransactionInvoiceState
         """
 
         self._state = state
     
@@ -528,26 +528,26 @@
 
         self._time_zone = time_zone
     
     @property
     def version(self):
         """Gets the version of this TransactionInvoice.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this TransactionInvoice.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this TransactionInvoice.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this TransactionInvoice.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_invoice_comment.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_invoice_comment.py`

 * *Files 7% similar despite different names*

```diff
@@ -53,189 +53,189 @@
         
 
     
     @property
     def content(self):
         """Gets the content of this TransactionInvoiceComment.
 
-            The comment's actual content.
+            
 
         :return: The content of this TransactionInvoiceComment.
         :rtype: str
         """
         return self._content
 
     @content.setter
     def content(self, content):
         """Sets the content of this TransactionInvoiceComment.
 
-            The comment's actual content.
+            
 
         :param content: The content of this TransactionInvoiceComment.
         :type: str
         """
         if content is not None and len(content) > 262144:
             raise ValueError("Invalid value for `content`, length must be less than or equal to `262144`")
 
         self._content = content
     
     @property
     def created_by(self):
         """Gets the created_by of this TransactionInvoiceComment.
 
-            The ID of the user the comment was created by.
+            
 
         :return: The created_by of this TransactionInvoiceComment.
         :rtype: int
         """
         return self._created_by
 
     @created_by.setter
     def created_by(self, created_by):
         """Sets the created_by of this TransactionInvoiceComment.
 
-            The ID of the user the comment was created by.
+            
 
         :param created_by: The created_by of this TransactionInvoiceComment.
         :type: int
         """
 
         self._created_by = created_by
     
     @property
     def created_on(self):
         """Gets the created_on of this TransactionInvoiceComment.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :return: The created_on of this TransactionInvoiceComment.
         :rtype: datetime
         """
         return self._created_on
 
     @created_on.setter
     def created_on(self, created_on):
         """Sets the created_on of this TransactionInvoiceComment.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :param created_on: The created_on of this TransactionInvoiceComment.
         :type: datetime
         """
 
         self._created_on = created_on
     
     @property
     def edited_by(self):
         """Gets the edited_by of this TransactionInvoiceComment.
 
-            The ID of the user the comment was last updated by.
+            
 
         :return: The edited_by of this TransactionInvoiceComment.
         :rtype: int
         """
         return self._edited_by
 
     @edited_by.setter
     def edited_by(self, edited_by):
         """Sets the edited_by of this TransactionInvoiceComment.
 
-            The ID of the user the comment was last updated by.
+            
 
         :param edited_by: The edited_by of this TransactionInvoiceComment.
         :type: int
         """
 
         self._edited_by = edited_by
     
     @property
     def edited_on(self):
         """Gets the edited_on of this TransactionInvoiceComment.
 
-            The date and time when the comment was last updated.
+            The date on which the comment was last edited.
 
         :return: The edited_on of this TransactionInvoiceComment.
         :rtype: datetime
         """
         return self._edited_on
 
     @edited_on.setter
     def edited_on(self, edited_on):
         """Sets the edited_on of this TransactionInvoiceComment.
 
-            The date and time when the comment was last updated.
+            The date on which the comment was last edited.
 
         :param edited_on: The edited_on of this TransactionInvoiceComment.
         :type: datetime
         """
 
         self._edited_on = edited_on
     
     @property
     def id(self):
         """Gets the id of this TransactionInvoiceComment.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this TransactionInvoiceComment.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this TransactionInvoiceComment.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this TransactionInvoiceComment.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this TransactionInvoiceComment.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this TransactionInvoiceComment.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this TransactionInvoiceComment.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this TransactionInvoiceComment.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
     @property
     def pinned(self):
         """Gets the pinned of this TransactionInvoiceComment.
 
-            Whether the comment is pinned to the top.
+            
 
         :return: The pinned of this TransactionInvoiceComment.
         :rtype: bool
         """
         return self._pinned
 
     @pinned.setter
     def pinned(self, pinned):
         """Sets the pinned of this TransactionInvoiceComment.
 
-            Whether the comment is pinned to the top.
+            
 
         :param pinned: The pinned of this TransactionInvoiceComment.
         :type: bool
         """
 
         self._pinned = pinned
     
@@ -262,26 +262,26 @@
 
         self._transaction_invoice = transaction_invoice
     
     @property
     def version(self):
         """Gets the version of this TransactionInvoiceComment.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this TransactionInvoiceComment.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this TransactionInvoiceComment.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this TransactionInvoiceComment.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_invoice_comment_active.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_invoice_comment_active.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_invoice_comment_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_invoice_comment_create.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_invoice_replacement.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_invoice_replacement.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_line_item_version.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_line_item_version.py`

 * *Files 12% similar despite different names*

```diff
@@ -128,26 +128,26 @@
 
         self._created_by = created_by
     
     @property
     def created_on(self):
         """Gets the created_on of this TransactionLineItemVersion.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :return: The created_on of this TransactionLineItemVersion.
         :rtype: datetime
         """
         return self._created_on
 
     @created_on.setter
     def created_on(self, created_on):
         """Sets the created_on of this TransactionLineItemVersion.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :param created_on: The created_on of this TransactionLineItemVersion.
         :type: datetime
         """
 
         self._created_on = created_on
     
@@ -243,26 +243,26 @@
 
         self._labels = labels
     
     @property
     def language(self):
         """Gets the language of this TransactionLineItemVersion.
 
-            The language that is linked to the object.
+            
 
         :return: The language of this TransactionLineItemVersion.
         :rtype: str
         """
         return self._language
 
     @language.setter
     def language(self, language):
         """Sets the language of this TransactionLineItemVersion.
 
-            The language that is linked to the object.
+            
 
         :param language: The language of this TransactionLineItemVersion.
         :type: str
         """
 
         self._language = language
     
@@ -312,26 +312,26 @@
 
         self._next_update_on = next_update_on
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this TransactionLineItemVersion.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this TransactionLineItemVersion.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this TransactionLineItemVersion.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this TransactionLineItemVersion.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -381,26 +381,26 @@
 
         self._space_view_id = space_view_id
     
     @property
     def state(self):
         """Gets the state of this TransactionLineItemVersion.
 
-            The object's current state.
+            
 
         :return: The state of this TransactionLineItemVersion.
         :rtype: TransactionLineItemVersionState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this TransactionLineItemVersion.
 
-            The object's current state.
+            
 
         :param state: The state of this TransactionLineItemVersion.
         :type: TransactionLineItemVersionState
         """
 
         self._state = state
     
@@ -496,26 +496,26 @@
 
         self._transaction = transaction
     
     @property
     def version(self):
         """Gets the version of this TransactionLineItemVersion.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this TransactionLineItemVersion.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this TransactionLineItemVersion.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this TransactionLineItemVersion.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_line_item_version_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_line_item_version_create.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_pending.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/webhook_listener_update.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
-from . import AbstractTransactionPending
+from . import AbstractWebhookListenerUpdate
 
 
-class TransactionPending(AbstractTransactionPending):
+class WebhookListenerUpdate(AbstractWebhookListenerUpdate):
 
     swagger_types = {
     
         'id': 'int',
         'version': 'int',
     }
 
@@ -31,55 +31,55 @@
         super().__init__(**kwargs)
         self.swagger_types.update(super().swagger_types)
         self.attribute_map.update(super().attribute_map)
 
     
     @property
     def id(self):
-        """Gets the id of this TransactionPending.
+        """Gets the id of this WebhookListenerUpdate.
 
             The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
-        :return: The id of this TransactionPending.
+        :return: The id of this WebhookListenerUpdate.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
-        """Sets the id of this TransactionPending.
+        """Sets the id of this WebhookListenerUpdate.
 
             The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
-        :param id: The id of this TransactionPending.
+        :param id: The id of this WebhookListenerUpdate.
         :type: int
         """
         if id is None:
             raise ValueError("Invalid value for `id`, must not be `None`")
 
         self._id = id
     
     @property
     def version(self):
-        """Gets the version of this TransactionPending.
+        """Gets the version of this WebhookListenerUpdate.
 
             The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
-        :return: The version of this TransactionPending.
+        :return: The version of this WebhookListenerUpdate.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
-        """Sets the version of this TransactionPending.
+        """Sets the version of this WebhookListenerUpdate.
 
             The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
-        :param version: The version of this TransactionPending.
+        :param version: The version of this WebhookListenerUpdate.
         :type: int
         """
         if version is None:
             raise ValueError("Invalid value for `version`, must not be `None`")
 
         self._version = version
     
@@ -102,27 +102,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(TransactionPending, dict):
+        if issubclass(WebhookListenerUpdate, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, TransactionPending):
+        if not isinstance(other, WebhookListenerUpdate):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/transaction_void.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/transaction_void.py`

 * *Files 6% similar despite different names*

```diff
@@ -96,26 +96,26 @@
 
         self._created_by = created_by
     
     @property
     def created_on(self):
         """Gets the created_on of this TransactionVoid.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :return: The created_on of this TransactionVoid.
         :rtype: datetime
         """
         return self._created_on
 
     @created_on.setter
     def created_on(self, created_on):
         """Sets the created_on of this TransactionVoid.
 
-            The date and time when the object was created.
+            The created on date indicates the date on which the entity was stored into the database.
 
         :param created_on: The created_on of this TransactionVoid.
         :type: datetime
         """
 
         self._created_on = created_on
     
@@ -188,26 +188,26 @@
 
         self._labels = labels
     
     @property
     def language(self):
         """Gets the language of this TransactionVoid.
 
-            The language that is linked to the object.
+            
 
         :return: The language of this TransactionVoid.
         :rtype: str
         """
         return self._language
 
     @language.setter
     def language(self, language):
         """Sets the language of this TransactionVoid.
 
-            The language that is linked to the object.
+            
 
         :param language: The language of this TransactionVoid.
         :type: str
         """
 
         self._language = language
     
@@ -257,26 +257,26 @@
 
         self._next_update_on = next_update_on
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this TransactionVoid.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this TransactionVoid.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this TransactionVoid.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this TransactionVoid.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
@@ -326,26 +326,26 @@
 
         self._space_view_id = space_view_id
     
     @property
     def state(self):
         """Gets the state of this TransactionVoid.
 
-            The object's current state.
+            
 
         :return: The state of this TransactionVoid.
         :rtype: TransactionVoidState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this TransactionVoid.
 
-            The object's current state.
+            
 
         :param state: The state of this TransactionVoid.
         :type: TransactionVoidState
         """
 
         self._state = state
     
@@ -418,26 +418,26 @@
 
         self._transaction = transaction
     
     @property
     def version(self):
         """Gets the version of this TransactionVoid.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this TransactionVoid.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this TransactionVoid.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this TransactionVoid.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/two_factor_authentication_type.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/two_factor_authentication_type.py`

 * *Files 18% similar despite different names*

```diff
@@ -38,118 +38,118 @@
         
 
     
     @property
     def description(self):
         """Gets the description of this TwoFactorAuthenticationType.
 
-            The localized description of the object.
+            
 
         :return: The description of this TwoFactorAuthenticationType.
         :rtype: dict(str, str)
         """
         return self._description
 
     @description.setter
     def description(self, description):
         """Sets the description of this TwoFactorAuthenticationType.
 
-            The localized description of the object.
+            
 
         :param description: The description of this TwoFactorAuthenticationType.
         :type: dict(str, str)
         """
 
         self._description = description
     
     @property
     def feature(self):
         """Gets the feature of this TwoFactorAuthenticationType.
 
-            The feature that this type belongs to.
+            
 
         :return: The feature of this TwoFactorAuthenticationType.
         :rtype: int
         """
         return self._feature
 
     @feature.setter
     def feature(self, feature):
         """Sets the feature of this TwoFactorAuthenticationType.
 
-            The feature that this type belongs to.
+            
 
         :param feature: The feature of this TwoFactorAuthenticationType.
         :type: int
         """
 
         self._feature = feature
     
     @property
     def icon(self):
         """Gets the icon of this TwoFactorAuthenticationType.
 
-            The identifier of the icon representing this type.
+            
 
         :return: The icon of this TwoFactorAuthenticationType.
         :rtype: str
         """
         return self._icon
 
     @icon.setter
     def icon(self, icon):
         """Sets the icon of this TwoFactorAuthenticationType.
 
-            The identifier of the icon representing this type.
+            
 
         :param icon: The icon of this TwoFactorAuthenticationType.
         :type: str
         """
 
         self._icon = icon
     
     @property
     def id(self):
         """Gets the id of this TwoFactorAuthenticationType.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this TwoFactorAuthenticationType.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this TwoFactorAuthenticationType.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this TwoFactorAuthenticationType.
         :type: int
         """
 
         self._id = id
     
     @property
     def name(self):
         """Gets the name of this TwoFactorAuthenticationType.
 
-            The localized name of the object.
+            
 
         :return: The name of this TwoFactorAuthenticationType.
         :rtype: dict(str, str)
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this TwoFactorAuthenticationType.
 
-            The localized name of the object.
+            
 
         :param name: The name of this TwoFactorAuthenticationType.
         :type: dict(str, str)
         """
 
         self._name = name
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/user.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/user.py`

 * *Files 9% similar despite different names*

```diff
@@ -7,15 +7,15 @@
 
 class User:
 
     swagger_types = {
     
         'id': 'int',
         'planned_purge_date': 'datetime',
-        'scope': 'int',
+        'scope': 'Scope',
         'state': 'CreationEntityState',
         'user_type': 'UserType',
         'version': 'int',
     }
 
     attribute_map = {
         'id': 'id','planned_purge_date': 'plannedPurgeDate','scope': 'scope','state': 'state','user_type': 'userType','version': 'version',
@@ -41,141 +41,141 @@
         
 
     
     @property
     def id(self):
         """Gets the id of this User.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this User.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this User.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this User.
         :type: int
         """
 
         self._id = id
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this User.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this User.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this User.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this User.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
     @property
     def scope(self):
         """Gets the scope of this User.
 
-            The scope that the user belongs to.
+            
 
         :return: The scope of this User.
-        :rtype: int
+        :rtype: Scope
         """
         return self._scope
 
     @scope.setter
     def scope(self, scope):
         """Sets the scope of this User.
 
-            The scope that the user belongs to.
+            
 
         :param scope: The scope of this User.
-        :type: int
+        :type: Scope
         """
 
         self._scope = scope
     
     @property
     def state(self):
         """Gets the state of this User.
 
-            The object's current state.
+            
 
         :return: The state of this User.
         :rtype: CreationEntityState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this User.
 
-            The object's current state.
+            
 
         :param state: The state of this User.
         :type: CreationEntityState
         """
 
         self._state = state
     
     @property
     def user_type(self):
         """Gets the user_type of this User.
 
-            The user's type which defines its role and capabilities.
+            
 
         :return: The user_type of this User.
         :rtype: UserType
         """
         return self._user_type
 
     @user_type.setter
     def user_type(self, user_type):
         """Sets the user_type of this User.
 
-            The user's type which defines its role and capabilities.
+            
 
         :param user_type: The user_type of this User.
         :type: UserType
         """
 
         self._user_type = user_type
     
     @property
     def version(self):
         """Gets the version of this User.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this User.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this User.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this User.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/user_account_role.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/user_account_role.py`

 * *Files 16% similar despite different names*

```diff
@@ -87,26 +87,26 @@
 
         self._applies_on_sub_account = applies_on_sub_account
     
     @property
     def id(self):
         """Gets the id of this UserAccountRole.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this UserAccountRole.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this UserAccountRole.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this UserAccountRole.
         :type: int
         """
 
         self._id = id
     
@@ -156,26 +156,26 @@
 
         self._user = user
     
     @property
     def version(self):
         """Gets the version of this UserAccountRole.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this UserAccountRole.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this UserAccountRole.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this UserAccountRole.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/web_app_confirmation_request.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/web_app_confirmation_request.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/web_app_confirmation_response.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/web_app_confirmation_response.py`

 * *Files identical despite different names*

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/webhook_identity.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/webhook_identity.py`

 * *Files 9% similar despite different names*

```diff
@@ -41,143 +41,143 @@
         
 
     
     @property
     def id(self):
         """Gets the id of this WebhookIdentity.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this WebhookIdentity.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this WebhookIdentity.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this WebhookIdentity.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this WebhookIdentity.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this WebhookIdentity.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this WebhookIdentity.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this WebhookIdentity.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
     @property
     def name(self):
         """Gets the name of this WebhookIdentity.
 
-            The name used to identify the webhook identity.
+            The identity name is used internally to identify the webhook identity in administrative interfaces. For example it is used within search fields and hence it should be distinct and descriptive.
 
         :return: The name of this WebhookIdentity.
         :rtype: str
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this WebhookIdentity.
 
-            The name used to identify the webhook identity.
+            The identity name is used internally to identify the webhook identity in administrative interfaces. For example it is used within search fields and hence it should be distinct and descriptive.
 
         :param name: The name of this WebhookIdentity.
         :type: str
         """
         if name is not None and len(name) > 50:
             raise ValueError("Invalid value for `name`, length must be less than or equal to `50`")
 
         self._name = name
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this WebhookIdentity.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this WebhookIdentity.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this WebhookIdentity.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this WebhookIdentity.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
     @property
     def state(self):
         """Gets the state of this WebhookIdentity.
 
-            The object's current state.
+            
 
         :return: The state of this WebhookIdentity.
         :rtype: CreationEntityState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this WebhookIdentity.
 
-            The object's current state.
+            
 
         :param state: The state of this WebhookIdentity.
         :type: CreationEntityState
         """
 
         self._state = state
     
     @property
     def version(self):
         """Gets the version of this WebhookIdentity.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this WebhookIdentity.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this WebhookIdentity.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this WebhookIdentity.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/webhook_listener.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/webhook_listener.py`

 * *Files 10% similar despite different names*

```diff
@@ -56,258 +56,258 @@
         
 
     
     @property
     def entity(self):
         """Gets the entity of this WebhookListener.
 
-            The entity that is to be monitored.
+            The listener listens on state changes of the entity linked with the listener.
 
         :return: The entity of this WebhookListener.
         :rtype: int
         """
         return self._entity
 
     @entity.setter
     def entity(self, entity):
         """Sets the entity of this WebhookListener.
 
-            The entity that is to be monitored.
+            The listener listens on state changes of the entity linked with the listener.
 
         :param entity: The entity of this WebhookListener.
         :type: int
         """
 
         self._entity = entity
     
     @property
     def entity_states(self):
         """Gets the entity_states of this WebhookListener.
 
-            The entity's target states that are to be monitored.
+            The target state identifies the state into which entities need to move into to trigger the webhook listener.
 
         :return: The entity_states of this WebhookListener.
         :rtype: list[str]
         """
         return self._entity_states
 
     @entity_states.setter
     def entity_states(self, entity_states):
         """Sets the entity_states of this WebhookListener.
 
-            The entity's target states that are to be monitored.
+            The target state identifies the state into which entities need to move into to trigger the webhook listener.
 
         :param entity_states: The entity_states of this WebhookListener.
         :type: list[str]
         """
 
         self._entity_states = entity_states
     
     @property
     def id(self):
         """Gets the id of this WebhookListener.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this WebhookListener.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this WebhookListener.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this WebhookListener.
         :type: int
         """
 
         self._id = id
     
     @property
     def identity(self):
         """Gets the identity of this WebhookListener.
 
-            The identity used to sign messages.
+            The identity which will be used to sign messages sent by this listener.
 
         :return: The identity of this WebhookListener.
         :rtype: WebhookIdentity
         """
         return self._identity
 
     @identity.setter
     def identity(self, identity):
         """Sets the identity of this WebhookListener.
 
-            The identity used to sign messages.
+            The identity which will be used to sign messages sent by this listener.
 
         :param identity: The identity of this WebhookListener.
         :type: WebhookIdentity
         """
 
         self._identity = identity
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this WebhookListener.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this WebhookListener.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this WebhookListener.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this WebhookListener.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
     @property
     def name(self):
         """Gets the name of this WebhookListener.
 
-            The name used to identify the webhook listener.
+            The webhook listener name is used internally to identify the webhook listener in administrative interfaces.For example it is used within search fields and hence it should be distinct and descriptive.
 
         :return: The name of this WebhookListener.
         :rtype: str
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this WebhookListener.
 
-            The name used to identify the webhook listener.
+            The webhook listener name is used internally to identify the webhook listener in administrative interfaces.For example it is used within search fields and hence it should be distinct and descriptive.
 
         :param name: The name of this WebhookListener.
         :type: str
         """
         if name is not None and len(name) > 50:
             raise ValueError("Invalid value for `name`, length must be less than or equal to `50`")
 
         self._name = name
     
     @property
     def notify_every_change(self):
         """Gets the notify_every_change of this WebhookListener.
 
-            Whether every update of the entity or only state changes are to be monitored.
+            Defines whether the webhook listener is to be informed about every change made to the entity in contrast to state transitions only.
 
         :return: The notify_every_change of this WebhookListener.
         :rtype: bool
         """
         return self._notify_every_change
 
     @notify_every_change.setter
     def notify_every_change(self, notify_every_change):
         """Sets the notify_every_change of this WebhookListener.
 
-            Whether every update of the entity or only state changes are to be monitored.
+            Defines whether the webhook listener is to be informed about every change made to the entity in contrast to state transitions only.
 
         :param notify_every_change: The notify_every_change of this WebhookListener.
         :type: bool
         """
 
         self._notify_every_change = notify_every_change
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this WebhookListener.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this WebhookListener.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this WebhookListener.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this WebhookListener.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
     @property
     def state(self):
         """Gets the state of this WebhookListener.
 
-            The object's current state.
+            
 
         :return: The state of this WebhookListener.
         :rtype: CreationEntityState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this WebhookListener.
 
-            The object's current state.
+            
 
         :param state: The state of this WebhookListener.
         :type: CreationEntityState
         """
 
         self._state = state
     
     @property
     def url(self):
         """Gets the url of this WebhookListener.
 
-            The URL where notifications about entity changes are sent to.
+            The URL which is invoked by the listener to notify the application about the event.
 
         :return: The url of this WebhookListener.
         :rtype: WebhookUrl
         """
         return self._url
 
     @url.setter
     def url(self, url):
         """Sets the url of this WebhookListener.
 
-            The URL where notifications about entity changes are sent to.
+            The URL which is invoked by the listener to notify the application about the event.
 
         :param url: The url of this WebhookListener.
         :type: WebhookUrl
         """
 
         self._url = url
     
     @property
     def version(self):
         """Gets the version of this WebhookListener.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this WebhookListener.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this WebhookListener.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this WebhookListener.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/webhook_listener_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/webhook_listener_create.py`

 * *Files 12% similar despite different names*

```diff
@@ -36,74 +36,74 @@
         self.attribute_map.update(super().attribute_map)
 
     
     @property
     def entity(self):
         """Gets the entity of this WebhookListenerCreate.
 
-            The entity that is to be monitored.
+            The listener listens on state changes of the entity linked with the listener.
 
         :return: The entity of this WebhookListenerCreate.
         :rtype: int
         """
         return self._entity
 
     @entity.setter
     def entity(self, entity):
         """Sets the entity of this WebhookListenerCreate.
 
-            The entity that is to be monitored.
+            The listener listens on state changes of the entity linked with the listener.
 
         :param entity: The entity of this WebhookListenerCreate.
         :type: int
         """
         if entity is None:
             raise ValueError("Invalid value for `entity`, must not be `None`")
 
         self._entity = entity
     
     @property
     def identity(self):
         """Gets the identity of this WebhookListenerCreate.
 
-            The identity used to sign messages.
+            The identity which will be used to sign messages sent by this listener.
 
         :return: The identity of this WebhookListenerCreate.
         :rtype: int
         """
         return self._identity
 
     @identity.setter
     def identity(self, identity):
         """Sets the identity of this WebhookListenerCreate.
 
-            The identity used to sign messages.
+            The identity which will be used to sign messages sent by this listener.
 
         :param identity: The identity of this WebhookListenerCreate.
         :type: int
         """
 
         self._identity = identity
     
     @property
     def url(self):
         """Gets the url of this WebhookListenerCreate.
 
-            The URL where notifications about entity changes are sent to.
+            The URL which is invoked by the listener to notify the application about the event.
 
         :return: The url of this WebhookListenerCreate.
         :rtype: int
         """
         return self._url
 
     @url.setter
     def url(self, url):
         """Sets the url of this WebhookListenerCreate.
 
-            The URL where notifications about entity changes are sent to.
+            The URL which is invoked by the listener to notify the application about the event.
 
         :param url: The url of this WebhookListenerCreate.
         :type: int
         """
         if url is None:
             raise ValueError("Invalid value for `url`, must not be `None`")
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/webhook_listener_entity.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/webhook_listener_entity.py`

 * *Files 16% similar despite different names*

```diff
@@ -32,72 +32,72 @@
         
 
     
     @property
     def id(self):
         """Gets the id of this WebhookListenerEntity.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this WebhookListenerEntity.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this WebhookListenerEntity.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this WebhookListenerEntity.
         :type: int
         """
 
         self._id = id
     
     @property
     def name(self):
         """Gets the name of this WebhookListenerEntity.
 
-            The name used to identify the webhook listener entity.
+            
 
         :return: The name of this WebhookListenerEntity.
         :rtype: dict(str, str)
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this WebhookListenerEntity.
 
-            The name used to identify the webhook listener entity.
+            
 
         :param name: The name of this WebhookListenerEntity.
         :type: dict(str, str)
         """
 
         self._name = name
     
     @property
     def technical_name(self):
         """Gets the technical_name of this WebhookListenerEntity.
 
-            The name used to programmatically identify the webhook listener entity.
+            
 
         :return: The technical_name of this WebhookListenerEntity.
         :rtype: str
         """
         return self._technical_name
 
     @technical_name.setter
     def technical_name(self, technical_name):
         """Sets the technical_name of this WebhookListenerEntity.
 
-            The name used to programmatically identify the webhook listener entity.
+            
 
         :param technical_name: The technical_name of this WebhookListenerEntity.
         :type: str
         """
 
         self._technical_name = technical_name
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/webhook_url.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/webhook_url.py`

 * *Files 9% similar despite different names*

```diff
@@ -47,166 +47,166 @@
         
 
     
     @property
     def application_managed(self):
         """Gets the application_managed of this WebhookUrl.
 
-            Whether the webhook URL is managed by the application, and therefore cannot be changed via the user interface.
+            The webhook URL is managed by the application and cannot be changed via the user interface.
 
         :return: The application_managed of this WebhookUrl.
         :rtype: bool
         """
         return self._application_managed
 
     @application_managed.setter
     def application_managed(self, application_managed):
         """Sets the application_managed of this WebhookUrl.
 
-            Whether the webhook URL is managed by the application, and therefore cannot be changed via the user interface.
+            The webhook URL is managed by the application and cannot be changed via the user interface.
 
         :param application_managed: The application_managed of this WebhookUrl.
         :type: bool
         """
 
         self._application_managed = application_managed
     
     @property
     def id(self):
         """Gets the id of this WebhookUrl.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :return: The id of this WebhookUrl.
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this WebhookUrl.
 
-            A unique identifier for the object.
+            The ID is the primary key of the entity. The ID identifies the entity uniquely.
 
         :param id: The id of this WebhookUrl.
         :type: int
         """
 
         self._id = id
     
     @property
     def linked_space_id(self):
         """Gets the linked_space_id of this WebhookUrl.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :return: The linked_space_id of this WebhookUrl.
         :rtype: int
         """
         return self._linked_space_id
 
     @linked_space_id.setter
     def linked_space_id(self, linked_space_id):
         """Sets the linked_space_id of this WebhookUrl.
 
-            The ID of the space this object belongs to.
+            The linked space id holds the ID of the space to which the entity belongs to.
 
         :param linked_space_id: The linked_space_id of this WebhookUrl.
         :type: int
         """
 
         self._linked_space_id = linked_space_id
     
     @property
     def name(self):
         """Gets the name of this WebhookUrl.
 
-            The name used to identify the webhook URL.
+            The URL name is used internally to identify the URL in administrative interfaces. For example it is used within search fields and hence it should be distinct and descriptive.
 
         :return: The name of this WebhookUrl.
         :rtype: str
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this WebhookUrl.
 
-            The name used to identify the webhook URL.
+            The URL name is used internally to identify the URL in administrative interfaces. For example it is used within search fields and hence it should be distinct and descriptive.
 
         :param name: The name of this WebhookUrl.
         :type: str
         """
         if name is not None and len(name) > 50:
             raise ValueError("Invalid value for `name`, length must be less than or equal to `50`")
 
         self._name = name
     
     @property
     def planned_purge_date(self):
         """Gets the planned_purge_date of this WebhookUrl.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :return: The planned_purge_date of this WebhookUrl.
         :rtype: datetime
         """
         return self._planned_purge_date
 
     @planned_purge_date.setter
     def planned_purge_date(self, planned_purge_date):
         """Sets the planned_purge_date of this WebhookUrl.
 
-            The date and time when the object is planned to be permanently removed. If the value is empty, the object will not be removed.
+            The planned purge date indicates when the entity is permanently removed. When the date is null the entity is not planned to be removed.
 
         :param planned_purge_date: The planned_purge_date of this WebhookUrl.
         :type: datetime
         """
 
         self._planned_purge_date = planned_purge_date
     
     @property
     def state(self):
         """Gets the state of this WebhookUrl.
 
-            The object's current state.
+            
 
         :return: The state of this WebhookUrl.
         :rtype: CreationEntityState
         """
         return self._state
 
     @state.setter
     def state(self, state):
         """Sets the state of this WebhookUrl.
 
-            The object's current state.
+            
 
         :param state: The state of this WebhookUrl.
         :type: CreationEntityState
         """
 
         self._state = state
     
     @property
     def url(self):
         """Gets the url of this WebhookUrl.
 
-            The actual URL where notifications about entity changes are sent to.
+            The URL to which the HTTP requests are sent to. An example URL could look like https://www.example.com/some/path?some-query-parameter=value.
 
         :return: The url of this WebhookUrl.
         :rtype: str
         """
         return self._url
 
     @url.setter
     def url(self, url):
         """Sets the url of this WebhookUrl.
 
-            The actual URL where notifications about entity changes are sent to.
+            The URL to which the HTTP requests are sent to. An example URL could look like https://www.example.com/some/path?some-query-parameter=value.
 
         :param url: The url of this WebhookUrl.
         :type: str
         """
         if url is not None and len(url) > 500:
             raise ValueError("Invalid value for `url`, length must be less than or equal to `500`")
         if url is not None and len(url) < 9:
@@ -214,26 +214,26 @@
 
         self._url = url
     
     @property
     def version(self):
         """Gets the version of this WebhookUrl.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :return: The version of this WebhookUrl.
         :rtype: int
         """
         return self._version
 
     @version.setter
     def version(self, version):
         """Sets the version of this WebhookUrl.
 
-            The version is used for optimistic locking and incremented whenever the object is updated.
+            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
 
         :param version: The version of this WebhookUrl.
         :type: int
         """
 
         self._version = version
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/webhook_url_create.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/database_translated_string_create.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,33 +1,57 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
-from . import AbstractWebhookUrlUpdate
 
 
-class WebhookUrlCreate(AbstractWebhookUrlUpdate):
+
+class DatabaseTranslatedStringCreate:
 
     swagger_types = {
     
+        'items': 'list[DatabaseTranslatedStringItemCreate]',
     }
 
     attribute_map = {
-        
+        'items': 'items',
     }
 
     
+    _items = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
-        super().__init__(**kwargs)
-        self.swagger_types.update(super().swagger_types)
-        self.attribute_map.update(super().attribute_map)
+        self.items = kwargs.get('items', None)
+        
+
+    
+    @property
+    def items(self):
+        """Gets the items of this DatabaseTranslatedStringCreate.
+
+            
+
+        :return: The items of this DatabaseTranslatedStringCreate.
+        :rtype: list[DatabaseTranslatedStringItemCreate]
+        """
+        return self._items
+
+    @items.setter
+    def items(self, items):
+        """Sets the items of this DatabaseTranslatedStringCreate.
+
+            
+
+        :param items: The items of this DatabaseTranslatedStringCreate.
+        :type: list[DatabaseTranslatedStringItemCreate]
+        """
 
+        self._items = items
     
 
     def to_dict(self):
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
@@ -44,27 +68,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(WebhookUrlCreate, dict):
+        if issubclass(DatabaseTranslatedStringCreate, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, WebhookUrlCreate):
+        if not isinstance(other, DatabaseTranslatedStringCreate):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/models/webhook_url_update.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/models/application_user_create.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,91 +1,62 @@
 # coding: utf-8
 import pprint
 import six
 from enum import Enum
-from . import AbstractWebhookUrlUpdate
+from . import AbstractApplicationUserUpdate
 
 
-class WebhookUrlUpdate(AbstractWebhookUrlUpdate):
+class ApplicationUserCreate(AbstractApplicationUserUpdate):
 
     swagger_types = {
     
-        'id': 'int',
-        'version': 'int',
+        'primary_account': 'int',
     }
 
     attribute_map = {
-        'id': 'id','version': 'version',
+        'primary_account': 'primaryAccount',
     }
 
     
-    _id = None
-    _version = None
+    _primary_account = None
 
     def __init__(self, **kwargs):
         self.discriminator = None
         
-        self.id = kwargs.get('id')
-
-        self.version = kwargs.get('version')
+        self.primary_account = kwargs.get('primary_account')
 
         super().__init__(**kwargs)
         self.swagger_types.update(super().swagger_types)
         self.attribute_map.update(super().attribute_map)
 
     
     @property
-    def id(self):
-        """Gets the id of this WebhookUrlUpdate.
-
-            The ID is the primary key of the entity. The ID identifies the entity uniquely.
-
-        :return: The id of this WebhookUrlUpdate.
-        :rtype: int
-        """
-        return self._id
-
-    @id.setter
-    def id(self, id):
-        """Sets the id of this WebhookUrlUpdate.
-
-            The ID is the primary key of the entity. The ID identifies the entity uniquely.
-
-        :param id: The id of this WebhookUrlUpdate.
-        :type: int
-        """
-        if id is None:
-            raise ValueError("Invalid value for `id`, must not be `None`")
-
-        self._id = id
-    
-    @property
-    def version(self):
-        """Gets the version of this WebhookUrlUpdate.
+    def primary_account(self):
+        """Gets the primary_account of this ApplicationUserCreate.
 
-            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
+            The account that this user is associated with. The account owner will be able to manage this user.
 
-        :return: The version of this WebhookUrlUpdate.
+        :return: The primary_account of this ApplicationUserCreate.
         :rtype: int
         """
-        return self._version
+        return self._primary_account
 
-    @version.setter
-    def version(self, version):
-        """Sets the version of this WebhookUrlUpdate.
+    @primary_account.setter
+    def primary_account(self, primary_account):
+        """Sets the primary_account of this ApplicationUserCreate.
 
-            The version number indicates the version of the entity. The version is incremented whenever the entity is changed.
+            The account that this user is associated with. The account owner will be able to manage this user.
 
-        :param version: The version of this WebhookUrlUpdate.
+        :param primary_account: The primary_account of this ApplicationUserCreate.
         :type: int
         """
-        if version is None:
-            raise ValueError("Invalid value for `version`, must not be `None`")
+        if primary_account is None:
+            raise ValueError("Invalid value for `primary_account`, must not be `None`")
 
-        self._version = version
+        self._primary_account = primary_account
     
 
     def to_dict(self):
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
@@ -102,27 +73,27 @@
                     if hasattr(item[1], "to_dict") else item,
                     value.items()
                 ))
             elif isinstance(value, Enum):
                 result[attr] = value.value
             else:
                 result[attr] = value
-        if issubclass(WebhookUrlUpdate, dict):
+        if issubclass(ApplicationUserCreate, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         return pprint.pformat(self.to_dict())
 
     def __repr__(self):
         return self.to_str()
 
     def __eq__(self, other):
-        if not isinstance(other, WebhookUrlUpdate):
+        if not isinstance(other, ApplicationUserCreate):
             return False
 
         return self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not self == other
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename/rest.py` & `whitelabelmachinename-4.0.1/whitelabelmachinename/rest.py`

 * *Files 3% similar despite different names*

```diff
@@ -134,80 +134,73 @@
                   len(_request_timeout) == 2):
                 timeout = urllib3.Timeout(
                     connect=_request_timeout[0], read=_request_timeout[1])
 
         if 'Content-Type' not in headers:
             headers['Content-Type'] = 'application/json'
 
-        retries = urllib3.Retry(False)
-
         try:
             # For `POST`, `PUT`, `PATCH`, `OPTIONS`, `DELETE`
             if method in ['POST', 'PUT', 'PATCH', 'OPTIONS', 'DELETE']:
                 if query_params:
                     url += '?' + urlencode(query_params)
                 if re.search('json', headers['Content-Type'], re.IGNORECASE):
                     request_body = None
                     if body is not None:
                         request_body = json.dumps(body)
                     r = self.pool_manager.request(
                         method, url,
                         body=request_body,
                         preload_content=_preload_content,
                         timeout=timeout,
-                        headers=headers,
-                        retries=retries)
+                        headers=headers)
                 elif headers['Content-Type'] == 'application/x-www-form-urlencoded':
                     r = self.pool_manager.request(
                         method, url,
                         fields=post_params,
                         encode_multipart=False,
                         preload_content=_preload_content,
                         timeout=timeout,
-                        headers=headers,
-                        retries=retries)
+                        headers=headers)
                 elif headers['Content-Type'] == 'multipart/form-data':
                     # must del headers['Content-Type'], or the correct
                     # Content-Type which generated by urllib3 will be
                     # overwritten.
                     del headers['Content-Type']
                     r = self.pool_manager.request(
                         method, url,
                         fields=post_params,
                         encode_multipart=True,
                         preload_content=_preload_content,
                         timeout=timeout,
-                        headers=headers,
-                        retries=retries)
+                        headers=headers)
                 # Pass a `string` parameter directly in the body to support
                 # other content types than Json when `body` argument is
                 # provided in serialized form
                 elif isinstance(body, str):
                     request_body = body
                     r = self.pool_manager.request(
                         method, url,
                         body=request_body,
                         preload_content=_preload_content,
                         timeout=timeout,
-                        headers=headers,
-                        retries=retries)
+                        headers=headers)
                 else:
                     # Cannot generate the request from given parameters
                     msg = """Cannot prepare a request message for provided
                              arguments. Please check that your arguments match
                              declared content type."""
                     raise ApiException(status=0, reason=msg)
             # For `GET`, `HEAD`
             else:
                 r = self.pool_manager.request(method, url,
                                               fields=query_params,
                                               preload_content=_preload_content,
                                               timeout=timeout,
-                                              headers=headers,
-                                              retries=retries)
+                                              headers=headers)
         except urllib3.exceptions.SSLError as e:
             msg = "{0}\n{1}".format(type(e).__name__, str(e))
             raise ApiException(status=0, reason=msg)
 
         if _preload_content:
             r = RESTResponse(r)
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename.egg-info/PKG-INFO` & `whitelabelmachinename-4.0.1/whitelabelmachinename.egg-info/PKG-INFO`

 * *Files 16% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: whitelabelmachinename
-Version: 4.0.0
+Version: 4.0.1
 Summary: SDK that allows you to access WhiteLabelName
 Author: Wallee AG
 License: Apache-2.0
 Keywords: whitelabelmachinename,Payment,Payment Integration
 Classifier: Intended Audience :: Developers
 Classifier: Intended Audience :: Financial and Insurance Industry
 Classifier: License :: OSI Approved :: Apache Software License
@@ -57,34 +57,28 @@
 python setup.py install
 ```
 (or `sudo python setup.py install` to install the package for all users)
 
 ## Usage
 The library needs to be configured with your account's space id, user id, and secret key which are available in your [WhiteLabelName
 account dashboard](https://app-wallee.com/account/select). Set `space_id`, `user_id`, and `api_secret` to their values.
-You can also optionally set `default_headers` to set some headers that will be sent to all requests
 
 ### Configuring a Service
 
 ```python
 from whitelabelmachinename import Configuration
 from whitelabelmachinename.api import TransactionServiceApi, TransactionPaymentPageServiceApi
 from whitelabelmachinename.models import LineItem, LineItemType, TransactionCreate
 
 space_id = 405
 
-# default_headers is an optional param, that represents headers sent to all requests
 config = Configuration(
     user_id=512,
-    api_secret='FKrO76r5VwJtBrqZawBspljbBNOxp5veKQQkOnZxucQ=',
-    default_headers={'x-meta-custom-header': 'value-1', 'x-meta-custom-header-2': 'value-2'},
-    # set a custom request timeout if needed. (If not set, then the default value is: 25 seconds)
-    request_timeout = 30
+    api_secret='FKrO76r5VwJtBrqZawBspljbBNOxp5veKQQkOnZxucQ='
 )
-
 transaction_service = TransactionServiceApi(configuration=config)
 transaction_payment_page_service = TransactionPaymentPageServiceApi(configuration=config)
 
 ```
 
 To get started with sending transactions, please review the example below:
 
@@ -93,17 +87,15 @@
 from whitelabelmachinename.api import TransactionServiceApi, TransactionPaymentPageServiceApi
 from whitelabelmachinename.models import LineItem, LineItemType, TransactionCreate
 
 space_id = 405
 
 config = Configuration(
     user_id=512,
-    api_secret='FKrO76r5VwJtBrqZawBspljbBNOxp5veKQQkOnZxucQ=',
-    # set a custom request timeout if needed. (If not set, then the default value is: 25 seconds)
-    request_timeout = 30
+    api_secret='FKrO76r5VwJtBrqZawBspljbBNOxp5veKQQkOnZxucQ='
 )
 
 transaction_service = TransactionServiceApi(configuration=config)
 transaction_payment_page_service = TransactionPaymentPageServiceApi(configuration=config)
 
 # create line item
 line_item = LineItem(
```

### Comparing `whitelabelmachinename-4.0.0/whitelabelmachinename.egg-info/SOURCES.txt` & `whitelabelmachinename-4.0.1/whitelabelmachinename.egg-info/SOURCES.txt`

 * *Files 1% similar despite different names*

```diff
@@ -8,15 +8,14 @@
 whitelabelmachinename.egg-info/PKG-INFO
 whitelabelmachinename.egg-info/SOURCES.txt
 whitelabelmachinename.egg-info/dependency_links.txt
 whitelabelmachinename.egg-info/requires.txt
 whitelabelmachinename.egg-info/top_level.txt
 whitelabelmachinename/api/__init__.py
 whitelabelmachinename/api/account_service_api.py
-whitelabelmachinename/api/analytics_query_service_api.py
 whitelabelmachinename/api/application_user_service_api.py
 whitelabelmachinename/api/bank_account_service_api.py
 whitelabelmachinename/api/bank_transaction_service_api.py
 whitelabelmachinename/api/card_processing_service_api.py
 whitelabelmachinename/api/charge_attempt_service_api.py
 whitelabelmachinename/api/charge_bank_transaction_service_api.py
 whitelabelmachinename/api/charge_flow_level_payment_link_service_api.py
@@ -40,17 +39,14 @@
 whitelabelmachinename/api/human_user_service_api.py
 whitelabelmachinename/api/installment_payment_service_api.py
 whitelabelmachinename/api/installment_payment_slice_service_api.py
 whitelabelmachinename/api/installment_plan_calculation_service_api.py
 whitelabelmachinename/api/installment_plan_configuration_service_api.py
 whitelabelmachinename/api/installment_plan_slice_configuration_service_api.py
 whitelabelmachinename/api/internal_transfer_bank_transaction_service_api.py
-whitelabelmachinename/api/invoice_reconciliation_record_invoice_link_service_api.py
-whitelabelmachinename/api/invoice_reconciliation_record_service_api.py
-whitelabelmachinename/api/invoice_reimbursement_service_api.py
 whitelabelmachinename/api/label_description_group_service_api.py
 whitelabelmachinename/api/label_description_service_api.py
 whitelabelmachinename/api/language_service_api.py
 whitelabelmachinename/api/legal_organization_form_service_api.py
 whitelabelmachinename/api/manual_task_service_api.py
 whitelabelmachinename/api/mertic_usage_service_api.py
 whitelabelmachinename/api/payment_connector_configuration_service_api.py
@@ -59,15 +55,14 @@
 whitelabelmachinename/api/payment_method_brand_service_api.py
 whitelabelmachinename/api/payment_method_configuration_service_api.py
 whitelabelmachinename/api/payment_method_service_api.py
 whitelabelmachinename/api/payment_processor_configuration_service_api.py
 whitelabelmachinename/api/payment_processor_service_api.py
 whitelabelmachinename/api/payment_terminal_service_api.py
 whitelabelmachinename/api/payment_terminal_till_service_api.py
-whitelabelmachinename/api/payment_terminal_transaction_summary_service_api.py
 whitelabelmachinename/api/payment_web_app_service_api.py
 whitelabelmachinename/api/permission_service_api.py
 whitelabelmachinename/api/refund_bank_transaction_service_api.py
 whitelabelmachinename/api/refund_comment_service_api.py
 whitelabelmachinename/api/refund_recovery_bank_transaction_service_api.py
 whitelabelmachinename/api/refund_service_api.py
 whitelabelmachinename/api/shopify_recurring_order_service_api.py
@@ -143,20 +138,14 @@
 whitelabelmachinename/models/account.py
 whitelabelmachinename/models/account_create.py
 whitelabelmachinename/models/account_state.py
 whitelabelmachinename/models/account_type.py
 whitelabelmachinename/models/account_update.py
 whitelabelmachinename/models/address.py
 whitelabelmachinename/models/address_create.py
-whitelabelmachinename/models/analytics_query.py
-whitelabelmachinename/models/analytics_query_execution.py
-whitelabelmachinename/models/analytics_query_execution_state.py
-whitelabelmachinename/models/analytics_query_result_batch.py
-whitelabelmachinename/models/analytics_schema_column.py
-whitelabelmachinename/models/analytics_schema_table.py
 whitelabelmachinename/models/application_user.py
 whitelabelmachinename/models/application_user_create.py
 whitelabelmachinename/models/application_user_create_with_mac_key.py
 whitelabelmachinename/models/application_user_update.py
 whitelabelmachinename/models/authenticated_card_data.py
 whitelabelmachinename/models/authenticated_card_data_create.py
 whitelabelmachinename/models/bank_account.py
@@ -209,14 +198,18 @@
 whitelabelmachinename/models/customer_comment_active.py
 whitelabelmachinename/models/customer_comment_create.py
 whitelabelmachinename/models/customer_create.py
 whitelabelmachinename/models/customer_postal_address.py
 whitelabelmachinename/models/customer_postal_address_create.py
 whitelabelmachinename/models/customers_presence.py
 whitelabelmachinename/models/data_collection_type.py
+whitelabelmachinename/models/database_translated_string.py
+whitelabelmachinename/models/database_translated_string_create.py
+whitelabelmachinename/models/database_translated_string_item.py
+whitelabelmachinename/models/database_translated_string_item_create.py
 whitelabelmachinename/models/debt_collection_case.py
 whitelabelmachinename/models/debt_collection_case_create.py
 whitelabelmachinename/models/debt_collection_case_document.py
 whitelabelmachinename/models/debt_collection_case_source.py
 whitelabelmachinename/models/debt_collection_case_state.py
 whitelabelmachinename/models/debt_collection_case_update.py
 whitelabelmachinename/models/debt_collection_environment.py
@@ -253,22 +246,14 @@
 whitelabelmachinename/models/installment_payment.py
 whitelabelmachinename/models/installment_payment_slice.py
 whitelabelmachinename/models/installment_payment_slice_state.py
 whitelabelmachinename/models/installment_payment_state.py
 whitelabelmachinename/models/installment_plan_configuration.py
 whitelabelmachinename/models/installment_plan_slice_configuration.py
 whitelabelmachinename/models/internal_transfer_bank_transaction.py
-whitelabelmachinename/models/invoice_reconciliation_record.py
-whitelabelmachinename/models/invoice_reconciliation_record_invoice_link.py
-whitelabelmachinename/models/invoice_reconciliation_record_rejection_status.py
-whitelabelmachinename/models/invoice_reconciliation_record_state.py
-whitelabelmachinename/models/invoice_reconciliation_record_type.py
-whitelabelmachinename/models/invoice_reimbursement.py
-whitelabelmachinename/models/invoice_reimbursement_state.py
-whitelabelmachinename/models/invoice_reimbursement_with_refund_reference.py
 whitelabelmachinename/models/label.py
 whitelabelmachinename/models/label_descriptor.py
 whitelabelmachinename/models/label_descriptor_category.py
 whitelabelmachinename/models/label_descriptor_group.py
 whitelabelmachinename/models/label_descriptor_type.py
 whitelabelmachinename/models/legal_organization_form.py
 whitelabelmachinename/models/line_item.py
@@ -310,16 +295,14 @@
 whitelabelmachinename/models/payment_connector_configuration.py
 whitelabelmachinename/models/payment_connector_feature.py
 whitelabelmachinename/models/payment_contract.py
 whitelabelmachinename/models/payment_contract_state.py
 whitelabelmachinename/models/payment_contract_type.py
 whitelabelmachinename/models/payment_information_hash.py
 whitelabelmachinename/models/payment_information_hash_type.py
-whitelabelmachinename/models/payment_initiation_advice_file.py
-whitelabelmachinename/models/payment_initiation_advice_file_state.py
 whitelabelmachinename/models/payment_link.py
 whitelabelmachinename/models/payment_link_active.py
 whitelabelmachinename/models/payment_link_address_handling_mode.py
 whitelabelmachinename/models/payment_link_create.py
 whitelabelmachinename/models/payment_link_protection_mode.py
 whitelabelmachinename/models/payment_link_update.py
 whitelabelmachinename/models/payment_method.py
@@ -330,24 +313,20 @@
 whitelabelmachinename/models/payment_processor_configuration.py
 whitelabelmachinename/models/payment_terminal.py
 whitelabelmachinename/models/payment_terminal_address.py
 whitelabelmachinename/models/payment_terminal_configuration.py
 whitelabelmachinename/models/payment_terminal_configuration_state.py
 whitelabelmachinename/models/payment_terminal_configuration_version.py
 whitelabelmachinename/models/payment_terminal_configuration_version_state.py
-whitelabelmachinename/models/payment_terminal_dcc_transaction_sum.py
 whitelabelmachinename/models/payment_terminal_location.py
 whitelabelmachinename/models/payment_terminal_location_state.py
 whitelabelmachinename/models/payment_terminal_location_version.py
 whitelabelmachinename/models/payment_terminal_location_version_state.py
 whitelabelmachinename/models/payment_terminal_receipt_type.py
 whitelabelmachinename/models/payment_terminal_state.py
-whitelabelmachinename/models/payment_terminal_transaction_sum.py
-whitelabelmachinename/models/payment_terminal_transaction_summary.py
-whitelabelmachinename/models/payment_terminal_transaction_summary_fetch_request.py
 whitelabelmachinename/models/payment_terminal_type.py
 whitelabelmachinename/models/permission.py
 whitelabelmachinename/models/persistable_currency_amount.py
 whitelabelmachinename/models/persistable_currency_amount_update.py
 whitelabelmachinename/models/product_fee_type.py
 whitelabelmachinename/models/product_metered_fee.py
 whitelabelmachinename/models/product_metered_fee_update.py
@@ -366,15 +345,14 @@
 whitelabelmachinename/models/refund_comment_create.py
 whitelabelmachinename/models/refund_create.py
 whitelabelmachinename/models/refund_recovery_bank_transaction.py
 whitelabelmachinename/models/refund_state.py
 whitelabelmachinename/models/refund_type.py
 whitelabelmachinename/models/rendered_document.py
 whitelabelmachinename/models/rendered_terminal_receipt.py
-whitelabelmachinename/models/rendered_terminal_transaction_summary.py
 whitelabelmachinename/models/resource_path.py
 whitelabelmachinename/models/resource_state.py
 whitelabelmachinename/models/rest_address_format.py
 whitelabelmachinename/models/rest_address_format_field.py
 whitelabelmachinename/models/rest_country.py
 whitelabelmachinename/models/rest_country_state.py
 whitelabelmachinename/models/rest_currency.py
@@ -526,29 +504,29 @@
 whitelabelmachinename/models/transaction_group_state.py
 whitelabelmachinename/models/transaction_invoice.py
 whitelabelmachinename/models/transaction_invoice_comment.py
 whitelabelmachinename/models/transaction_invoice_comment_active.py
 whitelabelmachinename/models/transaction_invoice_comment_create.py
 whitelabelmachinename/models/transaction_invoice_replacement.py
 whitelabelmachinename/models/transaction_invoice_state.py
+whitelabelmachinename/models/transaction_line_item_update_request.py
 whitelabelmachinename/models/transaction_line_item_version.py
 whitelabelmachinename/models/transaction_line_item_version_create.py
 whitelabelmachinename/models/transaction_line_item_version_state.py
 whitelabelmachinename/models/transaction_pending.py
 whitelabelmachinename/models/transaction_state.py
 whitelabelmachinename/models/transaction_user_interface_type.py
 whitelabelmachinename/models/transaction_void.py
 whitelabelmachinename/models/transaction_void_mode.py
 whitelabelmachinename/models/transaction_void_state.py
 whitelabelmachinename/models/two_factor_authentication_type.py
 whitelabelmachinename/models/user.py
 whitelabelmachinename/models/user_account_role.py
 whitelabelmachinename/models/user_space_role.py
 whitelabelmachinename/models/user_type.py
-whitelabelmachinename/models/wallet_type.py
 whitelabelmachinename/models/web_app_confirmation_request.py
 whitelabelmachinename/models/web_app_confirmation_response.py
 whitelabelmachinename/models/webhook_identity.py
 whitelabelmachinename/models/webhook_listener.py
 whitelabelmachinename/models/webhook_listener_create.py
 whitelabelmachinename/models/webhook_listener_entity.py
 whitelabelmachinename/models/webhook_listener_update.py
```

